; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	PyType_GenericNew
PUBLIC	??_C@_05MKJDPMKP@super?$AA@			; `string'
PUBLIC	??_C@_0DH@MEJKBCJN@the?5type?5of?5the?5instance?5invokin@ ; `string'
PUBLIC	??_C@_0P@FDFALBKM@__self_class__?$AA@		; `string'
PUBLIC	??_C@_0CL@OAHEPBOJ@the?5instance?5invoking?5super?$CI?$CJ?$DL?5m@ ; `string'
PUBLIC	??_C@_08KFOOMKEG@__self__?$AA@			; `string'
PUBLIC	??_C@_0BL@NCAHCDDF@the?5class?5invoking?5super?$CI?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0O@BEEHOGAG@__thisclass__?$AA@		; `string'
PUBLIC	??_C@_0BO@NHHBFPJ@x?4__contains__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?5in?5x?$AA@ ; `string'
PUBLIC	??_C@_0BH@FMFFBHMG@x?4__rmul__?$CIn?$CJ?5?$DM?$DN?$DN?$DO?5n?$CKx?$AA@ ; `string'
PUBLIC	??_C@_0BG@FOCCMDEC@x?4__mul__?$CIn?$CJ?5?$DM?$DN?$DN?$DO?5x?$CKn?$AA@ ; `string'
PUBLIC	??_C@_0BP@HKMFPPHC@x?4__delitem__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5del?5x?$FLy?$FN?$AA@ ; `string'
PUBLIC	??_C@_0CA@GAOMDJJJ@x?4__setitem__?$CIi?0?5y?$CJ?5?$DM?$DN?$DN?$DO?5x?$FLi?$FN?$DNy?$AA@ ; `string'
PUBLIC	??_C@_0BL@MOLOBEHD@x?4__getitem__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$FLy?$FN?$AA@ ; `string'
PUBLIC	??_C@_0BI@LJFJONPL@x?4__len__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5len?$CIx?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CL@DOCBMFDB@x?$FLy?3z?$FN?5?$DM?$DN?$DN?$DO?5x?$FLy?4__index__?$CI?$CJ?3z?4__@ ; `string'
PUBLIC	??_C@_0BL@NHAJGPKM@x?4__itruediv__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?1y?$AA@ ; `string'
PUBLIC	??_C@_0BN@KGGFDMPH@x?4__ifloordiv__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?1?1y?$AA@ ; `string'
PUBLIC	??_C@_0BL@BIAMFNP@x?4__rtruediv__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?1x?$AA@ ; `string'
PUBLIC	??_C@_0BK@KJLHHIEM@x?4__truediv__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?1y?$AA@ ; `string'
PUBLIC	??_C@_0BN@MDOPCGIM@x?4__rfloordiv__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?1?1x?$AA@ ; `string'
PUBLIC	??_C@_0BM@HLMIDEGC@x?4__floordiv__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?1?1y?$AA@ ; `string'
PUBLIC	??_C@_0BH@KMKCFFEL@x?4__ior__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$HM?$DNy?$AA@ ; `string'
PUBLIC	??_C@_0BI@KNFBDEPM@x?4__ixor__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$FO?$DNy?$AA@ ; `string'
PUBLIC	??_C@_0BI@JBOMICMM@x?4__iand__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CG?$DNy?$AA@ ; `string'
PUBLIC	??_C@_0BM@OEGAKNLC@x?4__irshift__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DO?$DO?$DNy?$AA@ ; `string'
PUBLIC	??_C@_0BM@NIKIIBEJ@x?4__ilshift__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DM?$DM?$DNy?$AA@ ; `string'
PUBLIC	??_C@_0BJ@IFHFJGNM@x?4__ipow__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CK?$CK?$DNy?$AA@ ; `string'
PUBLIC	??_C@_0BI@IMMCILKE@x?4__imod__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CF?$DNy?$AA@ ; `string'
PUBLIC	??_C@_0BI@OJHENPL@x?4__imul__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CK?$DNy?$AA@ ; `string'
PUBLIC	??_C@_0BI@FFFLKAEI@x?4__isub__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?9?$DNy?$AA@ ; `string'
PUBLIC	??_C@_0BI@HBADJPJO@x?4__iadd__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CL?$DNy?$AA@ ; `string'
PUBLIC	??_C@_0BM@HEPIFLMJ@x?4__float__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5float?$CIx?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BI@BGKNGPBI@x?4__int__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5int?$CIx?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BG@NBLDDBOA@x?4__ror__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$HMx?$AA@ ; `string'
PUBLIC	??_C@_0BF@IGCMIDJE@x?4__or__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$HMy?$AA@ ; `string'
PUBLIC	??_C@_0BH@JDGCAPPB@x?4__rxor__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$FOx?$AA@ ; `string'
PUBLIC	??_C@_0BG@FJFIDAMF@x?4__xor__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$FOy?$AA@ ; `string'
PUBLIC	??_C@_0BH@CNDAOONF@x?4__rand__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$CGx?$AA@ ; `string'
PUBLIC	??_C@_0BG@OHAKNBOB@x?4__and__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CGy?$AA@ ; `string'
PUBLIC	??_C@_0BL@IAPLBOLD@x?4__rrshift__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$DO?$DOx?$AA@ ; `string'
PUBLIC	??_C@_0BK@KNBAONPF@x?4__rshift__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DO?$DOy?$AA@ ; `string'
PUBLIC	??_C@_0BL@ELDDDEJH@x?4__rlshift__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$DM?$DMx?$AA@ ; `string'
PUBLIC	??_C@_0BK@GGNIMHNB@x?4__lshift__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DM?$DMy?$AA@ ; `string'
PUBLIC	??_C@_0BH@MNOEIHBG@x?4__invert__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5?$HOx?$AA@ ; `string'
PUBLIC	??_C@_0BJ@NDLGPPDN@x?4__bool__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5x?5?$CB?$DN?50?$AA@ ; `string'
PUBLIC	??_C@_0BI@HMJMPBKF@x?4__abs__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5abs?$CIx?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BE@CMMOLCI@x?4__pos__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5?$CLx?$AA@ ; `string'
PUBLIC	??_C@_0BE@NIPFJBMO@x?4__neg__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5?9x?$AA@ ; `string'
PUBLIC	??_C@_0CH@EKLFEJDK@y?4__rpow__?$CIx?$FL?0?5z?$FN?$CJ?5?$DM?$DN?$DN?$DO?5pow?$CIx?0?5y@ ; `string'
PUBLIC	??_C@_0CG@GMODBFLE@x?4__pow__?$CIy?$FL?0?5z?$FN?$CJ?5?$DM?$DN?$DN?$DO?5pow?$CIx?0?5y?$FL@ ; `string'
PUBLIC	??_C@_0CD@IFNHNEOL@x?4__rdivmod__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5divmod?$CIy?0?5@ ; `string'
PUBLIC	??_C@_0CC@ICKLDEBI@x?4__divmod__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5divmod?$CIx?0?5y@ ; `string'
PUBLIC	??_C@_0BH@LECJOCMF@x?4__rmod__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$CFx?$AA@ ; `string'
PUBLIC	??_C@_0BG@HOBDNNPB@x?4__mod__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CFy?$AA@ ; `string'
PUBLIC	??_C@_0BH@OJBLHMJD@x?4__rmul__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$CKx?$AA@ ; `string'
PUBLIC	??_C@_0BG@CDCBEDKH@x?4__mul__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CKy?$AA@ ; `string'
PUBLIC	??_C@_0BH@PLFINCCM@x?4__rsub__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?9x?$AA@ ; `string'
PUBLIC	??_C@_0BG@DBGCONBI@x?4__sub__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?9y?$AA@ ; `string'
PUBLIC	??_C@_0BH@BHMEKCNP@x?4__radd__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$CLx?$AA@ ; `string'
PUBLIC	??_C@_0BG@NNPOJNOL@x?4__add__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CLy?$AA@ ; `string'
PUBLIC	??_C@_0DP@PEBGGFGF@x?4__init__?$CI?4?4?4?$CJ?5initializes?5x?$DL?5s@ ; `string'
PUBLIC	??_C@_0BG@GKILFGMF@descr?4__delete__?$CIobj?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BK@HNGNCDND@descr?4__set__?$CIobj?0?5value?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CE@IDHMMHDD@descr?4__get__?$CIobj?$FL?0?5type?$FN?$CJ?5?9?$DO?5va@ ; `string'
PUBLIC	??_C@_0BK@EKPAAGNF@x?4__next__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5next?$CIx?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BK@MLDIHFPK@x?4__iter__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5iter?$CIx?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BG@GPAFEHPB@x?4__ge__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DO?$DNy?$AA@ ; `string'
PUBLIC	??_C@_0BF@EALDPMEA@x?4__gt__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DOy?$AA@ ; `string'
PUBLIC	??_C@_0BG@JPHMBINF@x?4__ne__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CB?$DNy?$AA@ ; `string'
PUBLIC	??_C@_0BG@BMDNDNCO@x?4__eq__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DN?$DNy?$AA@ ; `string'
PUBLIC	??_C@_0BG@DINLPMBE@x?4__le__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DM?$DNy?$AA@ ; `string'
PUBLIC	??_C@_0BF@PGLNDMDE@x?4__lt__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DMy?$AA@ ; `string'
PUBLIC	??_C@_0CG@LPHBAOH@x?4__delattr__?$CI?8name?8?$CJ?5?$DM?$DN?$DN?$DO?5del?5x@ ; `string'
PUBLIC	??_C@_0DB@GBCEKDDL@x?4__setattr__?$CI?8name?8?0?5value?$CJ?5?$DM?$DN?$DN@ ; `string'
PUBLIC	??_C@_0CH@MJEJMFHD@x?4__getattribute__?$CI?8name?8?$CJ?5?$DM?$DN?$DN?$DO?5@ ; `string'
PUBLIC	??_C@_0BI@CPPGOPCF@x?4__str__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5str?$CIx?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BM@OCNACKJL@x?4__call__?$CI?4?4?4?$CJ?5?$DM?$DN?$DN?$DO?5x?$CI?4?4?4?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BK@BGPGEPCP@x?4__hash__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5hash?$CIx?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BK@EOOFHHJM@x?4__repr__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5repr?$CIx?$CJ?$AA@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_07CKMCINHO@__del__?$AA@			; `string'
PUBLIC	??_C@_08DOHHOJGB@__init__?$AA@			; `string'
PUBLIC	??_C@_07KBLMMACN@__set__?$AA@			; `string'
PUBLIC	??_C@_0L@OAODBFBD@__delete__?$AA@		; `string'
PUBLIC	??_C@_07DJPLIAKA@__get__?$AA@			; `string'
PUBLIC	??_C@_08MMJHJJBO@__next__?$AA@			; `string'
PUBLIC	??_C@_08HMKBHKEB@__iter__?$AA@			; `string'
PUBLIC	??_C@_06DHPPIHIH@__ge__?$AA@			; `string'
PUBLIC	??_C@_06NPFKLHHN@__gt__?$AA@			; `string'
PUBLIC	??_C@_06DKOPOFPG@__ne__?$AA@			; `string'
PUBLIC	??_C@_06EACPLGJG@__le__?$AA@			; `string'
PUBLIC	??_C@_06KIIKIGGM@__lt__?$AA@			; `string'
PUBLIC	??_C@_0M@CIMGLOJN@__setattr__?$AA@		; `string'
PUBLIC	??_C@_0M@ECOKAOJC@__delattr__?$AA@		; `string'
PUBLIC	??_C@_0M@GIDJPAP@__getattr__?$AA@		; `string'
PUBLIC	??_C@_08DGBMPEPK@__call__?$AA@			; `string'
PUBLIC	??_C@_07NJFHCBMD@__str__?$AA@			; `string'
PUBLIC	??_C@_08HJPCHLLJ@__repr__?$AA@			; `string'
PUBLIC	??_C@_0N@LEBOILNI@__itruediv__?$AA@		; `string'
PUBLIC	??_C@_0O@FFFGEHEN@__ifloordiv__?$AA@		; `string'
PUBLIC	??_C@_0N@DJMJMIFH@__rtruediv__?$AA@		; `string'
PUBLIC	??_C@_0M@COJKGICO@__truediv__?$AA@		; `string'
PUBLIC	??_C@_0O@CINMAOLP@__rfloordiv__?$AA@		; `string'
PUBLIC	??_C@_0N@BBCJEIH@__floordiv__?$AA@		; `string'
PUBLIC	??_C@_07GMCKKGKN@__ior__?$AA@			; `string'
PUBLIC	??_C@_08EBNDKCJL@__ixor__?$AA@			; `string'
PUBLIC	??_C@_08CNBINADL@__iand__?$AA@			; `string'
PUBLIC	??_C@_0M@MPLFEGLF@__irshift__?$AA@		; `string'
PUBLIC	??_C@_0M@KLLHNPFG@__ilshift__?$AA@		; `string'
PUBLIC	??_C@_08JKFONAME@__ipow__?$AA@			; `string'
PUBLIC	??_C@_08GHLKDJPA@__imod__?$AA@			; `string'
PUBLIC	??_C@_08IIFOJODM@__imul__?$AA@			; `string'
PUBLIC	??_C@_08FBFNIKOE@__isub__?$AA@			; `string'
PUBLIC	??_C@_08GHKIMIJK@__iadd__?$AA@			; `string'
PUBLIC	??_C@_09EAHNLHOJ@__float__?$AA@			; `string'
PUBLIC	??_C@_07HECBNAMB@__int__?$AA@			; `string'
PUBLIC	??_C@_07FDLFEPF@__ror__?$AA@			; `string'
PUBLIC	??_C@_06MKEBKDGA@__or__?$AA@			; `string'
PUBLIC	??_C@_08CEAKGKKP@__rxor__?$AA@			; `string'
PUBLIC	??_C@_07KEKAHHJD@__xor__?$AA@			; `string'
PUBLIC	??_C@_08EIMBBIAP@__rand__?$AA@			; `string'
PUBLIC	??_C@_07MIGLAFDD@__and__?$AA@			; `string'
PUBLIC	??_C@_0M@BAPLDMKK@__rrshift__?$AA@		; `string'
PUBLIC	??_C@_0L@PEOFAGDE@__rshift__?$AA@		; `string'
PUBLIC	??_C@_0M@HEPJKFEJ@__rlshift__?$AA@		; `string'
PUBLIC	??_C@_0L@JAOHJPNH@__lshift__?$AA@		; `string'
PUBLIC	??_C@_0L@OIINOIMI@__invert__?$AA@		; `string'
PUBLIC	??_C@_09NLFDFNNH@__index__?$AA@			; `string'
PUBLIC	??_C@_08ONMBOEOO@__bool__?$AA@			; `string'
PUBLIC	??_C@_07MAFFIHBE@__abs__?$AA@			; `string'
PUBLIC	??_C@_07PAEPJCJL@__pos__?$AA@			; `string'
PUBLIC	??_C@_07FMFICJBJ@__neg__?$AA@			; `string'
PUBLIC	??_C@_08PPIHBIPA@__rpow__?$AA@			; `string'
PUBLIC	??_C@_07HPCNAFMM@__pow__?$AA@			; `string'
PUBLIC	??_C@_0M@NDCDLKNJ@__rdivmod__?$AA@		; `string'
PUBLIC	??_C@_0L@DHDNIAEH@__divmod__?$AA@		; `string'
PUBLIC	??_C@_08CGDPBME@__rmod__?$AA@			; `string'
PUBLIC	??_C@_07ICMJOMPI@__mod__?$AA@			; `string'
PUBLIC	??_C@_08ONIHFGAI@__rmul__?$AA@			; `string'
PUBLIC	??_C@_07GNCNELDE@__mul__?$AA@			; `string'
PUBLIC	??_C@_08DEIEECNA@__rsub__?$AA@			; `string'
PUBLIC	??_C@_07LECOFPOM@__sub__?$AA@			; `string'
PUBLIC	??_C@_08CHBAAKO@__radd__?$AA@			; `string'
PUBLIC	??_C@_07ICNLBNJC@__add__?$AA@			; `string'
PUBLIC	??_C@_0N@MCIOADFH@__contains__?$AA@		; `string'
PUBLIC	??_C@_0M@EONDAJAB@__setitem__?$AA@		; `string'
PUBLIC	??_C@_0M@CEPPLJAO@__delitem__?$AA@		; `string'
PUBLIC	??_C@_07GMJIMHJI@__len__?$AA@			; `string'
PUBLIC	??_C@_0DO@MFNFNJKD@T?4__new__?$CIS?0?5?4?4?4?$CJ?5?9?$DO?5a?5new?5objec@ ; `string'
PUBLIC	??_C@_06JCEEBECP@__eq__?$AA@			; `string'
PUBLIC	PyType_GenericAlloc
PUBLIC	??_C@_0BD@EEFIMND@The?5most?5base?5type?$AA@	; `string'
PUBLIC	??_C@_06IEOJBDIK@object?$AA@			; `string'
PUBLIC	??_C@_0CP@DOIFJKJG@__dir__?$CI?$CJ?5?9?$DO?5list?6default?5dir?$CI?$CJ?5@ ; `string'
PUBLIC	??_C@_0DH@GGNPGAHM@__sizeof__?$CI?$CJ?5?9?$DO?5int?6size?5of?5obje@ ; `string'
PUBLIC	??_C@_0BJ@OLCCKPLB@default?5object?5formatter?$AA@ ; `string'
PUBLIC	??_C@_0L@MEMCGMKL@__format__?$AA@		; `string'
PUBLIC	??_C@_0BB@NHNPNHAH@__subclasshook__?$AA@	; `string'
PUBLIC	??_C@_0BC@KKCCEOPP@helper?5for?5pickle?$AA@	; `string'
PUBLIC	??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@		; `string'
PUBLIC	??_C@_0L@NNMACJIG@__reduce__?$AA@		; `string'
PUBLIC	??_C@_05CFHBDDLG@items?$AA@			; `string'
PUBLIC	??_C@_0L@GEMAGKL@__newobj__?$AA@		; `string'
PUBLIC	??_C@_0N@NAMJJHIO@__getstate__?$AA@		; `string'
PUBLIC	??_C@_0P@BCBHENLA@__getnewargs__?$AA@		; `string'
PUBLIC	??_C@_0L@NMBFFBAC@_slotnames?$AA@		; `string'
PUBLIC	??_C@_0O@NLMJLHMN@__slotnames__?$AA@		; `string'
PUBLIC	??_C@_07ODDBKIAB@copyreg?$AA@			; `string'
PUBLIC	??_C@_0BD@BFBMEIMB@the?5object?8s?5class?$AA@	; `string'
PUBLIC	??_C@_06GOHDHELE@sorted?$AA@			; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	??_C@_04GPMDFGEJ@type?$AA@			; `string'
PUBLIC	??_C@_0EB@IFDKCHCE@__sizeof__?$CI?$CJ?5?9?$DO?5int?6return?5memor@ ; `string'
PUBLIC	??_C@_0L@HOGGIPGN@__sizeof__?$AA@		; `string'
PUBLIC	??_C@_0DP@LCGOHIAJ@__dir__?$CI?$CJ?5?9?$DO?5list?6specialized?5__@ ; `string'
PUBLIC	??_C@_07FPPEEAND@__dir__?$AA@			; `string'
PUBLIC	??_C@_0DL@PBOIKCPL@__subclasscheck__?$CI?$CJ?5?9?$DO?5bool?6chec@ ; `string'
PUBLIC	??_C@_0BC@NFPPCOGG@__subclasscheck__?$AA@	; `string'
PUBLIC	??_C@_0DO@KLHIJGEM@__instancecheck__?$CI?$CJ?5?9?$DO?5bool?6chec@ ; `string'
PUBLIC	??_C@_0BC@JKBHKBMG@__instancecheck__?$AA@	; `string'
PUBLIC	??_C@_0EL@GOMGOOLM@__prepare__?$CI?$CJ?5?9?$DO?5dict?6used?5to?5cr@ ; `string'
PUBLIC	??_C@_0M@GLHNIFEH@__prepare__?$AA@		; `string'
PUBLIC	??_C@_0DB@NPEDHMIB@__subclasses__?$CI?$CJ?5?9?$DO?5list?5of?5imme@ ; `string'
PUBLIC	??_C@_0P@IOKGGKON@__subclasses__?$AA@		; `string'
PUBLIC	??_C@_0DG@EJDLFMM@mro?$CI?$CJ?5?9?$DO?5list?6return?5a?5type?8s?5me@ ; `string'
PUBLIC	??_C@_09EBPBKION@__slots__?$AA@			; `string'
PUBLIC	??_C@_04BCIDKIGN@dict?$AA@			; `string'
PUBLIC	??_C@_05JMNHICHM@bases?$AA@			; `string'
PUBLIC	??_C@_04MEMAJGDJ@name?$AA@			; `string'
PUBLIC	??_C@_0DD@DKNNDAFM@list?5of?5weak?5references?5to?5the?5o@ ; `string'
PUBLIC	??_C@_0M@OFKEODAB@__weakref__?$AA@		; `string'
PUBLIC	??_C@_0CP@GPHMLMIJ@dictionary?5for?5instance?5variable@ ; `string'
PUBLIC	??_C@_03KCOHMEGL@mro?$AA@			; `string'
PUBLIC	??_C@_0BE@EMDECJMP@__abstractmethods__?$AA@	; `string'
PUBLIC	??_C@_09LJKDIEEK@__bases__?$AA@			; `string'
PUBLIC	??_C@_0N@FMLGAKCE@__qualname__?$AA@		; `string'
PUBLIC	??_C@_07MNLIDIMK@__mro__?$AA@			; `string'
PUBLIC	??_C@_0P@NBEFJBEP@__dictoffset__?$AA@		; `string'
PUBLIC	??_C@_08PNDLAJH@__base__?$AA@			; `string'
PUBLIC	??_C@_0BC@PHCHJLGH@__weakrefoffset__?$AA@	; `string'
PUBLIC	??_C@_09GIOABLIA@__flags__?$AA@			; `string'
PUBLIC	??_C@_0N@OJNCBPH@__itemsize__?$AA@		; `string'
PUBLIC	??_C@_0O@IAOKENCJ@__basicsize__?$AA@		; `string'
PUBLIC	??_C@_07MEBHOIG@__new__?$AA@			; `string'
PUBLIC	??_C@_08BHKDPDAA@__name__?$AA@			; `string'
PUBLIC	??_C@_0L@LNCJCPDP@__module__?$AA@		; `string'
PUBLIC	??_C@_08FJMJDHAE@__hash__?$AA@			; `string'
PUBLIC	??_C@_0BB@FJMKAPEO@__getattribute__?$AA@	; `string'
PUBLIC	??_C@_0M@GAJGCIJD@__getitem__?$AA@		; `string'
PUBLIC	??_C@_07DIBBIFIJ@__doc__?$AA@			; `string'
PUBLIC	??_C@_08IBFKALI@__dict__?$AA@			; `string'
PUBLIC	??_C@_09LFGACEKG@__class__?$AA@			; `string'
PUBLIC	PyType_Type
PUBLIC	PyBaseObject_Type
PUBLIC	PySuper_Type
EXTRN	PyObject_Free:PROC
EXTRN	PyObject_GenericSetAttr:PROC
EXTRN	PyObject_GenericGetAttr:PROC
EXTRN	_Py_HashPointer:PROC
EXTRN	PyObject_GC_Del:PROC
_BSS	SEGMENT
next_version_tag DD 01H DUP (?)
?initialized@?1??init_slotdefs@@9@9 DD 01H DUP (?)	; `init_slotdefs'::`2'::initialized
_BSS	ENDS
;	COMDAT ??_C@_05MKJDPMKP@super?$AA@
CONST	SEGMENT
??_C@_05MKJDPMKP@super?$AA@ DB 'super', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@MEJKBCJN@the?5type?5of?5the?5instance?5invokin@
CONST	SEGMENT
??_C@_0DH@MEJKBCJN@the?5type?5of?5the?5instance?5invokin@ DB 'the type of'
	DB	' the instance invoking super(); may be None', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FDFALBKM@__self_class__?$AA@
CONST	SEGMENT
??_C@_0P@FDFALBKM@__self_class__?$AA@ DB '__self_class__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@OAHEPBOJ@the?5instance?5invoking?5super?$CI?$CJ?$DL?5m@
CONST	SEGMENT
??_C@_0CL@OAHEPBOJ@the?5instance?5invoking?5super?$CI?$CJ?$DL?5m@ DB 'the'
	DB	' instance invoking super(); may be None', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KFOOMKEG@__self__?$AA@
CONST	SEGMENT
??_C@_08KFOOMKEG@__self__?$AA@ DB '__self__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NCAHCDDF@the?5class?5invoking?5super?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BL@NCAHCDDF@the?5class?5invoking?5super?$CI?$CJ?$AA@ DB 'the class'
	DB	' invoking super()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BEEHOGAG@__thisclass__?$AA@
CONST	SEGMENT
??_C@_0O@BEEHOGAG@__thisclass__?$AA@ DB '__thisclass__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NHHBFPJ@x?4__contains__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?5in?5x?$AA@
CONST	SEGMENT
??_C@_0BO@NHHBFPJ@x?4__contains__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?5in?5x?$AA@ DB 'x'
	DB	'.__contains__(y) <==> y in x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FMFFBHMG@x?4__rmul__?$CIn?$CJ?5?$DM?$DN?$DN?$DO?5n?$CKx?$AA@
CONST	SEGMENT
??_C@_0BH@FMFFBHMG@x?4__rmul__?$CIn?$CJ?5?$DM?$DN?$DN?$DO?5n?$CKx?$AA@ DB 'x'
	DB	'.__rmul__(n) <==> n*x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FOCCMDEC@x?4__mul__?$CIn?$CJ?5?$DM?$DN?$DN?$DO?5x?$CKn?$AA@
CONST	SEGMENT
??_C@_0BG@FOCCMDEC@x?4__mul__?$CIn?$CJ?5?$DM?$DN?$DN?$DO?5x?$CKn?$AA@ DB 'x'
	DB	'.__mul__(n) <==> x*n', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HKMFPPHC@x?4__delitem__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5del?5x?$FLy?$FN?$AA@
CONST	SEGMENT
??_C@_0BP@HKMFPPHC@x?4__delitem__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5del?5x?$FLy?$FN?$AA@ DB 'x'
	DB	'.__delitem__(y) <==> del x[y]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@GAOMDJJJ@x?4__setitem__?$CIi?0?5y?$CJ?5?$DM?$DN?$DN?$DO?5x?$FLi?$FN?$DNy?$AA@
CONST	SEGMENT
??_C@_0CA@GAOMDJJJ@x?4__setitem__?$CIi?0?5y?$CJ?5?$DM?$DN?$DN?$DO?5x?$FLi?$FN?$DNy?$AA@ DB 'x'
	DB	'.__setitem__(i, y) <==> x[i]=y', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MOLOBEHD@x?4__getitem__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$FLy?$FN?$AA@
CONST	SEGMENT
??_C@_0BL@MOLOBEHD@x?4__getitem__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$FLy?$FN?$AA@ DB 'x'
	DB	'.__getitem__(y) <==> x[y]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LJFJONPL@x?4__len__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5len?$CIx?$CJ?$AA@
CONST	SEGMENT
??_C@_0BI@LJFJONPL@x?4__len__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5len?$CIx?$CJ?$AA@ DB 'x'
	DB	'.__len__() <==> len(x)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DOCBMFDB@x?$FLy?3z?$FN?5?$DM?$DN?$DN?$DO?5x?$FLy?4__index__?$CI?$CJ?3z?4__@
CONST	SEGMENT
??_C@_0CL@DOCBMFDB@x?$FLy?3z?$FN?5?$DM?$DN?$DN?$DO?5x?$FLy?4__index__?$CI?$CJ?3z?4__@ DB 'x'
	DB	'[y:z] <==> x[y.__index__():z.__index__()]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NHAJGPKM@x?4__itruediv__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?1y?$AA@
CONST	SEGMENT
??_C@_0BL@NHAJGPKM@x?4__itruediv__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?1y?$AA@ DB 'x'
	DB	'.__itruediv__(y) <==> x/y', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KGGFDMPH@x?4__ifloordiv__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?1?1y?$AA@
CONST	SEGMENT
??_C@_0BN@KGGFDMPH@x?4__ifloordiv__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?1?1y?$AA@ DB 'x'
	DB	'.__ifloordiv__(y) <==> x//y', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BIAMFNP@x?4__rtruediv__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?1x?$AA@
CONST	SEGMENT
??_C@_0BL@BIAMFNP@x?4__rtruediv__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?1x?$AA@ DB 'x'
	DB	'.__rtruediv__(y) <==> y/x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KJLHHIEM@x?4__truediv__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?1y?$AA@
CONST	SEGMENT
??_C@_0BK@KJLHHIEM@x?4__truediv__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?1y?$AA@ DB 'x'
	DB	'.__truediv__(y) <==> x/y', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MDOPCGIM@x?4__rfloordiv__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?1?1x?$AA@
CONST	SEGMENT
??_C@_0BN@MDOPCGIM@x?4__rfloordiv__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?1?1x?$AA@ DB 'x'
	DB	'.__rfloordiv__(y) <==> y//x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HLMIDEGC@x?4__floordiv__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?1?1y?$AA@
CONST	SEGMENT
??_C@_0BM@HLMIDEGC@x?4__floordiv__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?1?1y?$AA@ DB 'x'
	DB	'.__floordiv__(y) <==> x//y', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KMKCFFEL@x?4__ior__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$HM?$DNy?$AA@
CONST	SEGMENT
??_C@_0BH@KMKCFFEL@x?4__ior__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$HM?$DNy?$AA@ DB 'x'
	DB	'.__ior__(y) <==> x|=y', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KNFBDEPM@x?4__ixor__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$FO?$DNy?$AA@
CONST	SEGMENT
??_C@_0BI@KNFBDEPM@x?4__ixor__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$FO?$DNy?$AA@ DB 'x'
	DB	'.__ixor__(y) <==> x^=y', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JBOMICMM@x?4__iand__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CG?$DNy?$AA@
CONST	SEGMENT
??_C@_0BI@JBOMICMM@x?4__iand__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CG?$DNy?$AA@ DB 'x'
	DB	'.__iand__(y) <==> x&=y', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OEGAKNLC@x?4__irshift__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DO?$DO?$DNy?$AA@
CONST	SEGMENT
??_C@_0BM@OEGAKNLC@x?4__irshift__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DO?$DO?$DNy?$AA@ DB 'x'
	DB	'.__irshift__(y) <==> x>>=y', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NIKIIBEJ@x?4__ilshift__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DM?$DM?$DNy?$AA@
CONST	SEGMENT
??_C@_0BM@NIKIIBEJ@x?4__ilshift__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DM?$DM?$DNy?$AA@ DB 'x'
	DB	'.__ilshift__(y) <==> x<<=y', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IFHFJGNM@x?4__ipow__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CK?$CK?$DNy?$AA@
CONST	SEGMENT
??_C@_0BJ@IFHFJGNM@x?4__ipow__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CK?$CK?$DNy?$AA@ DB 'x'
	DB	'.__ipow__(y) <==> x**=y', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IMMCILKE@x?4__imod__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CF?$DNy?$AA@
CONST	SEGMENT
??_C@_0BI@IMMCILKE@x?4__imod__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CF?$DNy?$AA@ DB 'x'
	DB	'.__imod__(y) <==> x%=y', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@OJHENPL@x?4__imul__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CK?$DNy?$AA@
CONST	SEGMENT
??_C@_0BI@OJHENPL@x?4__imul__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CK?$DNy?$AA@ DB 'x'
	DB	'.__imul__(y) <==> x*=y', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FFFLKAEI@x?4__isub__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?9?$DNy?$AA@
CONST	SEGMENT
??_C@_0BI@FFFLKAEI@x?4__isub__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?9?$DNy?$AA@ DB 'x'
	DB	'.__isub__(y) <==> x-=y', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HBADJPJO@x?4__iadd__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CL?$DNy?$AA@
CONST	SEGMENT
??_C@_0BI@HBADJPJO@x?4__iadd__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CL?$DNy?$AA@ DB 'x'
	DB	'.__iadd__(y) <==> x+=y', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HEPIFLMJ@x?4__float__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5float?$CIx?$CJ?$AA@
CONST	SEGMENT
??_C@_0BM@HEPIFLMJ@x?4__float__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5float?$CIx?$CJ?$AA@ DB 'x'
	DB	'.__float__() <==> float(x)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BGKNGPBI@x?4__int__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5int?$CIx?$CJ?$AA@
CONST	SEGMENT
??_C@_0BI@BGKNGPBI@x?4__int__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5int?$CIx?$CJ?$AA@ DB 'x'
	DB	'.__int__() <==> int(x)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NBLDDBOA@x?4__ror__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$HMx?$AA@
CONST	SEGMENT
??_C@_0BG@NBLDDBOA@x?4__ror__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$HMx?$AA@ DB 'x'
	DB	'.__ror__(y) <==> y|x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IGCMIDJE@x?4__or__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$HMy?$AA@
CONST	SEGMENT
??_C@_0BF@IGCMIDJE@x?4__or__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$HMy?$AA@ DB 'x'
	DB	'.__or__(y) <==> x|y', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JDGCAPPB@x?4__rxor__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$FOx?$AA@
CONST	SEGMENT
??_C@_0BH@JDGCAPPB@x?4__rxor__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$FOx?$AA@ DB 'x'
	DB	'.__rxor__(y) <==> y^x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FJFIDAMF@x?4__xor__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$FOy?$AA@
CONST	SEGMENT
??_C@_0BG@FJFIDAMF@x?4__xor__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$FOy?$AA@ DB 'x'
	DB	'.__xor__(y) <==> x^y', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CNDAOONF@x?4__rand__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$CGx?$AA@
CONST	SEGMENT
??_C@_0BH@CNDAOONF@x?4__rand__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$CGx?$AA@ DB 'x'
	DB	'.__rand__(y) <==> y&x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OHAKNBOB@x?4__and__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CGy?$AA@
CONST	SEGMENT
??_C@_0BG@OHAKNBOB@x?4__and__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CGy?$AA@ DB 'x'
	DB	'.__and__(y) <==> x&y', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IAPLBOLD@x?4__rrshift__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$DO?$DOx?$AA@
CONST	SEGMENT
??_C@_0BL@IAPLBOLD@x?4__rrshift__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$DO?$DOx?$AA@ DB 'x'
	DB	'.__rrshift__(y) <==> y>>x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KNBAONPF@x?4__rshift__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DO?$DOy?$AA@
CONST	SEGMENT
??_C@_0BK@KNBAONPF@x?4__rshift__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DO?$DOy?$AA@ DB 'x'
	DB	'.__rshift__(y) <==> x>>y', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@ELDDDEJH@x?4__rlshift__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$DM?$DMx?$AA@
CONST	SEGMENT
??_C@_0BL@ELDDDEJH@x?4__rlshift__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$DM?$DMx?$AA@ DB 'x'
	DB	'.__rlshift__(y) <==> y<<x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GGNIMHNB@x?4__lshift__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DM?$DMy?$AA@
CONST	SEGMENT
??_C@_0BK@GGNIMHNB@x?4__lshift__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DM?$DMy?$AA@ DB 'x'
	DB	'.__lshift__(y) <==> x<<y', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MNOEIHBG@x?4__invert__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5?$HOx?$AA@
CONST	SEGMENT
??_C@_0BH@MNOEIHBG@x?4__invert__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5?$HOx?$AA@ DB 'x'
	DB	'.__invert__() <==> ~x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NDLGPPDN@x?4__bool__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5x?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_0BJ@NDLGPPDN@x?4__bool__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5x?5?$CB?$DN?50?$AA@ DB 'x'
	DB	'.__bool__() <==> x != 0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HMJMPBKF@x?4__abs__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5abs?$CIx?$CJ?$AA@
CONST	SEGMENT
??_C@_0BI@HMJMPBKF@x?4__abs__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5abs?$CIx?$CJ?$AA@ DB 'x'
	DB	'.__abs__() <==> abs(x)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CMMOLCI@x?4__pos__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5?$CLx?$AA@
CONST	SEGMENT
??_C@_0BE@CMMOLCI@x?4__pos__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5?$CLx?$AA@ DB 'x.'
	DB	'__pos__() <==> +x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NIPFJBMO@x?4__neg__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5?9x?$AA@
CONST	SEGMENT
??_C@_0BE@NIPFJBMO@x?4__neg__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5?9x?$AA@ DB 'x._'
	DB	'_neg__() <==> -x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@EKLFEJDK@y?4__rpow__?$CIx?$FL?0?5z?$FN?$CJ?5?$DM?$DN?$DN?$DO?5pow?$CIx?0?5y@
CONST	SEGMENT
??_C@_0CH@EKLFEJDK@y?4__rpow__?$CIx?$FL?0?5z?$FN?$CJ?5?$DM?$DN?$DN?$DO?5pow?$CIx?0?5y@ DB 'y'
	DB	'.__rpow__(x[, z]) <==> pow(x, y[, z])', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GMODBFLE@x?4__pow__?$CIy?$FL?0?5z?$FN?$CJ?5?$DM?$DN?$DN?$DO?5pow?$CIx?0?5y?$FL@
CONST	SEGMENT
??_C@_0CG@GMODBFLE@x?4__pow__?$CIy?$FL?0?5z?$FN?$CJ?5?$DM?$DN?$DN?$DO?5pow?$CIx?0?5y?$FL@ DB 'x'
	DB	'.__pow__(y[, z]) <==> pow(x, y[, z])', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@IFNHNEOL@x?4__rdivmod__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5divmod?$CIy?0?5@
CONST	SEGMENT
??_C@_0CD@IFNHNEOL@x?4__rdivmod__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5divmod?$CIy?0?5@ DB 'x'
	DB	'.__rdivmod__(y) <==> divmod(y, x)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@ICKLDEBI@x?4__divmod__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5divmod?$CIx?0?5y@
CONST	SEGMENT
??_C@_0CC@ICKLDEBI@x?4__divmod__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5divmod?$CIx?0?5y@ DB 'x'
	DB	'.__divmod__(y) <==> divmod(x, y)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LECJOCMF@x?4__rmod__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$CFx?$AA@
CONST	SEGMENT
??_C@_0BH@LECJOCMF@x?4__rmod__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$CFx?$AA@ DB 'x'
	DB	'.__rmod__(y) <==> y%x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HOBDNNPB@x?4__mod__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CFy?$AA@
CONST	SEGMENT
??_C@_0BG@HOBDNNPB@x?4__mod__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CFy?$AA@ DB 'x'
	DB	'.__mod__(y) <==> x%y', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OJBLHMJD@x?4__rmul__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$CKx?$AA@
CONST	SEGMENT
??_C@_0BH@OJBLHMJD@x?4__rmul__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$CKx?$AA@ DB 'x'
	DB	'.__rmul__(y) <==> y*x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CDCBEDKH@x?4__mul__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CKy?$AA@
CONST	SEGMENT
??_C@_0BG@CDCBEDKH@x?4__mul__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CKy?$AA@ DB 'x'
	DB	'.__mul__(y) <==> x*y', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PLFINCCM@x?4__rsub__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?9x?$AA@
CONST	SEGMENT
??_C@_0BH@PLFINCCM@x?4__rsub__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?9x?$AA@ DB 'x'
	DB	'.__rsub__(y) <==> y-x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DBGCONBI@x?4__sub__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?9y?$AA@
CONST	SEGMENT
??_C@_0BG@DBGCONBI@x?4__sub__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?9y?$AA@ DB 'x'
	DB	'.__sub__(y) <==> x-y', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BHMEKCNP@x?4__radd__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$CLx?$AA@
CONST	SEGMENT
??_C@_0BH@BHMEKCNP@x?4__radd__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$CLx?$AA@ DB 'x'
	DB	'.__radd__(y) <==> y+x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NNPOJNOL@x?4__add__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CLy?$AA@
CONST	SEGMENT
??_C@_0BG@NNPOJNOL@x?4__add__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CLy?$AA@ DB 'x'
	DB	'.__add__(y) <==> x+y', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@PEBGGFGF@x?4__init__?$CI?4?4?4?$CJ?5initializes?5x?$DL?5s@
CONST	SEGMENT
??_C@_0DP@PEBGGFGF@x?4__init__?$CI?4?4?4?$CJ?5initializes?5x?$DL?5s@ DB 'x'
	DB	'.__init__(...) initializes x; see help(type(x)) for signature'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GKILFGMF@descr?4__delete__?$CIobj?$CJ?$AA@
CONST	SEGMENT
??_C@_0BG@GKILFGMF@descr?4__delete__?$CIobj?$CJ?$AA@ DB 'descr.__delete__'
	DB	'(obj)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HNGNCDND@descr?4__set__?$CIobj?0?5value?$CJ?$AA@
CONST	SEGMENT
??_C@_0BK@HNGNCDND@descr?4__set__?$CIobj?0?5value?$CJ?$AA@ DB 'descr.__se'
	DB	't__(obj, value)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@IDHMMHDD@descr?4__get__?$CIobj?$FL?0?5type?$FN?$CJ?5?9?$DO?5va@
CONST	SEGMENT
??_C@_0CE@IDHMMHDD@descr?4__get__?$CIobj?$FL?0?5type?$FN?$CJ?5?9?$DO?5va@ DB 'd'
	DB	'escr.__get__(obj[, type]) -> value', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EKPAAGNF@x?4__next__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5next?$CIx?$CJ?$AA@
CONST	SEGMENT
??_C@_0BK@EKPAAGNF@x?4__next__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5next?$CIx?$CJ?$AA@ DB 'x'
	DB	'.__next__() <==> next(x)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MLDIHFPK@x?4__iter__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5iter?$CIx?$CJ?$AA@
CONST	SEGMENT
??_C@_0BK@MLDIHFPK@x?4__iter__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5iter?$CIx?$CJ?$AA@ DB 'x'
	DB	'.__iter__() <==> iter(x)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GPAFEHPB@x?4__ge__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DO?$DNy?$AA@
CONST	SEGMENT
??_C@_0BG@GPAFEHPB@x?4__ge__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DO?$DNy?$AA@ DB 'x'
	DB	'.__ge__(y) <==> x>=y', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EALDPMEA@x?4__gt__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DOy?$AA@
CONST	SEGMENT
??_C@_0BF@EALDPMEA@x?4__gt__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DOy?$AA@ DB 'x'
	DB	'.__gt__(y) <==> x>y', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JPHMBINF@x?4__ne__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CB?$DNy?$AA@
CONST	SEGMENT
??_C@_0BG@JPHMBINF@x?4__ne__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CB?$DNy?$AA@ DB 'x'
	DB	'.__ne__(y) <==> x!=y', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BMDNDNCO@x?4__eq__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DN?$DNy?$AA@
CONST	SEGMENT
??_C@_0BG@BMDNDNCO@x?4__eq__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DN?$DNy?$AA@ DB 'x'
	DB	'.__eq__(y) <==> x==y', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DINLPMBE@x?4__le__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DM?$DNy?$AA@
CONST	SEGMENT
??_C@_0BG@DINLPMBE@x?4__le__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DM?$DNy?$AA@ DB 'x'
	DB	'.__le__(y) <==> x<=y', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PGLNDMDE@x?4__lt__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DMy?$AA@
CONST	SEGMENT
??_C@_0BF@PGLNDMDE@x?4__lt__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DMy?$AA@ DB 'x'
	DB	'.__lt__(y) <==> x<y', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@LPHBAOH@x?4__delattr__?$CI?8name?8?$CJ?5?$DM?$DN?$DN?$DO?5del?5x@
CONST	SEGMENT
??_C@_0CG@LPHBAOH@x?4__delattr__?$CI?8name?8?$CJ?5?$DM?$DN?$DN?$DO?5del?5x@ DB 'x'
	DB	'.__delattr__(''name'') <==> del x.name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GBCEKDDL@x?4__setattr__?$CI?8name?8?0?5value?$CJ?5?$DM?$DN?$DN@
CONST	SEGMENT
??_C@_0DB@GBCEKDDL@x?4__setattr__?$CI?8name?8?0?5value?$CJ?5?$DM?$DN?$DN@ DB 'x'
	DB	'.__setattr__(''name'', value) <==> x.name = value', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MJEJMFHD@x?4__getattribute__?$CI?8name?8?$CJ?5?$DM?$DN?$DN?$DO?5@
CONST	SEGMENT
??_C@_0CH@MJEJMFHD@x?4__getattribute__?$CI?8name?8?$CJ?5?$DM?$DN?$DN?$DO?5@ DB 'x'
	DB	'.__getattribute__(''name'') <==> x.name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CPPGOPCF@x?4__str__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5str?$CIx?$CJ?$AA@
CONST	SEGMENT
??_C@_0BI@CPPGOPCF@x?4__str__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5str?$CIx?$CJ?$AA@ DB 'x'
	DB	'.__str__() <==> str(x)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OCNACKJL@x?4__call__?$CI?4?4?4?$CJ?5?$DM?$DN?$DN?$DO?5x?$CI?4?4?4?$CJ?$AA@
CONST	SEGMENT
??_C@_0BM@OCNACKJL@x?4__call__?$CI?4?4?4?$CJ?5?$DM?$DN?$DN?$DO?5x?$CI?4?4?4?$CJ?$AA@ DB 'x'
	DB	'.__call__(...) <==> x(...)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BGPGEPCP@x?4__hash__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5hash?$CIx?$CJ?$AA@
CONST	SEGMENT
??_C@_0BK@BGPGEPCP@x?4__hash__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5hash?$CIx?$CJ?$AA@ DB 'x'
	DB	'.__hash__() <==> hash(x)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EOOFHHJM@x?4__repr__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5repr?$CIx?$CJ?$AA@
CONST	SEGMENT
??_C@_0BK@EOOFHHJM@x?4__repr__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5repr?$CIx?$CJ?$AA@ DB 'x'
	DB	'.__repr__() <==> repr(x)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07CKMCINHO@__del__?$AA@
CONST	SEGMENT
??_C@_07CKMCINHO@__del__?$AA@ DB '__del__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DOHHOJGB@__init__?$AA@
CONST	SEGMENT
??_C@_08DOHHOJGB@__init__?$AA@ DB '__init__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07KBLMMACN@__set__?$AA@
CONST	SEGMENT
??_C@_07KBLMMACN@__set__?$AA@ DB '__set__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OAODBFBD@__delete__?$AA@
CONST	SEGMENT
??_C@_0L@OAODBFBD@__delete__?$AA@ DB '__delete__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07DJPLIAKA@__get__?$AA@
CONST	SEGMENT
??_C@_07DJPLIAKA@__get__?$AA@ DB '__get__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MMJHJJBO@__next__?$AA@
CONST	SEGMENT
??_C@_08MMJHJJBO@__next__?$AA@ DB '__next__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HMKBHKEB@__iter__?$AA@
CONST	SEGMENT
??_C@_08HMKBHKEB@__iter__?$AA@ DB '__iter__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06DHPPIHIH@__ge__?$AA@
CONST	SEGMENT
??_C@_06DHPPIHIH@__ge__?$AA@ DB '__ge__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NPFKLHHN@__gt__?$AA@
CONST	SEGMENT
??_C@_06NPFKLHHN@__gt__?$AA@ DB '__gt__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DKOPOFPG@__ne__?$AA@
CONST	SEGMENT
??_C@_06DKOPOFPG@__ne__?$AA@ DB '__ne__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EACPLGJG@__le__?$AA@
CONST	SEGMENT
??_C@_06EACPLGJG@__le__?$AA@ DB '__le__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KIIKIGGM@__lt__?$AA@
CONST	SEGMENT
??_C@_06KIIKIGGM@__lt__?$AA@ DB '__lt__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CIMGLOJN@__setattr__?$AA@
CONST	SEGMENT
??_C@_0M@CIMGLOJN@__setattr__?$AA@ DB '__setattr__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ECOKAOJC@__delattr__?$AA@
CONST	SEGMENT
??_C@_0M@ECOKAOJC@__delattr__?$AA@ DB '__delattr__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GIDJPAP@__getattr__?$AA@
CONST	SEGMENT
??_C@_0M@GIDJPAP@__getattr__?$AA@ DB '__getattr__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08DGBMPEPK@__call__?$AA@
CONST	SEGMENT
??_C@_08DGBMPEPK@__call__?$AA@ DB '__call__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NJFHCBMD@__str__?$AA@
CONST	SEGMENT
??_C@_07NJFHCBMD@__str__?$AA@ DB '__str__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HJPCHLLJ@__repr__?$AA@
CONST	SEGMENT
??_C@_08HJPCHLLJ@__repr__?$AA@ DB '__repr__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LEBOILNI@__itruediv__?$AA@
CONST	SEGMENT
??_C@_0N@LEBOILNI@__itruediv__?$AA@ DB '__itruediv__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FFFGEHEN@__ifloordiv__?$AA@
CONST	SEGMENT
??_C@_0O@FFFGEHEN@__ifloordiv__?$AA@ DB '__ifloordiv__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DJMJMIFH@__rtruediv__?$AA@
CONST	SEGMENT
??_C@_0N@DJMJMIFH@__rtruediv__?$AA@ DB '__rtruediv__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@COJKGICO@__truediv__?$AA@
CONST	SEGMENT
??_C@_0M@COJKGICO@__truediv__?$AA@ DB '__truediv__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CINMAOLP@__rfloordiv__?$AA@
CONST	SEGMENT
??_C@_0O@CINMAOLP@__rfloordiv__?$AA@ DB '__rfloordiv__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BBCJEIH@__floordiv__?$AA@
CONST	SEGMENT
??_C@_0N@BBCJEIH@__floordiv__?$AA@ DB '__floordiv__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07GMCKKGKN@__ior__?$AA@
CONST	SEGMENT
??_C@_07GMCKKGKN@__ior__?$AA@ DB '__ior__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EBNDKCJL@__ixor__?$AA@
CONST	SEGMENT
??_C@_08EBNDKCJL@__ixor__?$AA@ DB '__ixor__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CNBINADL@__iand__?$AA@
CONST	SEGMENT
??_C@_08CNBINADL@__iand__?$AA@ DB '__iand__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MPLFEGLF@__irshift__?$AA@
CONST	SEGMENT
??_C@_0M@MPLFEGLF@__irshift__?$AA@ DB '__irshift__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KLLHNPFG@__ilshift__?$AA@
CONST	SEGMENT
??_C@_0M@KLLHNPFG@__ilshift__?$AA@ DB '__ilshift__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JKFONAME@__ipow__?$AA@
CONST	SEGMENT
??_C@_08JKFONAME@__ipow__?$AA@ DB '__ipow__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GHLKDJPA@__imod__?$AA@
CONST	SEGMENT
??_C@_08GHLKDJPA@__imod__?$AA@ DB '__imod__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08IIFOJODM@__imul__?$AA@
CONST	SEGMENT
??_C@_08IIFOJODM@__imul__?$AA@ DB '__imul__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FBFNIKOE@__isub__?$AA@
CONST	SEGMENT
??_C@_08FBFNIKOE@__isub__?$AA@ DB '__isub__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GHKIMIJK@__iadd__?$AA@
CONST	SEGMENT
??_C@_08GHKIMIJK@__iadd__?$AA@ DB '__iadd__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09EAHNLHOJ@__float__?$AA@
CONST	SEGMENT
??_C@_09EAHNLHOJ@__float__?$AA@ DB '__float__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07HECBNAMB@__int__?$AA@
CONST	SEGMENT
??_C@_07HECBNAMB@__int__?$AA@ DB '__int__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FDLFEPF@__ror__?$AA@
CONST	SEGMENT
??_C@_07FDLFEPF@__ror__?$AA@ DB '__ror__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MKEBKDGA@__or__?$AA@
CONST	SEGMENT
??_C@_06MKEBKDGA@__or__?$AA@ DB '__or__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CEAKGKKP@__rxor__?$AA@
CONST	SEGMENT
??_C@_08CEAKGKKP@__rxor__?$AA@ DB '__rxor__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07KEKAHHJD@__xor__?$AA@
CONST	SEGMENT
??_C@_07KEKAHHJD@__xor__?$AA@ DB '__xor__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EIMBBIAP@__rand__?$AA@
CONST	SEGMENT
??_C@_08EIMBBIAP@__rand__?$AA@ DB '__rand__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MIGLAFDD@__and__?$AA@
CONST	SEGMENT
??_C@_07MIGLAFDD@__and__?$AA@ DB '__and__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BAPLDMKK@__rrshift__?$AA@
CONST	SEGMENT
??_C@_0M@BAPLDMKK@__rrshift__?$AA@ DB '__rrshift__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PEOFAGDE@__rshift__?$AA@
CONST	SEGMENT
??_C@_0L@PEOFAGDE@__rshift__?$AA@ DB '__rshift__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HEPJKFEJ@__rlshift__?$AA@
CONST	SEGMENT
??_C@_0M@HEPJKFEJ@__rlshift__?$AA@ DB '__rlshift__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JAOHJPNH@__lshift__?$AA@
CONST	SEGMENT
??_C@_0L@JAOHJPNH@__lshift__?$AA@ DB '__lshift__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OIINOIMI@__invert__?$AA@
CONST	SEGMENT
??_C@_0L@OIINOIMI@__invert__?$AA@ DB '__invert__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NLFDFNNH@__index__?$AA@
CONST	SEGMENT
??_C@_09NLFDFNNH@__index__?$AA@ DB '__index__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08ONMBOEOO@__bool__?$AA@
CONST	SEGMENT
??_C@_08ONMBOEOO@__bool__?$AA@ DB '__bool__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MAFFIHBE@__abs__?$AA@
CONST	SEGMENT
??_C@_07MAFFIHBE@__abs__?$AA@ DB '__abs__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PAEPJCJL@__pos__?$AA@
CONST	SEGMENT
??_C@_07PAEPJCJL@__pos__?$AA@ DB '__pos__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FMFICJBJ@__neg__?$AA@
CONST	SEGMENT
??_C@_07FMFICJBJ@__neg__?$AA@ DB '__neg__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PPIHBIPA@__rpow__?$AA@
CONST	SEGMENT
??_C@_08PPIHBIPA@__rpow__?$AA@ DB '__rpow__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07HPCNAFMM@__pow__?$AA@
CONST	SEGMENT
??_C@_07HPCNAFMM@__pow__?$AA@ DB '__pow__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NDCDLKNJ@__rdivmod__?$AA@
CONST	SEGMENT
??_C@_0M@NDCDLKNJ@__rdivmod__?$AA@ DB '__rdivmod__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DHDNIAEH@__divmod__?$AA@
CONST	SEGMENT
??_C@_0L@DHDNIAEH@__divmod__?$AA@ DB '__divmod__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CGDPBME@__rmod__?$AA@
CONST	SEGMENT
??_C@_08CGDPBME@__rmod__?$AA@ DB '__rmod__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07ICMJOMPI@__mod__?$AA@
CONST	SEGMENT
??_C@_07ICMJOMPI@__mod__?$AA@ DB '__mod__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08ONIHFGAI@__rmul__?$AA@
CONST	SEGMENT
??_C@_08ONIHFGAI@__rmul__?$AA@ DB '__rmul__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GNCNELDE@__mul__?$AA@
CONST	SEGMENT
??_C@_07GNCNELDE@__mul__?$AA@ DB '__mul__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DEIEECNA@__rsub__?$AA@
CONST	SEGMENT
??_C@_08DEIEECNA@__rsub__?$AA@ DB '__rsub__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LECOFPOM@__sub__?$AA@
CONST	SEGMENT
??_C@_07LECOFPOM@__sub__?$AA@ DB '__sub__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CHBAAKO@__radd__?$AA@
CONST	SEGMENT
??_C@_08CHBAAKO@__radd__?$AA@ DB '__radd__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07ICNLBNJC@__add__?$AA@
CONST	SEGMENT
??_C@_07ICNLBNJC@__add__?$AA@ DB '__add__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MCIOADFH@__contains__?$AA@
CONST	SEGMENT
??_C@_0N@MCIOADFH@__contains__?$AA@ DB '__contains__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EONDAJAB@__setitem__?$AA@
CONST	SEGMENT
??_C@_0M@EONDAJAB@__setitem__?$AA@ DB '__setitem__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CEPPLJAO@__delitem__?$AA@
CONST	SEGMENT
??_C@_0M@CEPPLJAO@__delitem__?$AA@ DB '__delitem__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07GMJIMHJI@__len__?$AA@
CONST	SEGMENT
??_C@_07GMJIMHJI@__len__?$AA@ DB '__len__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@MFNFNJKD@T?4__new__?$CIS?0?5?4?4?4?$CJ?5?9?$DO?5a?5new?5objec@
CONST	SEGMENT
??_C@_0DO@MFNFNJKD@T?4__new__?$CIS?0?5?4?4?4?$CJ?5?9?$DO?5a?5new?5objec@ DB 'T'
	DB	'.__new__(S, ...) -> a new object with type S, a subtype of T', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06JCEEBECP@__eq__?$AA@
CONST	SEGMENT
??_C@_06JCEEBECP@__eq__?$AA@ DB '__eq__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EEFIMND@The?5most?5base?5type?$AA@
CONST	SEGMENT
??_C@_0BD@EEFIMND@The?5most?5base?5type?$AA@ DB 'The most base type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06IEOJBDIK@object?$AA@
CONST	SEGMENT
??_C@_06IEOJBDIK@object?$AA@ DB 'object', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@DOIFJKJG@__dir__?$CI?$CJ?5?9?$DO?5list?6default?5dir?$CI?$CJ?5@
CONST	SEGMENT
??_C@_0CP@DOIFJKJG@__dir__?$CI?$CJ?5?9?$DO?5list?6default?5dir?$CI?$CJ?5@ DB '_'
	DB	'_dir__() -> list', 0aH, 'default dir() implementation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@GGNPGAHM@__sizeof__?$CI?$CJ?5?9?$DO?5int?6size?5of?5obje@
CONST	SEGMENT
??_C@_0DH@GGNPGAHM@__sizeof__?$CI?$CJ?5?9?$DO?5int?6size?5of?5obje@ DB '_'
	DB	'_sizeof__() -> int', 0aH, 'size of object in memory, in bytes'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OLCCKPLB@default?5object?5formatter?$AA@
CONST	SEGMENT
??_C@_0BJ@OLCCKPLB@default?5object?5formatter?$AA@ DB 'default object for'
	DB	'matter', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MEMCGMKL@__format__?$AA@
CONST	SEGMENT
??_C@_0L@MEMCGMKL@__format__?$AA@ DB '__format__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NHNPNHAH@__subclasshook__?$AA@
CONST	SEGMENT
??_C@_0BB@NHNPNHAH@__subclasshook__?$AA@ DB '__subclasshook__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KKCCEOPP@helper?5for?5pickle?$AA@
CONST	SEGMENT
??_C@_0BC@KKCCEOPP@helper?5for?5pickle?$AA@ DB 'helper for pickle', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@
CONST	SEGMENT
??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@ DB '__reduce_ex__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NNMACJIG@__reduce__?$AA@
CONST	SEGMENT
??_C@_0L@NNMACJIG@__reduce__?$AA@ DB '__reduce__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05CFHBDDLG@items?$AA@
CONST	SEGMENT
??_C@_05CFHBDDLG@items?$AA@ DB 'items', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GEMAGKL@__newobj__?$AA@
CONST	SEGMENT
??_C@_0L@GEMAGKL@__newobj__?$AA@ DB '__newobj__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NAMJJHIO@__getstate__?$AA@
CONST	SEGMENT
??_C@_0N@NAMJJHIO@__getstate__?$AA@ DB '__getstate__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BCBHENLA@__getnewargs__?$AA@
CONST	SEGMENT
??_C@_0P@BCBHENLA@__getnewargs__?$AA@ DB '__getnewargs__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NMBFFBAC@_slotnames?$AA@
CONST	SEGMENT
??_C@_0L@NMBFFBAC@_slotnames?$AA@ DB '_slotnames', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NLMJLHMN@__slotnames__?$AA@
CONST	SEGMENT
??_C@_0O@NLMJLHMN@__slotnames__?$AA@ DB '__slotnames__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07ODDBKIAB@copyreg?$AA@
CONST	SEGMENT
??_C@_07ODDBKIAB@copyreg?$AA@ DB 'copyreg', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BFBMEIMB@the?5object?8s?5class?$AA@
CONST	SEGMENT
??_C@_0BD@BFBMEIMB@the?5object?8s?5class?$AA@ DB 'the object''s class', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GOHDHELE@sorted?$AA@
CONST	SEGMENT
??_C@_06GOHDHELE@sorted?$AA@ DB 'sorted', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GPMDFGEJ@type?$AA@
CONST	SEGMENT
??_C@_04GPMDFGEJ@type?$AA@ DB 'type', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@IFDKCHCE@__sizeof__?$CI?$CJ?5?9?$DO?5int?6return?5memor@
CONST	SEGMENT
??_C@_0EB@IFDKCHCE@__sizeof__?$CI?$CJ?5?9?$DO?5int?6return?5memor@ DB '__'
	DB	'sizeof__() -> int', 0aH, 'return memory consumption of the ty'
	DB	'pe object', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HOGGIPGN@__sizeof__?$AA@
CONST	SEGMENT
??_C@_0L@HOGGIPGN@__sizeof__?$AA@ DB '__sizeof__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@LCGOHIAJ@__dir__?$CI?$CJ?5?9?$DO?5list?6specialized?5__@
CONST	SEGMENT
??_C@_0DP@LCGOHIAJ@__dir__?$CI?$CJ?5?9?$DO?5list?6specialized?5__@ DB '__'
	DB	'dir__() -> list', 0aH, 'specialized __dir__ implementation fo'
	DB	'r types', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07FPPEEAND@__dir__?$AA@
CONST	SEGMENT
??_C@_07FPPEEAND@__dir__?$AA@ DB '__dir__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@PBOIKCPL@__subclasscheck__?$CI?$CJ?5?9?$DO?5bool?6chec@
CONST	SEGMENT
??_C@_0DL@PBOIKCPL@__subclasscheck__?$CI?$CJ?5?9?$DO?5bool?6chec@ DB '__s'
	DB	'ubclasscheck__() -> bool', 0aH, 'check if a class is a subcla'
	DB	'ss', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NFPPCOGG@__subclasscheck__?$AA@
CONST	SEGMENT
??_C@_0BC@NFPPCOGG@__subclasscheck__?$AA@ DB '__subclasscheck__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@KLHIJGEM@__instancecheck__?$CI?$CJ?5?9?$DO?5bool?6chec@
CONST	SEGMENT
??_C@_0DO@KLHIJGEM@__instancecheck__?$CI?$CJ?5?9?$DO?5bool?6chec@ DB '__i'
	DB	'nstancecheck__() -> bool', 0aH, 'check if an object is an ins'
	DB	'tance', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JKBHKBMG@__instancecheck__?$AA@
CONST	SEGMENT
??_C@_0BC@JKBHKBMG@__instancecheck__?$AA@ DB '__instancecheck__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@GOMGOOLM@__prepare__?$CI?$CJ?5?9?$DO?5dict?6used?5to?5cr@
CONST	SEGMENT
??_C@_0EL@GOMGOOLM@__prepare__?$CI?$CJ?5?9?$DO?5dict?6used?5to?5cr@ DB '_'
	DB	'_prepare__() -> dict', 0aH, 'used to create the namespace for'
	DB	' the class statement', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GLHNIFEH@__prepare__?$AA@
CONST	SEGMENT
??_C@_0M@GLHNIFEH@__prepare__?$AA@ DB '__prepare__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@NPEDHMIB@__subclasses__?$CI?$CJ?5?9?$DO?5list?5of?5imme@
CONST	SEGMENT
??_C@_0DB@NPEDHMIB@__subclasses__?$CI?$CJ?5?9?$DO?5list?5of?5imme@ DB '__'
	DB	'subclasses__() -> list of immediate subclasses', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IOKGGKON@__subclasses__?$AA@
CONST	SEGMENT
??_C@_0P@IOKGGKON@__subclasses__?$AA@ DB '__subclasses__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@EJDLFMM@mro?$CI?$CJ?5?9?$DO?5list?6return?5a?5type?8s?5me@
CONST	SEGMENT
??_C@_0DG@EJDLFMM@mro?$CI?$CJ?5?9?$DO?5list?6return?5a?5type?8s?5me@ DB 'm'
	DB	'ro() -> list', 0aH, 'return a type''s method resolution order'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_09EBPBKION@__slots__?$AA@
CONST	SEGMENT
??_C@_09EBPBKION@__slots__?$AA@ DB '__slots__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04BCIDKIGN@dict?$AA@
CONST	SEGMENT
??_C@_04BCIDKIGN@dict?$AA@ DB 'dict', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JMNHICHM@bases?$AA@
CONST	SEGMENT
??_C@_05JMNHICHM@bases?$AA@ DB 'bases', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name?$AA@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name?$AA@ DB 'name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@DKNNDAFM@list?5of?5weak?5references?5to?5the?5o@
CONST	SEGMENT
??_C@_0DD@DKNNDAFM@list?5of?5weak?5references?5to?5the?5o@ DB 'list of we'
	DB	'ak references to the object (if defined)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OFKEODAB@__weakref__?$AA@
CONST	SEGMENT
??_C@_0M@OFKEODAB@__weakref__?$AA@ DB '__weakref__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@GPHMLMIJ@dictionary?5for?5instance?5variable@
CONST	SEGMENT
??_C@_0CP@GPHMLMIJ@dictionary?5for?5instance?5variable@ DB 'dictionary fo'
	DB	'r instance variables (if defined)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03KCOHMEGL@mro?$AA@
CONST	SEGMENT
??_C@_03KCOHMEGL@mro?$AA@ DB 'mro', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMDECJMP@__abstractmethods__?$AA@
CONST	SEGMENT
??_C@_0BE@EMDECJMP@__abstractmethods__?$AA@ DB '__abstractmethods__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LJKDIEEK@__bases__?$AA@
CONST	SEGMENT
??_C@_09LJKDIEEK@__bases__?$AA@ DB '__bases__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FMLGAKCE@__qualname__?$AA@
CONST	SEGMENT
??_C@_0N@FMLGAKCE@__qualname__?$AA@ DB '__qualname__', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
type_members DQ	FLAT:??_C@_0O@IAOKENCJ@__basicsize__?$AA@
	DD	013H
	ORG $+4
	DQ	0000000000000078H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0N@OJNCBPH@__itemsize__?$AA@
	DD	013H
	ORG $+4
	DQ	0000000000000080H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_09GIOABLIA@__flags__?$AA@
	DD	02H
	ORG $+4
	DQ	0000000000000100H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0BC@PHCHJLGH@__weakrefoffset__?$AA@
	DD	02H
	ORG $+4
	DQ	0000000000000128H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_08PNDLAJH@__base__?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000158H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0P@NBEFJBEP@__dictoffset__?$AA@
	DD	02H
	ORG $+4
	DQ	0000000000000178H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_07MNLIDIMK@__mro__?$AA@
	DD	06H
	ORG $+4
	DQ	00000000000001b0H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
type_getsets DQ	FLAT:??_C@_08BHKDPDAA@__name__?$AA@
	DQ	FLAT:type_name
	DQ	FLAT:type_set_name
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0N@FMLGAKCE@__qualname__?$AA@
	DQ	FLAT:type_qualname
	DQ	FLAT:type_set_qualname
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_09LJKDIEEK@__bases__?$AA@
	DQ	FLAT:type_get_bases
	DQ	FLAT:type_set_bases
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0L@LNCJCPDP@__module__?$AA@
	DQ	FLAT:type_module
	DQ	FLAT:type_set_module
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BE@EMDECJMP@__abstractmethods__?$AA@
	DQ	FLAT:type_abstractmethods
	DQ	FLAT:type_set_abstractmethods
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_08IBFKALI@__dict__?$AA@
	DQ	FLAT:type_dict
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_07DIBBIFIJ@__doc__?$AA@
	DQ	FLAT:type_get_doc
	DQ	FLAT:type_set_doc
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
subtype_getsets_full DQ FLAT:??_C@_08IBFKALI@__dict__?$AA@
	DQ	FLAT:subtype_dict
	DQ	FLAT:subtype_setdict
	DQ	FLAT:??_C@_0CP@GPHMLMIJ@dictionary?5for?5instance?5variable@
	ORG $+8
	DQ	FLAT:??_C@_0M@OFKEODAB@__weakref__?$AA@
	DQ	FLAT:subtype_getweakref
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0DD@DKNNDAFM@list?5of?5weak?5references?5to?5the?5o@
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
	ORG $+8
subtype_getsets_dict_only DQ FLAT:??_C@_08IBFKALI@__dict__?$AA@
	DQ	FLAT:subtype_dict
	DQ	FLAT:subtype_setdict
	DQ	FLAT:??_C@_0CP@GPHMLMIJ@dictionary?5for?5instance?5variable@
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
subtype_getsets_weakref_only DQ FLAT:??_C@_0M@OFKEODAB@__weakref__?$AA@
	DQ	FLAT:subtype_getweakref
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0DD@DKNNDAFM@list?5of?5weak?5references?5to?5the?5o@
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
?kwlist@?1??type_new@@9@9 DQ FLAT:??_C@_04MEMAJGDJ@name?$AA@ ; `type_new'::`2'::kwlist
	DQ	FLAT:??_C@_05JMNHICHM@bases?$AA@
	DQ	FLAT:??_C@_04BCIDKIGN@dict?$AA@
	DQ	0000000000000000H
slotoffsets DW	0ffffH
	DW	00H
	DW	00H
	DW	0300H
	DW	02f0H
	DW	02f8H
	DW	0220H
	DW	01e0H
	DW	0248H
	DW	0228H
	DW	0200H
	DW	0270H
	DW	02c8H
	DW	02e8H
	DW	0278H
	DW	02b0H
	DW	02d8H
	DW	02a0H
	DW	0288H
	DW	02c0H
	DW	0298H
	DW	0290H
	DW	02a8H
	DW	0280H
	DW	02e0H
	DW	02b8H
	DW	0260H
	DW	0230H
	DW	0238H
	DW	01f0H
	DW	0210H
	DW	0258H
	DW	0218H
	DW	0208H
	DW	01f8H
	DW	0240H
	DW	01e8H
	DW	02d0H
	DW	0250H
	DW	0330H
	DW	0310H
	DW	0340H
	DW	0348H
	DW	0350H
	DW	0320H
	DW	0308H
	DW	0318H
	DW	0188H
	DW	0158H
	DW	01a8H
	DW	0d8H
	DW	0118H
	DW	088H
	DW	01d0H
	DW	0168H
	DW	0170H
	DW	0108H
	DW	098H
	DW	0e8H
	DW	0d0H
	DW	0180H
	DW	01a0H
	DW	0130H
	DW	0138H
	DW	0140H
	DW	0190H
	DW	0b0H
	DW	0120H
	DW	0a0H
	DW	0f0H
	DW	0e0H
	DW	0110H
	DW	0148H
	DW	0150H
	DW	0198H
	ORG $+10
type_methods DQ	FLAT:??_C@_03KCOHMEGL@mro?$AA@
	DQ	FLAT:mro_external
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0DG@EJDLFMM@mro?$CI?$CJ?5?9?$DO?5list?6return?5a?5type?8s?5me@
	DQ	FLAT:??_C@_0P@IOKGGKON@__subclasses__?$AA@
	DQ	FLAT:type_subclasses
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0DB@NPEDHMIB@__subclasses__?$CI?$CJ?5?9?$DO?5list?5of?5imme@
	DQ	FLAT:??_C@_0M@GLHNIFEH@__prepare__?$AA@
	DQ	FLAT:type_prepare
	DD	013H
	ORG $+4
	DQ	FLAT:??_C@_0EL@GOMGOOLM@__prepare__?$CI?$CJ?5?9?$DO?5dict?6used?5to?5cr@
	DQ	FLAT:??_C@_0BC@JKBHKBMG@__instancecheck__?$AA@
	DQ	FLAT:type___instancecheck__
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_0DO@KLHIJGEM@__instancecheck__?$CI?$CJ?5?9?$DO?5bool?6chec@
	DQ	FLAT:??_C@_0BC@NFPPCOGG@__subclasscheck__?$AA@
	DQ	FLAT:type___subclasscheck__
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_0DL@PBOIKCPL@__subclasscheck__?$CI?$CJ?5?9?$DO?5bool?6chec@
	DQ	FLAT:??_C@_07FPPEEAND@__dir__?$AA@
	DQ	FLAT:type_dir
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0DP@LCGOHIAJ@__dir__?$CI?$CJ?5?9?$DO?5list?6specialized?5__@
	DQ	FLAT:??_C@_0L@HOGGIPGN@__sizeof__?$AA@
	DQ	FLAT:type_sizeof
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0EB@IFDKCHCE@__sizeof__?$CI?$CJ?5?9?$DO?5int?6return?5memor@
	DQ	0000000000000000H
	ORG $+24
type_doc DB	'type(object) -> the object''s type', 0aH, 'type(name, ba'
	DB	'ses, dict) -> a new type', 00H
	ORG $+8
PyType_Type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_04GPMDFGEJ@type?$AA@
	DQ	0000000000000390H
	DQ	0000000000000028H
	DQ	FLAT:type_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:type_repr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:type_call
	DQ	0000000000000000H
	DQ	FLAT:type_getattro
	DQ	FLAT:type_setattro
	DQ	0000000000000000H
	DD	080044400H
	ORG $+4
	DQ	FLAT:type_doc
	DQ	FLAT:type_traverse
	DQ	FLAT:type_clear
	DQ	0000000000000000H
	DQ	00000000000001c8H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:type_methods
	DQ	FLAT:type_members
	DQ	FLAT:type_getsets
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000160H
	DQ	FLAT:type_init
	DQ	0000000000000000H
	DQ	FLAT:type_new
	DQ	FLAT:PyObject_GC_Del
	DQ	FLAT:type_is_gc
	ORG $+56
object_getsets DQ FLAT:??_C@_09LFGACEKG@__class__?$AA@
	DQ	FLAT:object_get_class
	DQ	FLAT:object_set_class
	DQ	FLAT:??_C@_0BD@BFBMEIMB@the?5object?8s?5class?$AA@
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
object_subclasshook_doc DB 'Abstract classes can override this to customi'
	DB	'ze issubclass().', 0aH, 0aH, 'This is invoked early on by abc'
	DB	'.ABCMeta.__subclasscheck__().', 0aH, 'It should return True, '
	DB	'False or NotImplemented.  If it returns', 0aH, 'NotImplemente'
	DB	'd, the normal algorithm is used.  Otherwise, it', 0aH, 'overr'
	DB	'ides the normal algorithm (and the outcome is cached).', 0aH, 00H
	ORG $+11
object_methods DQ FLAT:??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@
	DQ	FLAT:object_reduce_ex
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0BC@KKCCEOPP@helper?5for?5pickle?$AA@
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:object_reduce
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0BC@KKCCEOPP@helper?5for?5pickle?$AA@
	DQ	FLAT:??_C@_0BB@NHNPNHAH@__subclasshook__?$AA@
	DQ	FLAT:object_subclasshook
	DD	011H
	ORG $+4
	DQ	FLAT:object_subclasshook_doc
	DQ	FLAT:??_C@_0L@MEMCGMKL@__format__?$AA@
	DQ	FLAT:object_format
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0BJ@OLCCKPLB@default?5object?5formatter?$AA@
	DQ	FLAT:??_C@_0L@HOGGIPGN@__sizeof__?$AA@
	DQ	FLAT:object_sizeof
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0DH@GGNPGAHM@__sizeof__?$CI?$CJ?5?9?$DO?5int?6size?5of?5obje@
	DQ	FLAT:??_C@_07FPPEEAND@__dir__?$AA@
	DQ	FLAT:object_dir
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CP@DOIFJKJG@__dir__?$CI?$CJ?5?9?$DO?5list?6default?5dir?$CI?$CJ?5@
	DQ	0000000000000000H
	ORG $+24
PyBaseObject_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_06IEOJBDIK@object?$AA@
	DQ	0000000000000060H
	DQ	0000000000000000H
	DQ	FLAT:object_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:object_repr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:_Py_HashPointer
	DQ	0000000000000000H
	DQ	FLAT:object_str
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	FLAT:PyObject_GenericSetAttr
	DQ	0000000000000000H
	DD	040400H
	ORG $+4
	DQ	FLAT:??_C@_0BD@EEFIMND@The?5most?5base?5type?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:object_richcompare
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:object_methods
	DQ	0000000000000000H
	DQ	FLAT:object_getsets
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:object_init
	DQ	FLAT:PyType_GenericAlloc
	DQ	FLAT:object_new
	DQ	FLAT:PyObject_Free
	ORG $+64
tp_new_methoddef DQ FLAT:??_C@_07MEBHOIG@__new__?$AA@
	DQ	FLAT:tp_new_wrapper
	DD	03H
	ORG $+4
	DQ	FLAT:??_C@_0DO@MFNFNJKD@T?4__new__?$CIS?0?5?4?4?4?$CJ?5?9?$DO?5a?5new?5objec@
	DQ	0000000000000000H
	ORG $+24
name_op	DQ	0000000000000000H
	DQ	FLAT:??_C@_06KIIKIGGM@__lt__?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:??_C@_06EACPLGJG@__le__?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:??_C@_06JCEEBECP@__eq__?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:??_C@_06DKOPOFPG@__ne__?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:??_C@_06NPFKLHHN@__gt__?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:??_C@_06DHPPIHIH@__ge__?$AA@
	DQ	0000000000000000H
slotdefs DQ	FLAT:??_C@_0BB@FJMKAPEO@__getattribute__?$AA@
	DD	098H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:??_C@_00CNPNBAHC@?$AA@
	ORG $+16
	DQ	FLAT:??_C@_0M@GIDJPAP@__getattr__?$AA@
	DD	098H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:??_C@_00CNPNBAHC@?$AA@
	ORG $+16
	DQ	FLAT:??_C@_0M@CIMGLOJN@__setattr__?$AA@
	DD	0a0H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:??_C@_00CNPNBAHC@?$AA@
	ORG $+16
	DQ	FLAT:??_C@_0M@ECOKAOJC@__delattr__?$AA@
	DD	0a0H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:??_C@_00CNPNBAHC@?$AA@
	ORG $+16
	DQ	FLAT:??_C@_08HJPCHLLJ@__repr__?$AA@
	DD	0b0H
	ORG $+4
	DQ	FLAT:slot_tp_repr
	DQ	FLAT:wrap_unaryfunc
	DQ	FLAT:??_C@_0BK@EOOFHHJM@x?4__repr__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5repr?$CIx?$CJ?$AA@
	ORG $+16
	DQ	FLAT:??_C@_08FJMJDHAE@__hash__?$AA@
	DD	0d0H
	ORG $+4
	DQ	FLAT:slot_tp_hash
	DQ	FLAT:wrap_hashfunc
	DQ	FLAT:??_C@_0BK@BGPGEPCP@x?4__hash__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5hash?$CIx?$CJ?$AA@
	ORG $+16
	DQ	FLAT:??_C@_08DGBMPEPK@__call__?$AA@
	DD	0d8H
	ORG $+4
	DQ	FLAT:slot_tp_call
	DQ	FLAT:wrap_call
	DQ	FLAT:??_C@_0BM@OCNACKJL@x?4__call__?$CI?4?4?4?$CJ?5?$DM?$DN?$DN?$DO?5x?$CI?4?4?4?$CJ?$AA@
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_07NJFHCBMD@__str__?$AA@
	DD	0e0H
	ORG $+4
	DQ	FLAT:slot_tp_str
	DQ	FLAT:wrap_unaryfunc
	DQ	FLAT:??_C@_0BI@CPPGOPCF@x?4__str__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5str?$CIx?$CJ?$AA@
	ORG $+16
	DQ	FLAT:??_C@_0BB@FJMKAPEO@__getattribute__?$AA@
	DD	0e8H
	ORG $+4
	DQ	FLAT:slot_tp_getattr_hook
	DQ	FLAT:wrap_binaryfunc
	DQ	FLAT:??_C@_0CH@MJEJMFHD@x?4__getattribute__?$CI?8name?8?$CJ?5?$DM?$DN?$DN?$DO?5@
	ORG $+16
	DQ	FLAT:??_C@_0M@GIDJPAP@__getattr__?$AA@
	DD	0e8H
	ORG $+4
	DQ	FLAT:slot_tp_getattr_hook
	DQ	0000000000000000H
	DQ	FLAT:??_C@_00CNPNBAHC@?$AA@
	ORG $+16
	DQ	FLAT:??_C@_0M@CIMGLOJN@__setattr__?$AA@
	DD	0f0H
	ORG $+4
	DQ	FLAT:slot_tp_setattro
	DQ	FLAT:wrap_setattr
	DQ	FLAT:??_C@_0DB@GBCEKDDL@x?4__setattr__?$CI?8name?8?0?5value?$CJ?5?$DM?$DN?$DN@
	ORG $+16
	DQ	FLAT:??_C@_0M@ECOKAOJC@__delattr__?$AA@
	DD	0f0H
	ORG $+4
	DQ	FLAT:slot_tp_setattro
	DQ	FLAT:wrap_delattr
	DQ	FLAT:??_C@_0CG@LPHBAOH@x?4__delattr__?$CI?8name?8?$CJ?5?$DM?$DN?$DN?$DO?5del?5x@
	ORG $+16
	DQ	FLAT:??_C@_06KIIKIGGM@__lt__?$AA@
	DD	0120H
	ORG $+4
	DQ	FLAT:slot_tp_richcompare
	DQ	FLAT:richcmp_lt
	DQ	FLAT:??_C@_0BF@PGLNDMDE@x?4__lt__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DMy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_06EACPLGJG@__le__?$AA@
	DD	0120H
	ORG $+4
	DQ	FLAT:slot_tp_richcompare
	DQ	FLAT:richcmp_le
	DQ	FLAT:??_C@_0BG@DINLPMBE@x?4__le__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DM?$DNy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_06JCEEBECP@__eq__?$AA@
	DD	0120H
	ORG $+4
	DQ	FLAT:slot_tp_richcompare
	DQ	FLAT:richcmp_eq
	DQ	FLAT:??_C@_0BG@BMDNDNCO@x?4__eq__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DN?$DNy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_06DKOPOFPG@__ne__?$AA@
	DD	0120H
	ORG $+4
	DQ	FLAT:slot_tp_richcompare
	DQ	FLAT:richcmp_ne
	DQ	FLAT:??_C@_0BG@JPHMBINF@x?4__ne__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CB?$DNy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_06NPFKLHHN@__gt__?$AA@
	DD	0120H
	ORG $+4
	DQ	FLAT:slot_tp_richcompare
	DQ	FLAT:richcmp_gt
	DQ	FLAT:??_C@_0BF@EALDPMEA@x?4__gt__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DOy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_06DHPPIHIH@__ge__?$AA@
	DD	0120H
	ORG $+4
	DQ	FLAT:slot_tp_richcompare
	DQ	FLAT:richcmp_ge
	DQ	FLAT:??_C@_0BG@GPAFEHPB@x?4__ge__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DO?$DNy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_08HMKBHKEB@__iter__?$AA@
	DD	0130H
	ORG $+4
	DQ	FLAT:slot_tp_iter
	DQ	FLAT:wrap_unaryfunc
	DQ	FLAT:??_C@_0BK@MLDIHFPK@x?4__iter__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5iter?$CIx?$CJ?$AA@
	ORG $+16
	DQ	FLAT:??_C@_08MMJHJJBO@__next__?$AA@
	DD	0138H
	ORG $+4
	DQ	FLAT:slot_tp_iternext
	DQ	FLAT:wrap_next
	DQ	FLAT:??_C@_0BK@EKPAAGNF@x?4__next__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5next?$CIx?$CJ?$AA@
	ORG $+16
	DQ	FLAT:??_C@_07DJPLIAKA@__get__?$AA@
	DD	0168H
	ORG $+4
	DQ	FLAT:slot_tp_descr_get
	DQ	FLAT:wrap_descr_get
	DQ	FLAT:??_C@_0CE@IDHMMHDD@descr?4__get__?$CIobj?$FL?0?5type?$FN?$CJ?5?9?$DO?5va@
	ORG $+16
	DQ	FLAT:??_C@_07KBLMMACN@__set__?$AA@
	DD	0170H
	ORG $+4
	DQ	FLAT:slot_tp_descr_set
	DQ	FLAT:wrap_descr_set
	DQ	FLAT:??_C@_0BK@HNGNCDND@descr?4__set__?$CIobj?0?5value?$CJ?$AA@
	ORG $+16
	DQ	FLAT:??_C@_0L@OAODBFBD@__delete__?$AA@
	DD	0170H
	ORG $+4
	DQ	FLAT:slot_tp_descr_set
	DQ	FLAT:wrap_descr_delete
	DQ	FLAT:??_C@_0BG@GKILFGMF@descr?4__delete__?$CIobj?$CJ?$AA@
	ORG $+16
	DQ	FLAT:??_C@_08DOHHOJGB@__init__?$AA@
	DD	0180H
	ORG $+4
	DQ	FLAT:slot_tp_init
	DQ	FLAT:wrap_init
	DQ	FLAT:??_C@_0DP@PEBGGFGF@x?4__init__?$CI?4?4?4?$CJ?5initializes?5x?$DL?5s@
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_07MEBHOIG@__new__?$AA@
	DD	0190H
	ORG $+4
	DQ	FLAT:slot_tp_new
	DQ	0000000000000000H
	DQ	FLAT:??_C@_00CNPNBAHC@?$AA@
	ORG $+16
	DQ	FLAT:??_C@_07CKMCINHO@__del__?$AA@
	DD	01d0H
	ORG $+4
	DQ	FLAT:slot_tp_del
	DQ	0000000000000000H
	DQ	FLAT:??_C@_00CNPNBAHC@?$AA@
	ORG $+16
	DQ	FLAT:??_C@_07ICNLBNJC@__add__?$AA@
	DD	01e0H
	ORG $+4
	DQ	FLAT:slot_nb_add
	DQ	FLAT:wrap_binaryfunc_l
	DQ	FLAT:??_C@_0BG@NNPOJNOL@x?4__add__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CLy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_08CHBAAKO@__radd__?$AA@
	DD	01e0H
	ORG $+4
	DQ	FLAT:slot_nb_add
	DQ	FLAT:wrap_binaryfunc_r
	DQ	FLAT:??_C@_0BH@BHMEKCNP@x?4__radd__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$CLx?$AA@
	ORG $+16
	DQ	FLAT:??_C@_07LECOFPOM@__sub__?$AA@
	DD	01e8H
	ORG $+4
	DQ	FLAT:slot_nb_subtract
	DQ	FLAT:wrap_binaryfunc_l
	DQ	FLAT:??_C@_0BG@DBGCONBI@x?4__sub__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?9y?$AA@
	ORG $+16
	DQ	FLAT:??_C@_08DEIEECNA@__rsub__?$AA@
	DD	01e8H
	ORG $+4
	DQ	FLAT:slot_nb_subtract
	DQ	FLAT:wrap_binaryfunc_r
	DQ	FLAT:??_C@_0BH@PLFINCCM@x?4__rsub__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?9x?$AA@
	ORG $+16
	DQ	FLAT:??_C@_07GNCNELDE@__mul__?$AA@
	DD	01f0H
	ORG $+4
	DQ	FLAT:slot_nb_multiply
	DQ	FLAT:wrap_binaryfunc_l
	DQ	FLAT:??_C@_0BG@CDCBEDKH@x?4__mul__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CKy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_08ONIHFGAI@__rmul__?$AA@
	DD	01f0H
	ORG $+4
	DQ	FLAT:slot_nb_multiply
	DQ	FLAT:wrap_binaryfunc_r
	DQ	FLAT:??_C@_0BH@OJBLHMJD@x?4__rmul__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$CKx?$AA@
	ORG $+16
	DQ	FLAT:??_C@_07ICMJOMPI@__mod__?$AA@
	DD	01f8H
	ORG $+4
	DQ	FLAT:slot_nb_remainder
	DQ	FLAT:wrap_binaryfunc_l
	DQ	FLAT:??_C@_0BG@HOBDNNPB@x?4__mod__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CFy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_08CGDPBME@__rmod__?$AA@
	DD	01f8H
	ORG $+4
	DQ	FLAT:slot_nb_remainder
	DQ	FLAT:wrap_binaryfunc_r
	DQ	FLAT:??_C@_0BH@LECJOCMF@x?4__rmod__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$CFx?$AA@
	ORG $+16
	DQ	FLAT:??_C@_0L@DHDNIAEH@__divmod__?$AA@
	DD	0200H
	ORG $+4
	DQ	FLAT:slot_nb_divmod
	DQ	FLAT:wrap_binaryfunc_l
	DQ	FLAT:??_C@_0CC@ICKLDEBI@x?4__divmod__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5divmod?$CIx?0?5y@
	ORG $+16
	DQ	FLAT:??_C@_0M@NDCDLKNJ@__rdivmod__?$AA@
	DD	0200H
	ORG $+4
	DQ	FLAT:slot_nb_divmod
	DQ	FLAT:wrap_binaryfunc_r
	DQ	FLAT:??_C@_0CD@IFNHNEOL@x?4__rdivmod__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5divmod?$CIy?0?5@
	ORG $+16
	DQ	FLAT:??_C@_07HPCNAFMM@__pow__?$AA@
	DD	0208H
	ORG $+4
	DQ	FLAT:slot_nb_power
	DQ	FLAT:wrap_ternaryfunc
	DQ	FLAT:??_C@_0CG@GMODBFLE@x?4__pow__?$CIy?$FL?0?5z?$FN?$CJ?5?$DM?$DN?$DN?$DO?5pow?$CIx?0?5y?$FL@
	ORG $+16
	DQ	FLAT:??_C@_08PPIHBIPA@__rpow__?$AA@
	DD	0208H
	ORG $+4
	DQ	FLAT:slot_nb_power
	DQ	FLAT:wrap_ternaryfunc_r
	DQ	FLAT:??_C@_0CH@EKLFEJDK@y?4__rpow__?$CIx?$FL?0?5z?$FN?$CJ?5?$DM?$DN?$DN?$DO?5pow?$CIx?0?5y@
	ORG $+16
	DQ	FLAT:??_C@_07FMFICJBJ@__neg__?$AA@
	DD	0210H
	ORG $+4
	DQ	FLAT:slot_nb_negative
	DQ	FLAT:wrap_unaryfunc
	DQ	FLAT:??_C@_0BE@NIPFJBMO@x?4__neg__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5?9x?$AA@
	ORG $+16
	DQ	FLAT:??_C@_07PAEPJCJL@__pos__?$AA@
	DD	0218H
	ORG $+4
	DQ	FLAT:slot_nb_positive
	DQ	FLAT:wrap_unaryfunc
	DQ	FLAT:??_C@_0BE@CMMOLCI@x?4__pos__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5?$CLx?$AA@
	ORG $+16
	DQ	FLAT:??_C@_07MAFFIHBE@__abs__?$AA@
	DD	0220H
	ORG $+4
	DQ	FLAT:slot_nb_absolute
	DQ	FLAT:wrap_unaryfunc
	DQ	FLAT:??_C@_0BI@HMJMPBKF@x?4__abs__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5abs?$CIx?$CJ?$AA@
	ORG $+16
	DQ	FLAT:??_C@_08ONMBOEOO@__bool__?$AA@
	DD	0228H
	ORG $+4
	DQ	FLAT:slot_nb_bool
	DQ	FLAT:wrap_inquirypred
	DQ	FLAT:??_C@_0BJ@NDLGPPDN@x?4__bool__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5x?5?$CB?$DN?50?$AA@
	ORG $+16
	DQ	FLAT:??_C@_0L@OIINOIMI@__invert__?$AA@
	DD	0230H
	ORG $+4
	DQ	FLAT:slot_nb_invert
	DQ	FLAT:wrap_unaryfunc
	DQ	FLAT:??_C@_0BH@MNOEIHBG@x?4__invert__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5?$HOx?$AA@
	ORG $+16
	DQ	FLAT:??_C@_0L@JAOHJPNH@__lshift__?$AA@
	DD	0238H
	ORG $+4
	DQ	FLAT:slot_nb_lshift
	DQ	FLAT:wrap_binaryfunc_l
	DQ	FLAT:??_C@_0BK@GGNIMHNB@x?4__lshift__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DM?$DMy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_0M@HEPJKFEJ@__rlshift__?$AA@
	DD	0238H
	ORG $+4
	DQ	FLAT:slot_nb_lshift
	DQ	FLAT:wrap_binaryfunc_r
	DQ	FLAT:??_C@_0BL@ELDDDEJH@x?4__rlshift__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$DM?$DMx?$AA@
	ORG $+16
	DQ	FLAT:??_C@_0L@PEOFAGDE@__rshift__?$AA@
	DD	0240H
	ORG $+4
	DQ	FLAT:slot_nb_rshift
	DQ	FLAT:wrap_binaryfunc_l
	DQ	FLAT:??_C@_0BK@KNBAONPF@x?4__rshift__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DO?$DOy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_0M@BAPLDMKK@__rrshift__?$AA@
	DD	0240H
	ORG $+4
	DQ	FLAT:slot_nb_rshift
	DQ	FLAT:wrap_binaryfunc_r
	DQ	FLAT:??_C@_0BL@IAPLBOLD@x?4__rrshift__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$DO?$DOx?$AA@
	ORG $+16
	DQ	FLAT:??_C@_07MIGLAFDD@__and__?$AA@
	DD	0248H
	ORG $+4
	DQ	FLAT:slot_nb_and
	DQ	FLAT:wrap_binaryfunc_l
	DQ	FLAT:??_C@_0BG@OHAKNBOB@x?4__and__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CGy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_08EIMBBIAP@__rand__?$AA@
	DD	0248H
	ORG $+4
	DQ	FLAT:slot_nb_and
	DQ	FLAT:wrap_binaryfunc_r
	DQ	FLAT:??_C@_0BH@CNDAOONF@x?4__rand__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$CGx?$AA@
	ORG $+16
	DQ	FLAT:??_C@_07KEKAHHJD@__xor__?$AA@
	DD	0250H
	ORG $+4
	DQ	FLAT:slot_nb_xor
	DQ	FLAT:wrap_binaryfunc_l
	DQ	FLAT:??_C@_0BG@FJFIDAMF@x?4__xor__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$FOy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_08CEAKGKKP@__rxor__?$AA@
	DD	0250H
	ORG $+4
	DQ	FLAT:slot_nb_xor
	DQ	FLAT:wrap_binaryfunc_r
	DQ	FLAT:??_C@_0BH@JDGCAPPB@x?4__rxor__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$FOx?$AA@
	ORG $+16
	DQ	FLAT:??_C@_06MKEBKDGA@__or__?$AA@
	DD	0258H
	ORG $+4
	DQ	FLAT:slot_nb_or
	DQ	FLAT:wrap_binaryfunc_l
	DQ	FLAT:??_C@_0BF@IGCMIDJE@x?4__or__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$HMy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_07FDLFEPF@__ror__?$AA@
	DD	0258H
	ORG $+4
	DQ	FLAT:slot_nb_or
	DQ	FLAT:wrap_binaryfunc_r
	DQ	FLAT:??_C@_0BG@NBLDDBOA@x?4__ror__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?$HMx?$AA@
	ORG $+16
	DQ	FLAT:??_C@_07HECBNAMB@__int__?$AA@
	DD	0260H
	ORG $+4
	DQ	FLAT:slot_nb_int
	DQ	FLAT:wrap_unaryfunc
	DQ	FLAT:??_C@_0BI@BGKNGPBI@x?4__int__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5int?$CIx?$CJ?$AA@
	ORG $+16
	DQ	FLAT:??_C@_09EAHNLHOJ@__float__?$AA@
	DD	0270H
	ORG $+4
	DQ	FLAT:slot_nb_float
	DQ	FLAT:wrap_unaryfunc
	DQ	FLAT:??_C@_0BM@HEPIFLMJ@x?4__float__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5float?$CIx?$CJ?$AA@
	ORG $+16
	DQ	FLAT:??_C@_08GHKIMIJK@__iadd__?$AA@
	DD	0278H
	ORG $+4
	DQ	FLAT:slot_nb_inplace_add
	DQ	FLAT:wrap_binaryfunc
	DQ	FLAT:??_C@_0BI@HBADJPJO@x?4__iadd__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CL?$DNy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_08FBFNIKOE@__isub__?$AA@
	DD	0280H
	ORG $+4
	DQ	FLAT:slot_nb_inplace_subtract
	DQ	FLAT:wrap_binaryfunc
	DQ	FLAT:??_C@_0BI@FFFLKAEI@x?4__isub__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?9?$DNy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_08IIFOJODM@__imul__?$AA@
	DD	0288H
	ORG $+4
	DQ	FLAT:slot_nb_inplace_multiply
	DQ	FLAT:wrap_binaryfunc
	DQ	FLAT:??_C@_0BI@OJHENPL@x?4__imul__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CK?$DNy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_08GHLKDJPA@__imod__?$AA@
	DD	0290H
	ORG $+4
	DQ	FLAT:slot_nb_inplace_remainder
	DQ	FLAT:wrap_binaryfunc
	DQ	FLAT:??_C@_0BI@IMMCILKE@x?4__imod__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CF?$DNy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_08JKFONAME@__ipow__?$AA@
	DD	0298H
	ORG $+4
	DQ	FLAT:slot_nb_inplace_power
	DQ	FLAT:wrap_binaryfunc
	DQ	FLAT:??_C@_0BJ@IFHFJGNM@x?4__ipow__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CK?$CK?$DNy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_0M@KLLHNPFG@__ilshift__?$AA@
	DD	02a0H
	ORG $+4
	DQ	FLAT:slot_nb_inplace_lshift
	DQ	FLAT:wrap_binaryfunc
	DQ	FLAT:??_C@_0BM@NIKIIBEJ@x?4__ilshift__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DM?$DM?$DNy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_0M@MPLFEGLF@__irshift__?$AA@
	DD	02a8H
	ORG $+4
	DQ	FLAT:slot_nb_inplace_rshift
	DQ	FLAT:wrap_binaryfunc
	DQ	FLAT:??_C@_0BM@OEGAKNLC@x?4__irshift__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$DO?$DO?$DNy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_08CNBINADL@__iand__?$AA@
	DD	02b0H
	ORG $+4
	DQ	FLAT:slot_nb_inplace_and
	DQ	FLAT:wrap_binaryfunc
	DQ	FLAT:??_C@_0BI@JBOMICMM@x?4__iand__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CG?$DNy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_08EBNDKCJL@__ixor__?$AA@
	DD	02b8H
	ORG $+4
	DQ	FLAT:slot_nb_inplace_xor
	DQ	FLAT:wrap_binaryfunc
	DQ	FLAT:??_C@_0BI@KNFBDEPM@x?4__ixor__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$FO?$DNy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_07GMCKKGKN@__ior__?$AA@
	DD	02c0H
	ORG $+4
	DQ	FLAT:slot_nb_inplace_or
	DQ	FLAT:wrap_binaryfunc
	DQ	FLAT:??_C@_0BH@KMKCFFEL@x?4__ior__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$HM?$DNy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_0N@BBCJEIH@__floordiv__?$AA@
	DD	02c8H
	ORG $+4
	DQ	FLAT:slot_nb_floor_divide
	DQ	FLAT:wrap_binaryfunc_l
	DQ	FLAT:??_C@_0BM@HLMIDEGC@x?4__floordiv__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?1?1y?$AA@
	ORG $+16
	DQ	FLAT:??_C@_0O@CINMAOLP@__rfloordiv__?$AA@
	DD	02c8H
	ORG $+4
	DQ	FLAT:slot_nb_floor_divide
	DQ	FLAT:wrap_binaryfunc_r
	DQ	FLAT:??_C@_0BN@MDOPCGIM@x?4__rfloordiv__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?1?1x?$AA@
	ORG $+16
	DQ	FLAT:??_C@_0M@COJKGICO@__truediv__?$AA@
	DD	02d0H
	ORG $+4
	DQ	FLAT:slot_nb_true_divide
	DQ	FLAT:wrap_binaryfunc_l
	DQ	FLAT:??_C@_0BK@KJLHHIEM@x?4__truediv__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?1y?$AA@
	ORG $+16
	DQ	FLAT:??_C@_0N@DJMJMIFH@__rtruediv__?$AA@
	DD	02d0H
	ORG $+4
	DQ	FLAT:slot_nb_true_divide
	DQ	FLAT:wrap_binaryfunc_r
	DQ	FLAT:??_C@_0BL@BIAMFNP@x?4__rtruediv__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?1x?$AA@
	ORG $+16
	DQ	FLAT:??_C@_0O@FFFGEHEN@__ifloordiv__?$AA@
	DD	02d8H
	ORG $+4
	DQ	FLAT:slot_nb_inplace_floor_divide
	DQ	FLAT:wrap_binaryfunc
	DQ	FLAT:??_C@_0BN@KGGFDMPH@x?4__ifloordiv__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?1?1y?$AA@
	ORG $+16
	DQ	FLAT:??_C@_0N@LEBOILNI@__itruediv__?$AA@
	DD	02e0H
	ORG $+4
	DQ	FLAT:slot_nb_inplace_true_divide
	DQ	FLAT:wrap_binaryfunc
	DQ	FLAT:??_C@_0BL@NHAJGPKM@x?4__itruediv__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?1y?$AA@
	ORG $+16
	DQ	FLAT:??_C@_09NLFDFNNH@__index__?$AA@
	DD	02e8H
	ORG $+4
	DQ	FLAT:slot_nb_index
	DQ	FLAT:wrap_unaryfunc
	DQ	FLAT:??_C@_0CL@DOCBMFDB@x?$FLy?3z?$FN?5?$DM?$DN?$DN?$DO?5x?$FLy?4__index__?$CI?$CJ?3z?4__@
	ORG $+16
	DQ	FLAT:??_C@_07GMJIMHJI@__len__?$AA@
	DD	02f0H
	ORG $+4
	DQ	FLAT:slot_sq_length
	DQ	FLAT:wrap_lenfunc
	DQ	FLAT:??_C@_0BI@LJFJONPL@x?4__len__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5len?$CIx?$CJ?$AA@
	ORG $+16
	DQ	FLAT:??_C@_0M@GAJGCIJD@__getitem__?$AA@
	DD	02f8H
	ORG $+4
	DQ	FLAT:slot_mp_subscript
	DQ	FLAT:wrap_binaryfunc
	DQ	FLAT:??_C@_0BL@MOLOBEHD@x?4__getitem__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$FLy?$FN?$AA@
	ORG $+16
	DQ	FLAT:??_C@_0M@EONDAJAB@__setitem__?$AA@
	DD	0300H
	ORG $+4
	DQ	FLAT:slot_mp_ass_subscript
	DQ	FLAT:wrap_objobjargproc
	DQ	FLAT:??_C@_0CA@GAOMDJJJ@x?4__setitem__?$CIi?0?5y?$CJ?5?$DM?$DN?$DN?$DO?5x?$FLi?$FN?$DNy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_0M@CEPPLJAO@__delitem__?$AA@
	DD	0300H
	ORG $+4
	DQ	FLAT:slot_mp_ass_subscript
	DQ	FLAT:wrap_delitem
	DQ	FLAT:??_C@_0BP@HKMFPPHC@x?4__delitem__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5del?5x?$FLy?$FN?$AA@
	ORG $+16
	DQ	FLAT:??_C@_07GMJIMHJI@__len__?$AA@
	DD	0308H
	ORG $+4
	DQ	FLAT:slot_sq_length
	DQ	FLAT:wrap_lenfunc
	DQ	FLAT:??_C@_0BI@LJFJONPL@x?4__len__?$CI?$CJ?5?$DM?$DN?$DN?$DO?5len?$CIx?$CJ?$AA@
	ORG $+16
	DQ	FLAT:??_C@_07ICNLBNJC@__add__?$AA@
	DD	0310H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:wrap_binaryfunc
	DQ	FLAT:??_C@_0BG@NNPOJNOL@x?4__add__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CLy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_07GNCNELDE@__mul__?$AA@
	DD	0318H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:wrap_indexargfunc
	DQ	FLAT:??_C@_0BG@FOCCMDEC@x?4__mul__?$CIn?$CJ?5?$DM?$DN?$DN?$DO?5x?$CKn?$AA@
	ORG $+16
	DQ	FLAT:??_C@_08ONIHFGAI@__rmul__?$AA@
	DD	0318H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:wrap_indexargfunc
	DQ	FLAT:??_C@_0BH@FMFFBHMG@x?4__rmul__?$CIn?$CJ?5?$DM?$DN?$DN?$DO?5n?$CKx?$AA@
	ORG $+16
	DQ	FLAT:??_C@_0M@GAJGCIJD@__getitem__?$AA@
	DD	0320H
	ORG $+4
	DQ	FLAT:slot_sq_item
	DQ	FLAT:wrap_sq_item
	DQ	FLAT:??_C@_0BL@MOLOBEHD@x?4__getitem__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$FLy?$FN?$AA@
	ORG $+16
	DQ	FLAT:??_C@_0M@EONDAJAB@__setitem__?$AA@
	DD	0330H
	ORG $+4
	DQ	FLAT:slot_sq_ass_item
	DQ	FLAT:wrap_sq_setitem
	DQ	FLAT:??_C@_0CA@GAOMDJJJ@x?4__setitem__?$CIi?0?5y?$CJ?5?$DM?$DN?$DN?$DO?5x?$FLi?$FN?$DNy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_0M@CEPPLJAO@__delitem__?$AA@
	DD	0330H
	ORG $+4
	DQ	FLAT:slot_sq_ass_item
	DQ	FLAT:wrap_sq_delitem
	DQ	FLAT:??_C@_0BP@HKMFPPHC@x?4__delitem__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5del?5x?$FLy?$FN?$AA@
	ORG $+16
	DQ	FLAT:??_C@_0N@MCIOADFH@__contains__?$AA@
	DD	0340H
	ORG $+4
	DQ	FLAT:slot_sq_contains
	DQ	FLAT:wrap_objobjproc
	DQ	FLAT:??_C@_0BO@NHHBFPJ@x?4__contains__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5y?5in?5x?$AA@
	ORG $+16
	DQ	FLAT:??_C@_08GHKIMIJK@__iadd__?$AA@
	DD	0348H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:wrap_binaryfunc
	DQ	FLAT:??_C@_0BI@HBADJPJO@x?4__iadd__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CL?$DNy?$AA@
	ORG $+16
	DQ	FLAT:??_C@_08IIFOJODM@__imul__?$AA@
	DD	0350H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:wrap_indexargfunc
	DQ	FLAT:??_C@_0BI@OJHENPL@x?4__imul__?$CIy?$CJ?5?$DM?$DN?$DN?$DO?5x?$CK?$DNy?$AA@
	ORG $+16
	DQ	0000000000000000H
	ORG $+48
	ORG $+8
super_members DQ FLAT:??_C@_0O@BEEHOGAG@__thisclass__?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000060H
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0BL@NCAHCDDF@the?5class?5invoking?5super?$CI?$CJ?$AA@
	DQ	FLAT:??_C@_08KFOOMKEG@__self__?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000068H
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0CL@OAHEPBOJ@the?5instance?5invoking?5super?$CI?$CJ?$DL?5m@
	DQ	FLAT:??_C@_0P@FDFALBKM@__self_class__?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000070H
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0DH@MEJKBCJN@the?5type?5of?5the?5instance?5invokin@
	DQ	0000000000000000H
	ORG $+32
super_doc DB	'super() -> same as super(__class__, <first argument>)', 0aH
	DB	'super(type) -> unbound super object', 0aH, 'super(type, obj) '
	DB	'-> bound super object; requires isinstance(obj, type)', 0aH, 's'
	DB	'uper(type, type2) -> bound super object; requires issubclass('
	DB	'type2, type)', 0aH, 'Typical use to call a cooperative superc'
	DB	'lass method:', 0aH, 'class C(B):', 0aH, '    def meth(self, a'
	DB	'rg):', 0aH, '        super().meth(arg)', 0aH, 'This works for'
	DB	' class methods too:', 0aH, 'class C(B):', 0aH, '    @classmet'
	DB	'hod', 0aH, '    def cmeth(cls, arg):', 0aH, '        super().'
	DB	'cmeth(arg)', 0aH, 00H
	ORG $+12
PySuper_Type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_05MKJDPMKP@super?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:super_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:super_repr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:super_getattro
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:super_doc
	DQ	FLAT:super_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:super_members
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:super_descr_get
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:super_init
	DQ	FLAT:PyType_GenericAlloc
	DQ	FLAT:PyType_GenericNew
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
_DATA	ENDS
;	COMDAT ??_C@_07MNLIDIMK@__mro__?$AA@
CONST	SEGMENT
??_C@_07MNLIDIMK@__mro__?$AA@ DB '__mro__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NBEFJBEP@__dictoffset__?$AA@
CONST	SEGMENT
??_C@_0P@NBEFJBEP@__dictoffset__?$AA@ DB '__dictoffset__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PNDLAJH@__base__?$AA@
CONST	SEGMENT
??_C@_08PNDLAJH@__base__?$AA@ DB '__base__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PHCHJLGH@__weakrefoffset__?$AA@
CONST	SEGMENT
??_C@_0BC@PHCHJLGH@__weakrefoffset__?$AA@ DB '__weakrefoffset__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09GIOABLIA@__flags__?$AA@
CONST	SEGMENT
??_C@_09GIOABLIA@__flags__?$AA@ DB '__flags__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OJNCBPH@__itemsize__?$AA@
CONST	SEGMENT
??_C@_0N@OJNCBPH@__itemsize__?$AA@ DB '__itemsize__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IAOKENCJ@__basicsize__?$AA@
CONST	SEGMENT
??_C@_0O@IAOKENCJ@__basicsize__?$AA@ DB '__basicsize__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MEBHOIG@__new__?$AA@
CONST	SEGMENT
??_C@_07MEBHOIG@__new__?$AA@ DB '__new__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BHKDPDAA@__name__?$AA@
CONST	SEGMENT
??_C@_08BHKDPDAA@__name__?$AA@ DB '__name__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LNCJCPDP@__module__?$AA@
CONST	SEGMENT
??_C@_0L@LNCJCPDP@__module__?$AA@ DB '__module__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FJMJDHAE@__hash__?$AA@
CONST	SEGMENT
??_C@_08FJMJDHAE@__hash__?$AA@ DB '__hash__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FJMKAPEO@__getattribute__?$AA@
CONST	SEGMENT
??_C@_0BB@FJMKAPEO@__getattribute__?$AA@ DB '__getattribute__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GAJGCIJD@__getitem__?$AA@
CONST	SEGMENT
??_C@_0M@GAJGCIJD@__getitem__?$AA@ DB '__getitem__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DIBBIFIJ@__doc__?$AA@
CONST	SEGMENT
??_C@_07DIBBIFIJ@__doc__?$AA@ DB '__doc__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IBFKALI@__dict__?$AA@
CONST	SEGMENT
??_C@_08IBFKALI@__dict__?$AA@ DB '__dict__', 00H	; `string'
CONST	ENDS
_TLS	SEGMENT
PyId___doc__ DQ	0000000000000000H
	DQ	FLAT:??_C@_07DIBBIFIJ@__doc__?$AA@
	DQ	0000000000000000H
PyId___module__ DQ 0000000000000000H
	DQ	FLAT:??_C@_0L@LNCJCPDP@__module__?$AA@
	DQ	0000000000000000H
?rop_id@?1??slot_nb_true_divide@@9@9 DQ 0000000000000000H ; `slot_nb_true_divide'::`2'::rop_id
	DQ	FLAT:??_C@_0N@DJMJMIFH@__rtruediv__?$AA@
	DQ	0000000000000000H
?rop_id@?1??slot_nb_floor_divide@@9@9 DQ 0000000000000000H ; `slot_nb_floor_divide'::`2'::rop_id
	DQ	FLAT:??_C@_0O@CINMAOLP@__rfloordiv__?$AA@
	DQ	0000000000000000H
?rop_id@?1??slot_nb_or@@9@9 DQ 0000000000000000H	; `slot_nb_or'::`2'::rop_id
	DQ	FLAT:??_C@_07FDLFEPF@__ror__?$AA@
	DQ	0000000000000000H
?rop_id@?1??slot_nb_xor@@9@9 DQ 0000000000000000H	; `slot_nb_xor'::`2'::rop_id
	DQ	FLAT:??_C@_08CEAKGKKP@__rxor__?$AA@
	DQ	0000000000000000H
?rop_id@?1??slot_nb_and@@9@9 DQ 0000000000000000H	; `slot_nb_and'::`2'::rop_id
	DQ	FLAT:??_C@_08EIMBBIAP@__rand__?$AA@
	DQ	0000000000000000H
?rop_id@?1??slot_nb_rshift@@9@9 DQ 0000000000000000H	; `slot_nb_rshift'::`2'::rop_id
	DQ	FLAT:??_C@_0M@BAPLDMKK@__rrshift__?$AA@
	DQ	0000000000000000H
?rop_id@?1??slot_nb_lshift@@9@9 DQ 0000000000000000H	; `slot_nb_lshift'::`2'::rop_id
	DQ	FLAT:??_C@_0M@HEPJKFEJ@__rlshift__?$AA@
	DQ	0000000000000000H
?rop_id@?1??slot_nb_power_binary@@9@9 DQ 0000000000000000H ; `slot_nb_power_binary'::`2'::rop_id
	DQ	FLAT:??_C@_08PPIHBIPA@__rpow__?$AA@
	DQ	0000000000000000H
?rop_id@?1??slot_nb_divmod@@9@9 DQ 0000000000000000H	; `slot_nb_divmod'::`2'::rop_id
	DQ	FLAT:??_C@_0M@NDCDLKNJ@__rdivmod__?$AA@
	DQ	0000000000000000H
?rop_id@?1??slot_nb_remainder@@9@9 DQ 0000000000000000H	; `slot_nb_remainder'::`2'::rop_id
	DQ	FLAT:??_C@_08CGDPBME@__rmod__?$AA@
	DQ	0000000000000000H
?rop_id@?1??slot_nb_multiply@@9@9 DQ 0000000000000000H	; `slot_nb_multiply'::`2'::rop_id
	DQ	FLAT:??_C@_08ONIHFGAI@__rmul__?$AA@
	DQ	0000000000000000H
?rop_id@?1??slot_nb_subtract@@9@9 DQ 0000000000000000H	; `slot_nb_subtract'::`2'::rop_id
	DQ	FLAT:??_C@_08DEIEECNA@__rsub__?$AA@
	DQ	0000000000000000H
?rop_id@?1??slot_nb_add@@9@9 DQ 0000000000000000H	; `slot_nb_add'::`2'::rop_id
	DQ	FLAT:??_C@_08CHBAAKO@__radd__?$AA@
	DQ	0000000000000000H
?PyId___reduce__@?1??object_reduce_ex@@9@9 DQ 0000000000000000H ; `object_reduce_ex'::`2'::PyId___reduce__
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	0000000000000000H
PyId___new__ DQ	0000000000000000H
	DQ	FLAT:??_C@_07MEBHOIG@__new__?$AA@
	DQ	0000000000000000H
PyId___hash__ DQ 0000000000000000H
	DQ	FLAT:??_C@_08FJMJDHAE@__hash__?$AA@
	DQ	0000000000000000H
?PyId___qualname__@?1??type_new@@9@9 DQ 0000000000000000H ; `type_new'::`2'::PyId___qualname__
	DQ	FLAT:??_C@_0N@FMLGAKCE@__qualname__?$AA@
	DQ	0000000000000000H
PyId___getitem__ DQ 0000000000000000H
	DQ	FLAT:??_C@_0M@GAJGCIJD@__getitem__?$AA@
	DQ	0000000000000000H
PyId___dict__ DQ 0000000000000000H
	DQ	FLAT:??_C@_08IBFKALI@__dict__?$AA@
	DQ	0000000000000000H
?PyId___del__@?1??slot_tp_del@@9@9 DQ 0000000000000000H	; `slot_tp_del'::`2'::PyId___del__
	DQ	FLAT:??_C@_07CKMCINHO@__del__?$AA@
	DQ	0000000000000000H
?PyId___new__@?1??slot_tp_new@@9@9 DQ 0000000000000000H	; `slot_tp_new'::`2'::PyId___new__
	DQ	FLAT:??_C@_07MEBHOIG@__new__?$AA@
	DQ	0000000000000000H
?PyId___init__@?1??slot_tp_init@@9@9 DQ 0000000000000000H ; `slot_tp_init'::`2'::PyId___init__
	DQ	FLAT:??_C@_08DOHHOJGB@__init__?$AA@
	DQ	0000000000000000H
?PyId___set__@?1??slot_tp_descr_set@@9@9 DQ 0000000000000000H ; `slot_tp_descr_set'::`2'::PyId___set__
	DQ	FLAT:??_C@_07KBLMMACN@__set__?$AA@
	DQ	0000000000000000H
?PyId___delete__@?1??slot_tp_descr_set@@9@9 DQ 0000000000000000H ; `slot_tp_descr_set'::`2'::PyId___delete__
	DQ	FLAT:??_C@_0L@OAODBFBD@__delete__?$AA@
	DQ	0000000000000000H
?PyId___get__@?1??slot_tp_descr_get@@9@9 DQ 0000000000000000H ; `slot_tp_descr_get'::`2'::PyId___get__
	DQ	FLAT:??_C@_07DJPLIAKA@__get__?$AA@
	DQ	0000000000000000H
?PyId___next__@?1??slot_tp_iternext@@9@9 DQ 0000000000000000H ; `slot_tp_iternext'::`2'::PyId___next__
	DQ	FLAT:??_C@_08MMJHJJBO@__next__?$AA@
	DQ	0000000000000000H
?PyId___iter__@?1??slot_tp_iter@@9@9 DQ 0000000000000000H ; `slot_tp_iter'::`2'::PyId___iter__
	DQ	FLAT:??_C@_08HMKBHKEB@__iter__?$AA@
	DQ	0000000000000000H
?PyId___setattr__@?1??slot_tp_setattro@@9@9 DQ 0000000000000000H ; `slot_tp_setattro'::`2'::PyId___setattr__
	DQ	FLAT:??_C@_0M@CIMGLOJN@__setattr__?$AA@
	DQ	0000000000000000H
?PyId___delattr__@?1??slot_tp_setattro@@9@9 DQ 0000000000000000H ; `slot_tp_setattro'::`2'::PyId___delattr__
	DQ	FLAT:??_C@_0M@ECOKAOJC@__delattr__?$AA@
	DQ	0000000000000000H
?PyId___getattr__@?1??slot_tp_getattr_hook@@9@9 DQ 0000000000000000H ; `slot_tp_getattr_hook'::`2'::PyId___getattr__
	DQ	FLAT:??_C@_0M@GIDJPAP@__getattr__?$AA@
	DQ	0000000000000000H
?PyId___call__@?1??slot_tp_call@@9@9 DQ 0000000000000000H ; `slot_tp_call'::`2'::PyId___call__
	DQ	FLAT:??_C@_08DGBMPEPK@__call__?$AA@
	DQ	0000000000000000H
?PyId___str__@?1??slot_tp_str@@9@9 DQ 0000000000000000H	; `slot_tp_str'::`2'::PyId___str__
	DQ	FLAT:??_C@_07NJFHCBMD@__str__?$AA@
	DQ	0000000000000000H
?PyId___repr__@?1??slot_tp_repr@@9@9 DQ 0000000000000000H ; `slot_tp_repr'::`2'::PyId___repr__
	DQ	FLAT:??_C@_08HJPCHLLJ@__repr__?$AA@
	DQ	0000000000000000H
?id@?1??slot_nb_inplace_true_divide@@9@9 DQ 0000000000000000H ; `slot_nb_inplace_true_divide'::`2'::id
	DQ	FLAT:??_C@_0N@LEBOILNI@__itruediv__?$AA@
	DQ	0000000000000000H
?id@?1??slot_nb_inplace_floor_divide@@9@9 DQ 0000000000000000H ; `slot_nb_inplace_floor_divide'::`2'::id
	DQ	FLAT:??_C@_0O@FFFGEHEN@__ifloordiv__?$AA@
	DQ	0000000000000000H
?op_id@?1??slot_nb_true_divide@@9@9 DQ 0000000000000000H ; `slot_nb_true_divide'::`2'::op_id
	DQ	FLAT:??_C@_0M@COJKGICO@__truediv__?$AA@
	DQ	0000000000000000H
?op_id@?1??slot_nb_floor_divide@@9@9 DQ 0000000000000000H ; `slot_nb_floor_divide'::`2'::op_id
	DQ	FLAT:??_C@_0N@BBCJEIH@__floordiv__?$AA@
	DQ	0000000000000000H
?id@?1??slot_nb_inplace_or@@9@9 DQ 0000000000000000H	; `slot_nb_inplace_or'::`2'::id
	DQ	FLAT:??_C@_07GMCKKGKN@__ior__?$AA@
	DQ	0000000000000000H
?id@?1??slot_nb_inplace_xor@@9@9 DQ 0000000000000000H	; `slot_nb_inplace_xor'::`2'::id
	DQ	FLAT:??_C@_08EBNDKCJL@__ixor__?$AA@
	DQ	0000000000000000H
?id@?1??slot_nb_inplace_and@@9@9 DQ 0000000000000000H	; `slot_nb_inplace_and'::`2'::id
	DQ	FLAT:??_C@_08CNBINADL@__iand__?$AA@
	DQ	0000000000000000H
?id@?1??slot_nb_inplace_rshift@@9@9 DQ 0000000000000000H ; `slot_nb_inplace_rshift'::`2'::id
	DQ	FLAT:??_C@_0M@MPLFEGLF@__irshift__?$AA@
	DQ	0000000000000000H
?id@?1??slot_nb_inplace_lshift@@9@9 DQ 0000000000000000H ; `slot_nb_inplace_lshift'::`2'::id
	DQ	FLAT:??_C@_0M@KLLHNPFG@__ilshift__?$AA@
	DQ	0000000000000000H
?PyId___ipow__@?1??slot_nb_inplace_power@@9@9 DQ 0000000000000000H ; `slot_nb_inplace_power'::`2'::PyId___ipow__
	DQ	FLAT:??_C@_08JKFONAME@__ipow__?$AA@
	DQ	0000000000000000H
?id@?1??slot_nb_inplace_remainder@@9@9 DQ 0000000000000000H ; `slot_nb_inplace_remainder'::`2'::id
	DQ	FLAT:??_C@_08GHLKDJPA@__imod__?$AA@
	DQ	0000000000000000H
?id@?1??slot_nb_inplace_multiply@@9@9 DQ 0000000000000000H ; `slot_nb_inplace_multiply'::`2'::id
	DQ	FLAT:??_C@_08IIFOJODM@__imul__?$AA@
	DQ	0000000000000000H
?id@?1??slot_nb_inplace_subtract@@9@9 DQ 0000000000000000H ; `slot_nb_inplace_subtract'::`2'::id
	DQ	FLAT:??_C@_08FBFNIKOE@__isub__?$AA@
	DQ	0000000000000000H
?id@?1??slot_nb_inplace_add@@9@9 DQ 0000000000000000H	; `slot_nb_inplace_add'::`2'::id
	DQ	FLAT:??_C@_08GHKIMIJK@__iadd__?$AA@
	DQ	0000000000000000H
?id@?1??slot_nb_float@@9@9 DQ 0000000000000000H		; `slot_nb_float'::`2'::id
	DQ	FLAT:??_C@_09EAHNLHOJ@__float__?$AA@
	DQ	0000000000000000H
?id@?1??slot_nb_int@@9@9 DQ 0000000000000000H		; `slot_nb_int'::`2'::id
	DQ	FLAT:??_C@_07HECBNAMB@__int__?$AA@
	DQ	0000000000000000H
?op_id@?1??slot_nb_or@@9@9 DQ 0000000000000000H		; `slot_nb_or'::`2'::op_id
	DQ	FLAT:??_C@_06MKEBKDGA@__or__?$AA@
	DQ	0000000000000000H
?op_id@?1??slot_nb_xor@@9@9 DQ 0000000000000000H	; `slot_nb_xor'::`2'::op_id
	DQ	FLAT:??_C@_07KEKAHHJD@__xor__?$AA@
	DQ	0000000000000000H
?op_id@?1??slot_nb_and@@9@9 DQ 0000000000000000H	; `slot_nb_and'::`2'::op_id
	DQ	FLAT:??_C@_07MIGLAFDD@__and__?$AA@
	DQ	0000000000000000H
?op_id@?1??slot_nb_rshift@@9@9 DQ 0000000000000000H	; `slot_nb_rshift'::`2'::op_id
	DQ	FLAT:??_C@_0L@PEOFAGDE@__rshift__?$AA@
	DQ	0000000000000000H
?op_id@?1??slot_nb_lshift@@9@9 DQ 0000000000000000H	; `slot_nb_lshift'::`2'::op_id
	DQ	FLAT:??_C@_0L@JAOHJPNH@__lshift__?$AA@
	DQ	0000000000000000H
?id@?1??slot_nb_invert@@9@9 DQ 0000000000000000H	; `slot_nb_invert'::`2'::id
	DQ	FLAT:??_C@_0L@OIINOIMI@__invert__?$AA@
	DQ	0000000000000000H
?PyId___index__@?1??slot_nb_index@@9@9 DQ 0000000000000000H ; `slot_nb_index'::`2'::PyId___index__
	DQ	FLAT:??_C@_09NLFDFNNH@__index__?$AA@
	DQ	0000000000000000H
?PyId___bool__@?1??slot_nb_bool@@9@9 DQ 0000000000000000H ; `slot_nb_bool'::`2'::PyId___bool__
	DQ	FLAT:??_C@_08ONMBOEOO@__bool__?$AA@
	DQ	0000000000000000H
?PyId___len__@?1??slot_nb_bool@@9@9 DQ 0000000000000000H ; `slot_nb_bool'::`2'::PyId___len__
	DQ	FLAT:??_C@_07GMJIMHJI@__len__?$AA@
	DQ	0000000000000000H
?id@?1??slot_nb_absolute@@9@9 DQ 0000000000000000H	; `slot_nb_absolute'::`2'::id
	DQ	FLAT:??_C@_07MAFFIHBE@__abs__?$AA@
	DQ	0000000000000000H
?id@?1??slot_nb_positive@@9@9 DQ 0000000000000000H	; `slot_nb_positive'::`2'::id
	DQ	FLAT:??_C@_07PAEPJCJL@__pos__?$AA@
	DQ	0000000000000000H
?id@?1??slot_nb_negative@@9@9 DQ 0000000000000000H	; `slot_nb_negative'::`2'::id
	DQ	FLAT:??_C@_07FMFICJBJ@__neg__?$AA@
	DQ	0000000000000000H
?PyId___pow__@?1??slot_nb_power@@9@9 DQ 0000000000000000H ; `slot_nb_power'::`2'::PyId___pow__
	DQ	FLAT:??_C@_07HPCNAFMM@__pow__?$AA@
	DQ	0000000000000000H
?op_id@?1??slot_nb_power_binary@@9@9 DQ 0000000000000000H ; `slot_nb_power_binary'::`2'::op_id
	DQ	FLAT:??_C@_07HPCNAFMM@__pow__?$AA@
	DQ	0000000000000000H
?op_id@?1??slot_nb_divmod@@9@9 DQ 0000000000000000H	; `slot_nb_divmod'::`2'::op_id
	DQ	FLAT:??_C@_0L@DHDNIAEH@__divmod__?$AA@
	DQ	0000000000000000H
?op_id@?1??slot_nb_remainder@@9@9 DQ 0000000000000000H	; `slot_nb_remainder'::`2'::op_id
	DQ	FLAT:??_C@_07ICMJOMPI@__mod__?$AA@
	DQ	0000000000000000H
?op_id@?1??slot_nb_multiply@@9@9 DQ 0000000000000000H	; `slot_nb_multiply'::`2'::op_id
	DQ	FLAT:??_C@_07GNCNELDE@__mul__?$AA@
	DQ	0000000000000000H
?op_id@?1??slot_nb_subtract@@9@9 DQ 0000000000000000H	; `slot_nb_subtract'::`2'::op_id
	DQ	FLAT:??_C@_07LECOFPOM@__sub__?$AA@
	DQ	0000000000000000H
?op_id@?1??slot_nb_add@@9@9 DQ 0000000000000000H	; `slot_nb_add'::`2'::op_id
	DQ	FLAT:??_C@_07ICNLBNJC@__add__?$AA@
	DQ	0000000000000000H
?PyId___setitem__@?1??slot_mp_ass_subscript@@9@9 DQ 0000000000000000H ; `slot_mp_ass_subscript'::`2'::PyId___setitem__
	DQ	FLAT:??_C@_0M@EONDAJAB@__setitem__?$AA@
	DQ	0000000000000000H
?PyId___delitem__@?1??slot_mp_ass_subscript@@9@9 DQ 0000000000000000H ; `slot_mp_ass_subscript'::`2'::PyId___delitem__
	DQ	FLAT:??_C@_0M@CEPPLJAO@__delitem__?$AA@
	DQ	0000000000000000H
?id@?1??slot_mp_subscript@@9@9 DQ 0000000000000000H	; `slot_mp_subscript'::`2'::id
	DQ	FLAT:??_C@_0M@GAJGCIJD@__getitem__?$AA@
	DQ	0000000000000000H
?PyId___contains__@?1??slot_sq_contains@@9@9 DQ 0000000000000000H ; `slot_sq_contains'::`2'::PyId___contains__
	DQ	FLAT:??_C@_0N@MCIOADFH@__contains__?$AA@
	DQ	0000000000000000H
?PyId___setitem__@?1??slot_sq_ass_item@@9@9 DQ 0000000000000000H ; `slot_sq_ass_item'::`2'::PyId___setitem__
	DQ	FLAT:??_C@_0M@EONDAJAB@__setitem__?$AA@
	DQ	0000000000000000H
?PyId___delitem__@?1??slot_sq_ass_item@@9@9 DQ 0000000000000000H ; `slot_sq_ass_item'::`2'::PyId___delitem__
	DQ	FLAT:??_C@_0M@CEPPLJAO@__delitem__?$AA@
	DQ	0000000000000000H
?PyId___len__@?1??slot_sq_length@@9@9 DQ 0000000000000000H ; `slot_sq_length'::`2'::PyId___len__
	DQ	FLAT:??_C@_07GMJIMHJI@__len__?$AA@
	DQ	0000000000000000H
?PyId___eq__@?1??overrides_hash@@9@9 DQ 0000000000000000H ; `overrides_hash'::`2'::PyId___eq__
	DQ	FLAT:??_C@_06JCEEBECP@__eq__?$AA@
	DQ	0000000000000000H
?PyId_items@?P@??reduce_2@@9@9 DQ 0000000000000000H	; `reduce_2'::`15'::PyId_items
	DQ	FLAT:??_C@_05CFHBDDLG@items?$AA@
	DQ	0000000000000000H
?PyId___newobj__@?1??reduce_2@@9@9 DQ 0000000000000000H	; `reduce_2'::`2'::PyId___newobj__
	DQ	FLAT:??_C@_0L@GEMAGKL@__newobj__?$AA@
	DQ	0000000000000000H
?PyId___getstate__@?1??reduce_2@@9@9 DQ 0000000000000000H ; `reduce_2'::`2'::PyId___getstate__
	DQ	FLAT:??_C@_0N@NAMJJHIO@__getstate__?$AA@
	DQ	0000000000000000H
?PyId___getnewargs__@?1??reduce_2@@9@9 DQ 0000000000000000H ; `reduce_2'::`2'::PyId___getnewargs__
	DQ	FLAT:??_C@_0P@BCBHENLA@__getnewargs__?$AA@
	DQ	0000000000000000H
?PyId__slotnames@?1??slotnames@@9@9 DQ 0000000000000000H ; `slotnames'::`2'::PyId__slotnames
	DQ	FLAT:??_C@_0L@NMBFFBAC@_slotnames?$AA@
	DQ	0000000000000000H
?PyId___slotnames__@?1??slotnames@@9@9 DQ 0000000000000000H ; `slotnames'::`2'::PyId___slotnames__
	DQ	FLAT:??_C@_0O@NLMJLHMN@__slotnames__?$AA@
	DQ	0000000000000000H
?PyId_copyreg@?1??import_copyreg@@9@9 DQ 0000000000000000H ; `import_copyreg'::`2'::PyId_copyreg
	DQ	FLAT:??_C@_07ODDBKIAB@copyreg?$AA@
	DQ	0000000000000000H
?PyId_sorted@?3??object_new@@9@9 DQ 0000000000000000H	; `object_new'::`4'::PyId_sorted
	DQ	FLAT:??_C@_06GOHDHELE@sorted?$AA@
	DQ	0000000000000000H
?comma_id@?3??object_new@@9@9 DQ 0000000000000000H	; `object_new'::`4'::comma_id
	DQ	FLAT:??_C@_02KEGNLNML@?0?5?$AA@
	DQ	0000000000000000H
?PyId___bases__@?1??merge_class_dict@@9@9 DQ 0000000000000000H ; `merge_class_dict'::`2'::PyId___bases__
	DQ	FLAT:??_C@_09LJKDIEEK@__bases__?$AA@
	DQ	0000000000000000H
?PyId___slots__@?1??type_new@@9@9 DQ 0000000000000000H	; `type_new'::`2'::PyId___slots__
	DQ	FLAT:??_C@_09EBPBKION@__slots__?$AA@
	DQ	0000000000000000H
?PyId_mro@?3??mro_internal@@9@9 DQ 0000000000000000H	; `mro_internal'::`4'::PyId_mro
	DQ	FLAT:??_C@_03KCOHMEGL@mro?$AA@
	DQ	0000000000000000H
PyId___name__ DQ 0000000000000000H
	DQ	FLAT:??_C@_08BHKDPDAA@__name__?$AA@
	DQ	0000000000000000H
PyId___getattribute__ DQ 0000000000000000H
	DQ	FLAT:??_C@_0BB@FJMKAPEO@__getattribute__?$AA@
	DQ	0000000000000000H
PyId___class__ DQ 0000000000000000H
	DQ	FLAT:??_C@_09LFGACEKG@__class__?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_09LFGACEKG@__class__?$AA@
CONST	SEGMENT
??_C@_09LFGACEKG@__class__?$AA@ DB '__class__', 00H	; `string'
CONST	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\include\objimpl.h
_TEXT	ENDS
;	COMDAT _PyObject_InitHead
_TEXT	SEGMENT
op$ = 8
_PyObject_InitHead PROC					; COMDAT

; 216  :     assert(Py_TYPE(op));
; 217  :     op->is_px = _Py_NOT_PARALLEL;

  00000	48 ba 78 56 ef
	be 34 12 ad de	 mov	 rdx, -2401243008567650696 ; dead1234beef5678H

; 218  :     op->px    = _Py_NOT_PARALLEL;
; 219  :     op->slist_entry.Next = NULL;

  0000a	33 c0		 xor	 eax, eax

; 220  :     op->px_flags  = Py_PXFLAGS_ISPY;

  0000c	48 c7 41 20 01
	00 00 00	 mov	 QWORD PTR [rcx+32], 1
  00014	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00017	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx
  0001b	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 221  :     op->srw_lock  = NULL;

  0001f	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 222  :     op->event     = NULL;

  00023	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 223  :     op->orig_type = NULL;

  00027	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 224  : #ifdef Py_TRACE_REFS
; 225  :     op->_ob_next = NULL;
; 226  :     op->_ob_prev = NULL;
; 227  : #else
; 228  :     op->_ob_next = _Py_NOT_PARALLEL;

  0002b	48 89 51 40	 mov	 QWORD PTR [rcx+64], rdx

; 229  :     op->_ob_prev = _Py_NOT_PARALLEL;

  0002f	48 89 51 48	 mov	 QWORD PTR [rcx+72], rdx

; 230  : #endif
; 231  : }

  00033	c3		 ret	 0
_PyObject_InitHead ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@JKHPLOII@PyObject_INIT?$AA@		; `string'
PUBLIC	??_C@_0CE@FGBBJFKA@c?3?2src?2pyparallel?2include?2objimp@ ; `string'
EXTRN	_Px_NewReference:PROC
EXTRN	_PxObject_Init:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_INIT DD imagerel PyObject_INIT
	DD	imagerel PyObject_INIT+185
	DD	imagerel $unwind$PyObject_INIT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_INIT DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0O@JKHPLOII@PyObject_INIT?$AA@
CONST	SEGMENT
??_C@_0O@JKHPLOII@PyObject_INIT?$AA@ DB 'PyObject_INIT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FGBBJFKA@c?3?2src?2pyparallel?2include?2objimp@
CONST	SEGMENT
??_C@_0CE@FGBBJFKA@c?3?2src?2pyparallel?2include?2objimp@ DB 'c:\src\pypa'
	DB	'rallel\include\objimpl.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyObject_INIT
_TEXT	SEGMENT
op$ = 64
tp$ = 72
PyObject_INIT PROC					; COMDAT

; 236  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 237  :     Px_RETURN(_PxObject_Init(op, tp))

  00010	e8 00 00 00 00	 call	 _Py_PXCTX
  00015	85 c0		 test	 eax, eax
  00017	74 15		 je	 SHORT $LN1@PyObject_I
  00019	48 8b d7	 mov	 rdx, rdi
  0001c	48 8b cb	 mov	 rcx, rbx

; 242  : }

  0001f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00024	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00028	5f		 pop	 rdi
  00029	e9 00 00 00 00	 jmp	 _PxObject_Init
$LN1@PyObject_I:

; 238  :     Py_TYPE(op) = tp;
; 239  :     _PyObject_InitHead(op);

  0002e	48 b9 78 56 ef
	be 34 12 ad de	 mov	 rcx, -2401243008567650696 ; dead1234beef5678H
  00038	33 c0		 xor	 eax, eax

; 240  :     _Py_NewReference(op);

  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FGBBJFKA@c?3?2src?2pyparallel?2include?2objimp@
  00041	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  00044	48 89 4b 08	 mov	 QWORD PTR [rbx+8], rcx
  00048	48 89 4b 40	 mov	 QWORD PTR [rbx+64], rcx
  0004c	48 89 4b 48	 mov	 QWORD PTR [rbx+72], rcx
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@JKHPLOII@PyObject_INIT?$AA@
  00057	4c 8b cb	 mov	 r9, rbx
  0005a	41 b8 f0 00 00
	00		 mov	 r8d, 240		; 000000f0H
  00060	48 89 7b 58	 mov	 QWORD PTR [rbx+88], rdi
  00064	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
  00068	48 c7 43 20 01
	00 00 00	 mov	 QWORD PTR [rbx+32], 1
  00070	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax
  00074	48 89 43 30	 mov	 QWORD PTR [rbx+48], rax
  00078	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax
  0007c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00084	e8 00 00 00 00	 call	 _PyParallel_Guard
  00089	85 c0		 test	 eax, eax
  0008b	74 16		 je	 SHORT $LN4@PyObject_I
  0008d	48 8b cb	 mov	 rcx, rbx
  00090	e8 00 00 00 00	 call	 _Px_NewReference

; 241  :     return op;

  00095	48 8b c3	 mov	 rax, rbx

; 242  : }

  00098	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0009d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a1	5f		 pop	 rdi
  000a2	c3		 ret	 0
$LN4@PyObject_I:

; 240  :     _Py_NewReference(op);

  000a3	48 c7 43 50 01
	00 00 00	 mov	 QWORD PTR [rbx+80], 1

; 241  :     return op;

  000ab	48 8b c3	 mov	 rax, rbx

; 242  : }

  000ae	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b7	5f		 pop	 rdi
  000b8	c3		 ret	 0
PyObject_INIT ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@PCKAICOI@PyObject_INIT_VAR?$AA@	; `string'
EXTRN	_PxObject_InitVar:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_INIT_VAR DD imagerel PyObject_INIT_VAR
	DD	imagerel PyObject_INIT_VAR+215
	DD	imagerel $unwind$PyObject_INIT_VAR
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_INIT_VAR DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0BC@PCKAICOI@PyObject_INIT_VAR?$AA@
CONST	SEGMENT
??_C@_0BC@PCKAICOI@PyObject_INIT_VAR?$AA@ DB 'PyObject_INIT_VAR', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyObject_INIT_VAR
_TEXT	SEGMENT
op$ = 64
tp$ = 72
n$ = 80
PyObject_INIT_VAR PROC					; COMDAT

; 247  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 248  :     Px_RETURN(_PxObject_InitVar(op, tp, n))

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 1d		 je	 SHORT $LN1@PyObject_I@2
  00021	4c 8b c7	 mov	 r8, rdi
  00024	48 8b d6	 mov	 rdx, rsi
  00027	48 8b cb	 mov	 rcx, rbx

; 254  : }

  0002a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0002f	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00034	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00038	5f		 pop	 rdi
  00039	e9 00 00 00 00	 jmp	 _PxObject_InitVar
$LN1@PyObject_I@2:

; 249  :     Py_SIZE(op) = n;
; 250  :     Py_TYPE(op) = tp;
; 251  :     _PyObject_InitHead((PyObject *)op);

  0003e	48 b9 78 56 ef
	be 34 12 ad de	 mov	 rcx, -2401243008567650696 ; dead1234beef5678H
  00048	33 c0		 xor	 eax, eax

; 252  :     _Py_NewReference((PyObject *)op);

  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FGBBJFKA@c?3?2src?2pyparallel?2include?2objimp@
  00051	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  00054	48 89 4b 08	 mov	 QWORD PTR [rbx+8], rcx
  00058	48 89 4b 40	 mov	 QWORD PTR [rbx+64], rcx
  0005c	48 89 4b 48	 mov	 QWORD PTR [rbx+72], rcx
  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@PCKAICOI@PyObject_INIT_VAR?$AA@
  00067	4c 8b cb	 mov	 r9, rbx
  0006a	41 b8 fc 00 00
	00		 mov	 r8d, 252		; 000000fcH
  00070	48 89 7b 60	 mov	 QWORD PTR [rbx+96], rdi
  00074	48 89 73 58	 mov	 QWORD PTR [rbx+88], rsi
  00078	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
  0007c	48 c7 43 20 01
	00 00 00	 mov	 QWORD PTR [rbx+32], 1
  00084	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax
  00088	48 89 43 30	 mov	 QWORD PTR [rbx+48], rax
  0008c	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax
  00090	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00098	e8 00 00 00 00	 call	 _PyParallel_Guard
  0009d	85 c0		 test	 eax, eax
  0009f	74 1b		 je	 SHORT $LN4@PyObject_I@2
  000a1	48 8b cb	 mov	 rcx, rbx
  000a4	e8 00 00 00 00	 call	 _Px_NewReference

; 253  :     return op;

  000a9	48 8b c3	 mov	 rax, rbx

; 254  : }

  000ac	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b1	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000b6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ba	5f		 pop	 rdi
  000bb	c3		 ret	 0
$LN4@PyObject_I@2:
  000bc	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000c1	48 c7 43 50 01
	00 00 00	 mov	 QWORD PTR [rbx+80], 1
  000c9	48 8b c3	 mov	 rax, rbx
  000cc	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d5	5f		 pop	 rdi
  000d6	c3		 ret	 0
PyObject_INIT_VAR ENDP
_TEXT	ENDS
PUBLIC	PyType_Modified
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\objects\typeobject.c
pdata	SEGMENT
$pdata$PyType_Modified DD imagerel $LN15
	DD	imagerel $LN15+21
	DD	imagerel $unwind$PyType_Modified
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyType_Modified DD imagerel $LN15+21
	DD	imagerel $LN15+38
	DD	imagerel $chain$0$PyType_Modified
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyType_Modified DD imagerel $LN15+38
	DD	imagerel $LN15+120
	DD	imagerel $chain$2$PyType_Modified
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyType_Modified DD imagerel $LN15+120
	DD	imagerel $LN15+135
	DD	imagerel $chain$3$PyType_Modified
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyType_Modified DD imagerel $LN15+135
	DD	imagerel $LN15+141
	DD	imagerel $chain$4$PyType_Modified
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyType_Modified DD 021H
	DD	imagerel $LN15
	DD	imagerel $LN15+21
	DD	imagerel $unwind$PyType_Modified
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyType_Modified DD 021H
	DD	imagerel $LN15+21
	DD	imagerel $LN15+38
	DD	imagerel $chain$0$PyType_Modified
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyType_Modified DD 040a21H
	DD	08640aH
	DD	063405H
	DD	imagerel $LN15+21
	DD	imagerel $LN15+38
	DD	imagerel $chain$0$PyType_Modified
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyType_Modified DD 020521H
	DD	075405H
	DD	imagerel $LN15
	DD	imagerel $LN15+21
	DD	imagerel $unwind$PyType_Modified
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyType_Modified DD 020601H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyType_Modified
_TEXT	SEGMENT
type$ = 48
PyType_Modified PROC					; COMDAT

; 77   : {

$LN15:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 78   :     /* Invalidate any cached data for the specified type and all
; 79   :        subclasses.  This function is called after the base
; 80   :        classes, mro, or attributes of the type are altered.
; 81   : 
; 82   :        Invariants:
; 83   : 
; 84   :        - Py_TPFLAGS_VALID_VERSION_TAG is never set if
; 85   :          Py_TPFLAGS_HAVE_VERSION_TAG is not set (e.g. on type
; 86   :          objects coming from non-recompiled extension modules)
; 87   : 
; 88   :        - before Py_TPFLAGS_VALID_VERSION_TAG can be set on a type,
; 89   :          it must first be set on all super types.
; 90   : 
; 91   :        This function clears the Py_TPFLAGS_VALID_VERSION_TAG of a
; 92   :        type (so it must first clear it on all subclasses).  The
; 93   :        tp_version_tag value is meaningless unless this flag is set.
; 94   :        We don't assign new version tags eagerly, but only as
; 95   :        needed.
; 96   :      */
; 97   :     PyObject *raw, *ref;
; 98   :     Py_ssize_t i, n;
; 99   : 
; 100  :     if (!PyType_HasFeature(type, Py_TPFLAGS_VALID_VERSION_TAG))

  00006	f7 81 00 01 00
	00 00 00 08 00	 test	 DWORD PTR [rcx+256], 524288 ; 00080000H
  00010	48 8b f9	 mov	 rdi, rcx
  00013	74 72		 je	 SHORT $LN7@PyType_Mod

; 101  :         return;
; 102  : 
; 103  :     raw = type->tp_subclasses;

  00015	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  0001a	48 8b a9 c0 01
	00 00		 mov	 rbp, QWORD PTR [rcx+448]

; 104  :     if (raw != NULL) {

  00021	48 85 ed	 test	 rbp, rbp
  00024	74 52		 je	 SHORT $LN2@PyType_Mod

; 105  :         n = PyList_GET_SIZE(raw);

  00026	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0002b	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00030	48 8b 75 60	 mov	 rsi, QWORD PTR [rbp+96]

; 106  :         for (i = 0; i < n; i++) {

  00034	33 db		 xor	 ebx, ebx
  00036	48 85 f6	 test	 rsi, rsi
  00039	7e 33		 jle	 SHORT $LN14@PyType_Mod
  0003b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct
$LL4@PyType_Mod:

; 107  :             ref = PyList_GET_ITEM(raw, i);

  00042	48 8b 45 70	 mov	 rax, QWORD PTR [rbp+112]
  00046	48 8b 0c d8	 mov	 rcx, QWORD PTR [rax+rbx*8]

; 108  :             ref = PyWeakref_GET_OBJECT(ref);

  0004a	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0004e	48 83 79 50 00	 cmp	 QWORD PTR [rcx+80], 0
  00053	7e 11		 jle	 SHORT $LN3@PyType_Mod

; 109  :             if (ref != Py_None) {

  00055	48 3b ca	 cmp	 rcx, rdx
  00058	74 0c		 je	 SHORT $LN3@PyType_Mod

; 110  :                 PyType_Modified((PyTypeObject *)ref);

  0005a	e8 00 00 00 00	 call	 PyType_Modified
  0005f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct
$LN3@PyType_Mod:

; 106  :         for (i = 0; i < n; i++) {

  00066	48 ff c3	 inc	 rbx
  00069	48 3b de	 cmp	 rbx, rsi
  0006c	7c d4		 jl	 SHORT $LL4@PyType_Mod
$LN14@PyType_Mod:
  0006e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00073	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
$LN2@PyType_Mod:

; 111  :             }
; 112  :         }
; 113  :     }
; 114  :     type->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;

  00078	81 a7 00 01 00
	00 ff ff f7 ff	 and	 DWORD PTR [rdi+256], -524289 ; fffffffffff7ffffH
  00082	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
$LN7@PyType_Mod:

; 115  : }

  00087	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008b	5f		 pop	 rdi
  0008c	c3		 ret	 0
PyType_Modified ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@LFJFGPKP@assign_version_tag?$AA@	; `string'
PUBLIC	??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@ ; `string'
EXTRN	_PyParallel_ContextGuardFailure:PROC
_BSS	SEGMENT
method_cache DB	03000H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$assign_version_tag DD imagerel assign_version_tag
	DD	imagerel assign_version_tag+95
	DD	imagerel $unwind$assign_version_tag
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$assign_version_tag DD imagerel assign_version_tag+95
	DD	imagerel assign_version_tag+348
	DD	imagerel $chain$2$assign_version_tag
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$assign_version_tag DD imagerel assign_version_tag+348
	DD	imagerel assign_version_tag+352
	DD	imagerel $chain$4$assign_version_tag
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$assign_version_tag DD 060021H
	DD	0a7400H
	DD	095400H
	DD	083400H
	DD	imagerel assign_version_tag
	DD	imagerel assign_version_tag+95
	DD	imagerel $unwind$assign_version_tag
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$assign_version_tag DD 061921H
	DD	0a7419H
	DD	095414H
	DD	083405H
	DD	imagerel assign_version_tag
	DD	imagerel assign_version_tag+95
	DD	imagerel $unwind$assign_version_tag
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$assign_version_tag DD 020601H
	DD	060025206H
xdata	ENDS
;	COMDAT ??_C@_0BD@LFJFGPKP@assign_version_tag?$AA@
CONST	SEGMENT
??_C@_0BD@LFJFGPKP@assign_version_tag?$AA@ DB 'assign_version_tag', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
CONST	SEGMENT
??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@ DB '..\Objects\typeo'
	DB	'bject.c', 00H				; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
CONST	ENDS
;	COMDAT assign_version_tag
_TEXT	SEGMENT
type$ = 64
assign_version_tag PROC					; COMDAT

; 159  : {

  00000	40 56		 push	 rsi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b f1	 mov	 rsi, rcx

; 160  :     /* Ensure that the tp_version_tag is valid and set
; 161  :        Py_TPFLAGS_VALID_VERSION_TAG.  To respect the invariant, this
; 162  :        must first be done on all super classes.  Return 0 if this
; 163  :        cannot be done, 1 if Py_TPFLAGS_VALID_VERSION_TAG.
; 164  :     */
; 165  :     Py_ssize_t i, n;
; 166  :     PyObject *bases;
; 167  :     Py_GUARD

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 1c		 je	 SHORT $LN16@assign_ver
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@LFJFGPKP@assign_version_tag?$AA@
  00020	45 33 c9	 xor	 r9d, r9d
  00023	41 b8 a7 00 00
	00		 mov	 r8d, 167		; 000000a7H
  00029	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN16@assign_ver:

; 168  : 
; 169  :     if (PyType_HasFeature(type, Py_TPFLAGS_VALID_VERSION_TAG))

  0002e	8b 86 00 01 00
	00		 mov	 eax, DWORD PTR [rsi+256]
  00034	0f ba e0 13	 bt	 eax, 19
  00038	73 0b		 jae	 SHORT $LN15@assign_ver

; 170  :         return 1;

  0003a	b8 01 00 00 00	 mov	 eax, 1

; 204  : }

  0003f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00043	5e		 pop	 rsi
  00044	c3		 ret	 0
$LN15@assign_ver:

; 171  :     if (!PyType_HasFeature(type, Py_TPFLAGS_HAVE_VERSION_TAG))

  00045	0f ba e0 12	 bt	 eax, 18
  00049	72 08		 jb	 SHORT $LN14@assign_ver
$LN32@assign_ver:

; 172  :         return 0;

  0004b	33 c0		 xor	 eax, eax

; 204  : }

  0004d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00051	5e		 pop	 rsi
  00052	c3		 ret	 0
$LN14@assign_ver:

; 173  :     if (!PyType_HasFeature(type, Py_TPFLAGS_READY))

  00053	0f ba e0 0c	 bt	 eax, 12

; 174  :         return 0;

  00057	73 f2		 jae	 SHORT $LN32@assign_ver

; 175  : 
; 176  :     type->tp_version_tag = next_version_tag++;

  00059	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR next_version_tag
  0005f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 177  :     /* for stress-testing: next_version_tag &= 0xFF; */
; 178  : 
; 179  :     if (type->tp_version_tag == 0) {
; 180  :         /* wrap-around or just starting Python - clear the whole
; 181  :            cache by filling names with references to Py_None.
; 182  :            Values are also set to NULL for added protection, as they
; 183  :            are borrowed reference */
; 184  :         for (i = 0; i < (1 << MCACHE_SIZE_EXP); i++) {

  00064	33 db		 xor	 ebx, ebx
  00066	89 86 d8 01 00
	00		 mov	 DWORD PTR [rsi+472], eax
  0006c	ff c0		 inc	 eax
  0006e	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  00073	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00078	89 05 00 00 00
	00		 mov	 DWORD PTR next_version_tag, eax
  0007e	39 9e d8 01 00
	00		 cmp	 DWORD PTR [rsi+472], ebx
  00084	0f 85 82 00 00
	00		 jne	 $LN12@assign_ver
  0008a	48 8d 3d 08 00
	00 00		 lea	 rdi, OFFSET FLAT:method_cache+8
  00091	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:_Py_NoneStruct
  00098	48 8d 2d 08 30
	00 00		 lea	 rbp, OFFSET FLAT:method_cache+12296
  0009f	90		 npad	 1
$LL11@assign_ver:

; 185  :             method_cache[i].value = NULL;
; 186  :             Py_XDECREF(method_cache[i].name);

  000a0	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  000a3	48 89 5f 08	 mov	 QWORD PTR [rdi+8], rbx
  000a7	48 85 c9	 test	 rcx, rcx
  000aa	74 05		 je	 SHORT $LN7@assign_ver
  000ac	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@assign_ver:

; 187  :             method_cache[i].name = Py_None;

  000b1	48 89 37	 mov	 QWORD PTR [rdi], rsi

; 188  :             Py_INCREF(Py_None);

  000b4	e8 00 00 00 00	 call	 _Py_PXCTX
  000b9	85 c0		 test	 eax, eax
  000bb	75 38		 jne	 SHORT $LN10@assign_ver
  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000cb	4c 8b ce	 mov	 r9, rsi
  000ce	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000d4	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000dc	e8 00 00 00 00	 call	 _PyParallel_Guard
  000e1	85 c0		 test	 eax, eax
  000e3	75 09		 jne	 SHORT $LN19@assign_ver
  000e5	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000ec	74 07		 je	 SHORT $LN10@assign_ver
$LN19@assign_ver:
  000ee	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN10@assign_ver:

; 177  :     /* for stress-testing: next_version_tag &= 0xFF; */
; 178  : 
; 179  :     if (type->tp_version_tag == 0) {
; 180  :         /* wrap-around or just starting Python - clear the whole
; 181  :            cache by filling names with references to Py_None.
; 182  :            Values are also set to NULL for added protection, as they
; 183  :            are borrowed reference */
; 184  :         for (i = 0; i < (1 << MCACHE_SIZE_EXP); i++) {

  000f5	48 83 c7 18	 add	 rdi, 24
  000f9	48 3b fd	 cmp	 rdi, rbp
  000fc	7c a2		 jl	 SHORT $LL11@assign_ver

; 189  :         }
; 190  :         /* mark all version tags as invalid */
; 191  :         PyType_Modified(&PyBaseObject_Type);

  000fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBaseObject_Type
  00105	e8 00 00 00 00	 call	 PyType_Modified

; 192  :         return 1;

  0010a	eb 36		 jmp	 SHORT $LN31@assign_ver
$LN12@assign_ver:

; 193  :     }
; 194  :     bases = type->tp_bases;

  0010c	48 8b be a8 01
	00 00		 mov	 rdi, QWORD PTR [rsi+424]

; 195  :     n = PyTuple_GET_SIZE(bases);

  00113	48 8b 6f 60	 mov	 rbp, QWORD PTR [rdi+96]

; 196  :     for (i = 0; i < n; i++) {

  00117	48 85 ed	 test	 rbp, rbp
  0011a	7e 1c		 jle	 SHORT $LN2@assign_ver

; 193  :     }
; 194  :     bases = type->tp_bases;

  0011c	48 83 c7 70	 add	 rdi, 112		; 00000070H
$LL4@assign_ver:

; 197  :         PyObject *b = PyTuple_GET_ITEM(bases, i);
; 198  :         assert(PyType_Check(b));
; 199  :         if (!assign_version_tag((PyTypeObject *)b))

  00120	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00123	e8 00 00 00 00	 call	 assign_version_tag
  00128	85 c0		 test	 eax, eax
  0012a	74 30		 je	 SHORT $LN25@assign_ver

; 196  :     for (i = 0; i < n; i++) {

  0012c	48 ff c3	 inc	 rbx
  0012f	48 83 c7 08	 add	 rdi, 8
  00133	48 3b dd	 cmp	 rbx, rbp
  00136	7c e8		 jl	 SHORT $LL4@assign_ver
$LN2@assign_ver:

; 201  :     }
; 202  :     type->tp_flags |= Py_TPFLAGS_VALID_VERSION_TAG;

  00138	81 8e 00 01 00
	00 00 00 08 00	 or	 DWORD PTR [rsi+256], 524288 ; 00080000H
$LN31@assign_ver:

; 203  :     return 1;

  00142	b8 01 00 00 00	 mov	 eax, 1
$LN30@assign_ver:
  00147	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0014c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00151	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 204  : }

  00156	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0015a	5e		 pop	 rsi
  0015b	c3		 ret	 0
$LN25@assign_ver:

; 200  :             return 0;

  0015c	33 c0		 xor	 eax, eax
  0015e	eb e7		 jmp	 SHORT $LN30@assign_ver
assign_version_tag ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@GNPKCBL@can?8t?5delete?5?$CFs?4?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BA@KPNEJFKD@can?8t?5set?5?$CFs?4?$CFs?$AA@ ; `string'
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_set_special_type_attr DD imagerel check_set_special_type_attr
	DD	imagerel check_set_special_type_attr+97
	DD	imagerel $unwind$check_set_special_type_attr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_set_special_type_attr DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BD@GNPKCBL@can?8t?5delete?5?$CFs?4?$CFs?$AA@
CONST	SEGMENT
??_C@_0BD@GNPKCBL@can?8t?5delete?5?$CFs?4?$CFs?$AA@ DB 'can''t delete %s.'
	DB	'%s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KPNEJFKD@can?8t?5set?5?$CFs?4?$CFs?$AA@
CONST	SEGMENT
??_C@_0BA@KPNEJFKD@can?8t?5set?5?$CFs?4?$CFs?$AA@ DB 'can''t set %s.%s', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT check_set_special_type_attr
_TEXT	SEGMENT
type$ = 48
value$ = 56
name$ = 64
check_set_special_type_attr PROC			; COMDAT

; 222  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 223  :     if (!(type->tp_flags & Py_TPFLAGS_HEAPTYPE)) {

  00004	f7 81 00 01 00
	00 00 02 00 00	 test	 DWORD PTR [rcx+256], 512 ; 00000200H
  0000e	75 21		 jne	 SHORT $LN2@check_set_

; 224  :         PyErr_Format(PyExc_TypeError,
; 225  :                      "can't set %s.%s", type->tp_name, name);

  00010	4d 8b c8	 mov	 r9, r8
  00013	4c 8b 41 70	 mov	 r8, QWORD PTR [rcx+112]
  00017	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@KPNEJFKD@can?8t?5set?5?$CFs?4?$CFs?$AA@
  00025	e8 00 00 00 00	 call	 PyErr_Format

; 226  :         return 0;

  0002a	33 c0		 xor	 eax, eax

; 234  : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
$LN2@check_set_:

; 227  :     }
; 228  :     if (!value) {

  00031	48 85 d2	 test	 rdx, rdx
  00034	75 21		 jne	 SHORT $LN1@check_set_

; 229  :         PyErr_Format(PyExc_TypeError,
; 230  :                      "can't delete %s.%s", type->tp_name, name);

  00036	4d 8b c8	 mov	 r9, r8
  00039	4c 8b 41 70	 mov	 r8, QWORD PTR [rcx+112]
  0003d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@GNPKCBL@can?8t?5delete?5?$CFs?4?$CFs?$AA@
  0004b	e8 00 00 00 00	 call	 PyErr_Format

; 231  :         return 0;

  00050	33 c0		 xor	 eax, eax

; 234  : }

  00052	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00056	c3		 ret	 0
$LN1@check_set_:

; 232  :     }
; 233  :     return 1;

  00057	b8 01 00 00 00	 mov	 eax, 1

; 234  : }

  0005c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00060	c3		 ret	 0
check_set_special_type_attr ENDP
_TEXT	ENDS
EXTRN	PyUnicode_FromString:PROC
EXTRN	__imp_strrchr:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$type_name DD imagerel type_name
	DD	imagerel type_name+21
	DD	imagerel $unwind$type_name
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$type_name DD imagerel type_name+21
	DD	imagerel type_name+110
	DD	imagerel $chain$0$type_name
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$type_name DD imagerel type_name+110
	DD	imagerel type_name+163
	DD	imagerel $chain$1$type_name
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$type_name DD 021H
	DD	imagerel type_name
	DD	imagerel type_name+21
	DD	imagerel $unwind$type_name
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$type_name DD 020521H
	DD	087405H
	DD	imagerel type_name
	DD	imagerel type_name+21
	DD	imagerel $unwind$type_name
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_name DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT type_name
_TEXT	SEGMENT
type$ = 64
context$ = 72
type_name PROC						; COMDAT

; 238  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 239  :     const char *s;
; 240  : 
; 241  :     if (type->tp_flags & Py_TPFLAGS_HEAPTYPE) {

  00006	f7 81 00 01 00
	00 00 02 00 00	 test	 DWORD PTR [rcx+256], 512 ; 00000200H
  00010	48 8b d9	 mov	 rbx, rcx
  00013	74 59		 je	 SHORT $LN4@type_name

; 242  :         PyHeapTypeObject* et = (PyHeapTypeObject*)type;
; 243  : 
; 244  :         Py_INCREF(et->ht_name);

  00015	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  0001a	48 8b b9 68 03
	00 00		 mov	 rdi, QWORD PTR [rcx+872]
  00021	e8 00 00 00 00	 call	 _Py_PXCTX
  00026	85 c0		 test	 eax, eax
  00028	75 32		 jne	 SHORT $LN8@type_name
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00038	4c 8b cf	 mov	 r9, rdi
  0003b	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00041	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00049	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004e	85 c0		 test	 eax, eax
  00050	75 06		 jne	 SHORT $LN7@type_name
  00052	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  00056	74 04		 je	 SHORT $LN8@type_name
$LN7@type_name:
  00058	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN8@type_name:

; 245  :         return et->ht_name;

  0005c	48 8b 83 68 03
	00 00		 mov	 rax, QWORD PTR [rbx+872]
  00063	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 254  :     }
; 255  : }

  00068	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006c	5b		 pop	 rbx
  0006d	c3		 ret	 0
$LN4@type_name:

; 246  :     }
; 247  :     else {
; 248  :         s = strrchr(type->tp_name, '.');

  0006e	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00072	ba 2e 00 00 00	 mov	 edx, 46			; 0000002eH
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strrchr

; 249  :         if (s == NULL)

  0007d	48 85 c0	 test	 rax, rax
  00080	75 11		 jne	 SHORT $LN2@type_name

; 250  :             s = type->tp_name;

  00082	48 8b 43 70	 mov	 rax, QWORD PTR [rbx+112]

; 253  :         return PyUnicode_FromString(s);

  00086	48 8b c8	 mov	 rcx, rax

; 254  :     }
; 255  : }

  00089	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008d	5b		 pop	 rbx
  0008e	e9 00 00 00 00	 jmp	 PyUnicode_FromString
$LN2@type_name:

; 251  :         else
; 252  :             s++;

  00093	48 ff c0	 inc	 rax

; 253  :         return PyUnicode_FromString(s);

  00096	48 8b c8	 mov	 rcx, rax

; 254  :     }
; 255  : }

  00099	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009d	5b		 pop	 rbx
  0009e	e9 00 00 00 00	 jmp	 PyUnicode_FromString
type_name ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$type_qualname DD imagerel type_qualname
	DD	imagerel type_qualname+21
	DD	imagerel $unwind$type_qualname
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$type_qualname DD imagerel type_qualname+21
	DD	imagerel type_qualname+110
	DD	imagerel $chain$0$type_qualname
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$type_qualname DD imagerel type_qualname+110
	DD	imagerel type_qualname+120
	DD	imagerel $chain$1$type_qualname
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$type_qualname DD 021H
	DD	imagerel type_qualname
	DD	imagerel type_qualname+21
	DD	imagerel $unwind$type_qualname
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$type_qualname DD 020521H
	DD	083405H
	DD	imagerel type_qualname
	DD	imagerel type_qualname+21
	DD	imagerel $unwind$type_qualname
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_qualname DD 020601H
	DD	070025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT type_qualname
_TEXT	SEGMENT
type$ = 64
context$ = 72
type_qualname PROC					; COMDAT

; 259  : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 260  :     if (type->tp_flags & Py_TPFLAGS_HEAPTYPE) {

  00006	f7 81 00 01 00
	00 00 02 00 00	 test	 DWORD PTR [rcx+256], 512 ; 00000200H
  00010	48 8b f9	 mov	 rdi, rcx
  00013	74 59		 je	 SHORT $LN2@type_qualn

; 261  :         PyHeapTypeObject* et = (PyHeapTypeObject*)type;
; 262  :         Py_INCREF(et->ht_qualname);

  00015	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0001a	48 8b 99 78 03
	00 00		 mov	 rbx, QWORD PTR [rcx+888]
  00021	e8 00 00 00 00	 call	 _Py_PXCTX
  00026	85 c0		 test	 eax, eax
  00028	75 32		 jne	 SHORT $LN6@type_qualn
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00038	4c 8b cb	 mov	 r9, rbx
  0003b	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00041	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00049	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004e	85 c0		 test	 eax, eax
  00050	75 06		 jne	 SHORT $LN5@type_qualn
  00052	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00056	74 04		 je	 SHORT $LN6@type_qualn
$LN5@type_qualn:
  00058	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN6@type_qualn:

; 263  :         return et->ht_qualname;

  0005c	48 8b 87 78 03
	00 00		 mov	 rax, QWORD PTR [rdi+888]
  00063	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 264  :     }
; 265  :     else {
; 266  :         return type_name(type, context);
; 267  :     }
; 268  : }

  00068	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006c	5f		 pop	 rdi
  0006d	c3		 ret	 0
$LN2@type_qualn:
  0006e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00072	5f		 pop	 rdi
  00073	e9 00 00 00 00	 jmp	 type_name
type_qualname ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@CHHLCICM@__name__?5must?5not?5contain?5null?5b@ ; `string'
PUBLIC	??_C@_01LOCGONAA@?$AA?$AA@			; `string'
PUBLIC	??_C@_0DA@PFEBGGEN@can?5only?5assign?5string?5to?5?$CFs?4__n@ ; `string'
EXTRN	PyUnicode_AsUTF8:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyUnicode_Contains:PROC
EXTRN	PyUnicode_FromStringAndSize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$type_set_name DD imagerel type_set_name
	DD	imagerel type_set_name+102
	DD	imagerel $unwind$type_set_name
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$type_set_name DD imagerel type_set_name+102
	DD	imagerel type_set_name+181
	DD	imagerel $chain$0$type_set_name
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$type_set_name DD imagerel type_set_name+181
	DD	imagerel type_set_name+251
	DD	imagerel $chain$2$type_set_name
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$type_set_name DD 020021H
	DD	067400H
	DD	imagerel type_set_name
	DD	imagerel type_set_name+102
	DD	imagerel $unwind$type_set_name
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$type_set_name DD 020521H
	DD	067405H
	DD	imagerel type_set_name
	DD	imagerel type_set_name+102
	DD	imagerel $unwind$type_set_name
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_set_name DD 040a01H
	DD	07340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT ??_C@_0CF@CHHLCICM@__name__?5must?5not?5contain?5null?5b@
CONST	SEGMENT
??_C@_0CF@CHHLCICM@__name__?5must?5not?5contain?5null?5b@ DB '__name__ mu'
	DB	'st not contain null bytes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01LOCGONAA@?$AA?$AA@
CONST	SEGMENT
??_C@_01LOCGONAA@?$AA?$AA@ DB 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@PFEBGGEN@can?5only?5assign?5string?5to?5?$CFs?4__n@
CONST	SEGMENT
??_C@_0DA@PFEBGGEN@can?5only?5assign?5string?5to?5?$CFs?4__n@ DB 'can onl'
	DB	'y assign string to %s.__name__, not ''%s''', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT type_set_name
_TEXT	SEGMENT
type$ = 48
value$ = 56
context$ = 64
type_set_name PROC					; COMDAT

; 272  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 273  :     PyHeapTypeObject* et;
; 274  :     char *tp_name;
; 275  :     PyObject *tmp;
; 276  : 
; 277  :     if (!check_set_special_type_attr(type, value, "__name__"))

  0000a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_08BHKDPDAA@__name__?$AA@
  00011	48 8b da	 mov	 rbx, rdx
  00014	48 8b f1	 mov	 rsi, rcx
  00017	e8 00 00 00 00	 call	 check_set_special_type_attr
  0001c	85 c0		 test	 eax, eax

; 278  :         return -1;

  0001e	74 2c		 je	 SHORT $LN10@type_set_n

; 279  :     if (!PyUnicode_Check(value)) {

  00020	4c 8b 4b 58	 mov	 r9, QWORD PTR [rbx+88]
  00024	41 f7 81 00 01
	00 00 00 00 00
	10		 test	 DWORD PTR [r9+256], 268435456 ; 10000000H
  0002f	75 29		 jne	 SHORT $LN4@type_set_n

; 280  :         PyErr_Format(PyExc_TypeError,
; 281  :                      "can only assign string to %s.__name__, not '%s'",
; 282  :                      type->tp_name, Py_TYPE(value)->tp_name);

  00031	4d 8b 49 70	 mov	 r9, QWORD PTR [r9+112]
  00035	4c 8b 46 70	 mov	 r8, QWORD PTR [rsi+112]
  00039	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@PFEBGGEN@can?5only?5assign?5string?5to?5?$CFs?4__n@
  00047	e8 00 00 00 00	 call	 PyErr_Format
$LN10@type_set_n:

; 283  :         return -1;

  0004c	83 c8 ff	 or	 eax, -1

; 313  : 
; 314  :     return 0;
; 315  : }

  0004f	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00054	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00058	5e		 pop	 rsi
  00059	c3		 ret	 0
$LN4@type_set_n:

; 284  :     }
; 285  : 
; 286  :     /* Check absence of null characters */
; 287  :     tmp = PyUnicode_FromStringAndSize("\0", 1);

  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01LOCGONAA@?$AA?$AA@
  00061	ba 01 00 00 00	 mov	 edx, 1
  00066	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0006b	e8 00 00 00 00	 call	 PyUnicode_FromStringAndSize
  00070	48 8b f8	 mov	 rdi, rax

; 288  :     if (tmp == NULL)

  00073	48 85 c0	 test	 rax, rax

; 289  :         return -1;

  00076	74 2a		 je	 SHORT $LN9@type_set_n

; 290  :     if (PyUnicode_Contains(value, tmp) != 0) {

  00078	48 8b d0	 mov	 rdx, rax
  0007b	48 8b cb	 mov	 rcx, rbx
  0007e	e8 00 00 00 00	 call	 PyUnicode_Contains

; 291  :         Py_DECREF(tmp);

  00083	48 8b cf	 mov	 rcx, rdi
  00086	85 c0		 test	 eax, eax
  00088	74 2b		 je	 SHORT $LN2@type_set_n
  0008a	e8 00 00 00 00	 call	 _Py_DecRef

; 292  :         PyErr_Format(PyExc_ValueError,
; 293  :                      "__name__ must not contain null bytes");

  0008f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00096	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@CHHLCICM@__name__?5must?5not?5contain?5null?5b@
  0009d	e8 00 00 00 00	 call	 PyErr_Format
$LN9@type_set_n:

; 294  :         return -1;

  000a2	83 c8 ff	 or	 eax, -1
  000a5	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 313  : 
; 314  :     return 0;
; 315  : }

  000aa	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000af	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b3	5e		 pop	 rsi
  000b4	c3		 ret	 0
$LN2@type_set_n:

; 295  :     }
; 296  :     Py_DECREF(tmp);

  000b5	e8 00 00 00 00	 call	 _Py_DecRef

; 297  : 
; 298  :     tp_name = _PyUnicode_AsString(value);

  000ba	48 8b cb	 mov	 rcx, rbx
  000bd	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  000c2	48 8b f8	 mov	 rdi, rax

; 299  :     if (tp_name == NULL)

  000c5	48 85 c0	 test	 rax, rax

; 300  :         return -1;

  000c8	74 d8		 je	 SHORT $LN9@type_set_n

; 301  : 
; 302  :     et = (PyHeapTypeObject*)type;
; 303  : 
; 304  :     Py_INCREF(value);

  000ca	48 8b cb	 mov	 rcx, rbx
  000cd	e8 00 00 00 00	 call	 _Py_IncRef

; 305  : 
; 306  :     /* Wait until et is a sane state before Py_DECREF'ing the old et->ht_name
; 307  :        value.  (Bug #16447.)  */
; 308  :     tmp = et->ht_name;

  000d2	48 8b 8e 68 03
	00 00		 mov	 rcx, QWORD PTR [rsi+872]

; 309  :     et->ht_name = value;

  000d9	48 89 9e 68 03
	00 00		 mov	 QWORD PTR [rsi+872], rbx

; 310  : 
; 311  :     type->tp_name = tp_name;

  000e0	48 89 7e 70	 mov	 QWORD PTR [rsi+112], rdi

; 312  :     Py_DECREF(tmp);

  000e4	e8 00 00 00 00	 call	 _Py_DecRef
  000e9	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 313  : 
; 314  :     return 0;
; 315  : }

  000ee	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000f3	33 c0		 xor	 eax, eax
  000f5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f9	5e		 pop	 rsi
  000fa	c3		 ret	 0
type_set_name ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@BPFPODOA@can?5only?5assign?5string?5to?5?$CFs?4__q@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$type_set_qualname DD imagerel type_set_qualname
	DD	imagerel type_set_qualname+181
	DD	imagerel $unwind$type_set_qualname
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_set_qualname DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0DE@BPFPODOA@can?5only?5assign?5string?5to?5?$CFs?4__q@
CONST	SEGMENT
??_C@_0DE@BPFPODOA@can?5only?5assign?5string?5to?5?$CFs?4__q@ DB 'can onl'
	DB	'y assign string to %s.__qualname__, not ''%s''', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
CONST	ENDS
;	COMDAT type_set_qualname
_TEXT	SEGMENT
type$ = 64
value$ = 72
context$ = 80
type_set_qualname PROC					; COMDAT

; 319  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 320  :     PyHeapTypeObject* et;
; 321  : 
; 322  :     if (!check_set_special_type_attr(type, value, "__qualname__"))

  0000a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@FMLGAKCE@__qualname__?$AA@
  00011	48 8b da	 mov	 rbx, rdx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	e8 00 00 00 00	 call	 check_set_special_type_attr
  0001c	85 c0		 test	 eax, eax

; 323  :         return -1;

  0001e	74 2c		 je	 SHORT $LN9@type_set_q

; 324  :     if (!PyUnicode_Check(value)) {

  00020	4c 8b 4b 58	 mov	 r9, QWORD PTR [rbx+88]
  00024	41 f7 81 00 01
	00 00 00 00 00
	10		 test	 DWORD PTR [r9+256], 268435456 ; 10000000H
  0002f	75 29		 jne	 SHORT $LN1@type_set_q

; 325  :         PyErr_Format(PyExc_TypeError,
; 326  :                      "can only assign string to %s.__qualname__, not '%s'",
; 327  :                      type->tp_name, Py_TYPE(value)->tp_name);

  00031	4d 8b 49 70	 mov	 r9, QWORD PTR [r9+112]
  00035	4c 8b 47 70	 mov	 r8, QWORD PTR [rdi+112]
  00039	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@BPFPODOA@can?5only?5assign?5string?5to?5?$CFs?4__q@
  00047	e8 00 00 00 00	 call	 PyErr_Format
$LN9@type_set_q:

; 328  :         return -1;

  0004c	83 c8 ff	 or	 eax, -1

; 335  :     return 0;
; 336  : }

  0004f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00054	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00058	5f		 pop	 rdi
  00059	c3		 ret	 0
$LN1@type_set_q:

; 329  :     }
; 330  : 
; 331  :     et = (PyHeapTypeObject*)type;
; 332  :     Py_INCREF(value);

  0005a	e8 00 00 00 00	 call	 _Py_PXCTX
  0005f	85 c0		 test	 eax, eax
  00061	75 32		 jne	 SHORT $LN6@type_set_q
  00063	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00071	4c 8b cb	 mov	 r9, rbx
  00074	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0007a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00082	e8 00 00 00 00	 call	 _PyParallel_Guard
  00087	85 c0		 test	 eax, eax
  00089	75 06		 jne	 SHORT $LN5@type_set_q
  0008b	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0008f	74 04		 je	 SHORT $LN6@type_set_q
$LN5@type_set_q:
  00091	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN6@type_set_q:

; 333  :     Py_DECREF(et->ht_qualname);

  00095	48 8b 8f 78 03
	00 00		 mov	 rcx, QWORD PTR [rdi+888]
  0009c	e8 00 00 00 00	 call	 _Py_DecRef

; 334  :     et->ht_qualname = value;

  000a1	48 89 9f 78 03
	00 00		 mov	 QWORD PTR [rdi+888], rbx

; 335  :     return 0;
; 336  : }

  000a8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ad	33 c0		 xor	 eax, eax
  000af	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b3	5f		 pop	 rdi
  000b4	c3		 ret	 0
type_set_qualname ENDP
_TEXT	ENDS
PUBLIC	??_C@_08OCOMCJAJ@builtins?$AA@			; `string'
EXTRN	PyExc_AttributeError:QWORD
EXTRN	_PyDict_GetItemId:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$type_module DD imagerel type_module
	DD	imagerel type_module+222
	DD	imagerel $unwind$type_module
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_module DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_08OCOMCJAJ@builtins?$AA@
CONST	SEGMENT
??_C@_08OCOMCJAJ@builtins?$AA@ DB 'builtins', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
CONST	ENDS
;	COMDAT type_module
_TEXT	SEGMENT
type$ = 64
context$ = 72
type_module PROC					; COMDAT

; 340  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 341  :     PyObject *mod;
; 342  :     char *s;
; 343  : 
; 344  :     if (type->tp_flags & Py_TPFLAGS_HEAPTYPE) {

  00006	f7 81 00 01 00
	00 00 02 00 00	 test	 DWORD PTR [rcx+256], 512 ; 00000200H
  00010	48 8b d9	 mov	 rbx, rcx
  00013	0f 84 8c 00 00
	00		 je	 $LN8@type_modul

; 345  :         mod = _PyDict_GetItemId(type->tp_dict, &PyId___module__);

  00019	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00020	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00029	48 8b 89 60 01
	00 00		 mov	 rcx, QWORD PTR [rcx+352]
  00030	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId___module__
  00035	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  00039	e8 00 00 00 00	 call	 _PyDict_GetItemId
  0003e	48 8b d8	 mov	 rbx, rax

; 346  :         if (!mod) {

  00041	48 85 c0	 test	 rax, rax
  00044	75 1b		 jne	 SHORT $LN15@type_modul

; 347  :             PyErr_Format(PyExc_AttributeError, "__module__");

  00046	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@LNCJCPDP@__module__?$AA@
  00054	e8 00 00 00 00	 call	 PyErr_Format

; 348  :             return 0;

  00059	33 c0		 xor	 eax, eax

; 359  :     }
; 360  : }

  0005b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005f	5b		 pop	 rbx
  00060	c3		 ret	 0
$LN15@type_modul:

; 349  :         }
; 350  :         Py_XINCREF(mod);

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	75 32		 jne	 SHORT $LN5@type_modul
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00078	4c 8b cb	 mov	 r9, rbx
  0007b	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00081	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00089	e8 00 00 00 00	 call	 _PyParallel_Guard
  0008e	85 c0		 test	 eax, eax
  00090	75 06		 jne	 SHORT $LN11@type_modul
  00092	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00096	74 04		 je	 SHORT $LN5@type_modul
$LN11@type_modul:
  00098	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN5@type_modul:

; 351  :         return mod;

  0009c	48 8b c3	 mov	 rax, rbx

; 359  :     }
; 360  : }

  0009f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a3	5b		 pop	 rbx
  000a4	c3		 ret	 0
$LN8@type_modul:

; 352  :     }
; 353  :     else {
; 354  :         s = strrchr(type->tp_name, '.');

  000a5	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  000a9	ba 2e 00 00 00	 mov	 edx, 46			; 0000002eH
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strrchr

; 355  :         if (s != NULL)

  000b4	48 85 c0	 test	 rax, rax
  000b7	74 14		 je	 SHORT $LN1@type_modul

; 356  :             return PyUnicode_FromStringAndSize(
; 357  :                 type->tp_name, (Py_ssize_t)(s - type->tp_name));

  000b9	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  000bd	48 2b c1	 sub	 rax, rcx
  000c0	48 8b d0	 mov	 rdx, rax

; 359  :     }
; 360  : }

  000c3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c7	5b		 pop	 rbx
  000c8	e9 00 00 00 00	 jmp	 PyUnicode_FromStringAndSize
$LN1@type_modul:

; 358  :         return PyUnicode_FromString("builtins");

  000cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08OCOMCJAJ@builtins?$AA@

; 359  :     }
; 360  : }

  000d4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d8	5b		 pop	 rbx
  000d9	e9 00 00 00 00	 jmp	 PyUnicode_FromString
type_module ENDP
_TEXT	ENDS
EXTRN	_PyDict_SetItemId:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$type_set_module DD imagerel type_set_module
	DD	imagerel type_set_module+104
	DD	imagerel $unwind$type_set_module
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_set_module DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT type_set_module
_TEXT	SEGMENT
type$ = 48
value$ = 56
context$ = 64
type_set_module PROC					; COMDAT

; 364  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 365  :     if (!check_set_special_type_attr(type, value, "__module__"))

  0000a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@LNCJCPDP@__module__?$AA@
  00011	48 8b fa	 mov	 rdi, rdx
  00014	48 8b d9	 mov	 rbx, rcx
  00017	e8 00 00 00 00	 call	 check_set_special_type_attr
  0001c	85 c0		 test	 eax, eax
  0001e	75 0e		 jne	 SHORT $LN1@type_set_m

; 366  :         return -1;

  00020	83 c8 ff	 or	 eax, -1

; 371  : }

  00023	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5f		 pop	 rdi
  0002d	c3		 ret	 0
$LN1@type_set_m:

; 367  : 
; 368  :     PyType_Modified(type);

  0002e	48 8b cb	 mov	 rcx, rbx
  00031	e8 00 00 00 00	 call	 PyType_Modified

; 369  : 
; 370  :     return _PyDict_SetItemId(type->tp_dict, &PyId___module__, value);

  00036	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0003d	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00046	48 8b 8b 60 01
	00 00		 mov	 rcx, QWORD PTR [rbx+352]
  0004d	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId___module__
  00052	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  00056	4c 8b c7	 mov	 r8, rdi

; 371  : }

  00059	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00062	5f		 pop	 rdi
  00063	e9 00 00 00 00	 jmp	 _PyDict_SetItemId
type_set_module ENDP
_TEXT	ENDS
EXTRN	PyErr_SetString:PROC
EXTRN	PyDict_GetItemString:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$type_abstractmethods DD imagerel type_abstractmethods
	DD	imagerel type_abstractmethods+140
	DD	imagerel $unwind$type_abstractmethods
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_abstractmethods DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT type_abstractmethods
_TEXT	SEGMENT
type$ = 64
context$ = 72
type_abstractmethods PROC				; COMDAT

; 375  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 376  :     PyObject *mod = NULL;
; 377  :     /* type itself has an __abstractmethods__ descriptor (this). Don't return
; 378  :        that. */
; 379  :     if (type != &PyType_Type)

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyType_Type
  0000d	48 3b c8	 cmp	 rcx, rax
  00010	74 5f		 je	 SHORT $LN14@type_abstr

; 380  :         mod = PyDict_GetItemString(type->tp_dict, "__abstractmethods__");

  00012	48 8b 89 60 01
	00 00		 mov	 rcx, QWORD PTR [rcx+352]
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@EMDECJMP@__abstractmethods__?$AA@
  00020	e8 00 00 00 00	 call	 PyDict_GetItemString
  00025	48 8b d8	 mov	 rbx, rax

; 381  :     if (!mod) {

  00028	48 85 c0	 test	 rax, rax
  0002b	74 44		 je	 SHORT $LN14@type_abstr

; 384  :     }
; 385  :     Py_XINCREF(mod);

  0002d	e8 00 00 00 00	 call	 _Py_PXCTX
  00032	85 c0		 test	 eax, eax
  00034	75 32		 jne	 SHORT $LN3@type_abstr
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00044	4c 8b cb	 mov	 r9, rbx
  00047	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0004d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00055	e8 00 00 00 00	 call	 _PyParallel_Guard
  0005a	85 c0		 test	 eax, eax
  0005c	75 06		 jne	 SHORT $LN9@type_abstr
  0005e	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00062	74 04		 je	 SHORT $LN3@type_abstr
$LN9@type_abstr:
  00064	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN3@type_abstr:

; 386  :     return mod;

  00068	48 8b c3	 mov	 rax, rbx

; 387  : }

  0006b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006f	5b		 pop	 rbx
  00070	c3		 ret	 0
$LN14@type_abstr:

; 382  :         PyErr_SetString(PyExc_AttributeError, "__abstractmethods__");

  00071	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  00078	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@EMDECJMP@__abstractmethods__?$AA@
  0007f	e8 00 00 00 00	 call	 PyErr_SetString

; 383  :         return NULL;

  00084	33 c0		 xor	 eax, eax

; 387  : }

  00086	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008a	5b		 pop	 rbx
  0008b	c3		 ret	 0
type_abstractmethods ENDP
_TEXT	ENDS
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_KeyError:QWORD
EXTRN	PyDict_DelItemString:PROC
EXTRN	PyDict_SetItemString:PROC
EXTRN	PyObject_IsTrue:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$type_set_abstractmethods DD imagerel type_set_abstractmethods
	DD	imagerel type_set_abstractmethods+225
	DD	imagerel $unwind$type_set_abstractmethods
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_set_abstractmethods DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT type_set_abstractmethods
_TEXT	SEGMENT
type$ = 48
value$ = 56
context$ = 64
type_set_abstractmethods PROC				; COMDAT

; 391  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fa	 mov	 rdi, rdx
  00012	48 8b d9	 mov	 rbx, rcx

; 392  :     /* __abstractmethods__ should only be set once on a type, in
; 393  :        abc.ABCMeta.__new__, so this function doesn't do anything
; 394  :        special to update subclasses.
; 395  :     */
; 396  :     int abstract, res;
; 397  :     if (value != NULL) {

  00015	48 85 d2	 test	 rdx, rdx
  00018	74 5a		 je	 SHORT $LN7@type_set_a

; 398  :         abstract = PyObject_IsTrue(value);

  0001a	48 8b ca	 mov	 rcx, rdx
  0001d	e8 00 00 00 00	 call	 PyObject_IsTrue
  00022	8b f0		 mov	 esi, eax

; 399  :         if (abstract < 0)

  00024	85 c0		 test	 eax, eax

; 400  :             return -1;

  00026	0f 88 86 00 00
	00		 js	 $LN11@type_set_a

; 401  :         res = PyDict_SetItemString(type->tp_dict, "__abstractmethods__", value);

  0002c	48 8b 8b 60 01
	00 00		 mov	 rcx, QWORD PTR [rbx+352]
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@EMDECJMP@__abstractmethods__?$AA@
  0003a	4c 8b c7	 mov	 r8, rdi
  0003d	e8 00 00 00 00	 call	 PyDict_SetItemString
  00042	8b f8		 mov	 edi, eax
$LN4@type_set_a:

; 409  :         }
; 410  :     }
; 411  :     if (res == 0) {

  00044	85 ff		 test	 edi, edi
  00046	0f 85 83 00 00
	00		 jne	 $LN1@type_set_a
$LN10@type_set_a:

; 412  :         PyType_Modified(type);

  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	e8 00 00 00 00	 call	 PyType_Modified

; 413  :         if (abstract)

  00054	85 f6		 test	 esi, esi
  00056	74 6d		 je	 SHORT $LN2@type_set_a

; 414  :             type->tp_flags |= Py_TPFLAGS_IS_ABSTRACT;

  00058	81 8b 00 01 00
	00 00 00 10 00	 or	 DWORD PTR [rbx+256], 1048576 ; 00100000H

; 417  :     }
; 418  :     return res;

  00062	8b c7		 mov	 eax, edi

; 419  : }

  00064	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00069	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0006e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00072	5f		 pop	 rdi
  00073	c3		 ret	 0
$LN7@type_set_a:

; 402  :     }
; 403  :     else {
; 404  :         abstract = 0;
; 405  :         res = PyDict_DelItemString(type->tp_dict, "__abstractmethods__");

  00074	48 8b 89 60 01
	00 00		 mov	 rcx, QWORD PTR [rcx+352]
  0007b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@EMDECJMP@__abstractmethods__?$AA@
  00082	33 f6		 xor	 esi, esi
  00084	e8 00 00 00 00	 call	 PyDict_DelItemString
  00089	8b f8		 mov	 edi, eax

; 406  :         if (res && PyErr_ExceptionMatches(PyExc_KeyError)) {

  0008b	85 c0		 test	 eax, eax
  0008d	74 bd		 je	 SHORT $LN10@type_set_a
  0008f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyError
  00096	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0009b	85 c0		 test	 eax, eax
  0009d	74 a5		 je	 SHORT $LN4@type_set_a

; 407  :             PyErr_SetString(PyExc_AttributeError, "__abstractmethods__");

  0009f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  000a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@EMDECJMP@__abstractmethods__?$AA@
  000ad	e8 00 00 00 00	 call	 PyErr_SetString
$LN11@type_set_a:

; 408  :             return -1;

  000b2	83 c8 ff	 or	 eax, -1

; 419  : }

  000b5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ba	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000bf	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c3	5f		 pop	 rdi
  000c4	c3		 ret	 0
$LN2@type_set_a:

; 415  :         else
; 416  :             type->tp_flags &= ~Py_TPFLAGS_IS_ABSTRACT;

  000c5	81 a3 00 01 00
	00 ff ff ef ff	 and	 DWORD PTR [rbx+256], -1048577 ; ffffffffffefffffH
$LN1@type_set_a:

; 419  : }

  000cf	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000d4	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000d9	8b c7		 mov	 eax, edi
  000db	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000df	5f		 pop	 rdi
  000e0	c3		 ret	 0
type_set_abstractmethods ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$type_get_bases DD imagerel type_get_bases
	DD	imagerel type_get_bases+97
	DD	imagerel $unwind$type_get_bases
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_get_bases DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT type_get_bases
_TEXT	SEGMENT
type$ = 64
context$ = 72
type_get_bases PROC					; COMDAT

; 423  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 424  :     Py_INCREF(type->tp_bases);

  0000a	48 8b b9 a8 01
	00 00		 mov	 rdi, QWORD PTR [rcx+424]
  00011	48 8b d9	 mov	 rbx, rcx
  00014	e8 00 00 00 00	 call	 _Py_PXCTX
  00019	85 c0		 test	 eax, eax
  0001b	75 32		 jne	 SHORT $LN7@type_get_b
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0002b	4c 8b cf	 mov	 r9, rdi
  0002e	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00034	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0003c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00041	85 c0		 test	 eax, eax
  00043	75 06		 jne	 SHORT $LN3@type_get_b
  00045	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  00049	74 04		 je	 SHORT $LN7@type_get_b
$LN3@type_get_b:
  0004b	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN7@type_get_b:

; 425  :     return type->tp_bases;

  0004f	48 8b 83 a8 01
	00 00		 mov	 rax, QWORD PTR [rbx+424]

; 426  : }

  00056	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0005b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005f	5f		 pop	 rdi
  00060	c3		 ret	 0
type_get_bases ENDP
_TEXT	ENDS
EXTRN	PyDictProxy_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$type_dict DD imagerel type_dict
	DD	imagerel type_dict+106
	DD	imagerel $unwind$type_dict
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_dict DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT type_dict
_TEXT	SEGMENT
type$ = 64
context$ = 72
type_dict PROC						; COMDAT

; 613  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 614  :     if (type->tp_dict == NULL) {

  00004	48 8b 89 60 01
	00 00		 mov	 rcx, QWORD PTR [rcx+352]
  0000b	48 85 c9	 test	 rcx, rcx
  0000e	75 51		 jne	 SHORT $LN1@type_dict

; 615  :         Py_INCREF(Py_None);

  00010	e8 00 00 00 00	 call	 _Py_PXCTX
  00015	85 c0		 test	 eax, eax
  00017	75 3c		 jne	 SHORT $LN5@type_dict
  00019	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0002e	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00034	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0003c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00041	85 c0		 test	 eax, eax
  00043	75 09		 jne	 SHORT $LN4@type_dict
  00045	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0004c	74 07		 je	 SHORT $LN5@type_dict
$LN4@type_dict:
  0004e	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN5@type_dict:

; 616  :         return Py_None;

  00055	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 617  :     }
; 618  :     return PyDictProxy_New(type->tp_dict);
; 619  : }

  0005c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00060	c3		 ret	 0
$LN1@type_dict:
  00061	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00065	e9 00 00 00 00	 jmp	 PyDictProxy_New
type_dict ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$type_get_doc DD imagerel type_get_doc
	DD	imagerel type_get_doc+74
	DD	imagerel $unwind$type_get_doc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$type_get_doc DD imagerel type_get_doc+74
	DD	imagerel type_get_doc+178
	DD	imagerel $chain$0$type_get_doc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$type_get_doc DD imagerel type_get_doc+178
	DD	imagerel type_get_doc+219
	DD	imagerel $chain$2$type_get_doc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$type_get_doc DD imagerel type_get_doc+219
	DD	imagerel type_get_doc+238
	DD	imagerel $chain$4$type_get_doc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$type_get_doc DD 020021H
	DD	083400H
	DD	imagerel type_get_doc
	DD	imagerel type_get_doc+74
	DD	imagerel $unwind$type_get_doc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$type_get_doc DD 020021H
	DD	083400H
	DD	imagerel type_get_doc
	DD	imagerel type_get_doc+74
	DD	imagerel $unwind$type_get_doc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$type_get_doc DD 020521H
	DD	083405H
	DD	imagerel type_get_doc
	DD	imagerel type_get_doc+74
	DD	imagerel $unwind$type_get_doc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_get_doc DD 020601H
	DD	070025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT type_get_doc
_TEXT	SEGMENT
type$ = 64
context$ = 72
type_get_doc PROC					; COMDAT

; 623  : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 624  :     PyObject *result;
; 625  :     if (!(type->tp_flags & Py_TPFLAGS_HEAPTYPE) && type->tp_doc != NULL)

  00006	f7 81 00 01 00
	00 00 02 00 00	 test	 DWORD PTR [rcx+256], 512 ; 00000200H
  00010	48 8b f9	 mov	 rdi, rcx
  00013	75 16		 jne	 SHORT $LN5@type_get_d
  00015	48 8b 89 08 01
	00 00		 mov	 rcx, QWORD PTR [rcx+264]
  0001c	48 85 c9	 test	 rcx, rcx
  0001f	74 0a		 je	 SHORT $LN5@type_get_d

; 640  : }

  00021	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00025	5f		 pop	 rdi
  00026	e9 00 00 00 00	 jmp	 PyUnicode_FromString
$LN5@type_get_d:

; 626  :         return PyUnicode_FromString(type->tp_doc);
; 627  :     result = _PyDict_GetItemId(type->tp_dict, &PyId___doc__);

  0002b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00031	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0003a	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId___doc__
  0003f	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00043	48 8b 8f 60 01
	00 00		 mov	 rcx, QWORD PTR [rdi+352]
  0004a	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0004f	e8 00 00 00 00	 call	 _PyDict_GetItemId
  00054	48 8b d8	 mov	 rbx, rax

; 628  :     if (result == NULL) {

  00057	48 85 c0	 test	 rax, rax
  0005a	75 56		 jne	 SHORT $LN4@type_get_d

; 629  :         result = Py_None;

  0005c	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct

; 630  :         Py_INCREF(result);

  00063	e8 00 00 00 00	 call	 _Py_PXCTX
  00068	85 c0		 test	 eax, eax
  0006a	75 74		 jne	 SHORT $LN1@type_get_d
  0006c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0007a	4c 8b cb	 mov	 r9, rbx
  0007d	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00083	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00090	85 c0		 test	 eax, eax
  00092	75 09		 jne	 SHORT $LN8@type_get_d
  00094	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0009b	74 43		 je	 SHORT $LN1@type_get_d
$LN8@type_get_d:
  0009d	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80

; 638  :     }
; 639  :     return result;

  000a4	48 8b c3	 mov	 rax, rbx
  000a7	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 640  : }

  000ac	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b0	5f		 pop	 rdi
  000b1	c3		 ret	 0
$LN4@type_get_d:

; 631  :     }
; 632  :     else if (Py_TYPE(result)->tp_descr_get) {

  000b2	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]

; 633  :         result = Py_TYPE(result)->tp_descr_get(result, NULL,
; 634  :                                                (PyObject *)type);

  000b6	48 8b cb	 mov	 rcx, rbx
  000b9	4c 8b 88 68 01
	00 00		 mov	 r9, QWORD PTR [rax+360]
  000c0	4d 85 c9	 test	 r9, r9
  000c3	74 16		 je	 SHORT $LN2@type_get_d
  000c5	4c 8b c7	 mov	 r8, rdi
  000c8	33 d2		 xor	 edx, edx
  000ca	41 ff d1	 call	 r9
  000cd	48 8b d8	 mov	 rbx, rax
  000d0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 640  : }

  000d5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d9	5f		 pop	 rdi
  000da	c3		 ret	 0
$LN2@type_get_d:

; 635  :     }
; 636  :     else {
; 637  :         Py_INCREF(result);

  000db	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@type_get_d:

; 638  :     }
; 639  :     return result;

  000e0	48 8b c3	 mov	 rax, rbx
  000e3	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 640  : }

  000e8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ec	5f		 pop	 rdi
  000ed	c3		 ret	 0
type_get_doc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@DPJMDBLL@type_set_doc?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$type_set_doc DD imagerel type_set_doc
	DD	imagerel type_set_doc+147
	DD	imagerel $unwind$type_set_doc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_set_doc DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0N@DPJMDBLL@type_set_doc?$AA@
CONST	SEGMENT
??_C@_0N@DPJMDBLL@type_set_doc?$AA@ DB 'type_set_doc', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT type_set_doc
_TEXT	SEGMENT
type$ = 48
value$ = 56
context$ = 64
type_set_doc PROC					; COMDAT

; 644  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 645  :     Py_GUARD

  00010	e8 00 00 00 00	 call	 _Py_PXCTX
  00015	85 c0		 test	 eax, eax
  00017	74 1c		 je	 SHORT $LN2@type_set_d
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@DPJMDBLL@type_set_doc?$AA@
  00027	45 33 c9	 xor	 r9d, r9d
  0002a	41 b8 85 02 00
	00		 mov	 r8d, 645		; 00000285H
  00030	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN2@type_set_d:

; 646  :     if (!check_set_special_type_attr(type, value, "__doc__"))

  00035	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_07DIBBIFIJ@__doc__?$AA@
  0003c	48 8b d7	 mov	 rdx, rdi
  0003f	48 8b cb	 mov	 rcx, rbx
  00042	e8 00 00 00 00	 call	 check_set_special_type_attr
  00047	85 c0		 test	 eax, eax
  00049	75 0e		 jne	 SHORT $LN1@type_set_d

; 647  :         return -1;

  0004b	83 c8 ff	 or	 eax, -1

; 650  : }

  0004e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5f		 pop	 rdi
  00058	c3		 ret	 0
$LN1@type_set_d:

; 648  :     PyType_Modified(type);

  00059	48 8b cb	 mov	 rcx, rbx
  0005c	e8 00 00 00 00	 call	 PyType_Modified

; 649  :     return _PyDict_SetItemId(type->tp_dict, &PyId___doc__, value);

  00061	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00068	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00071	48 8b 8b 60 01
	00 00		 mov	 rcx, QWORD PTR [rbx+352]
  00078	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId___doc__
  0007d	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  00081	4c 8b c7	 mov	 r8, rdi

; 650  : }

  00084	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00089	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008d	5f		 pop	 rdi
  0008e	e9 00 00 00 00	 jmp	 _PyDict_SetItemId
type_set_doc ENDP
_TEXT	ENDS
EXTRN	_Py_FalseStruct:BYTE
EXTRN	_Py_TrueStruct:BYTE
EXTRN	_PyObject_RealIsInstance:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$type___instancecheck__ DD imagerel type___instancecheck__
	DD	imagerel type___instancecheck__+200
	DD	imagerel $unwind$type___instancecheck__
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type___instancecheck__ DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT type___instancecheck__
_TEXT	SEGMENT
type$ = 64
inst$ = 72
type___instancecheck__ PROC				; COMDAT

; 654  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 8b c2	 mov	 rax, rdx

; 655  :     switch (_PyObject_RealIsInstance(inst, type)) {

  00007	48 8b d1	 mov	 rdx, rcx
  0000a	48 8b c8	 mov	 rcx, rax
  0000d	e8 00 00 00 00	 call	 _PyObject_RealIsInstance
  00012	83 f8 ff	 cmp	 eax, -1
  00015	0f 84 a6 00 00
	00		 je	 $LN3@type___ins
  0001b	85 c0		 test	 eax, eax
  0001d	74 51		 je	 SHORT $LN2@type___ins

; 660  :     default:
; 661  :         Py_RETURN_TRUE;

  0001f	e8 00 00 00 00	 call	 _Py_PXCTX
  00024	85 c0		 test	 eax, eax
  00026	75 3c		 jne	 SHORT $LN13@type___ins
  00028	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_TrueStruct
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0003d	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00043	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0004b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00050	85 c0		 test	 eax, eax
  00052	75 09		 jne	 SHORT $LN12@type___ins
  00054	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_TrueStruct+32, 32 ; 00000020H
  0005b	74 07		 je	 SHORT $LN13@type___ins
$LN12@type___ins:
  0005d	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_TrueStruct+80
$LN13@type___ins:
  00064	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct

; 662  :     }
; 663  : }

  0006b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006f	c3		 ret	 0
$LN2@type___ins:

; 658  :     case 0:
; 659  :         Py_RETURN_FALSE;

  00070	e8 00 00 00 00	 call	 _Py_PXCTX
  00075	85 c0		 test	 eax, eax
  00077	75 3c		 jne	 SHORT $LN9@type___ins
  00079	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_FalseStruct
  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0008e	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00094	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0009c	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a1	85 c0		 test	 eax, eax
  000a3	75 09		 jne	 SHORT $LN8@type___ins
  000a5	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_FalseStruct+32, 32 ; 00000020H
  000ac	74 07		 je	 SHORT $LN9@type___ins
$LN8@type___ins:
  000ae	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_FalseStruct+80
$LN9@type___ins:
  000b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct

; 662  :     }
; 663  : }

  000bc	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c0	c3		 ret	 0
$LN3@type___ins:

; 656  :     case -1:
; 657  :         return NULL;

  000c1	33 c0		 xor	 eax, eax

; 662  :     }
; 663  : }

  000c3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c7	c3		 ret	 0
type___instancecheck__ ENDP
_TEXT	ENDS
EXTRN	_PyObject_RealIsSubclass:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$type___subclasscheck__ DD imagerel type___subclasscheck__
	DD	imagerel type___subclasscheck__+200
	DD	imagerel $unwind$type___subclasscheck__
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type___subclasscheck__ DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT type___subclasscheck__
_TEXT	SEGMENT
type$ = 64
inst$ = 72
type___subclasscheck__ PROC				; COMDAT

; 668  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 8b c2	 mov	 rax, rdx

; 669  :     switch (_PyObject_RealIsSubclass(inst, type)) {

  00007	48 8b d1	 mov	 rdx, rcx
  0000a	48 8b c8	 mov	 rcx, rax
  0000d	e8 00 00 00 00	 call	 _PyObject_RealIsSubclass
  00012	83 f8 ff	 cmp	 eax, -1
  00015	0f 84 a6 00 00
	00		 je	 $LN3@type___sub
  0001b	85 c0		 test	 eax, eax
  0001d	74 51		 je	 SHORT $LN2@type___sub

; 674  :     default:
; 675  :         Py_RETURN_TRUE;

  0001f	e8 00 00 00 00	 call	 _Py_PXCTX
  00024	85 c0		 test	 eax, eax
  00026	75 3c		 jne	 SHORT $LN13@type___sub
  00028	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_TrueStruct
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0003d	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00043	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0004b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00050	85 c0		 test	 eax, eax
  00052	75 09		 jne	 SHORT $LN12@type___sub
  00054	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_TrueStruct+32, 32 ; 00000020H
  0005b	74 07		 je	 SHORT $LN13@type___sub
$LN12@type___sub:
  0005d	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_TrueStruct+80
$LN13@type___sub:
  00064	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct

; 676  :     }
; 677  : }

  0006b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006f	c3		 ret	 0
$LN2@type___sub:

; 672  :     case 0:
; 673  :         Py_RETURN_FALSE;

  00070	e8 00 00 00 00	 call	 _Py_PXCTX
  00075	85 c0		 test	 eax, eax
  00077	75 3c		 jne	 SHORT $LN9@type___sub
  00079	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_FalseStruct
  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0008e	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00094	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0009c	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a1	85 c0		 test	 eax, eax
  000a3	75 09		 jne	 SHORT $LN8@type___sub
  000a5	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_FalseStruct+32, 32 ; 00000020H
  000ac	74 07		 je	 SHORT $LN9@type___sub
$LN8@type___sub:
  000ae	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_FalseStruct+80
$LN9@type___sub:
  000b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct

; 676  :     }
; 677  : }

  000bc	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c0	c3		 ret	 0
$LN3@type___sub:

; 670  :     case -1:
; 671  :         return NULL;

  000c1	33 c0		 xor	 eax, eax

; 676  :     }
; 677  : }

  000c3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c7	c3		 ret	 0
type___subclasscheck__ ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@GEOGLJIP@?$DMclass?5?8?$CFs?8?$DO?$AA@	; `string'
PUBLIC	??_C@_0BA@IKEBEBBA@?$DMclass?5?8?$CFU?4?$CFU?8?$DO?$AA@ ; `string'
EXTRN	PyUnicode_FromFormat:PROC
EXTRN	PyUnicode_CompareWithASCIIString:PROC
EXTRN	PyErr_Clear:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$type_repr DD imagerel type_repr
	DD	imagerel type_repr+444
	DD	imagerel $unwind$type_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_repr DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0N@GEOGLJIP@?$DMclass?5?8?$CFs?8?$DO?$AA@
CONST	SEGMENT
??_C@_0N@GEOGLJIP@?$DMclass?5?8?$CFs?8?$DO?$AA@ DB '<class ''%s''>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IKEBEBBA@?$DMclass?5?8?$CFU?4?$CFU?8?$DO?$AA@
CONST	SEGMENT
??_C@_0BA@IKEBEBBA@?$DMclass?5?8?$CFU?4?$CFU?8?$DO?$AA@ DB '<class ''%U.%'
	DB	'U''>', 00H					; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
CONST	ENDS
;	COMDAT type_repr
_TEXT	SEGMENT
type$ = 64
type_repr PROC						; COMDAT

; 694  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 695  :     PyObject *mod, *name, *rtn;
; 696  : 
; 697  :     mod = type_module(type, NULL);

  0000f	33 d2		 xor	 edx, edx
  00011	48 8b f9	 mov	 rdi, rcx
  00014	e8 00 00 00 00	 call	 type_module
  00019	48 8b d8	 mov	 rbx, rax

; 698  :     if (mod == NULL)

  0001c	48 85 c0	 test	 rax, rax
  0001f	75 07		 jne	 SHORT $LN14@type_repr

; 699  :         PyErr_Clear();

  00021	e8 00 00 00 00	 call	 PyErr_Clear
  00026	eb 1a		 jmp	 SHORT $LN12@type_repr
$LN14@type_repr:

; 700  :     else if (!PyUnicode_Check(mod)) {

  00028	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002c	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00036	75 0a		 jne	 SHORT $LN12@type_repr

; 701  :         Py_DECREF(mod);

  00038	48 8b cb	 mov	 rcx, rbx
  0003b	e8 00 00 00 00	 call	 _Py_DecRef

; 702  :         mod = NULL;

  00040	33 db		 xor	 ebx, ebx
$LN12@type_repr:

; 703  :     }
; 704  :     name = type_qualname(type, NULL);

  00042	33 d2		 xor	 edx, edx
  00044	48 8b cf	 mov	 rcx, rdi
  00047	e8 00 00 00 00	 call	 type_qualname
  0004c	48 8b f0	 mov	 rsi, rax

; 705  :     if (name == NULL) {

  0004f	48 85 c0	 test	 rax, rax
  00052	0f 85 a0 00 00
	00		 jne	 $LN11@type_repr

; 706  :         Py_XDECREF(mod);

  00058	48 85 db	 test	 rbx, rbx
  0005b	0f 84 85 00 00
	00		 je	 $LN9@type_repr
  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	75 7c		 jne	 SHORT $LN9@type_repr
  0006a	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0006e	a8 20		 test	 al, 32			; 00000020H
  00070	75 6c		 jne	 SHORT $LN21@type_repr
  00072	84 c0		 test	 al, al
  00074	78 68		 js	 SHORT $LN21@type_repr
  00076	a8 02		 test	 al, 2
  00078	75 6c		 jne	 SHORT $LN9@type_repr
  0007a	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0007e	75 66		 jne	 SHORT $LN9@type_repr
  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0008e	4c 8b cb	 mov	 r9, rbx
  00091	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00097	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0009f	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a4	48 8b cb	 mov	 rcx, rbx
  000a7	85 c0		 test	 eax, eax
  000a9	74 17		 je	 SHORT $LN26@type_repr
  000ab	e8 00 00 00 00	 call	 _Px_Dealloc

; 707  :         return NULL;

  000b0	33 c0		 xor	 eax, eax

; 717  :     return rtn;
; 718  : }

  000b2	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b7	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000bc	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c0	5f		 pop	 rdi
  000c1	c3		 ret	 0

; 706  :         Py_XDECREF(mod);

$LN26@type_repr:
  000c2	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000c6	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 707  :         return NULL;

  000cc	33 c0		 xor	 eax, eax

; 717  :     return rtn;
; 718  : }

  000ce	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d3	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000d8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000dc	5f		 pop	 rdi
  000dd	c3		 ret	 0

; 706  :         Py_XDECREF(mod);

$LN21@type_repr:
  000de	48 8b cb	 mov	 rcx, rbx
  000e1	e8 00 00 00 00	 call	 Px_DecRef
$LN9@type_repr:

; 707  :         return NULL;

  000e6	33 c0		 xor	 eax, eax

; 717  :     return rtn;
; 718  : }

  000e8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ed	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000f2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f6	5f		 pop	 rdi
  000f7	c3		 ret	 0
$LN11@type_repr:

; 708  :     }
; 709  : 
; 710  :     if (mod != NULL && PyUnicode_CompareWithASCIIString(mod, "builtins"))

  000f8	48 85 db	 test	 rbx, rbx
  000fb	74 27		 je	 SHORT $LN6@type_repr
  000fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08OCOMCJAJ@builtins?$AA@
  00104	48 8b cb	 mov	 rcx, rbx
  00107	e8 00 00 00 00	 call	 PyUnicode_CompareWithASCIIString
  0010c	85 c0		 test	 eax, eax
  0010e	74 14		 je	 SHORT $LN6@type_repr

; 711  :         rtn = PyUnicode_FromFormat("<class '%U.%U'>", mod, name);

  00110	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@IKEBEBBA@?$DMclass?5?8?$CFU?4?$CFU?8?$DO?$AA@
  00117	4c 8b c6	 mov	 r8, rsi
  0011a	48 8b d3	 mov	 rdx, rbx
  0011d	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 712  :     else

  00122	eb 10		 jmp	 SHORT $LN39@type_repr
$LN6@type_repr:

; 713  :         rtn = PyUnicode_FromFormat("<class '%s'>", type->tp_name);

  00124	48 8b 57 70	 mov	 rdx, QWORD PTR [rdi+112]
  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@GEOGLJIP@?$DMclass?5?8?$CFs?8?$DO?$AA@
  0012f	e8 00 00 00 00	 call	 PyUnicode_FromFormat
$LN39@type_repr:
  00134	48 8b f8	 mov	 rdi, rax

; 714  : 
; 715  :     Py_XDECREF(mod);

  00137	48 85 db	 test	 rbx, rbx
  0013a	74 65		 je	 SHORT $LN3@type_repr
  0013c	e8 00 00 00 00	 call	 _Py_PXCTX
  00141	85 c0		 test	 eax, eax
  00143	75 5c		 jne	 SHORT $LN3@type_repr
  00145	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00149	a8 20		 test	 al, 32			; 00000020H
  0014b	75 4c		 jne	 SHORT $LN32@type_repr
  0014d	84 c0		 test	 al, al
  0014f	78 48		 js	 SHORT $LN32@type_repr
  00151	a8 02		 test	 al, 2
  00153	75 4c		 jne	 SHORT $LN3@type_repr
  00155	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00159	75 46		 jne	 SHORT $LN3@type_repr
  0015b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00162	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00169	4c 8b cb	 mov	 r9, rbx
  0016c	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00172	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0017a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0017f	48 8b cb	 mov	 rcx, rbx
  00182	85 c0		 test	 eax, eax
  00184	74 07		 je	 SHORT $LN37@type_repr
  00186	e8 00 00 00 00	 call	 _Px_Dealloc
  0018b	eb 14		 jmp	 SHORT $LN3@type_repr
$LN37@type_repr:
  0018d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00191	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00197	eb 08		 jmp	 SHORT $LN3@type_repr
$LN32@type_repr:
  00199	48 8b cb	 mov	 rcx, rbx
  0019c	e8 00 00 00 00	 call	 Px_DecRef
$LN3@type_repr:

; 716  :     Py_DECREF(name);

  001a1	48 8b ce	 mov	 rcx, rsi
  001a4	e8 00 00 00 00	 call	 _Py_DecRef

; 717  :     return rtn;
; 718  : }

  001a9	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001ae	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  001b3	48 8b c7	 mov	 rax, rdi
  001b6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001ba	5f		 pop	 rdi
  001bb	c3		 ret	 0
type_repr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@ ; `string'
PUBLIC	??_C@_0BE@MMPMJCHN@PyType_GenericAlloc?$AA@	; `string'
EXTRN	_PyGC_generation0:QWORD
EXTRN	Py_FatalError:PROC
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyObject_Malloc:PROC
EXTRN	_PyObject_GC_Malloc:PROC
EXTRN	memset:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyType_GenericAlloc DD imagerel $LN26
	DD	imagerel $LN26+434
	DD	imagerel $unwind$PyType_GenericAlloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyType_GenericAlloc DD 081401H
	DD	0b6414H
	DD	0a5414H
	DD	093414H
	DD	070105214H
xdata	ENDS
;	COMDAT ??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
CONST	SEGMENT
??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@ DB 'GC object alread'
	DB	'y tracked', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MMPMJCHN@PyType_GenericAlloc?$AA@
CONST	SEGMENT
??_C@_0BE@MMPMJCHN@PyType_GenericAlloc?$AA@ DB 'PyType_GenericAlloc', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
CONST	ENDS
;	COMDAT PyType_GenericAlloc
_TEXT	SEGMENT
tv138 = 64
tv77 = 64
type$ = 64
nitems$ = 72
PyType_GenericAlloc PROC				; COMDAT

; 757  : {

$LN26:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 758  :     PyObject *obj;
; 759  :     const size_t size = _PyObject_VAR_SIZE(type, nitems+1);

  00014	48 8b 41 78	 mov	 rax, QWORD PTR [rcx+120]
  00018	4c 8d 42 01	 lea	 r8, QWORD PTR [rdx+1]
  0001c	48 8b ea	 mov	 rbp, rdx
  0001f	48 8b d9	 mov	 rbx, rcx
  00022	4c 0f af 81 80
	00 00 00	 imul	 r8, QWORD PTR [rcx+128]
  0002a	49 8d 74 00 07	 lea	 rsi, QWORD PTR [r8+rax+7]
  0002f	48 83 e6 f8	 and	 rsi, -8

; 760  :     /* note that we need to add one, for the sentinel */
; 761  : 
; 762  :     if (PyType_IS_GC(type))

  00033	e8 00 00 00 00	 call	 _Py_PXCTX
  00038	85 c0		 test	 eax, eax
  0003a	75 18		 jne	 SHORT $LN12@PyType_Gen
  0003c	8b 83 00 01 00
	00		 mov	 eax, DWORD PTR [rbx+256]
  00042	c1 e8 0e	 shr	 eax, 14
  00045	83 e0 01	 and	 eax, 1
  00048	74 0a		 je	 SHORT $LN12@PyType_Gen

; 763  :         obj = _PyObject_GC_Malloc(size);

  0004a	48 8b ce	 mov	 rcx, rsi
  0004d	e8 00 00 00 00	 call	 _PyObject_GC_Malloc

; 764  :     else

  00052	eb 08		 jmp	 SHORT $LN25@PyType_Gen
$LN12@PyType_Gen:

; 765  :         obj = (PyObject *)PyObject_MALLOC(size);

  00054	48 8b ce	 mov	 rcx, rsi
  00057	e8 00 00 00 00	 call	 PyObject_Malloc
$LN25@PyType_Gen:
  0005c	48 8b f8	 mov	 rdi, rax

; 766  : 
; 767  :     if (obj == NULL)

  0005f	48 85 c0	 test	 rax, rax
  00062	75 0a		 jne	 SHORT $LN10@PyType_Gen

; 768  :         return PyErr_NoMemory();

  00064	e8 00 00 00 00	 call	 PyErr_NoMemory
  00069	e9 2f 01 00 00	 jmp	 $LN13@PyType_Gen
$LN10@PyType_Gen:

; 769  : 
; 770  :     memset(obj, '\0', size);

  0006e	4c 8b c6	 mov	 r8, rsi
  00071	33 d2		 xor	 edx, edx
  00073	48 8b cf	 mov	 rcx, rdi
  00076	e8 00 00 00 00	 call	 memset

; 771  : 
; 772  :     if (type->tp_flags & Py_TPFLAGS_HEAPTYPE)

  0007b	f7 83 00 01 00
	00 00 02 00 00	 test	 DWORD PTR [rbx+256], 512 ; 00000200H
  00085	74 3b		 je	 SHORT $LN22@PyType_Gen

; 773  :         Py_INCREF(type);

  00087	e8 00 00 00 00	 call	 _Py_PXCTX
  0008c	85 c0		 test	 eax, eax
  0008e	75 32		 jne	 SHORT $LN22@PyType_Gen
  00090	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00097	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0009e	4c 8b cb	 mov	 r9, rbx
  000a1	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000a7	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000af	e8 00 00 00 00	 call	 _PyParallel_Guard
  000b4	85 c0		 test	 eax, eax
  000b6	75 06		 jne	 SHORT $LN21@PyType_Gen
  000b8	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000bc	74 04		 je	 SHORT $LN22@PyType_Gen
$LN21@PyType_Gen:
  000be	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN22@PyType_Gen:

; 774  : 
; 775  :     if (type->tp_itemsize == 0)

  000c2	48 83 bb 80 00
	00 00 00	 cmp	 QWORD PTR [rbx+128], 0

; 776  :         PyObject_INIT(obj, type);

  000ca	48 8b d3	 mov	 rdx, rbx
  000cd	48 8b cf	 mov	 rcx, rdi
  000d0	75 07		 jne	 SHORT $LN8@PyType_Gen
  000d2	e8 00 00 00 00	 call	 PyObject_INIT

; 777  :     else

  000d7	eb 08		 jmp	 SHORT $LN7@PyType_Gen
$LN8@PyType_Gen:

; 778  :         (void) PyObject_INIT_VAR((PyVarObject *)obj, type, nitems);

  000d9	4c 8b c5	 mov	 r8, rbp
  000dc	e8 00 00 00 00	 call	 PyObject_INIT_VAR
$LN7@PyType_Gen:

; 779  : 
; 780  :     if (PyType_IS_GC(type))

  000e1	e8 00 00 00 00	 call	 _Py_PXCTX
  000e6	85 c0		 test	 eax, eax
  000e8	0f 85 ac 00 00
	00		 jne	 $LN2@PyType_Gen
  000ee	8b 83 00 01 00
	00		 mov	 eax, DWORD PTR [rbx+256]
  000f4	c1 e8 0e	 shr	 eax, 14
  000f7	83 e0 01	 and	 eax, 1
  000fa	0f 84 9a 00 00
	00		 je	 $LN2@PyType_Gen

; 781  :         _PyObject_GC_TRACK(obj);

  00100	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  00107	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@MMPMJCHN@PyType_GenericAlloc?$AA@
  0010e	4c 8b cf	 mov	 r9, rdi
  00111	41 b8 0d 03 00
	00		 mov	 r8d, 781		; 0000030dH
  00117	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0011f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00124	85 c0		 test	 eax, eax
  00126	75 72		 jne	 SHORT $LN2@PyType_Gen
  00128	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  0012f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@MMPMJCHN@PyType_GenericAlloc?$AA@
  00136	4c 8b cf	 mov	 r9, rdi
  00139	41 b8 0d 03 00
	00		 mov	 r8d, 781		; 0000030dH
  0013f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00147	e8 00 00 00 00	 call	 _PyParallel_Guard
  0014c	85 c0		 test	 eax, eax
  0014e	74 04		 je	 SHORT $LN19@PyType_Gen
  00150	33 db		 xor	 ebx, ebx
  00152	eb 04		 jmp	 SHORT $LN20@PyType_Gen
$LN19@PyType_Gen:
  00154	48 8d 5f e8	 lea	 rbx, QWORD PTR [rdi-24]
$LN20@PyType_Gen:
  00158	48 83 7b 10 fe	 cmp	 QWORD PTR [rbx+16], -2
  0015d	74 0c		 je	 SHORT $LN1@PyType_Gen
  0015f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
  00166	e8 00 00 00 00	 call	 Py_FatalError
$LN1@PyType_Gen:
  0016b	48 c7 43 10 fd
	ff ff ff	 mov	 QWORD PTR [rbx+16], -3
  00173	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  0017a	48 89 03	 mov	 QWORD PTR [rbx], rax
  0017d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  00184	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00188	48 89 4b 08	 mov	 QWORD PTR [rbx+8], rcx
  0018c	48 89 19	 mov	 QWORD PTR [rcx], rbx
  0018f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  00196	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
$LN2@PyType_Gen:

; 782  :     return obj;

  0019a	48 8b c7	 mov	 rax, rdi
$LN13@PyType_Gen:

; 783  : }

  0019d	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  001a2	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  001a7	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  001ac	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001b0	5f		 pop	 rdi
  001b1	c3		 ret	 0
PyType_GenericAlloc ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT PyType_GenericNew
_TEXT	SEGMENT
type$ = 8
args$ = 16
kwds$ = 24
PyType_GenericNew PROC					; COMDAT

; 787  : {

  00000	48 8b c1	 mov	 rax, rcx

; 788  :     return type->tp_alloc(type, 0);

  00003	33 d2		 xor	 edx, edx

; 789  : }

  00005	48 ff a0 88 01
	00 00		 rex_jmp QWORD PTR [rax+392]
PyType_GenericNew ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$traverse_slots DD imagerel traverse_slots
	DD	imagerel traverse_slots+131
	DD	imagerel $unwind$traverse_slots
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$traverse_slots DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0d0143218H
	DD	07010c012H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT traverse_slots
_TEXT	SEGMENT
type$ = 64
self$ = 72
visit$ = 80
arg$ = 88
traverse_slots PROC					; COMDAT

; 795  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 796  :     Py_ssize_t i, n;
; 797  :     PyMemberDef *mp;
; 798  : 
; 799  :     n = Py_SIZE(type);

  00018	48 8b 71 60	 mov	 rsi, QWORD PTR [rcx+96]

; 800  :     mp = PyHeapType_GET_MEMBERS((PyHeapTypeObject *)type);

  0001c	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]

; 801  :     for (i = 0; i < n; i++, mp++) {

  00020	33 ff		 xor	 edi, edi
  00022	48 8b ea	 mov	 rbp, rdx
  00025	48 8b 50 78	 mov	 rdx, QWORD PTR [rax+120]
  00029	4d 8b e1	 mov	 r12, r9
  0002c	4d 8b e8	 mov	 r13, r8
  0002f	48 85 f6	 test	 rsi, rsi
  00032	7e 34		 jle	 SHORT $LN12@traverse_s

; 796  :     Py_ssize_t i, n;
; 797  :     PyMemberDef *mp;
; 798  : 
; 799  :     n = Py_SIZE(type);

  00034	48 8d 5c 11 10	 lea	 rbx, QWORD PTR [rcx+rdx+16]
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL6@traverse_s:

; 802  :         if (mp->type == T_OBJECT_EX) {

  00040	83 7b f8 10	 cmp	 DWORD PTR [rbx-8], 16
  00044	75 16		 jne	 SHORT $LN5@traverse_s

; 803  :             char *addr = (char *)self + mp->offset;
; 804  :             PyObject *obj = *(PyObject **)addr;

  00046	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00049	48 8b 0c 28	 mov	 rcx, QWORD PTR [rax+rbp]

; 805  :             if (obj != NULL) {

  0004d	48 85 c9	 test	 rcx, rcx
  00050	74 0a		 je	 SHORT $LN5@traverse_s

; 806  :                 int err = visit(obj, arg);

  00052	49 8b d4	 mov	 rdx, r12
  00055	41 ff d5	 call	 r13

; 807  :                 if (err)

  00058	85 c0		 test	 eax, eax
  0005a	75 0e		 jne	 SHORT $LN7@traverse_s
$LN5@traverse_s:

; 801  :     for (i = 0; i < n; i++, mp++) {

  0005c	48 ff c7	 inc	 rdi
  0005f	48 83 c3 28	 add	 rbx, 40			; 00000028H
  00063	48 3b fe	 cmp	 rdi, rsi
  00066	7c d8		 jl	 SHORT $LL6@traverse_s
$LN12@traverse_s:

; 808  :                     return err;
; 809  :             }
; 810  :         }
; 811  :     }
; 812  :     return 0;

  00068	33 c0		 xor	 eax, eax
$LN7@traverse_s:

; 813  : }

  0006a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0006f	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00074	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00079	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007d	41 5d		 pop	 r13
  0007f	41 5c		 pop	 r12
  00081	5f		 pop	 rdi
  00082	c3		 ret	 0
traverse_slots ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@KAJEFJMJ@subtype_traverse?$AA@	; `string'
EXTRN	_PyObject_GetDictPtr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$subtype_traverse DD imagerel subtype_traverse
	DD	imagerel subtype_traverse+324
	DD	imagerel $unwind$subtype_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$subtype_traverse DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0e01a321eH
	DD	0c016d018H
xdata	ENDS
;	COMDAT ??_C@_0BB@KAJEFJMJ@subtype_traverse?$AA@
CONST	SEGMENT
??_C@_0BB@KAJEFJMJ@subtype_traverse?$AA@ DB 'subtype_traverse', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT subtype_traverse
_TEXT	SEGMENT
self$ = 64
visit$ = 72
arg$ = 80
subtype_traverse PROC					; COMDAT

; 817  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 818  :     PyTypeObject *type, *base;
; 819  :     traverseproc basetraverse;
; 820  : 
; 821  :     /* Find the nearest base with a different tp_traverse,
; 822  :        and traverse slots while we're at it */
; 823  :     type = Py_TYPE(self);

  0001e	4c 8b 61 58	 mov	 r12, QWORD PTR [rcx+88]

; 824  :     base = type;
; 825  :     while ((basetraverse = base->tp_traverse) == subtype_traverse) {

  00022	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:subtype_traverse
  00029	49 8b f0	 mov	 rsi, r8
  0002c	49 8b bc 24 10
	01 00 00	 mov	 rdi, QWORD PTR [r12+272]
  00034	48 8b ea	 mov	 rbp, rdx
  00037	4c 8b e9	 mov	 r13, rcx
  0003a	49 8b dc	 mov	 rbx, r12
  0003d	49 3b fe	 cmp	 rdi, r14
  00040	75 33		 jne	 SHORT $LN26@subtype_tr
$LL20@subtype_tr:

; 826  :         if (Py_SIZE(base)) {

  00042	48 83 7b 60 00	 cmp	 QWORD PTR [rbx+96], 0
  00047	74 19		 je	 SHORT $LN17@subtype_tr

; 827  :             int err = traverse_slots(base, self, visit, arg);

  00049	4c 8b ce	 mov	 r9, rsi
  0004c	4c 8b c5	 mov	 r8, rbp
  0004f	49 8b d5	 mov	 rdx, r13
  00052	48 8b cb	 mov	 rcx, rbx
  00055	e8 00 00 00 00	 call	 traverse_slots

; 828  :             if (err)

  0005a	85 c0		 test	 eax, eax
  0005c	0f 85 c3 00 00
	00		 jne	 $LN21@subtype_tr
$LN17@subtype_tr:

; 829  :                 return err;
; 830  :         }
; 831  :         base = base->tp_base;

  00062	48 8b 9b 58 01
	00 00		 mov	 rbx, QWORD PTR [rbx+344]
  00069	48 8b bb 10 01
	00 00		 mov	 rdi, QWORD PTR [rbx+272]
  00070	49 3b fe	 cmp	 rdi, r14
  00073	74 cd		 je	 SHORT $LL20@subtype_tr
$LN26@subtype_tr:

; 832  :         assert(base);
; 833  :     }
; 834  : 
; 835  :     if (type->tp_dictoffset != base->tp_dictoffset) {

  00075	48 8b 83 78 01
	00 00		 mov	 rax, QWORD PTR [rbx+376]
  0007c	49 39 84 24 78
	01 00 00	 cmp	 QWORD PTR [r12+376], rax
  00084	74 4c		 je	 SHORT $LN12@subtype_tr

; 836  :         PyObject **dictptr = _PyObject_GetDictPtr(self);

  00086	49 8b cd	 mov	 rcx, r13
  00089	e8 00 00 00 00	 call	 _PyObject_GetDictPtr
  0008e	48 8b d8	 mov	 rbx, rax

; 837  :         if (dictptr && *dictptr)

  00091	48 85 c0	 test	 rax, rax
  00094	74 3c		 je	 SHORT $LN12@subtype_tr
  00096	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0009a	74 36		 je	 SHORT $LN12@subtype_tr

; 838  :             Py_VISIT(*dictptr);

  0009c	e8 00 00 00 00	 call	 _Py_PXCTX
  000a1	85 c0		 test	 eax, eax
  000a3	74 1c		 je	 SHORT $LN11@subtype_tr
  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@KAJEFJMJ@subtype_traverse?$AA@
  000b3	45 33 c9	 xor	 r9d, r9d
  000b6	41 b8 46 03 00
	00		 mov	 r8d, 838		; 00000346H
  000bc	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN11@subtype_tr:
  000c1	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000c4	48 85 c9	 test	 rcx, rcx
  000c7	74 09		 je	 SHORT $LN12@subtype_tr
  000c9	48 8b d6	 mov	 rdx, rsi
  000cc	ff d5		 call	 rbp
  000ce	85 c0		 test	 eax, eax
  000d0	75 53		 jne	 SHORT $LN21@subtype_tr
$LN12@subtype_tr:

; 839  :     }
; 840  : 
; 841  :     if (type->tp_flags & Py_TPFLAGS_HEAPTYPE)

  000d2	41 f7 84 24 00
	01 00 00 00 02
	00 00		 test	 DWORD PTR [r12+256], 512 ; 00000200H
  000de	74 31		 je	 SHORT $LN5@subtype_tr

; 842  :         /* For a heaptype, the instances count as references
; 843  :            to the type.          Traverse the type so the collector
; 844  :            can find cycles involving this link. */
; 845  :         Py_VISIT(type);

  000e0	e8 00 00 00 00	 call	 _Py_PXCTX
  000e5	85 c0		 test	 eax, eax
  000e7	74 1c		 je	 SHORT $LN4@subtype_tr
  000e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  000f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@KAJEFJMJ@subtype_traverse?$AA@
  000f7	45 33 c9	 xor	 r9d, r9d
  000fa	41 b8 4d 03 00
	00		 mov	 r8d, 845		; 0000034dH
  00100	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN4@subtype_tr:
  00105	48 8b d6	 mov	 rdx, rsi
  00108	49 8b cc	 mov	 rcx, r12
  0010b	ff d5		 call	 rbp
  0010d	85 c0		 test	 eax, eax
  0010f	75 14		 jne	 SHORT $LN21@subtype_tr
$LN5@subtype_tr:

; 846  : 
; 847  :     if (basetraverse)

  00111	48 85 ff	 test	 rdi, rdi
  00114	74 0d		 je	 SHORT $LN1@subtype_tr

; 848  :         return basetraverse(self, visit, arg);

  00116	4c 8b c6	 mov	 r8, rsi
  00119	48 8b d5	 mov	 rdx, rbp
  0011c	49 8b cd	 mov	 rcx, r13
  0011f	ff d7		 call	 rdi
  00121	eb 02		 jmp	 SHORT $LN21@subtype_tr
$LN1@subtype_tr:

; 849  :     return 0;

  00123	33 c0		 xor	 eax, eax
$LN21@subtype_tr:

; 850  : }

  00125	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0012a	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0012f	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00134	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00139	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0013d	41 5e		 pop	 r14
  0013f	41 5d		 pop	 r13
  00141	41 5c		 pop	 r12
  00143	c3		 ret	 0
subtype_traverse ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$clear_slots DD imagerel clear_slots
	DD	imagerel clear_slots+30
	DD	imagerel $unwind$clear_slots
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$clear_slots DD imagerel clear_slots+30
	DD	imagerel clear_slots+100
	DD	imagerel $chain$1$clear_slots
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$clear_slots DD imagerel clear_slots+100
	DD	imagerel clear_slots+111
	DD	imagerel $chain$2$clear_slots
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$clear_slots DD 021H
	DD	imagerel clear_slots
	DD	imagerel clear_slots+30
	DD	imagerel $unwind$clear_slots
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$clear_slots DD 040a21H
	DD	07540aH
	DD	063405H
	DD	imagerel clear_slots
	DD	imagerel clear_slots+30
	DD	imagerel $unwind$clear_slots
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$clear_slots DD 040a01H
	DD	08640aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT clear_slots
_TEXT	SEGMENT
type$ = 48
self$ = 56
clear_slots PROC					; COMDAT

; 854  : {

  00000	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 855  :     Py_ssize_t i, n;
; 856  :     PyMemberDef *mp;
; 857  : 
; 858  :     n = Py_SIZE(type);

  0000a	48 8b 79 60	 mov	 rdi, QWORD PTR [rcx+96]

; 859  :     mp = PyHeapType_GET_MEMBERS((PyHeapTypeObject *)type);

  0000e	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b 50 78	 mov	 rdx, QWORD PTR [rax+120]

; 860  :     for (i = 0; i < n; i++, mp++) {

  00019	48 85 ff	 test	 rdi, rdi
  0001c	7e 46		 jle	 SHORT $LN3@clear_slot

; 855  :     Py_ssize_t i, n;
; 856  :     PyMemberDef *mp;
; 857  : 
; 858  :     n = Py_SIZE(type);

  0001e	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00023	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  00028	33 ed		 xor	 ebp, ebp
  0002a	48 8d 5c 11 18	 lea	 rbx, QWORD PTR [rcx+rdx+24]
  0002f	90		 npad	 1
$LL5@clear_slot:

; 861  :         if (mp->type == T_OBJECT_EX && !(mp->flags & READONLY)) {

  00030	83 7b f0 10	 cmp	 DWORD PTR [rbx-16], 16
  00034	75 1b		 jne	 SHORT $LN4@clear_slot
  00036	f6 03 01	 test	 BYTE PTR [rbx], 1
  00039	75 16		 jne	 SHORT $LN4@clear_slot

; 862  :             char *addr = (char *)self + mp->offset;

  0003b	48 8b 43 f8	 mov	 rax, QWORD PTR [rbx-8]

; 863  :             PyObject *obj = *(PyObject **)addr;

  0003f	48 8b 0c 06	 mov	 rcx, QWORD PTR [rsi+rax]

; 864  :             if (obj != NULL) {

  00043	48 85 c9	 test	 rcx, rcx
  00046	74 09		 je	 SHORT $LN4@clear_slot

; 865  :                 *(PyObject **)addr = NULL;

  00048	48 89 2c 06	 mov	 QWORD PTR [rsi+rax], rbp

; 866  :                 Py_DECREF(obj);

  0004c	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@clear_slot:

; 860  :     for (i = 0; i < n; i++, mp++) {

  00051	48 83 c3 28	 add	 rbx, 40			; 00000028H
  00055	48 ff cf	 dec	 rdi
  00058	75 d6		 jne	 SHORT $LL5@clear_slot
  0005a	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0005f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
$LN3@clear_slot:

; 867  :             }
; 868  :         }
; 869  :     }
; 870  : }

  00064	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00069	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006d	5f		 pop	 rdi
  0006e	c3		 ret	 0
clear_slots ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@KICMAMDL@subtype_clear?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$subtype_clear DD imagerel subtype_clear
	DD	imagerel subtype_clear+225
	DD	imagerel $unwind$subtype_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$subtype_clear DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0c016521aH
xdata	ENDS
;	COMDAT ??_C@_0O@KICMAMDL@subtype_clear?$AA@
CONST	SEGMENT
??_C@_0O@KICMAMDL@subtype_clear?$AA@ DB 'subtype_clear', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT subtype_clear
_TEXT	SEGMENT
self$ = 64
subtype_clear PROC					; COMDAT

; 874  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 875  :     PyTypeObject *type, *base;
; 876  :     inquiry baseclear;
; 877  : 
; 878  :     /* Find the nearest base with a different tp_clear
; 879  :        and clear slots while we're at it */
; 880  :     type = Py_TYPE(self);

  0001a	48 8b 69 58	 mov	 rbp, QWORD PTR [rcx+88]

; 881  :     base = type;
; 882  :     while ((baseclear = base->tp_clear) == subtype_clear) {

  0001e	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:subtype_clear
  00025	48 8b f1	 mov	 rsi, rcx
  00028	48 8b bd 18 01
	00 00		 mov	 rdi, QWORD PTR [rbp+280]
  0002f	48 8b dd	 mov	 rbx, rbp
  00032	49 3b fc	 cmp	 rdi, r12
  00035	75 25		 jne	 SHORT $LN9@subtype_cl
$LL10@subtype_cl:

; 883  :         if (Py_SIZE(base))

  00037	48 83 7b 60 00	 cmp	 QWORD PTR [rbx+96], 0
  0003c	74 0b		 je	 SHORT $LN8@subtype_cl

; 884  :             clear_slots(base, self);

  0003e	48 8b d6	 mov	 rdx, rsi
  00041	48 8b cb	 mov	 rcx, rbx
  00044	e8 00 00 00 00	 call	 clear_slots
$LN8@subtype_cl:

; 885  :         base = base->tp_base;

  00049	48 8b 9b 58 01
	00 00		 mov	 rbx, QWORD PTR [rbx+344]
  00050	48 8b bb 18 01
	00 00		 mov	 rdi, QWORD PTR [rbx+280]
  00057	49 3b fc	 cmp	 rdi, r12
  0005a	74 db		 je	 SHORT $LL10@subtype_cl
$LN9@subtype_cl:

; 886  :         assert(base);
; 887  :     }
; 888  : 
; 889  :     /* Clear the instance dict (if any), to break cycles involving only
; 890  :        __dict__ slots (as in the case 'self.__dict__ is self'). */
; 891  :     if (type->tp_dictoffset != base->tp_dictoffset) {

  0005c	48 8b 83 78 01
	00 00		 mov	 rax, QWORD PTR [rbx+376]
  00063	48 39 85 78 01
	00 00		 cmp	 QWORD PTR [rbp+376], rax
  0006a	74 4c		 je	 SHORT $LN3@subtype_cl

; 892  :         PyObject **dictptr = _PyObject_GetDictPtr(self);

  0006c	48 8b ce	 mov	 rcx, rsi
  0006f	e8 00 00 00 00	 call	 _PyObject_GetDictPtr
  00074	48 8b d8	 mov	 rbx, rax

; 893  :         if (dictptr && *dictptr)

  00077	48 85 c0	 test	 rax, rax
  0007a	74 3c		 je	 SHORT $LN3@subtype_cl
  0007c	4c 8b 08	 mov	 r9, QWORD PTR [rax]
  0007f	4d 85 c9	 test	 r9, r9
  00082	74 34		 je	 SHORT $LN3@subtype_cl

; 894  :             Py_CLEAR(*dictptr);

  00084	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  0008b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@KICMAMDL@subtype_clear?$AA@
  00092	41 b8 7e 03 00
	00		 mov	 r8d, 894		; 0000037eH
  00098	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000a0	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a5	85 c0		 test	 eax, eax
  000a7	75 0f		 jne	 SHORT $LN3@subtype_cl
  000a9	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000ac	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0
  000b3	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@subtype_cl:

; 895  :     }
; 896  : 
; 897  :     if (baseclear)

  000b8	48 85 ff	 test	 rdi, rdi
  000bb	74 07		 je	 SHORT $LN1@subtype_cl

; 898  :         return baseclear(self);

  000bd	48 8b ce	 mov	 rcx, rsi
  000c0	ff d7		 call	 rdi
  000c2	eb 02		 jmp	 SHORT $LN11@subtype_cl
$LN1@subtype_cl:

; 899  :     return 0;

  000c4	33 c0		 xor	 eax, eax
$LN11@subtype_cl:

; 900  : }

  000c6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000cb	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000d0	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000d5	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000da	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000de	41 5c		 pop	 r12
  000e0	c3		 ret	 0
subtype_clear ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@HEMFFFIH@subtype_dealloc?$AA@		; `string'
EXTRN	_PyTrash_thread_deposit_object:PROC
EXTRN	_PyTrash_thread_destroy_chain:PROC
EXTRN	_PyWeakref_ClearRef:PROC
EXTRN	PyObject_ClearWeakRefs:PROC
EXTRN	_PyTrash_delete_nesting:DWORD
EXTRN	PyObject_GC_UnTrack:PROC
EXTRN	_PyThreadState_Current:QWORD
EXTRN	_PyParallel_GetThreadState:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$subtype_dealloc DD imagerel subtype_dealloc
	DD	imagerel subtype_dealloc+81
	DD	imagerel $unwind$subtype_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$subtype_dealloc DD imagerel subtype_dealloc+81
	DD	imagerel subtype_dealloc+148
	DD	imagerel $chain$1$subtype_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$subtype_dealloc DD imagerel subtype_dealloc+148
	DD	imagerel subtype_dealloc+970
	DD	imagerel $chain$4$subtype_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$subtype_dealloc DD imagerel subtype_dealloc+970
	DD	imagerel subtype_dealloc+1027
	DD	imagerel $chain$5$subtype_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$subtype_dealloc DD imagerel subtype_dealloc+1027
	DD	imagerel subtype_dealloc+1122
	DD	imagerel $chain$6$subtype_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$subtype_dealloc DD 021H
	DD	imagerel subtype_dealloc
	DD	imagerel subtype_dealloc+81
	DD	imagerel $unwind$subtype_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$subtype_dealloc DD 021H
	DD	imagerel subtype_dealloc+81
	DD	imagerel subtype_dealloc+148
	DD	imagerel $chain$1$subtype_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$subtype_dealloc DD 067021H
	DD	0fc470H
	DD	06f425H
	DD	0e6405H
	DD	imagerel subtype_dealloc+81
	DD	imagerel subtype_dealloc+148
	DD	imagerel $chain$1$subtype_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$subtype_dealloc DD 020521H
	DD	07e405H
	DD	imagerel subtype_dealloc
	DD	imagerel subtype_dealloc+81
	DD	imagerel $unwind$subtype_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$subtype_dealloc DD 062f01H
	DD	0d542fH
	DD	0d0057209H
	DD	030027003H
xdata	ENDS
;	COMDAT ??_C@_0BA@HEMFFFIH@subtype_dealloc?$AA@
CONST	SEGMENT
??_C@_0BA@HEMFFFIH@subtype_dealloc?$AA@ DB 'subtype_dealloc', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT subtype_dealloc
_TEXT	SEGMENT
tv233 = 96
tv75 = 96
self$ = 96
subtype_dealloc PROC					; COMDAT

; 904  : {

  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	41 55		 push	 r13
  00005	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00009	48 8b f9	 mov	 rdi, rcx

; 905  :     PyTypeObject *type, *base;
; 906  :     destructor basedealloc;
; 907  :     PyThreadState *tstate = PyThreadState_GET();

  0000c	e8 00 00 00 00	 call	 _Py_PXCTX
  00011	85 c0		 test	 eax, eax
  00013	74 0a		 je	 SHORT $LN44@subtype_de
  00015	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  0001a	4c 8b e8	 mov	 r13, rax
  0001d	eb 07		 jmp	 SHORT $LN45@subtype_de
$LN44@subtype_de:
  0001f	4c 8b 2d 00 00
	00 00		 mov	 r13, QWORD PTR _PyThreadState_Current
$LN45@subtype_de:

; 908  : 
; 909  :     /* Extract the type; we expect it to be a heap type */
; 910  :     type = Py_TYPE(self);

  00026	48 8b 5f 58	 mov	 rbx, QWORD PTR [rdi+88]
  0002a	48 89 6c 24 68	 mov	 QWORD PTR [rsp+104], rbp

; 911  :     assert(type->tp_flags & Py_TPFLAGS_HEAPTYPE);
; 912  : 
; 913  :     /* Test whether the type has GC exactly once */
; 914  : 
; 915  :     if (!PyType_IS_GC(type)) {

  0002f	e8 00 00 00 00	 call	 _Py_PXCTX
  00034	85 c0		 test	 eax, eax
  00036	0f 85 c7 03 00
	00		 jne	 $LN66@subtype_de
  0003c	8b 83 00 01 00
	00		 mov	 eax, DWORD PTR [rbx+256]
  00042	c1 e8 0e	 shr	 eax, 14
  00045	83 e0 01	 and	 eax, 1
  00048	0f 84 b5 03 00
	00		 je	 $LN66@subtype_de

; 946  : 
; 947  :         /* Done */
; 948  :         return;
; 949  :     }
; 950  : 
; 951  :     /* We get here only if the type has GC */
; 952  : 
; 953  :     /* UnTrack and re-Track around the trashcan macro, alas */
; 954  :     /* See explanation at end of function for full disclosure */
; 955  :     PyObject_GC_UnTrack(self);

  0004e	48 8b cf	 mov	 rcx, rdi
  00051	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  00056	e8 00 00 00 00	 call	 PyObject_GC_UnTrack

; 956  :     ++_PyTrash_delete_nesting;

  0005b	ff 05 00 00 00
	00		 inc	 DWORD PTR _PyTrash_delete_nesting

; 957  :     ++ tstate->trash_delete_nesting;

  00061	41 ff 85 94 00
	00 00		 inc	 DWORD PTR [r13+148]

; 958  :     Py_TRASHCAN_SAFE_BEGIN(self);

  00068	e8 00 00 00 00	 call	 _Py_PXCTX
  0006d	85 c0		 test	 eax, eax
  0006f	74 0a		 je	 SHORT $LN48@subtype_de
  00071	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00076	4c 8b f0	 mov	 r14, rax
  00079	eb 07		 jmp	 SHORT $LN49@subtype_de
$LN48@subtype_de:
  0007b	4c 8b 35 00 00
	00 00		 mov	 r14, QWORD PTR _PyThreadState_Current
$LN49@subtype_de:
  00082	41 8b 86 94 00
	00 00		 mov	 eax, DWORD PTR [r14+148]
  00089	83 f8 32	 cmp	 eax, 50			; 00000032H
  0008c	0f 8d 49 03 00
	00		 jge	 $LN33@subtype_de
  00092	ff c0		 inc	 eax
  00094	48 89 74 24 70	 mov	 QWORD PTR [rsp+112], rsi

; 959  :     --_PyTrash_delete_nesting;
; 960  :     -- tstate->trash_delete_nesting;
; 961  :     /* DO NOT restore GC tracking at this point.  weakref callbacks
; 962  :      * (if any, and whether directly here or indirectly in something we
; 963  :      * call) may trigger GC, and if self is tracked at that point, it
; 964  :      * will look like trash to GC and GC will try to delete self again.
; 965  :      */
; 966  : 
; 967  :     /* Find the nearest base with a different tp_dealloc */
; 968  :     base = type;
; 969  :     while ((/*basedealloc =*/ base->tp_dealloc) == subtype_dealloc) {

  00099	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:subtype_dealloc
  000a0	41 89 86 94 00
	00 00		 mov	 DWORD PTR [r14+148], eax
  000a7	ff 0d 00 00 00
	00		 dec	 DWORD PTR _PyTrash_delete_nesting
  000ad	41 ff 8d 94 00
	00 00		 dec	 DWORD PTR [r13+148]
  000b4	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15
  000b9	48 8b f3	 mov	 rsi, rbx
  000bc	48 39 ab 88 00
	00 00		 cmp	 QWORD PTR [rbx+136], rbp
  000c3	75 1b		 jne	 SHORT $LN31@subtype_de
  000c5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL32@subtype_de:

; 970  :         base = base->tp_base;

  000d0	48 8b b6 58 01
	00 00		 mov	 rsi, QWORD PTR [rsi+344]
  000d7	48 39 ae 88 00
	00 00		 cmp	 QWORD PTR [rsi+136], rbp
  000de	74 f0		 je	 SHORT $LL32@subtype_de
$LN31@subtype_de:

; 971  :         assert(base);
; 972  :     }
; 973  : 
; 974  :     /* If we added a weaklist, we clear it.      Do this *before* calling
; 975  :        the finalizer (__del__), clearing slots, or clearing the instance
; 976  :        dict. */
; 977  : 
; 978  :     if (type->tp_weaklistoffset && !base->tp_weaklistoffset)

  000e0	48 83 bb 28 01
	00 00 00	 cmp	 QWORD PTR [rbx+296], 0
  000e8	74 12		 je	 SHORT $LN30@subtype_de
  000ea	48 83 be 28 01
	00 00 00	 cmp	 QWORD PTR [rsi+296], 0
  000f2	75 08		 jne	 SHORT $LN30@subtype_de

; 979  :         PyObject_ClearWeakRefs(self);

  000f4	48 8b cf	 mov	 rcx, rdi
  000f7	e8 00 00 00 00	 call	 PyObject_ClearWeakRefs
$LN30@subtype_de:

; 980  : 
; 981  :     /* Maybe call finalizer; exit early if resurrected */
; 982  :     if (type->tp_del) {

  000fc	45 33 ff	 xor	 r15d, r15d
  000ff	4c 89 64 24 78	 mov	 QWORD PTR [rsp+120], r12
  00104	4c 39 bb d0 01
	00 00		 cmp	 QWORD PTR [rbx+464], r15
  0010b	0f 84 60 01 00
	00		 je	 $LN15@subtype_de

; 983  :         _PyObject_GC_TRACK(self);

  00111	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  00118	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@HEMFFFIH@subtype_dealloc?$AA@
  0011f	4c 8b cf	 mov	 r9, rdi
  00122	41 b8 d7 03 00
	00		 mov	 r8d, 983		; 000003d7H
  00128	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00130	e8 00 00 00 00	 call	 _PyParallel_Guard
  00135	85 c0		 test	 eax, eax
  00137	75 75		 jne	 SHORT $LN25@subtype_de
  00139	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  00140	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@HEMFFFIH@subtype_dealloc?$AA@
  00147	4c 8b cf	 mov	 r9, rdi
  0014a	41 b8 d7 03 00
	00		 mov	 r8d, 983		; 000003d7H
  00150	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00158	e8 00 00 00 00	 call	 _PyParallel_Guard
  0015d	45 8b e7	 mov	 r12d, r15d
  00160	85 c0		 test	 eax, eax
  00162	75 04		 jne	 SHORT $LN51@subtype_de
  00164	4c 8d 67 e8	 lea	 r12, QWORD PTR [rdi-24]
$LN51@subtype_de:
  00168	49 83 7c 24 10
	fe		 cmp	 QWORD PTR [r12+16], -2
  0016e	74 0c		 je	 SHORT $LN24@subtype_de
  00170	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
  00177	e8 00 00 00 00	 call	 Py_FatalError
$LN24@subtype_de:
  0017c	49 c7 44 24 10
	fd ff ff ff	 mov	 QWORD PTR [r12+16], -3
  00185	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  0018c	49 89 04 24	 mov	 QWORD PTR [r12], rax
  00190	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  00197	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0019b	49 89 4c 24 08	 mov	 QWORD PTR [r12+8], rcx
  001a0	4c 89 21	 mov	 QWORD PTR [rcx], r12
  001a3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  001aa	4c 89 60 08	 mov	 QWORD PTR [rax+8], r12
$LN25@subtype_de:

; 984  :         type->tp_del(self);

  001ae	48 8b cf	 mov	 rcx, rdi
  001b1	ff 93 d0 01 00
	00		 call	 QWORD PTR [rbx+464]

; 985  :         if (self->ob_refcnt > 0)

  001b7	4c 39 7f 50	 cmp	 QWORD PTR [rdi+80], r15
  001bb	0f 8f dc 01 00
	00		 jg	 $endlabel$21118

; 986  :             goto endlabel;              /* resurrected */
; 987  :         else
; 988  :             _PyObject_GC_UNTRACK(self);

  001c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  001c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@HEMFFFIH@subtype_dealloc?$AA@
  001cf	4c 8b cf	 mov	 r9, rdi
  001d2	41 b8 dc 03 00
	00		 mov	 r8d, 988		; 000003dcH
  001d8	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001e0	e8 00 00 00 00	 call	 _PyParallel_Guard
  001e5	85 c0		 test	 eax, eax
  001e7	75 4f		 jne	 SHORT $LN18@subtype_de
  001e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  001f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@HEMFFFIH@subtype_dealloc?$AA@
  001f7	4c 8b cf	 mov	 r9, rdi
  001fa	41 b8 dc 03 00
	00		 mov	 r8d, 988		; 000003dcH
  00200	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00208	e8 00 00 00 00	 call	 _PyParallel_Guard
  0020d	49 8b d7	 mov	 rdx, r15
  00210	85 c0		 test	 eax, eax
  00212	75 04		 jne	 SHORT $LN53@subtype_de
  00214	48 8d 57 e8	 lea	 rdx, QWORD PTR [rdi-24]
$LN53@subtype_de:
  00218	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0021b	48 8b 4a 08	 mov	 rcx, QWORD PTR [rdx+8]
  0021f	48 c7 42 10 fe
	ff ff ff	 mov	 QWORD PTR [rdx+16], -2
  00227	48 89 01	 mov	 QWORD PTR [rcx], rax
  0022a	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  0022d	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00231	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00235	4c 89 3a	 mov	 QWORD PTR [rdx], r15
$LN18@subtype_de:

; 989  :         /* New weakrefs could be created during the finalizer call.
; 990  :             If this occurs, clear them out without calling their
; 991  :             finalizers since they might rely on part of the object
; 992  :             being finalized that has already been destroyed. */
; 993  :         if (type->tp_weaklistoffset && !base->tp_weaklistoffset) {

  00238	4c 39 bb 28 01
	00 00		 cmp	 QWORD PTR [rbx+296], r15
  0023f	74 30		 je	 SHORT $LN15@subtype_de
  00241	4c 39 be 28 01
	00 00		 cmp	 QWORD PTR [rsi+296], r15
  00248	75 27		 jne	 SHORT $LN15@subtype_de

; 994  :             /* Modeled after GET_WEAKREFS_LISTPTR() */
; 995  :             PyWeakReference **list = (PyWeakReference **) \
; 996  :                 PyObject_GET_WEAKREFS_LISTPTR(self);

  0024a	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0024e	48 8b b0 28 01
	00 00		 mov	 rsi, QWORD PTR [rax+296]

; 997  :             while (*list)

  00255	48 8b 04 37	 mov	 rax, QWORD PTR [rdi+rsi]
  00259	48 85 c0	 test	 rax, rax
  0025c	74 13		 je	 SHORT $LN15@subtype_de
  0025e	66 90		 npad	 2
$LL16@subtype_de:

; 998  :                 _PyWeakref_ClearRef(*list);

  00260	48 8b c8	 mov	 rcx, rax
  00263	e8 00 00 00 00	 call	 _PyWeakref_ClearRef
  00268	48 8b 04 37	 mov	 rax, QWORD PTR [rdi+rsi]
  0026c	48 85 c0	 test	 rax, rax
  0026f	75 ef		 jne	 SHORT $LL16@subtype_de
$LN15@subtype_de:

; 999  :         }
; 1000 :     }
; 1001 : 
; 1002 :     /*  Clear slots up to the nearest base with a different tp_dealloc */
; 1003 :     base = type;
; 1004 :     while ((basedealloc = base->tp_dealloc) == subtype_dealloc) {

  00271	4c 8b a3 88 00
	00 00		 mov	 r12, QWORD PTR [rbx+136]
  00278	48 8b f3	 mov	 rsi, rbx
  0027b	4c 3b e5	 cmp	 r12, rbp
  0027e	75 24		 jne	 SHORT $LN13@subtype_de
$LL14@subtype_de:

; 1005 :         if (Py_SIZE(base))

  00280	4c 39 7e 60	 cmp	 QWORD PTR [rsi+96], r15
  00284	74 0b		 je	 SHORT $LN12@subtype_de

; 1006 :             clear_slots(base, self);

  00286	48 8b d7	 mov	 rdx, rdi
  00289	48 8b ce	 mov	 rcx, rsi
  0028c	e8 00 00 00 00	 call	 clear_slots
$LN12@subtype_de:

; 1007 :         base = base->tp_base;

  00291	48 8b b6 58 01
	00 00		 mov	 rsi, QWORD PTR [rsi+344]
  00298	4c 8b a6 88 00
	00 00		 mov	 r12, QWORD PTR [rsi+136]
  0029f	4c 3b e5	 cmp	 r12, rbp
  002a2	74 dc		 je	 SHORT $LL14@subtype_de
$LN13@subtype_de:

; 1008 :         assert(base);
; 1009 :     }
; 1010 : 
; 1011 :     /* If we added a dict, DECREF it */
; 1012 :     if (type->tp_dictoffset && !base->tp_dictoffset) {

  002a4	4c 39 bb 78 01
	00 00		 cmp	 QWORD PTR [rbx+376], r15
  002ab	74 29		 je	 SHORT $LN9@subtype_de
  002ad	4c 39 be 78 01
	00 00		 cmp	 QWORD PTR [rsi+376], r15
  002b4	75 20		 jne	 SHORT $LN9@subtype_de

; 1013 :         PyObject **dictptr = _PyObject_GetDictPtr(self);

  002b6	48 8b cf	 mov	 rcx, rdi
  002b9	e8 00 00 00 00	 call	 _PyObject_GetDictPtr
  002be	48 8b d8	 mov	 rbx, rax

; 1014 :         if (dictptr != NULL) {

  002c1	48 85 c0	 test	 rax, rax
  002c4	74 10		 je	 SHORT $LN9@subtype_de

; 1015 :             PyObject *dict = *dictptr;

  002c6	48 8b 08	 mov	 rcx, QWORD PTR [rax]

; 1016 :             if (dict != NULL) {

  002c9	48 85 c9	 test	 rcx, rcx
  002cc	74 08		 je	 SHORT $LN9@subtype_de

; 1017 :                 Py_DECREF(dict);

  002ce	e8 00 00 00 00	 call	 _Py_DecRef

; 1018 :                 *dictptr = NULL;

  002d3	4c 89 3b	 mov	 QWORD PTR [rbx], r15
$LN9@subtype_de:

; 1019 :             }
; 1020 :         }
; 1021 :     }
; 1022 : 
; 1023 :     /* Extract the type again; tp_del may have changed it */
; 1024 :     type = Py_TYPE(self);

  002d6	48 8b 5f 58	 mov	 rbx, QWORD PTR [rdi+88]

; 1025 : 
; 1026 :     /* Call the base tp_dealloc(); first retrack self if
; 1027 :      * basedealloc knows about gc.
; 1028 :      */
; 1029 :     if (PyType_IS_GC(base))

  002da	e8 00 00 00 00	 call	 _Py_PXCTX
  002df	85 c0		 test	 eax, eax
  002e1	0f 85 a8 00 00
	00		 jne	 $LN4@subtype_de
  002e7	8b 86 00 01 00
	00		 mov	 eax, DWORD PTR [rsi+256]
  002ed	c1 e8 0e	 shr	 eax, 14
  002f0	83 e0 01	 and	 eax, 1
  002f3	0f 84 96 00 00
	00		 je	 $LN4@subtype_de

; 1030 :         _PyObject_GC_TRACK(self);

  002f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  00300	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@HEMFFFIH@subtype_dealloc?$AA@
  00307	4c 8b cf	 mov	 r9, rdi
  0030a	41 b8 06 04 00
	00		 mov	 r8d, 1030		; 00000406H
  00310	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00318	e8 00 00 00 00	 call	 _PyParallel_Guard
  0031d	85 c0		 test	 eax, eax
  0031f	75 6e		 jne	 SHORT $LN4@subtype_de
  00321	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  00328	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@HEMFFFIH@subtype_dealloc?$AA@
  0032f	4c 8b cf	 mov	 r9, rdi
  00332	41 b8 06 04 00
	00		 mov	 r8d, 1030		; 00000406H
  00338	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00340	e8 00 00 00 00	 call	 _PyParallel_Guard
  00345	85 c0		 test	 eax, eax
  00347	75 04		 jne	 SHORT $LN57@subtype_de
  00349	4c 8d 7f e8	 lea	 r15, QWORD PTR [rdi-24]
$LN57@subtype_de:
  0034d	49 83 7f 10 fe	 cmp	 QWORD PTR [r15+16], -2
  00352	74 0c		 je	 SHORT $LN3@subtype_de
  00354	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
  0035b	e8 00 00 00 00	 call	 Py_FatalError
$LN3@subtype_de:
  00360	49 c7 47 10 fd
	ff ff ff	 mov	 QWORD PTR [r15+16], -3
  00368	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  0036f	49 89 07	 mov	 QWORD PTR [r15], rax
  00372	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  00379	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0037d	49 89 57 08	 mov	 QWORD PTR [r15+8], rdx
  00381	4c 89 3a	 mov	 QWORD PTR [rdx], r15
  00384	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  0038b	4c 89 78 08	 mov	 QWORD PTR [rax+8], r15
$LN4@subtype_de:

; 1031 :     assert(basedealloc);
; 1032 :     basedealloc(self);

  0038f	48 8b cf	 mov	 rcx, rdi
  00392	41 ff d4	 call	 r12

; 1033 : 
; 1034 :     /* Can't reference self beyond this point */
; 1035 :     Py_DECREF(type);

  00395	48 8b cb	 mov	 rcx, rbx
  00398	e8 00 00 00 00	 call	 _Py_DecRef
$endlabel$21118:

; 1036 : 
; 1037 :   endlabel:
; 1038 :     ++_PyTrash_delete_nesting;

  0039d	ff 05 00 00 00
	00		 inc	 DWORD PTR _PyTrash_delete_nesting

; 1039 :     ++ tstate->trash_delete_nesting;

  003a3	41 ff 85 94 00
	00 00		 inc	 DWORD PTR [r13+148]

; 1040 :     Py_TRASHCAN_SAFE_END(self);

  003aa	41 ff 8e 94 00
	00 00		 dec	 DWORD PTR [r14+148]
  003b1	49 83 be 98 00
	00 00 00	 cmp	 QWORD PTR [r14+152], 0
  003b9	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]
  003be	4c 8b 64 24 78	 mov	 r12, QWORD PTR [rsp+120]
  003c3	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  003c8	74 19		 je	 SHORT $LN35@subtype_de
  003ca	41 83 be 94 00
	00 00 00	 cmp	 DWORD PTR [r14+148], 0
  003d2	7f 0f		 jg	 SHORT $LN35@subtype_de
  003d4	e8 00 00 00 00	 call	 _PyTrash_thread_destroy_chain
  003d9	eb 08		 jmp	 SHORT $LN35@subtype_de
$LN33@subtype_de:
  003db	48 8b cf	 mov	 rcx, rdi
  003de	e8 00 00 00 00	 call	 _PyTrash_thread_deposit_object
$LN35@subtype_de:

; 1041 :     --_PyTrash_delete_nesting;

  003e3	ff 0d 00 00 00
	00		 dec	 DWORD PTR _PyTrash_delete_nesting
  003e9	4c 8b 74 24 38	 mov	 r14, QWORD PTR [rsp+56]

; 1042 :     -- tstate->trash_delete_nesting;

  003ee	41 ff 8d 94 00
	00 00		 dec	 DWORD PTR [r13+148]
  003f5	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]

; 1043 : 
; 1044 :     /* Explanation of the weirdness around the trashcan macros:
; 1045 : 
; 1046 :        Q. What do the trashcan macros do?
; 1047 : 
; 1048 :        A. Read the comment titled "Trashcan mechanism" in object.h.
; 1049 :           For one, this explains why there must be a call to GC-untrack
; 1050 :           before the trashcan begin macro.      Without understanding the
; 1051 :           trashcan code, the answers to the following questions don't make
; 1052 :           sense.
; 1053 : 
; 1054 :        Q. Why do we GC-untrack before the trashcan and then immediately
; 1055 :           GC-track again afterward?
; 1056 : 
; 1057 :        A. In the case that the base class is GC-aware, the base class
; 1058 :           probably GC-untracks the object.      If it does that using the
; 1059 :           UNTRACK macro, this will crash when the object is already
; 1060 :           untracked.  Because we don't know what the base class does, the
; 1061 :           only safe thing is to make sure the object is tracked when we
; 1062 :           call the base class dealloc.  But...  The trashcan begin macro
; 1063 :           requires that the object is *untracked* before it is called.  So
; 1064 :           the dance becomes:
; 1065 : 
; 1066 :          GC untrack
; 1067 :          trashcan begin
; 1068 :          GC track
; 1069 : 
; 1070 :        Q. Why did the last question say "immediately GC-track again"?
; 1071 :           It's nowhere near immediately.
; 1072 : 
; 1073 :        A. Because the code *used* to re-track immediately.      Bad Idea.
; 1074 :           self has a refcount of 0, and if gc ever gets its hands on it
; 1075 :           (which can happen if any weakref callback gets invoked), it
; 1076 :           looks like trash to gc too, and gc also tries to delete self
; 1077 :           then.  But we're already deleting self.  Double deallocation is
; 1078 :           a subtle disaster.
; 1079 : 
; 1080 :        Q. Why the bizarre (net-zero) manipulation of
; 1081 :           _PyTrash_delete_nesting around the trashcan macros?
; 1082 : 
; 1083 :        A. Some base classes (e.g. list) also use the trashcan mechanism.
; 1084 :           The following scenario used to be possible:
; 1085 : 
; 1086 :           - suppose the trashcan level is one below the trashcan limit
; 1087 : 
; 1088 :           - subtype_dealloc() is called
; 1089 : 
; 1090 :           - the trashcan limit is not yet reached, so the trashcan level
; 1091 :         is incremented and the code between trashcan begin and end is
; 1092 :         executed
; 1093 : 
; 1094 :           - this destroys much of the object's contents, including its
; 1095 :         slots and __dict__
; 1096 : 
; 1097 :           - basedealloc() is called; this is really list_dealloc(), or
; 1098 :         some other type which also uses the trashcan macros
; 1099 : 
; 1100 :           - the trashcan limit is now reached, so the object is put on the
; 1101 :         trashcan's to-be-deleted-later list
; 1102 : 
; 1103 :           - basedealloc() returns
; 1104 : 
; 1105 :           - subtype_dealloc() decrefs the object's type
; 1106 : 
; 1107 :           - subtype_dealloc() returns
; 1108 : 
; 1109 :           - later, the trashcan code starts deleting the objects from its
; 1110 :         to-be-deleted-later list
; 1111 : 
; 1112 :           - subtype_dealloc() is called *AGAIN* for the same object
; 1113 : 
; 1114 :           - at the very least (if the destroyed slots and __dict__ don't
; 1115 :         cause problems) the object's type gets decref'ed a second
; 1116 :         time, which is *BAD*!!!
; 1117 : 
; 1118 :           The remedy is to make sure that if the code between trashcan
; 1119 :           begin and end in subtype_dealloc() is called, the code between
; 1120 :           trashcan begin and end in basedealloc() will also be called.
; 1121 :           This is done by decrementing the level after passing into the
; 1122 :           trashcan block, and incrementing it just before leaving the
; 1123 :           block.
; 1124 : 
; 1125 :           But now it's possible that a chain of objects consisting solely
; 1126 :           of objects whose deallocator is subtype_dealloc() will defeat
; 1127 :           the trashcan mechanism completely: the decremented level means
; 1128 :           that the effective level never reaches the limit.      Therefore, we
; 1129 :           *increment* the level *before* entering the trashcan block, and
; 1130 :           matchingly decrement it after leaving.  This means the trashcan
; 1131 :           code will trigger a little early, but that's no big deal.
; 1132 : 
; 1133 :        Q. Are there any live examples of code in need of all this
; 1134 :           complexity?
; 1135 : 
; 1136 :        A. Yes.  See SF bug 668433 for code that crashed (when Python was
; 1137 :           compiled in debug mode) before the trashcan level manipulations
; 1138 :           were added.  For more discussion, see SF patches 581742, 575073
; 1139 :           and bug 574207.
; 1140 :     */
; 1141 : }

  003fa	48 83 c4 40	 add	 rsp, 64			; 00000040H
  003fe	41 5d		 pop	 r13
  00400	5f		 pop	 rdi
  00401	5b		 pop	 rbx
  00402	c3		 ret	 0
$LN66@subtype_de:

; 916  :         /* It's really rare to find a dynamic type that doesn't have
; 917  :            GC; it can only happen when deriving from 'object' and not
; 918  :            adding any slots or instance variables.  This allows
; 919  :            certain simplifications: there's no need to call
; 920  :            clear_slots(), or DECREF the dict, or clear weakrefs. */
; 921  : 
; 922  :         /* Maybe call finalizer; exit early if resurrected */
; 923  :         if (type->tp_del) {

  00403	48 8b 83 d0 01
	00 00		 mov	 rax, QWORD PTR [rbx+464]
  0040a	48 85 c0	 test	 rax, rax
  0040d	74 0c		 je	 SHORT $LN39@subtype_de

; 924  :             type->tp_del(self);

  0040f	48 8b cf	 mov	 rcx, rdi
  00412	ff d0		 call	 rax

; 925  :             if (self->ob_refcnt > 0)

  00414	48 83 7f 50 00	 cmp	 QWORD PTR [rdi+80], 0
  00419	7f 39		 jg	 SHORT $LN42@subtype_de
$LN39@subtype_de:

; 926  :                 return;
; 927  :         }
; 928  : 
; 929  :         /* Find the nearest base with a different tp_dealloc */
; 930  :         base = type;
; 931  :         while ((basedealloc = base->tp_dealloc) == subtype_dealloc) {

  0041b	48 8b 83 88 00
	00 00		 mov	 rax, QWORD PTR [rbx+136]
  00422	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:subtype_dealloc
  00429	48 3b c5	 cmp	 rax, rbp
  0042c	75 15		 jne	 SHORT $LN37@subtype_de
  0042e	66 90		 npad	 2
$LL38@subtype_de:

; 932  :             assert(Py_SIZE(base) == 0);
; 933  :             base = base->tp_base;

  00430	48 8b 9b 58 01
	00 00		 mov	 rbx, QWORD PTR [rbx+344]
  00437	48 8b 83 88 00
	00 00		 mov	 rax, QWORD PTR [rbx+136]
  0043e	48 3b c5	 cmp	 rax, rbp
  00441	74 ed		 je	 SHORT $LL38@subtype_de
$LN37@subtype_de:

; 934  :             assert(base);
; 935  :         }
; 936  : 
; 937  :         /* Extract the type again; tp_del may have changed it */
; 938  :         type = Py_TYPE(self);

  00443	48 8b 5f 58	 mov	 rbx, QWORD PTR [rdi+88]

; 939  : 
; 940  :         /* Call the base tp_dealloc() */
; 941  :         assert(basedealloc);
; 942  :         basedealloc(self);

  00447	48 8b cf	 mov	 rcx, rdi
  0044a	ff d0		 call	 rax

; 943  : 
; 944  :         /* Can't reference self beyond this point */
; 945  :         Py_DECREF(type);

  0044c	48 8b cb	 mov	 rcx, rbx
  0044f	e8 00 00 00 00	 call	 _Py_DecRef
$LN42@subtype_de:
  00454	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]

; 1043 : 
; 1044 :     /* Explanation of the weirdness around the trashcan macros:
; 1045 : 
; 1046 :        Q. What do the trashcan macros do?
; 1047 : 
; 1048 :        A. Read the comment titled "Trashcan mechanism" in object.h.
; 1049 :           For one, this explains why there must be a call to GC-untrack
; 1050 :           before the trashcan begin macro.      Without understanding the
; 1051 :           trashcan code, the answers to the following questions don't make
; 1052 :           sense.
; 1053 : 
; 1054 :        Q. Why do we GC-untrack before the trashcan and then immediately
; 1055 :           GC-track again afterward?
; 1056 : 
; 1057 :        A. In the case that the base class is GC-aware, the base class
; 1058 :           probably GC-untracks the object.      If it does that using the
; 1059 :           UNTRACK macro, this will crash when the object is already
; 1060 :           untracked.  Because we don't know what the base class does, the
; 1061 :           only safe thing is to make sure the object is tracked when we
; 1062 :           call the base class dealloc.  But...  The trashcan begin macro
; 1063 :           requires that the object is *untracked* before it is called.  So
; 1064 :           the dance becomes:
; 1065 : 
; 1066 :          GC untrack
; 1067 :          trashcan begin
; 1068 :          GC track
; 1069 : 
; 1070 :        Q. Why did the last question say "immediately GC-track again"?
; 1071 :           It's nowhere near immediately.
; 1072 : 
; 1073 :        A. Because the code *used* to re-track immediately.      Bad Idea.
; 1074 :           self has a refcount of 0, and if gc ever gets its hands on it
; 1075 :           (which can happen if any weakref callback gets invoked), it
; 1076 :           looks like trash to gc too, and gc also tries to delete self
; 1077 :           then.  But we're already deleting self.  Double deallocation is
; 1078 :           a subtle disaster.
; 1079 : 
; 1080 :        Q. Why the bizarre (net-zero) manipulation of
; 1081 :           _PyTrash_delete_nesting around the trashcan macros?
; 1082 : 
; 1083 :        A. Some base classes (e.g. list) also use the trashcan mechanism.
; 1084 :           The following scenario used to be possible:
; 1085 : 
; 1086 :           - suppose the trashcan level is one below the trashcan limit
; 1087 : 
; 1088 :           - subtype_dealloc() is called
; 1089 : 
; 1090 :           - the trashcan limit is not yet reached, so the trashcan level
; 1091 :         is incremented and the code between trashcan begin and end is
; 1092 :         executed
; 1093 : 
; 1094 :           - this destroys much of the object's contents, including its
; 1095 :         slots and __dict__
; 1096 : 
; 1097 :           - basedealloc() is called; this is really list_dealloc(), or
; 1098 :         some other type which also uses the trashcan macros
; 1099 : 
; 1100 :           - the trashcan limit is now reached, so the object is put on the
; 1101 :         trashcan's to-be-deleted-later list
; 1102 : 
; 1103 :           - basedealloc() returns
; 1104 : 
; 1105 :           - subtype_dealloc() decrefs the object's type
; 1106 : 
; 1107 :           - subtype_dealloc() returns
; 1108 : 
; 1109 :           - later, the trashcan code starts deleting the objects from its
; 1110 :         to-be-deleted-later list
; 1111 : 
; 1112 :           - subtype_dealloc() is called *AGAIN* for the same object
; 1113 : 
; 1114 :           - at the very least (if the destroyed slots and __dict__ don't
; 1115 :         cause problems) the object's type gets decref'ed a second
; 1116 :         time, which is *BAD*!!!
; 1117 : 
; 1118 :           The remedy is to make sure that if the code between trashcan
; 1119 :           begin and end in subtype_dealloc() is called, the code between
; 1120 :           trashcan begin and end in basedealloc() will also be called.
; 1121 :           This is done by decrementing the level after passing into the
; 1122 :           trashcan block, and incrementing it just before leaving the
; 1123 :           block.
; 1124 : 
; 1125 :           But now it's possible that a chain of objects consisting solely
; 1126 :           of objects whose deallocator is subtype_dealloc() will defeat
; 1127 :           the trashcan mechanism completely: the decremented level means
; 1128 :           that the effective level never reaches the limit.      Therefore, we
; 1129 :           *increment* the level *before* entering the trashcan block, and
; 1130 :           matchingly decrement it after leaving.  This means the trashcan
; 1131 :           code will trigger a little early, but that's no big deal.
; 1132 : 
; 1133 :        Q. Are there any live examples of code in need of all this
; 1134 :           complexity?
; 1135 : 
; 1136 :        A. Yes.  See SF bug 668433 for code that crashed (when Python was
; 1137 :           compiled in debug mode) before the trashcan level manipulations
; 1138 :           were added.  For more discussion, see SF patches 581742, 575073
; 1139 :           and bug 574207.
; 1140 :     */
; 1141 : }

  00459	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0045d	41 5d		 pop	 r13
  0045f	5f		 pop	 rdi
  00460	5b		 pop	 rbx
  00461	c3		 ret	 0
subtype_dealloc ENDP
_TEXT	ENDS
PUBLIC	PyType_IsSubtype
; Function compile flags: /Ogtpy
;	COMDAT PyType_IsSubtype
_TEXT	SEGMENT
a$ = 8
b$ = 16
PyType_IsSubtype PROC					; COMDAT

; 1150 :     PyObject *mro;
; 1151 : 
; 1152 :     mro = a->tp_mro;

  00000	4c 8b 89 b0 01
	00 00		 mov	 r9, QWORD PTR [rcx+432]

; 1153 :     if (mro != NULL) {

  00007	4d 85 c9	 test	 r9, r9
  0000a	74 28		 je	 SHORT $LL4@PyType_IsS

; 1154 :         /* Deal with multiple inheritance without recursion
; 1155 :            by walking the MRO tuple */
; 1156 :         Py_ssize_t i, n;
; 1157 :         assert(PyTuple_Check(mro));
; 1158 :         n = PyTuple_GET_SIZE(mro);

  0000c	4d 8b 41 60	 mov	 r8, QWORD PTR [r9+96]

; 1159 :         for (i = 0; i < n; i++) {

  00010	33 c0		 xor	 eax, eax
  00012	4d 85 c0	 test	 r8, r8
  00015	7e 1a		 jle	 SHORT $LN7@PyType_IsS

; 1154 :         /* Deal with multiple inheritance without recursion
; 1155 :            by walking the MRO tuple */
; 1156 :         Py_ssize_t i, n;
; 1157 :         assert(PyTuple_Check(mro));
; 1158 :         n = PyTuple_GET_SIZE(mro);

  00017	49 8d 49 70	 lea	 rcx, QWORD PTR [r9+112]
  0001b	0f 1f 44 00 00	 npad	 5
$LL9@PyType_IsS:

; 1160 :             if (PyTuple_GET_ITEM(mro, i) == (PyObject *)b)

  00020	48 39 11	 cmp	 QWORD PTR [rcx], rdx
  00023	74 30		 je	 SHORT $LN16@PyType_IsS

; 1159 :         for (i = 0; i < n; i++) {

  00025	48 ff c0	 inc	 rax
  00028	48 83 c1 08	 add	 rcx, 8
  0002c	49 3b c0	 cmp	 rax, r8
  0002f	7c ef		 jl	 SHORT $LL9@PyType_IsS
$LN7@PyType_IsS:

; 1161 :                 return 1;
; 1162 :         }
; 1163 :         return 0;

  00031	33 c0		 xor	 eax, eax

; 1173 :     }
; 1174 : }

  00033	c3		 ret	 0
$LL4@PyType_IsS:

; 1164 :     }
; 1165 :     else {
; 1166 :         /* a is not completely initilized yet; follow tp_base */
; 1167 :         do {
; 1168 :             if (a == b)

  00034	48 3b ca	 cmp	 rcx, rdx
  00037	74 1c		 je	 SHORT $LN16@PyType_IsS

; 1170 :             a = a->tp_base;

  00039	48 8b 89 58 01
	00 00		 mov	 rcx, QWORD PTR [rcx+344]

; 1171 :         } while (a != NULL);

  00040	48 85 c9	 test	 rcx, rcx
  00043	75 ef		 jne	 SHORT $LL4@PyType_IsS

; 1172 :         return b == &PyBaseObject_Type;

  00045	33 c0		 xor	 eax, eax
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBaseObject_Type
  0004e	48 3b d1	 cmp	 rdx, rcx
  00051	0f 94 c0	 sete	 al

; 1173 :     }
; 1174 : }

  00054	c3		 ret	 0
$LN16@PyType_IsS:

; 1169 :                 return 1;

  00055	b8 01 00 00 00	 mov	 eax, 1

; 1173 :     }
; 1174 : }

  0005a	c3		 ret	 0
PyType_IsSubtype ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT tail_contains
_TEXT	SEGMENT
list$ = 8
whence$ = 16
o$ = 24
tail_contains PROC					; COMDAT

; 1328 :     Py_ssize_t j, size;
; 1329 :     size = PyList_GET_SIZE(list);

  00000	4c 8b 49 60	 mov	 r9, QWORD PTR [rcx+96]

; 1330 : 
; 1331 :     for (j = whence+1; j < size; j++) {

  00004	8d 42 01	 lea	 eax, DWORD PTR [rdx+1]
  00007	48 63 d0	 movsxd	 rdx, eax
  0000a	49 3b d1	 cmp	 rdx, r9
  0000d	7d 19		 jge	 SHORT $LN2@tail_conta

; 1328 :     Py_ssize_t j, size;
; 1329 :     size = PyList_GET_SIZE(list);

  0000f	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00013	48 8d 0c d0	 lea	 rcx, QWORD PTR [rax+rdx*8]
$LL4@tail_conta:

; 1332 :         if (PyList_GET_ITEM(list, j) == o)

  00017	4c 39 01	 cmp	 QWORD PTR [rcx], r8
  0001a	74 0f		 je	 SHORT $LN8@tail_conta

; 1330 : 
; 1331 :     for (j = whence+1; j < size; j++) {

  0001c	48 ff c2	 inc	 rdx
  0001f	48 83 c1 08	 add	 rcx, 8
  00023	49 3b d1	 cmp	 rdx, r9
  00026	7c ef		 jl	 SHORT $LL4@tail_conta
$LN2@tail_conta:

; 1334 :     }
; 1335 :     return 0;

  00028	33 c0		 xor	 eax, eax

; 1336 : }

  0002a	c3		 ret	 0
$LN8@tail_conta:

; 1333 :             return 1;

  0002b	b8 01 00 00 00	 mov	 eax, 1

; 1336 : }

  00030	c3		 ret	 0
tail_contains ENDP
_TEXT	ENDS
EXTRN	PyObject_Repr:PROC
EXTRN	_PyObject_GetAttrId:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$class_name DD imagerel class_name
	DD	imagerel class_name+109
	DD	imagerel $unwind$class_name
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$class_name DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT class_name
_TEXT	SEGMENT
cls$ = 48
class_name PROC						; COMDAT

; 1340 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1341 :     PyObject *name = _PyObject_GetAttrId(cls, &PyId___name__);

  00006	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0000d	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00016	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId___name__
  0001b	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  0001f	48 8b d9	 mov	 rbx, rcx
  00022	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00027	4c 8b d8	 mov	 r11, rax

; 1342 :     if (name == NULL) {

  0002a	48 85 c0	 test	 rax, rax
  0002d	75 15		 jne	 SHORT $LN2@class_name

; 1343 :         PyErr_Clear();

  0002f	e8 00 00 00 00	 call	 PyErr_Clear

; 1344 :         Py_XDECREF(name);
; 1345 :         name = PyObject_Repr(cls);

  00034	48 8b cb	 mov	 rcx, rbx
  00037	e8 00 00 00 00	 call	 PyObject_Repr
  0003c	4c 8b d8	 mov	 r11, rax

; 1346 :     }
; 1347 :     if (name == NULL)

  0003f	48 85 c0	 test	 rax, rax

; 1348 :         return NULL;

  00042	74 18		 je	 SHORT $LN21@class_name
$LN2@class_name:

; 1349 :     if (!PyUnicode_Check(name)) {

  00044	49 8b 43 58	 mov	 rax, QWORD PTR [r11+88]
  00048	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00052	75 10		 jne	 SHORT $LN1@class_name

; 1350 :         Py_DECREF(name);

  00054	49 8b cb	 mov	 rcx, r11
  00057	e8 00 00 00 00	 call	 _Py_DecRef
$LN21@class_name:

; 1351 :         return NULL;

  0005c	33 c0		 xor	 eax, eax

; 1354 : }

  0005e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00062	5b		 pop	 rbx
  00063	c3		 ret	 0
$LN1@class_name:

; 1352 :     }
; 1353 :     return name;

  00064	49 8b c3	 mov	 rax, r11

; 1354 : }

  00067	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006b	5b		 pop	 rbx
  0006c	c3		 ret	 0
class_name ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@CDGJEON@duplicate?5base?5class?$AA@	; `string'
PUBLIC	??_C@_0BI@CCNFBLFC@duplicate?5base?5class?5?$CFU?$AA@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$check_duplicates DD imagerel check_duplicates
	DD	imagerel check_duplicates+86
	DD	imagerel $unwind$check_duplicates
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$check_duplicates DD imagerel check_duplicates+86
	DD	imagerel check_duplicates+226
	DD	imagerel $chain$0$check_duplicates
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$check_duplicates DD imagerel check_duplicates+226
	DD	imagerel check_duplicates+249
	DD	imagerel $chain$2$check_duplicates
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$check_duplicates DD imagerel check_duplicates+249
	DD	imagerel check_duplicates+270
	DD	imagerel $chain$4$check_duplicates
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$check_duplicates DD imagerel check_duplicates+270
	DD	imagerel check_duplicates+295
	DD	imagerel $chain$6$check_duplicates
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$check_duplicates DD 020021H
	DD	063400H
	DD	imagerel check_duplicates
	DD	imagerel check_duplicates+86
	DD	imagerel $unwind$check_duplicates
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$check_duplicates DD 020021H
	DD	063400H
	DD	imagerel check_duplicates
	DD	imagerel check_duplicates+86
	DD	imagerel $unwind$check_duplicates
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$check_duplicates DD 020021H
	DD	063400H
	DD	imagerel check_duplicates
	DD	imagerel check_duplicates+86
	DD	imagerel $unwind$check_duplicates
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$check_duplicates DD 020521H
	DD	063405H
	DD	imagerel check_duplicates
	DD	imagerel check_duplicates+86
	DD	imagerel $unwind$check_duplicates
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_duplicates DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0BF@CDGJEON@duplicate?5base?5class?$AA@
CONST	SEGMENT
??_C@_0BF@CDGJEON@duplicate?5base?5class?$AA@ DB 'duplicate base class', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CCNFBLFC@duplicate?5base?5class?5?$CFU?$AA@
CONST	SEGMENT
??_C@_0BI@CCNFBLFC@duplicate?5base?5class?5?$CFU?$AA@ DB 'duplicate base '
	DB	'class %U', 00H				; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
CONST	ENDS
;	COMDAT check_duplicates
_TEXT	SEGMENT
list$ = 64
check_duplicates PROC					; COMDAT

; 1358 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1359 :     Py_ssize_t i, j, n;
; 1360 :     /* Let's use a quadratic time algorithm,
; 1361 :        assuming that the bases lists is short.
; 1362 :     */
; 1363 :     n = PyList_GET_SIZE(list);

  00004	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]

; 1364 :     for (i = 0; i < n; i++) {

  00008	45 33 d2	 xor	 r10d, r10d
  0000b	48 85 d2	 test	 rdx, rdx
  0000e	7e 3c		 jle	 SHORT $LN28@check_dupl

; 1359 :     Py_ssize_t i, j, n;
; 1360 :     /* Let's use a quadratic time algorithm,
; 1361 :        assuming that the bases lists is short.
; 1362 :     */
; 1363 :     n = PyList_GET_SIZE(list);

  00010	4c 8b 49 70	 mov	 r9, QWORD PTR [rcx+112]
  00014	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL9@check_dupl:

; 1365 :         PyObject *o = PyList_GET_ITEM(list, i);

  00020	4d 8b 01	 mov	 r8, QWORD PTR [r9]
  00023	49 ff c2	 inc	 r10

; 1366 :         for (j = i + 1; j < n; j++) {

  00026	49 8b ca	 mov	 rcx, r10
  00029	4c 3b d2	 cmp	 r10, rdx
  0002c	7d 15		 jge	 SHORT $LN8@check_dupl

; 1365 :         PyObject *o = PyList_GET_ITEM(list, i);

  0002e	49 8d 41 08	 lea	 rax, QWORD PTR [r9+8]
$LL6@check_dupl:

; 1367 :             if (PyList_GET_ITEM(list, j) == o) {

  00032	4c 39 00	 cmp	 QWORD PTR [rax], r8
  00035	74 1c		 je	 SHORT $LN25@check_dupl

; 1366 :         for (j = i + 1; j < n; j++) {

  00037	48 ff c1	 inc	 rcx
  0003a	48 83 c0 08	 add	 rax, 8
  0003e	48 3b ca	 cmp	 rcx, rdx
  00041	7c ef		 jl	 SHORT $LL6@check_dupl
$LN8@check_dupl:

; 1364 :     for (i = 0; i < n; i++) {

  00043	49 83 c1 08	 add	 r9, 8
  00047	4c 3b d2	 cmp	 r10, rdx
  0004a	7c d4		 jl	 SHORT $LL9@check_dupl
$LN28@check_dupl:

; 1379 :             }
; 1380 :         }
; 1381 :     }
; 1382 :     return 0;

  0004c	33 c0		 xor	 eax, eax

; 1383 : }

  0004e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00052	c3		 ret	 0
$LN25@check_dupl:

; 1368 :                 o = class_name(o);

  00053	49 8b c8	 mov	 rcx, r8
  00056	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0005b	e8 00 00 00 00	 call	 class_name

; 1369 :                 if (o != NULL) {
; 1370 :                     PyErr_Format(PyExc_TypeError,
; 1371 :                                  "duplicate base class %U",
; 1372 :                                  o);

  00060	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00067	48 8b d8	 mov	 rbx, rax
  0006a	48 85 c0	 test	 rax, rax
  0006d	0f 84 9b 00 00
	00		 je	 $LN2@check_dupl
  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@CCNFBLFC@duplicate?5base?5class?5?$CFU?$AA@
  0007a	4c 8b c0	 mov	 r8, rax
  0007d	e8 00 00 00 00	 call	 PyErr_Format

; 1373 :                     Py_DECREF(o);

  00082	e8 00 00 00 00	 call	 _Py_PXCTX
  00087	85 c0		 test	 eax, eax
  00089	0f 85 8b 00 00
	00		 jne	 $LN1@check_dupl
  0008f	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00093	a8 20		 test	 al, 32			; 00000020H
  00095	75 62		 jne	 SHORT $LN16@check_dupl
  00097	84 c0		 test	 al, al
  00099	78 5e		 js	 SHORT $LN16@check_dupl
  0009b	a8 02		 test	 al, 2
  0009d	75 7b		 jne	 SHORT $LN1@check_dupl
  0009f	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000a3	75 75		 jne	 SHORT $LN1@check_dupl
  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000b3	4c 8b cb	 mov	 r9, rbx
  000b6	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000bc	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000c4	e8 00 00 00 00	 call	 _PyParallel_Guard
  000c9	48 8b cb	 mov	 rcx, rbx
  000cc	85 c0		 test	 eax, eax
  000ce	74 12		 je	 SHORT $LN21@check_dupl
  000d0	e8 00 00 00 00	 call	 _Px_Dealloc
  000d5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1377 :                 }
; 1378 :                 return -1;

  000da	83 c8 ff	 or	 eax, -1

; 1383 : }

  000dd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e1	c3		 ret	 0

; 1373 :                     Py_DECREF(o);

$LN21@check_dupl:
  000e2	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000e6	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000ec	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1377 :                 }
; 1378 :                 return -1;

  000f1	83 c8 ff	 or	 eax, -1

; 1383 : }

  000f4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f8	c3		 ret	 0

; 1373 :                     Py_DECREF(o);

$LN16@check_dupl:
  000f9	48 8b cb	 mov	 rcx, rbx
  000fc	e8 00 00 00 00	 call	 Px_DecRef
  00101	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1377 :                 }
; 1378 :                 return -1;

  00106	83 c8 ff	 or	 eax, -1

; 1383 : }

  00109	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0010d	c3		 ret	 0
$LN2@check_dupl:

; 1374 :                 } else {
; 1375 :                     PyErr_SetString(PyExc_TypeError,
; 1376 :                                  "duplicate base class");

  0010e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@CDGJEON@duplicate?5base?5class?$AA@
  00115	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@check_dupl:

; 1377 :                 }
; 1378 :                 return -1;

  0011a	83 c8 ff	 or	 eax, -1
  0011d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1383 : }

  00122	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00126	c3		 ret	 0
check_duplicates ENDP
_TEXT	ENDS
PUBLIC	??_C@_03EEBNCBOD@?5?$CFs?$AA@			; `string'
PUBLIC	??_C@_01OGPIMHDM@?$DP?$AA@			; `string'
PUBLIC	??_C@_0ED@INELAAJC@Cannot?5create?5a?5consistent?5metho@ ; `string'
EXTRN	PyDict_Next:PROC
EXTRN	PyOS_snprintf:PROC
EXTRN	PyDict_Size:PROC
EXTRN	PyDict_SetItem:PROC
EXTRN	PyDict_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_mro_error DD imagerel set_mro_error
	DD	imagerel set_mro_error+37
	DD	imagerel $unwind$set_mro_error
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$set_mro_error DD imagerel set_mro_error+37
	DD	imagerel set_mro_error+624
	DD	imagerel $chain$0$set_mro_error
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$set_mro_error DD imagerel set_mro_error+624
	DD	imagerel set_mro_error+635
	DD	imagerel $chain$1$set_mro_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$set_mro_error DD 021H
	DD	imagerel set_mro_error
	DD	imagerel set_mro_error+37
	DD	imagerel $unwind$set_mro_error
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$set_mro_error DD 020821H
	DD	08a3408H
	DD	imagerel set_mro_error
	DD	imagerel set_mro_error+37
	DD	imagerel $unwind$set_mro_error
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_mro_error DD 050b01H
	DD	086010bH
	DD	060037004H
	DD	05002H
xdata	ENDS
;	COMDAT ??_C@_03EEBNCBOD@?5?$CFs?$AA@
CONST	SEGMENT
??_C@_03EEBNCBOD@?5?$CFs?$AA@ DB ' %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01OGPIMHDM@?$DP?$AA@
CONST	SEGMENT
??_C@_01OGPIMHDM@?$DP?$AA@ DB '?', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@INELAAJC@Cannot?5create?5a?5consistent?5metho@
CONST	SEGMENT
??_C@_0ED@INELAAJC@Cannot?5create?5a?5consistent?5metho@ DB 'Cannot creat'
	DB	'e a consistent method resolution', 0aH, 'order (MRO) for base'
	DB	's', 00H					; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
CONST	ENDS
;	COMDAT set_mro_error
_TEXT	SEGMENT
v$ = 48
buf$ = 64
to_merge$ = 1104
remain$ = 1112
i$ = 1120
k$ = 1128
set_mro_error PROC					; COMDAT

; 1396 : {

  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 81 ec 30 04
	00 00		 sub	 rsp, 1072		; 00000430H
  0000b	48 8b ea	 mov	 rbp, rdx
  0000e	48 8b f9	 mov	 rdi, rcx

; 1397 :     Py_ssize_t i, n, off, to_merge_size;
; 1398 :     char buf[1000];
; 1399 :     PyObject *k, *v;
; 1400 :     PyObject *set = PyDict_New();

  00011	e8 00 00 00 00	 call	 PyDict_New
  00016	48 8b f0	 mov	 rsi, rax

; 1401 :     if (!set) return;

  00019	48 85 c0	 test	 rax, rax
  0001c	0f 84 4e 02 00
	00		 je	 $LN40@set_mro_er

; 1402 : 
; 1403 :     to_merge_size = PyList_GET_SIZE(to_merge);
; 1404 :     for (i = 0; i < to_merge_size; i++) {

  00022	45 33 c0	 xor	 r8d, r8d
  00025	48 89 9c 24 50
	04 00 00	 mov	 QWORD PTR [rsp+1104], rbx
  0002d	48 8b 5f 60	 mov	 rbx, QWORD PTR [rdi+96]
  00031	4c 89 84 24 60
	04 00 00	 mov	 QWORD PTR i$[rsp], r8
  00039	48 85 db	 test	 rbx, rbx
  0003c	7e 4c		 jle	 SHORT $LN45@set_mro_er
  0003e	66 90		 npad	 2
$LL15@set_mro_er:

; 1405 :         PyObject *L = PyList_GET_ITEM(to_merge, i);

  00040	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]

; 1406 :         if (remain[i] < PyList_GET_SIZE(L)) {

  00044	4a 63 54 85 00	 movsxd	 rdx, DWORD PTR [rbp+r8*4]
  00049	4a 8b 04 c0	 mov	 rax, QWORD PTR [rax+r8*8]
  0004d	48 3b 50 60	 cmp	 rdx, QWORD PTR [rax+96]
  00051	7d 27		 jge	 SHORT $LN14@set_mro_er

; 1407 :             PyObject *c = PyList_GET_ITEM(L, remain[i]);

  00053	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]

; 1408 :             if (PyDict_SetItem(set, c, Py_None) < 0) {

  00057	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_NoneStruct
  0005e	48 8b ce	 mov	 rcx, rsi
  00061	48 8b 14 d0	 mov	 rdx, QWORD PTR [rax+rdx*8]
  00065	e8 00 00 00 00	 call	 PyDict_SetItem
  0006a	85 c0		 test	 eax, eax
  0006c	0f 88 1c 01 00
	00		 js	 $LN43@set_mro_er
  00072	4c 8b 84 24 60
	04 00 00	 mov	 r8, QWORD PTR i$[rsp]
$LN14@set_mro_er:

; 1402 : 
; 1403 :     to_merge_size = PyList_GET_SIZE(to_merge);
; 1404 :     for (i = 0; i < to_merge_size; i++) {

  0007a	49 ff c0	 inc	 r8
  0007d	4c 89 84 24 60
	04 00 00	 mov	 QWORD PTR i$[rsp], r8
  00085	4c 3b c3	 cmp	 r8, rbx
  00088	7c b6		 jl	 SHORT $LL15@set_mro_er
$LN45@set_mro_er:

; 1411 :             }
; 1412 :         }
; 1413 :     }
; 1414 :     n = PyDict_Size(set);

  0008a	48 8b ce	 mov	 rcx, rsi
  0008d	e8 00 00 00 00	 call	 PyDict_Size

; 1415 : 
; 1416 :     off = PyOS_snprintf(buf, sizeof(buf), "Cannot create a \
; 1417 : consistent method resolution\norder (MRO) for bases");

  00092	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0ED@INELAAJC@Cannot?5create?5a?5consistent?5metho@
  00099	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buf$[rsp]
  0009e	ba e8 03 00 00	 mov	 edx, 1000		; 000003e8H
  000a3	48 8b e8	 mov	 rbp, rax
  000a6	e8 00 00 00 00	 call	 PyOS_snprintf

; 1418 :     i = 0;
; 1419 :     while (PyDict_Next(set, &i, &k, &v) && (size_t)off < sizeof(buf)) {

  000ab	4c 8d 4c 24 30	 lea	 r9, QWORD PTR v$[rsp]
  000b0	4c 8d 84 24 68
	04 00 00	 lea	 r8, QWORD PTR k$[rsp]
  000b8	48 8d 94 24 60
	04 00 00	 lea	 rdx, QWORD PTR i$[rsp]
  000c0	48 8b ce	 mov	 rcx, rsi
  000c3	48 c7 84 24 60
	04 00 00 00 00
	00 00		 mov	 QWORD PTR i$[rsp], 0
  000cf	48 63 f8	 movsxd	 rdi, eax
  000d2	e8 00 00 00 00	 call	 PyDict_Next
  000d7	85 c0		 test	 eax, eax
  000d9	0f 84 13 01 00
	00		 je	 $LN46@set_mro_er
  000df	90		 npad	 1
$LL10@set_mro_er:
  000e0	48 81 ff e8 03
	00 00		 cmp	 rdi, 1000		; 000003e8H
  000e7	0f 83 05 01 00
	00		 jae	 $LN46@set_mro_er

; 1420 :         PyObject *name = class_name(k);

  000ed	48 8b 8c 24 68
	04 00 00	 mov	 rcx, QWORD PTR k$[rsp]
  000f5	e8 00 00 00 00	 call	 class_name
  000fa	48 8b d8	 mov	 rbx, rax

; 1421 :         char *name_str;
; 1422 :         if (name != NULL) {

  000fd	48 85 c0	 test	 rax, rax
  00100	74 0d		 je	 SHORT $LN8@set_mro_er

; 1423 :             name_str = _PyUnicode_AsString(name);

  00102	48 8b c8	 mov	 rcx, rax
  00105	e8 00 00 00 00	 call	 PyUnicode_AsUTF8

; 1424 :             if (name_str == NULL)

  0010a	48 85 c0	 test	 rax, rax
  0010d	75 07		 jne	 SHORT $LN6@set_mro_er
$LN8@set_mro_er:

; 1425 :                 name_str = "?";
; 1426 :         } else
; 1427 :             name_str = "?";

  0010f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_01OGPIMHDM@?$DP?$AA@
$LN6@set_mro_er:

; 1428 :         off += PyOS_snprintf(buf + off, sizeof(buf) - off, " %s", name_str);

  00116	ba e8 03 00 00	 mov	 edx, 1000		; 000003e8H
  0011b	48 8d 4c 3c 40	 lea	 rcx, QWORD PTR buf$[rsp+rdi]
  00120	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03EEBNCBOD@?5?$CFs?$AA@
  00127	48 2b d7	 sub	 rdx, rdi
  0012a	4c 8b c8	 mov	 r9, rax
  0012d	e8 00 00 00 00	 call	 PyOS_snprintf
  00132	48 63 c8	 movsxd	 rcx, eax
  00135	48 03 f9	 add	 rdi, rcx

; 1429 :         Py_XDECREF(name);

  00138	48 85 db	 test	 rbx, rbx
  0013b	74 72		 je	 SHORT $LN4@set_mro_er
  0013d	e8 00 00 00 00	 call	 _Py_PXCTX
  00142	85 c0		 test	 eax, eax
  00144	75 69		 jne	 SHORT $LN4@set_mro_er
  00146	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0014a	a8 20		 test	 al, 32			; 00000020H
  0014c	75 59		 jne	 SHORT $LN23@set_mro_er
  0014e	84 c0		 test	 al, al
  00150	78 55		 js	 SHORT $LN23@set_mro_er
  00152	a8 02		 test	 al, 2
  00154	75 59		 jne	 SHORT $LN4@set_mro_er
  00156	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0015a	75 53		 jne	 SHORT $LN4@set_mro_er
  0015c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00163	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0016a	4c 8b cb	 mov	 r9, rbx
  0016d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00173	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0017b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00180	48 8b cb	 mov	 rcx, rbx
  00183	85 c0		 test	 eax, eax
  00185	74 14		 je	 SHORT $LN28@set_mro_er
  00187	e8 00 00 00 00	 call	 _Px_Dealloc
  0018c	eb 21		 jmp	 SHORT $LN4@set_mro_er
$LN43@set_mro_er:

; 1409 :                 Py_DECREF(set);

  0018e	48 8b ce	 mov	 rcx, rsi
  00191	e8 00 00 00 00	 call	 _Py_DecRef

; 1410 :                 return;

  00196	e9 cd 00 00 00	 jmp	 $LN47@set_mro_er

; 1429 :         Py_XDECREF(name);

$LN28@set_mro_er:
  0019b	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0019f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001a5	eb 08		 jmp	 SHORT $LN4@set_mro_er
$LN23@set_mro_er:
  001a7	48 8b cb	 mov	 rcx, rbx
  001aa	e8 00 00 00 00	 call	 Px_DecRef
$LN4@set_mro_er:

; 1430 :         if (--n && (size_t)(off+1) < sizeof(buf)) {

  001af	48 ff cd	 dec	 rbp
  001b2	74 19		 je	 SHORT $LN1@set_mro_er
  001b4	48 8d 47 01	 lea	 rax, QWORD PTR [rdi+1]
  001b8	48 3d e8 03 00
	00		 cmp	 rax, 1000		; 000003e8H
  001be	73 0d		 jae	 SHORT $LN1@set_mro_er

; 1431 :             buf[off++] = ',';

  001c0	c6 44 3c 40 2c	 mov	 BYTE PTR buf$[rsp+rdi], 44 ; 0000002cH
  001c5	48 8b f8	 mov	 rdi, rax

; 1432 :             buf[off] = '\0';

  001c8	c6 44 04 40 00	 mov	 BYTE PTR buf$[rsp+rax], 0
$LN1@set_mro_er:

; 1418 :     i = 0;
; 1419 :     while (PyDict_Next(set, &i, &k, &v) && (size_t)off < sizeof(buf)) {

  001cd	4c 8d 4c 24 30	 lea	 r9, QWORD PTR v$[rsp]
  001d2	4c 8d 84 24 68
	04 00 00	 lea	 r8, QWORD PTR k$[rsp]
  001da	48 8d 94 24 60
	04 00 00	 lea	 rdx, QWORD PTR i$[rsp]
  001e2	48 8b ce	 mov	 rcx, rsi
  001e5	e8 00 00 00 00	 call	 PyDict_Next
  001ea	85 c0		 test	 eax, eax
  001ec	0f 85 ee fe ff
	ff		 jne	 $LL10@set_mro_er
$LN46@set_mro_er:

; 1433 :         }
; 1434 :     }
; 1435 :     PyErr_SetString(PyExc_TypeError, buf);

  001f2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  001f9	48 8d 54 24 40	 lea	 rdx, QWORD PTR buf$[rsp]
  001fe	e8 00 00 00 00	 call	 PyErr_SetString

; 1436 :     Py_DECREF(set);

  00203	e8 00 00 00 00	 call	 _Py_PXCTX
  00208	85 c0		 test	 eax, eax
  0020a	75 5c		 jne	 SHORT $LN47@set_mro_er
  0020c	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  00210	a8 20		 test	 al, 32			; 00000020H
  00212	75 4c		 jne	 SHORT $LN34@set_mro_er
  00214	84 c0		 test	 al, al
  00216	78 48		 js	 SHORT $LN34@set_mro_er
  00218	a8 02		 test	 al, 2
  0021a	75 4c		 jne	 SHORT $LN47@set_mro_er
  0021c	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  00220	75 46		 jne	 SHORT $LN47@set_mro_er
  00222	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00229	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00230	4c 8b ce	 mov	 r9, rsi
  00233	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00239	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00241	e8 00 00 00 00	 call	 _PyParallel_Guard
  00246	48 8b ce	 mov	 rcx, rsi
  00249	85 c0		 test	 eax, eax
  0024b	74 07		 je	 SHORT $LN39@set_mro_er
  0024d	e8 00 00 00 00	 call	 _Px_Dealloc
  00252	eb 14		 jmp	 SHORT $LN47@set_mro_er
$LN39@set_mro_er:
  00254	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  00258	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0025e	eb 08		 jmp	 SHORT $LN47@set_mro_er
$LN34@set_mro_er:
  00260	48 8b ce	 mov	 rcx, rsi
  00263	e8 00 00 00 00	 call	 Px_DecRef
$LN47@set_mro_er:
  00268	48 8b 9c 24 50
	04 00 00	 mov	 rbx, QWORD PTR [rsp+1104]
$LN40@set_mro_er:

; 1437 : }

  00270	48 81 c4 30 04
	00 00		 add	 rsp, 1072		; 00000430H
  00277	5f		 pop	 rdi
  00278	5e		 pop	 rsi
  00279	5d		 pop	 rbp
  0027a	c3		 ret	 0
set_mro_error ENDP
_TEXT	ENDS
EXTRN	__imp_free:PROC
EXTRN	_PxMem_Free:PROC
EXTRN	PyMem_Free:PROC
EXTRN	PyList_Append:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_PxMem_Malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$pmerge DD imagerel pmerge
	DD	imagerel pmerge+105
	DD	imagerel $unwind$pmerge
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$pmerge DD imagerel pmerge+105
	DD	imagerel pmerge+344
	DD	imagerel $chain$2$pmerge
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$pmerge DD imagerel pmerge+344
	DD	imagerel pmerge+418
	DD	imagerel $chain$4$pmerge
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$pmerge DD imagerel pmerge+418
	DD	imagerel pmerge+436
	DD	imagerel $chain$5$pmerge
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$pmerge DD 021H
	DD	imagerel pmerge
	DD	imagerel pmerge+105
	DD	imagerel $unwind$pmerge
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$pmerge DD 060021H
	DD	0ac400H
	DD	097400H
	DD	085400H
	DD	imagerel pmerge
	DD	imagerel pmerge+105
	DD	imagerel $unwind$pmerge
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$pmerge DD 060f21H
	DD	0ac40fH
	DD	09740aH
	DD	085405H
	DD	imagerel pmerge
	DD	imagerel pmerge+105
	DD	imagerel $unwind$pmerge
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pmerge DD 060e01H
	DD	0b340eH
	DD	0e00a320eH
	DD	06006d008H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT pmerge
_TEXT	SEGMENT
acc$ = 64
to_merge$ = 72
pmerge	PROC						; COMDAT

; 1440 : pmerge(PyObject *acc, PyObject* to_merge) {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	56		 push	 rsi
  00006	41 55		 push	 r13
  00008	41 56		 push	 r14
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1441 :     Py_ssize_t i, j, to_merge_size, empty_cnt;
; 1442 :     int *remain;
; 1443 :     int ok;
; 1444 : 
; 1445 :     to_merge_size = PyList_GET_SIZE(to_merge);

  0000e	48 8b 5a 60	 mov	 rbx, QWORD PTR [rdx+96]
  00012	4c 8b ea	 mov	 r13, rdx
  00015	4c 8b f1	 mov	 r14, rcx

; 1446 : 
; 1447 :     /* remain stores an index into each sublist of to_merge.
; 1448 :        remain[i] is the index of the next base in to_merge[i]
; 1449 :        that is not included in acc.
; 1450 :     */
; 1451 :     remain = (int *)PyMem_MALLOC(SIZEOF_INT*to_merge_size);

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 0f		 je	 SHORT $LN25@pmerge
  00021	48 8d 0c 9d 00
	00 00 00	 lea	 rcx, QWORD PTR [rbx*4]
  00029	e8 00 00 00 00	 call	 _PxMem_Malloc
  0002e	eb 2d		 jmp	 SHORT $LN61@pmerge
$LN25@pmerge:
  00030	48 8d 04 9d 00
	00 00 00	 lea	 rax, QWORD PTR [rbx*4]
  00038	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00042	48 3b c1	 cmp	 rax, rcx
  00045	0f 87 57 01 00
	00		 ja	 $LN41@pmerge
  0004b	48 85 c0	 test	 rax, rax
  0004e	b9 01 00 00 00	 mov	 ecx, 1
  00053	48 0f 45 c8	 cmovne	 rcx, rax
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN61@pmerge:
  0005d	48 8b f0	 mov	 rsi, rax

; 1452 :     if (remain == NULL)

  00060	48 85 c0	 test	 rax, rax
  00063	0f 84 39 01 00
	00		 je	 $LN41@pmerge

; 1454 :     for (i = 0; i < to_merge_size; i++)

  00069	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  0006e	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  00073	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  00078	48 85 db	 test	 rbx, rbx
  0007b	7e 13		 jle	 SHORT $again$21420
  0007d	4c 8b c3	 mov	 r8, rbx
  00080	33 d2		 xor	 edx, edx
  00082	48 8b c8	 mov	 rcx, rax
  00085	49 c1 e0 02	 shl	 r8, 2
  00089	e8 00 00 00 00	 call	 memset
  0008e	66 90		 npad	 2
$again$21420:

; 1455 :         remain[i] = 0;
; 1456 : 
; 1457 :   again:
; 1458 :     empty_cnt = 0;

  00090	33 ed		 xor	 ebp, ebp

; 1459 :     for (i = 0; i < to_merge_size; i++) {

  00092	33 ff		 xor	 edi, edi
$LL14@pmerge:
  00094	48 3b fb	 cmp	 rdi, rbx
  00097	0f 8d bb 00 00
	00		 jge	 $LN12@pmerge

; 1460 :         PyObject *candidate;
; 1461 : 
; 1462 :         PyObject *cur_list = PyList_GET_ITEM(to_merge, i);

  0009d	4d 8b 5d 70	 mov	 r11, QWORD PTR [r13+112]

; 1463 : 
; 1464 :         if (remain[i] >= PyList_GET_SIZE(cur_list)) {

  000a1	48 63 0c be	 movsxd	 rcx, DWORD PTR [rsi+rdi*4]
  000a5	49 8b 04 fb	 mov	 rax, QWORD PTR [r11+rdi*8]
  000a9	48 3b 48 60	 cmp	 rcx, QWORD PTR [rax+96]
  000ad	7c 08		 jl	 SHORT $LN11@pmerge

; 1465 :             empty_cnt++;

  000af	48 ff c5	 inc	 rbp
$skip$21436:

; 1459 :     for (i = 0; i < to_merge_size; i++) {

  000b2	48 ff c7	 inc	 rdi

; 1454 :     for (i = 0; i < to_merge_size; i++)

  000b5	eb dd		 jmp	 SHORT $LL14@pmerge
$LN11@pmerge:

; 1466 :             continue;
; 1467 :         }
; 1468 : 
; 1469 :         /* Choose next candidate for MRO.
; 1470 : 
; 1471 :            The input sequences alone can determine the choice.
; 1472 :            If not, choose the class which appears in the MRO
; 1473 :            of the earliest direct superclass of the new class.
; 1474 :         */
; 1475 : 
; 1476 :         candidate = PyList_GET_ITEM(cur_list, remain[i]);

  000b7	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]

; 1477 :         for (j = 0; j < to_merge_size; j++) {

  000bb	45 33 d2	 xor	 r10d, r10d
  000be	4c 8b 24 c8	 mov	 r12, QWORD PTR [rax+rcx*8]
$LL10@pmerge:
  000c2	4c 3b d3	 cmp	 r10, rbx
  000c5	7d 1c		 jge	 SHORT $LN8@pmerge

; 1478 :             PyObject *j_lst = PyList_GET_ITEM(to_merge, j);
; 1479 :             if (tail_contains(j_lst, remain[j], candidate)) {

  000c7	42 8b 14 96	 mov	 edx, DWORD PTR [rsi+r10*4]
  000cb	49 8b 0b	 mov	 rcx, QWORD PTR [r11]
  000ce	4d 8b c4	 mov	 r8, r12
  000d1	e8 00 00 00 00	 call	 tail_contains
  000d6	85 c0		 test	 eax, eax
  000d8	75 d8		 jne	 SHORT $skip$21436

; 1477 :         for (j = 0; j < to_merge_size; j++) {

  000da	49 ff c2	 inc	 r10
  000dd	49 83 c3 08	 add	 r11, 8
  000e1	eb df		 jmp	 SHORT $LL10@pmerge
$LN8@pmerge:

; 1480 :                 goto skip; /* continue outer loop */
; 1481 :             }
; 1482 :         }
; 1483 :         ok = PyList_Append(acc, candidate);

  000e3	49 8b d4	 mov	 rdx, r12
  000e6	49 8b ce	 mov	 rcx, r14
  000e9	e8 00 00 00 00	 call	 PyList_Append

; 1484 :         if (ok < 0) {

  000ee	85 c0		 test	 eax, eax
  000f0	78 3d		 js	 SHORT $LN38@pmerge

; 1487 :         }
; 1488 :         for (j = 0; j < to_merge_size; j++) {

  000f2	33 c9		 xor	 ecx, ecx
  000f4	48 85 db	 test	 rbx, rbx
  000f7	7e 97		 jle	 SHORT $again$21420
  000f9	0f 1f 80 00 00
	00 00		 npad	 7
$LL5@pmerge:

; 1489 :             PyObject *j_lst = PyList_GET_ITEM(to_merge, j);

  00100	49 8b 45 70	 mov	 rax, QWORD PTR [r13+112]
  00104	48 63 14 8e	 movsxd	 rdx, DWORD PTR [rsi+rcx*4]
  00108	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]

; 1490 :             if (remain[j] < PyList_GET_SIZE(j_lst) &&
; 1491 :                 PyList_GET_ITEM(j_lst, remain[j]) == candidate) {

  0010c	48 3b 50 60	 cmp	 rdx, QWORD PTR [rax+96]
  00110	7d 10		 jge	 SHORT $LN4@pmerge
  00112	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00116	4c 39 24 d0	 cmp	 QWORD PTR [rax+rdx*8], r12
  0011a	75 06		 jne	 SHORT $LN4@pmerge

; 1492 :                 remain[j]++;

  0011c	8d 42 01	 lea	 eax, DWORD PTR [rdx+1]
  0011f	89 04 8e	 mov	 DWORD PTR [rsi+rcx*4], eax
$LN4@pmerge:

; 1487 :         }
; 1488 :         for (j = 0; j < to_merge_size; j++) {

  00122	48 ff c1	 inc	 rcx
  00125	48 3b cb	 cmp	 rcx, rbx
  00128	7c d6		 jl	 SHORT $LL5@pmerge

; 1493 :             }
; 1494 :         }
; 1495 :         goto again;

  0012a	e9 61 ff ff ff	 jmp	 $again$21420
$LN38@pmerge:

; 1485 :             PyMem_Free(remain);

  0012f	48 8b ce	 mov	 rcx, rsi
  00132	e8 00 00 00 00	 call	 PyMem_Free
$LN30@pmerge:

; 1486 :             return -1;

  00137	83 c8 ff	 or	 eax, -1
$LN60@pmerge:
  0013a	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0013f	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00144	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]

; 1506 : }

  00149	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0014e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00152	41 5e		 pop	 r14
  00154	41 5d		 pop	 r13
  00156	5e		 pop	 rsi
  00157	c3		 ret	 0
$LN12@pmerge:

; 1496 :       skip: ;
; 1497 :     }
; 1498 : 
; 1499 :     if (empty_cnt == to_merge_size) {

  00158	48 3b eb	 cmp	 rbp, rbx
  0015b	75 1f		 jne	 SHORT $LN1@pmerge

; 1500 :         PyMem_FREE(remain);

  0015d	e8 00 00 00 00	 call	 _Py_PXCTX
  00162	48 8b ce	 mov	 rcx, rsi
  00165	85 c0		 test	 eax, eax
  00167	74 09		 je	 SHORT $LN27@pmerge
  00169	e8 00 00 00 00	 call	 _PxMem_Free

; 1501 :         return 0;

  0016e	33 c0		 xor	 eax, eax
  00170	eb c8		 jmp	 SHORT $LN60@pmerge
$LN27@pmerge:

; 1500 :         PyMem_FREE(remain);

  00172	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1501 :         return 0;

  00178	33 c0		 xor	 eax, eax
  0017a	eb be		 jmp	 SHORT $LN60@pmerge
$LN1@pmerge:

; 1502 :     }
; 1503 :     set_mro_error(to_merge, remain);

  0017c	48 8b d6	 mov	 rdx, rsi
  0017f	49 8b cd	 mov	 rcx, r13
  00182	e8 00 00 00 00	 call	 set_mro_error

; 1504 :     PyMem_FREE(remain);

  00187	e8 00 00 00 00	 call	 _Py_PXCTX
  0018c	48 8b ce	 mov	 rcx, rsi
  0018f	85 c0		 test	 eax, eax
  00191	74 07		 je	 SHORT $LN29@pmerge
  00193	e8 00 00 00 00	 call	 _PxMem_Free
  00198	eb 9d		 jmp	 SHORT $LN30@pmerge
$LN29@pmerge:
  0019a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1505 :     return -1;

  001a0	eb 95		 jmp	 SHORT $LN30@pmerge
$LN41@pmerge:

; 1453 :         return -1;

  001a2	83 c8 ff	 or	 eax, -1

; 1506 : }

  001a5	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  001aa	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001ae	41 5e		 pop	 r14
  001b0	41 5d		 pop	 r13
  001b2	5e		 pop	 rsi
  001b3	c3		 ret	 0
pmerge	ENDP
_TEXT	ENDS
PUBLIC	??_C@_03LGGEEBKE@?$FLO?$FN?$AA@			; `string'
PUBLIC	PyType_Ready
EXTRN	Py_BuildValue:PROC
EXTRN	PySequence_List:PROC
EXTRN	PyList_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$mro_implementation DD imagerel mro_implementation
	DD	imagerel mro_implementation+84
	DD	imagerel $unwind$mro_implementation
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$mro_implementation DD imagerel mro_implementation+84
	DD	imagerel mro_implementation+271
	DD	imagerel $chain$3$mro_implementation
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$mro_implementation DD imagerel mro_implementation+271
	DD	imagerel mro_implementation+292
	DD	imagerel $chain$4$mro_implementation
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$mro_implementation DD 021H
	DD	imagerel mro_implementation
	DD	imagerel mro_implementation+84
	DD	imagerel $unwind$mro_implementation
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$mro_implementation DD 020521H
	DD	063405H
	DD	imagerel mro_implementation
	DD	imagerel mro_implementation+84
	DD	imagerel $unwind$mro_implementation
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mro_implementation DD 083301H
	DD	09c433H
	DD	08742eH
	DD	076429H
	DD	050023206H
xdata	ENDS
;	COMDAT ??_C@_03LGGEEBKE@?$FLO?$FN?$AA@
CONST	SEGMENT
??_C@_03LGGEEBKE@?$FLO?$FN?$AA@ DB '[O]', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT mro_implementation
_TEXT	SEGMENT
type$ = 48
mro_implementation PROC					; COMDAT

; 1510 : {

  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1511 :     Py_ssize_t i, n;
; 1512 :     int ok;
; 1513 :     PyObject *bases, *result;
; 1514 :     PyObject *to_merge, *bases_aslist;
; 1515 : 
; 1516 :     if (type->tp_dict == NULL) {

  00006	48 83 b9 60 01
	00 00 00	 cmp	 QWORD PTR [rcx+352], 0
  0000e	48 8b e9	 mov	 rbp, rcx
  00011	75 11		 jne	 SHORT $LN10@mro_implem

; 1517 :         if (PyType_Ready(type) < 0)

  00013	e8 00 00 00 00	 call	 PyType_Ready
  00018	85 c0		 test	 eax, eax
  0001a	79 08		 jns	 SHORT $LN10@mro_implem

; 1518 :             return NULL;

  0001c	33 c0		 xor	 eax, eax

; 1576 : }

  0001e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00022	5d		 pop	 rbp
  00023	c3		 ret	 0
$LN10@mro_implem:
  00024	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00029	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  0002e	4c 89 64 24 48	 mov	 QWORD PTR [rsp+72], r12

; 1519 :     }
; 1520 : 
; 1521 :     /* Find a superclass linearization that honors the constraints
; 1522 :        of the explicit lists of bases and the constraints implied by
; 1523 :        each base class.
; 1524 : 
; 1525 :        to_merge is a list of lists, where each list is a superclass
; 1526 :        linearization implied by a base class.  The last element of
; 1527 :        to_merge is the declared list of bases.
; 1528 :     */
; 1529 : 
; 1530 :     bases = type->tp_bases;

  00033	4c 8b a5 a8 01
	00 00		 mov	 r12, QWORD PTR [rbp+424]

; 1531 :     n = PyTuple_GET_SIZE(bases);

  0003a	49 8b 74 24 60	 mov	 rsi, QWORD PTR [r12+96]

; 1532 : 
; 1533 :     to_merge = PyList_New(n+1);

  0003f	48 8d 4e 01	 lea	 rcx, QWORD PTR [rsi+1]
  00043	e8 00 00 00 00	 call	 PyList_New
  00048	48 8b f8	 mov	 rdi, rax

; 1534 :     if (to_merge == NULL)

  0004b	48 85 c0	 test	 rax, rax
  0004e	0f 84 bb 00 00
	00		 je	 $LN19@mro_implem
$LN9@mro_implem:
  00054	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 1535 :         return NULL;
; 1536 : 
; 1537 :     for (i = 0; i < n; i++) {

  00059	33 db		 xor	 ebx, ebx
  0005b	48 85 f6	 test	 rsi, rsi
  0005e	7e 27		 jle	 SHORT $LN6@mro_implem
$LL8@mro_implem:

; 1538 :         PyObject *base = PyTuple_GET_ITEM(bases, i);

  00060	49 8b 4c dc 70	 mov	 rcx, QWORD PTR [r12+rbx*8+112]

; 1539 :         PyObject *parentMRO;
; 1540 :         parentMRO = PySequence_List(((PyTypeObject*)base)->tp_mro);

  00065	48 8b 89 b0 01
	00 00		 mov	 rcx, QWORD PTR [rcx+432]
  0006c	e8 00 00 00 00	 call	 PySequence_List

; 1541 :         if (parentMRO == NULL) {

  00071	48 85 c0	 test	 rax, rax
  00074	74 60		 je	 SHORT $LN21@mro_implem

; 1542 :             Py_DECREF(to_merge);
; 1543 :             return NULL;
; 1544 :         }
; 1545 : 
; 1546 :         PyList_SET_ITEM(to_merge, i, parentMRO);

  00076	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  0007a	48 ff c3	 inc	 rbx
  0007d	48 89 44 d9 f8	 mov	 QWORD PTR [rcx+rbx*8-8], rax
  00082	48 3b de	 cmp	 rbx, rsi
  00085	7c d9		 jl	 SHORT $LL8@mro_implem
$LN6@mro_implem:

; 1547 :     }
; 1548 : 
; 1549 :     bases_aslist = PySequence_List(bases);

  00087	49 8b cc	 mov	 rcx, r12
  0008a	e8 00 00 00 00	 call	 PySequence_List
  0008f	48 8b d8	 mov	 rbx, rax

; 1550 :     if (bases_aslist == NULL) {

  00092	48 85 c0	 test	 rax, rax

; 1551 :         Py_DECREF(to_merge);
; 1552 :         return NULL;

  00095	74 3f		 je	 SHORT $LN21@mro_implem

; 1553 :     }
; 1554 :     /* This is just a basic sanity check. */
; 1555 :     if (check_duplicates(bases_aslist) < 0) {

  00097	48 8b c8	 mov	 rcx, rax
  0009a	e8 00 00 00 00	 call	 check_duplicates
  0009f	85 c0		 test	 eax, eax
  000a1	79 14		 jns	 SHORT $LN3@mro_implem

; 1556 :         Py_DECREF(to_merge);

  000a3	48 8b cf	 mov	 rcx, rdi
  000a6	e8 00 00 00 00	 call	 _Py_DecRef

; 1557 :         Py_DECREF(bases_aslist);

  000ab	48 8b cb	 mov	 rcx, rbx
  000ae	e8 00 00 00 00	 call	 _Py_DecRef

; 1558 :         return NULL;

  000b3	33 c0		 xor	 eax, eax
  000b5	eb 53		 jmp	 SHORT $LN20@mro_implem
$LN3@mro_implem:

; 1559 :     }
; 1560 :     PyList_SET_ITEM(to_merge, n, bases_aslist);

  000b7	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]

; 1561 : 
; 1562 :     result = Py_BuildValue("[O]", (PyObject *)type);

  000bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03LGGEEBKE@?$FLO?$FN?$AA@
  000c2	48 8b d5	 mov	 rdx, rbp
  000c5	48 89 1c f0	 mov	 QWORD PTR [rax+rsi*8], rbx
  000c9	e8 00 00 00 00	 call	 Py_BuildValue
  000ce	48 8b f0	 mov	 rsi, rax

; 1563 :     if (result == NULL) {

  000d1	48 85 c0	 test	 rax, rax
  000d4	75 0c		 jne	 SHORT $LN2@mro_implem
$LN21@mro_implem:

; 1564 :         Py_DECREF(to_merge);

  000d6	48 8b cf	 mov	 rcx, rdi
  000d9	e8 00 00 00 00	 call	 _Py_DecRef

; 1565 :         return NULL;

  000de	33 c0		 xor	 eax, eax
  000e0	eb 28		 jmp	 SHORT $LN20@mro_implem
$LN2@mro_implem:

; 1566 :     }
; 1567 : 
; 1568 :     ok = pmerge(result, to_merge);

  000e2	48 8b d7	 mov	 rdx, rdi
  000e5	48 8b c8	 mov	 rcx, rax
  000e8	e8 00 00 00 00	 call	 pmerge

; 1569 :     Py_DECREF(to_merge);

  000ed	48 8b cf	 mov	 rcx, rdi
  000f0	8b d8		 mov	 ebx, eax
  000f2	e8 00 00 00 00	 call	 _Py_DecRef

; 1570 :     if (ok < 0) {

  000f7	85 db		 test	 ebx, ebx
  000f9	79 0c		 jns	 SHORT $LN1@mro_implem

; 1571 :         Py_DECREF(result);

  000fb	48 8b ce	 mov	 rcx, rsi
  000fe	e8 00 00 00 00	 call	 _Py_DecRef

; 1572 :         return NULL;

  00103	33 c0		 xor	 eax, eax
  00105	eb 03		 jmp	 SHORT $LN20@mro_implem
$LN1@mro_implem:

; 1573 :     }
; 1574 : 
; 1575 :     return result;

  00107	48 8b c6	 mov	 rax, rsi
$LN20@mro_implem:
  0010a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
$LN19@mro_implem:
  0010f	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00114	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00119	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]

; 1576 : }

  0011e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00122	5d		 pop	 rbp
  00123	c3		 ret	 0
mro_implementation ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT mro_external
_TEXT	SEGMENT
self$ = 8
mro_external PROC					; COMDAT

; 1581 :     PyTypeObject *type = (PyTypeObject *)self;
; 1582 : 
; 1583 :     return mro_implementation(type);
; 1584 : }

  00000	e9 00 00 00 00	 jmp	 mro_implementation
mro_external ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT extra_ivars
_TEXT	SEGMENT
type$ = 8
base$ = 16
extra_ivars PROC					; COMDAT

; 1707 :     size_t t_size = type->tp_basicsize;
; 1708 :     size_t b_size = base->tp_basicsize;
; 1709 : 
; 1710 :     assert(t_size >= b_size); /* Else type smaller than base! */
; 1711 :     if (type->tp_itemsize || base->tp_itemsize) {

  00000	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]
  00007	4c 8b 41 78	 mov	 r8, QWORD PTR [rcx+120]
  0000b	4c 8b 4a 78	 mov	 r9, QWORD PTR [rdx+120]
  0000f	48 85 c0	 test	 rax, rax
  00012	75 70		 jne	 SHORT $LN3@extra_ivar
  00014	48 39 82 80 00
	00 00		 cmp	 QWORD PTR [rdx+128], rax
  0001b	75 67		 jne	 SHORT $LN3@extra_ivar

; 1715 :     }
; 1716 :     if (type->tp_weaklistoffset && base->tp_weaklistoffset == 0 &&
; 1717 :         type->tp_weaklistoffset + sizeof(PyObject *) == t_size &&
; 1718 :         type->tp_flags & Py_TPFLAGS_HEAPTYPE)

  0001d	48 8b 81 28 01
	00 00		 mov	 rax, QWORD PTR [rcx+296]
  00024	48 85 c0	 test	 rax, rax
  00027	74 23		 je	 SHORT $LN2@extra_ivar
  00029	48 83 ba 28 01
	00 00 00	 cmp	 QWORD PTR [rdx+296], 0
  00031	75 19		 jne	 SHORT $LN2@extra_ivar
  00033	48 83 c0 08	 add	 rax, 8
  00037	49 3b c0	 cmp	 rax, r8
  0003a	75 10		 jne	 SHORT $LN2@extra_ivar
  0003c	f7 81 00 01 00
	00 00 02 00 00	 test	 DWORD PTR [rcx+256], 512 ; 00000200H
  00046	74 04		 je	 SHORT $LN2@extra_ivar

; 1719 :         t_size -= sizeof(PyObject *);

  00048	49 83 e8 08	 sub	 r8, 8
$LN2@extra_ivar:

; 1720 :     if (type->tp_dictoffset && base->tp_dictoffset == 0 &&
; 1721 :         type->tp_dictoffset + sizeof(PyObject *) == t_size &&
; 1722 :         type->tp_flags & Py_TPFLAGS_HEAPTYPE)

  0004c	48 8b 81 78 01
	00 00		 mov	 rax, QWORD PTR [rcx+376]
  00053	48 85 c0	 test	 rax, rax
  00056	74 23		 je	 SHORT $LN1@extra_ivar
  00058	48 83 ba 78 01
	00 00 00	 cmp	 QWORD PTR [rdx+376], 0
  00060	75 19		 jne	 SHORT $LN1@extra_ivar
  00062	48 83 c0 08	 add	 rax, 8
  00066	49 3b c0	 cmp	 rax, r8
  00069	75 10		 jne	 SHORT $LN1@extra_ivar
  0006b	f7 81 00 01 00
	00 00 02 00 00	 test	 DWORD PTR [rcx+256], 512 ; 00000200H
  00075	74 04		 je	 SHORT $LN1@extra_ivar

; 1723 :         t_size -= sizeof(PyObject *);

  00077	49 83 e8 08	 sub	 r8, 8
$LN1@extra_ivar:

; 1724 : 
; 1725 :     return t_size != b_size;

  0007b	33 c0		 xor	 eax, eax
  0007d	4d 3b c1	 cmp	 r8, r9
  00080	0f 95 c0	 setne	 al

; 1726 : }

  00083	c3		 ret	 0
$LN3@extra_ivar:

; 1712 :         /* If itemsize is involved, stricter rules */
; 1713 :         return t_size != b_size ||
; 1714 :             type->tp_itemsize != base->tp_itemsize;

  00084	4d 3b c1	 cmp	 r8, r9
  00087	75 0c		 jne	 SHORT $LN7@extra_ivar
  00089	48 3b 82 80 00
	00 00		 cmp	 rax, QWORD PTR [rdx+128]
  00090	75 03		 jne	 SHORT $LN7@extra_ivar
  00092	33 c0		 xor	 eax, eax

; 1726 : }

  00094	c3		 ret	 0
$LN7@extra_ivar:

; 1712 :         /* If itemsize is involved, stricter rules */
; 1713 :         return t_size != b_size ||
; 1714 :             type->tp_itemsize != base->tp_itemsize;

  00095	b8 01 00 00 00	 mov	 eax, 1

; 1726 : }

  0009a	c3		 ret	 0
extra_ivars ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$solid_base DD imagerel solid_base
	DD	imagerel solid_base+61
	DD	imagerel $unwind$solid_base
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$solid_base DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT solid_base
_TEXT	SEGMENT
type$ = 48
solid_base PROC						; COMDAT

; 1730 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1731 :     PyTypeObject *base;
; 1732 : 
; 1733 :     if (type->tp_base)

  00009	48 8b 89 58 01
	00 00		 mov	 rcx, QWORD PTR [rcx+344]
  00010	48 85 c9	 test	 rcx, rcx
  00013	74 0a		 je	 SHORT $LN4@solid_base

; 1734 :         base = solid_base(type->tp_base);

  00015	e8 00 00 00 00	 call	 solid_base
  0001a	48 8b d0	 mov	 rdx, rax

; 1735 :     else

  0001d	eb 07		 jmp	 SHORT $LN3@solid_base
$LN4@solid_base:

; 1736 :         base = &PyBaseObject_Type;

  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyBaseObject_Type
$LN3@solid_base:

; 1737 :     if (extra_ivars(type, base))

  00026	48 8b cb	 mov	 rcx, rbx
  00029	e8 00 00 00 00	 call	 extra_ivars
  0002e	85 c0		 test	 eax, eax
  00030	48 0f 45 d3	 cmovne	 rdx, rbx
  00034	48 8b c2	 mov	 rax, rdx

; 1738 :         return type;
; 1739 :     else
; 1740 :         return base;
; 1741 : }

  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5b		 pop	 rbx
  0003c	c3		 ret	 0
solid_base ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT get_builtin_base_with_dict
_TEXT	SEGMENT
type$ = 8
get_builtin_base_with_dict PROC				; COMDAT

; 1756 :     while (type->tp_base != NULL) {

  00000	48 8b 81 58 01
	00 00		 mov	 rax, QWORD PTR [rcx+344]
$LN11@get_builti:
  00007	48 85 c0	 test	 rax, rax
  0000a	74 26		 je	 SHORT $LN9@get_builti

; 1757 :         if (type->tp_dictoffset != 0 &&
; 1758 :             !(type->tp_flags & Py_TPFLAGS_HEAPTYPE))

  0000c	48 83 b9 78 01
	00 00 00	 cmp	 QWORD PTR [rcx+376], 0
  00014	74 0c		 je	 SHORT $LN1@get_builti
  00016	f7 81 00 01 00
	00 00 02 00 00	 test	 DWORD PTR [rcx+256], 512 ; 00000200H
  00020	74 0c		 je	 SHORT $LN7@get_builti
$LN1@get_builti:

; 1760 :         type = type->tp_base;

  00022	48 8b c8	 mov	 rcx, rax
  00025	48 8b 80 58 01
	00 00		 mov	 rax, QWORD PTR [rax+344]
  0002c	eb d9		 jmp	 SHORT $LN11@get_builti
$LN7@get_builti:

; 1759 :             return type;

  0002e	48 8b c1	 mov	 rax, rcx

; 1761 :     }
; 1762 :     return NULL;
; 1763 : }

  00031	c3		 ret	 0
$LN9@get_builti:
  00032	f3 c3		 fatret	 0
get_builtin_base_with_dict ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DL@MECENEFN@this?5__dict__?5descriptor?5does?5no@ ; `string'
;	COMDAT ??_C@_0DL@MECENEFN@this?5__dict__?5descriptor?5does?5no@
CONST	SEGMENT
??_C@_0DL@MECENEFN@this?5__dict__?5descriptor?5does?5no@ DB 'this __dict_'
	DB	'_ descriptor does not support ''%.200s'' objects', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT raise_dict_descr_error
_TEXT	SEGMENT
obj$ = 8
raise_dict_descr_error PROC				; COMDAT

; 1780 :     PyErr_Format(PyExc_TypeError,
; 1781 :                  "this __dict__ descriptor does not support "
; 1782 :                  "'%.200s' objects", Py_TYPE(obj)->tp_name);

  00000	4c 8b 41 58	 mov	 r8, QWORD PTR [rcx+88]
  00004	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0000b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DL@MECENEFN@this?5__dict__?5descriptor?5does?5no@
  00012	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]

; 1783 : }

  00016	e9 00 00 00 00	 jmp	 PyErr_Format
raise_dict_descr_error ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@LKMOIFEN@This?5object?5has?5no?5__weakref__?$AA@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$subtype_getweakref DD imagerel subtype_getweakref
	DD	imagerel subtype_getweakref+141
	DD	imagerel $unwind$subtype_getweakref
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$subtype_getweakref DD 033701H
	DD	063437H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0BP@LKMOIFEN@This?5object?5has?5no?5__weakref__?$AA@
CONST	SEGMENT
??_C@_0BP@LKMOIFEN@This?5object?5has?5no?5__weakref__?$AA@ DB 'This objec'
	DB	't has no __weakref__', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
CONST	ENDS
;	COMDAT subtype_getweakref
_TEXT	SEGMENT
obj$ = 64
context$ = 72
subtype_getweakref PROC					; COMDAT

; 1851 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1852 :     PyObject **weaklistptr;
; 1853 :     PyObject *result;
; 1854 : 
; 1855 :     if (Py_TYPE(obj)->tp_weaklistoffset == 0) {

  00004	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00008	48 8b 80 28 01
	00 00		 mov	 rax, QWORD PTR [rax+296]
  0000f	48 85 c0	 test	 rax, rax
  00012	75 1a		 jne	 SHORT $LN3@subtype_ge

; 1856 :         PyErr_SetString(PyExc_AttributeError,
; 1857 :                         "This object has no __weakref__");

  00014	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@LKMOIFEN@This?5object?5has?5no?5__weakref__?$AA@
  00022	e8 00 00 00 00	 call	 PyErr_SetString

; 1858 :         return NULL;

  00027	33 c0		 xor	 eax, eax

; 1871 : }

  00029	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002d	c3		 ret	 0
$LN3@subtype_ge:

; 1859 :     }
; 1860 :     assert(Py_TYPE(obj)->tp_weaklistoffset > 0);
; 1861 :     assert(Py_TYPE(obj)->tp_weaklistoffset + sizeof(PyObject *) <=
; 1862 :            (size_t)(Py_TYPE(obj)->tp_basicsize));
; 1863 :     weaklistptr = (PyObject **)
; 1864 :         ((char *)obj + Py_TYPE(obj)->tp_weaklistoffset);
; 1865 :     if (*weaklistptr == NULL)

  0002e	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]
  00032	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00037	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  0003e	48 85 c0	 test	 rax, rax
  00041	48 0f 45 d8	 cmovne	 rbx, rax

; 1866 :         result = Py_None;
; 1867 :     else
; 1868 :         result = *weaklistptr;
; 1869 :     Py_INCREF(result);

  00045	e8 00 00 00 00	 call	 _Py_PXCTX
  0004a	85 c0		 test	 eax, eax
  0004c	75 32		 jne	 SHORT $LN7@subtype_ge
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0005c	4c 8b cb	 mov	 r9, rbx
  0005f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00065	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0006d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00072	85 c0		 test	 eax, eax
  00074	75 06		 jne	 SHORT $LN6@subtype_ge
  00076	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0007a	74 04		 je	 SHORT $LN7@subtype_ge
$LN6@subtype_ge:
  0007c	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN7@subtype_ge:

; 1870 :     return result;

  00080	48 8b c3	 mov	 rax, rbx
  00083	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1871 : }

  00088	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008c	c3		 ret	 0
subtype_getweakref ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@PKJAMNDC@__slots__?5must?5be?5identifiers?$AA@ ; `string'
PUBLIC	??_C@_0CO@MJHHCBKP@__slots__?5items?5must?5be?5strings?0@ ; `string'
EXTRN	PyUnicode_IsIdentifier:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$valid_identifier DD imagerel valid_identifier
	DD	imagerel valid_identifier+96
	DD	imagerel $unwind$valid_identifier
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$valid_identifier DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BO@PKJAMNDC@__slots__?5must?5be?5identifiers?$AA@
CONST	SEGMENT
??_C@_0BO@PKJAMNDC@__slots__?5must?5be?5identifiers?$AA@ DB '__slots__ mu'
	DB	'st be identifiers', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@MJHHCBKP@__slots__?5items?5must?5be?5strings?0@
CONST	SEGMENT
??_C@_0CO@MJHHCBKP@__slots__?5items?5must?5be?5strings?0@ DB '__slots__ i'
	DB	'tems must be strings, not ''%.200s''', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT valid_identifier
_TEXT	SEGMENT
s$ = 48
valid_identifier PROC					; COMDAT

; 1897 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1898 :     if (!PyUnicode_Check(s)) {

  00004	4c 8b 41 58	 mov	 r8, QWORD PTR [rcx+88]
  00008	41 f7 80 00 01
	00 00 00 00 00
	10		 test	 DWORD PTR [r8+256], 268435456 ; 10000000H
  00013	75 1e		 jne	 SHORT $LN2@valid_iden

; 1899 :         PyErr_Format(PyExc_TypeError,
; 1900 :                      "__slots__ items must be strings, not '%.200s'",
; 1901 :                      Py_TYPE(s)->tp_name);

  00015	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@MJHHCBKP@__slots__?5items?5must?5be?5strings?0@
  00027	e8 00 00 00 00	 call	 PyErr_Format

; 1902 :         return 0;

  0002c	33 c0		 xor	 eax, eax

; 1910 : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
$LN2@valid_iden:

; 1903 :     }
; 1904 :     if (!PyUnicode_IsIdentifier(s)) {

  00033	e8 00 00 00 00	 call	 PyUnicode_IsIdentifier
  00038	85 c0		 test	 eax, eax
  0003a	75 1a		 jne	 SHORT $LN1@valid_iden

; 1905 :         PyErr_SetString(PyExc_TypeError,
; 1906 :                         "__slots__ must be identifiers");

  0003c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@PKJAMNDC@__slots__?5must?5be?5identifiers?$AA@
  0004a	e8 00 00 00 00	 call	 PyErr_SetString

; 1907 :         return 0;

  0004f	33 c0		 xor	 eax, eax

; 1910 : }

  00051	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00055	c3		 ret	 0
$LN1@valid_iden:

; 1908 :     }
; 1909 :     return 1;

  00056	b8 01 00 00 00	 mov	 eax, 1

; 1910 : }

  0005b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005f	c3		 ret	 0
valid_identifier ENDP
_TEXT	ENDS
PUBLIC	PyType_GetFlags
; Function compile flags: /Ogtpy
;	COMDAT PyType_GetFlags
_TEXT	SEGMENT
type$ = 8
PyType_GetFlags PROC					; COMDAT

; 1948 :     return type->tp_flags;

  00000	8b 81 00 01 00
	00		 mov	 eax, DWORD PTR [rcx+256]

; 1949 : }

  00006	c3		 ret	 0
PyType_GetFlags ENDP
_TEXT	ENDS
PUBLIC	??_C@_0HJ@LMIOILHN@metaclass?5conflict?3?5the?5metaclas@ ; `string'
PUBLIC	_PyType_CalculateMetaclass
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyType_CalculateMetaclass DD imagerel $LN11
	DD	imagerel $LN11+142
	DD	imagerel $unwind$_PyType_CalculateMetaclass
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyType_CalculateMetaclass DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0HJ@LMIOILHN@metaclass?5conflict?3?5the?5metaclas@
CONST	SEGMENT
??_C@_0HJ@LMIOILHN@metaclass?5conflict?3?5the?5metaclas@ DB 'metaclass co'
	DB	'nflict: the metaclass of a derived class must be a (non-stric'
	DB	't) subclass of the metaclasses of all its bases', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyType_CalculateMetaclass
_TEXT	SEGMENT
metatype$ = 48
bases$ = 56
_PyType_CalculateMetaclass PROC				; COMDAT

; 1954 : {

$LN11:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1955 :     Py_ssize_t i, nbases;
; 1956 :     PyTypeObject *winner;
; 1957 :     PyObject *tmp;
; 1958 :     PyTypeObject *tmptype;
; 1959 : 
; 1960 :     /* Determine the proper metatype to deal with this,
; 1961 :        and check for metatype conflicts while we're at it.
; 1962 :        Note that if some other metatype wins to contract,
; 1963 :        it's possible that its instances are not types. */
; 1964 : 
; 1965 :     nbases = PyTuple_GET_SIZE(bases);

  0000f	48 8b 72 60	 mov	 rsi, QWORD PTR [rdx+96]

; 1966 :     winner = metatype;
; 1967 :     for (i = 0; i < nbases; i++) {

  00013	45 33 d2	 xor	 r10d, r10d
  00016	48 8b d9	 mov	 rbx, rcx
  00019	48 85 f6	 test	 rsi, rsi
  0001c	7e 38		 jle	 SHORT $LN10@PyType_Cal

; 1955 :     Py_ssize_t i, nbases;
; 1956 :     PyTypeObject *winner;
; 1957 :     PyObject *tmp;
; 1958 :     PyTypeObject *tmptype;
; 1959 : 
; 1960 :     /* Determine the proper metatype to deal with this,
; 1961 :        and check for metatype conflicts while we're at it.
; 1962 :        Note that if some other metatype wins to contract,
; 1963 :        it's possible that its instances are not types. */
; 1964 : 
; 1965 :     nbases = PyTuple_GET_SIZE(bases);

  0001e	4c 8d 5a 70	 lea	 r11, QWORD PTR [rdx+112]
$LL5@PyType_Cal:

; 1968 :         tmp = PyTuple_GET_ITEM(bases, i);
; 1969 :         tmptype = Py_TYPE(tmp);

  00022	49 8b 03	 mov	 rax, QWORD PTR [r11]

; 1970 :         if (PyType_IsSubtype(winner, tmptype))

  00025	48 8b cb	 mov	 rcx, rbx
  00028	48 8b 78 58	 mov	 rdi, QWORD PTR [rax+88]
  0002c	48 8b d7	 mov	 rdx, rdi
  0002f	e8 00 00 00 00	 call	 PyType_IsSubtype
  00034	85 c0		 test	 eax, eax
  00036	75 12		 jne	 SHORT $LN4@PyType_Cal

; 1971 :             continue;
; 1972 :         if (PyType_IsSubtype(tmptype, winner)) {

  00038	48 8b d3	 mov	 rdx, rbx
  0003b	48 8b cf	 mov	 rcx, rdi
  0003e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00043	85 c0		 test	 eax, eax
  00045	74 22		 je	 SHORT $LN1@PyType_Cal

; 1973 :             winner = tmptype;

  00047	48 8b df	 mov	 rbx, rdi
$LN4@PyType_Cal:

; 1966 :     winner = metatype;
; 1967 :     for (i = 0; i < nbases; i++) {

  0004a	49 ff c2	 inc	 r10
  0004d	49 83 c3 08	 add	 r11, 8
  00051	4c 3b d6	 cmp	 r10, rsi
  00054	7c cc		 jl	 SHORT $LL5@PyType_Cal
$LN10@PyType_Cal:

; 1982 :         return NULL;
; 1983 :     }
; 1984 :     return winner;

  00056	48 8b c3	 mov	 rax, rbx

; 1985 : }

  00059	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00063	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00067	5f		 pop	 rdi
  00068	c3		 ret	 0
$LN1@PyType_Cal:

; 1974 :             continue;
; 1975 :         }
; 1976 :         /* else: */
; 1977 :         PyErr_SetString(PyExc_TypeError,
; 1978 :                         "metaclass conflict: "
; 1979 :                         "the metaclass of a derived class "
; 1980 :                         "must be a (non-strict) subclass "
; 1981 :                         "of the metaclasses of all its bases");

  00069	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00070	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0HJ@LMIOILHN@metaclass?5conflict?3?5the?5metaclas@
  00077	e8 00 00 00 00	 call	 PyErr_SetString

; 1985 : }

  0007c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00081	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00086	33 c0		 xor	 eax, eax
  00088	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008c	5f		 pop	 rdi
  0008d	c3		 ret	 0
_PyType_CalculateMetaclass ENDP
_TEXT	ENDS
PUBLIC	_PyType_Lookup
EXTRN	PyDict_GetItem:PROC
EXTRN	_PyUnicode_Ready:PROC
EXTRN	PyUnicode_Type:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_PyType_Lookup DD imagerel $LN39
	DD	imagerel $LN39+125
	DD	imagerel $unwind$_PyType_Lookup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_PyType_Lookup DD imagerel $LN39+125
	DD	imagerel $LN39+160
	DD	imagerel $chain$0$_PyType_Lookup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$_PyType_Lookup DD imagerel $LN39+160
	DD	imagerel $LN39+321
	DD	imagerel $chain$5$_PyType_Lookup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$_PyType_Lookup DD imagerel $LN39+321
	DD	imagerel $LN39+542
	DD	imagerel $chain$6$_PyType_Lookup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$_PyType_Lookup DD 040021H
	DD	0ec400H
	DD	0c3400H
	DD	imagerel $LN39
	DD	imagerel $LN39+125
	DD	imagerel $unwind$_PyType_Lookup
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$_PyType_Lookup DD 080f21H
	DD	06d40fH
	DD	0ec40aH
	DD	0d6405H
	DD	0c3400H
	DD	imagerel $LN39
	DD	imagerel $LN39+125
	DD	imagerel $unwind$_PyType_Lookup
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_PyType_Lookup DD 020521H
	DD	0c3405H
	DD	imagerel $LN39
	DD	imagerel $LN39+125
	DD	imagerel $unwind$_PyType_Lookup
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyType_Lookup DD 050b01H
	DD	0f007620bH
	DD	07003e005H
	DD	05002H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT _PyType_Lookup
_TEXT	SEGMENT
type$ = 96
name$ = 104
_PyType_Lookup PROC					; COMDAT

; 2534 : {

$LN39:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	41 56		 push	 r14
  00005	41 57		 push	 r15
  00007	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2535 :     Py_ssize_t i, n;
; 2536 :     PyObject *mro, *res, *base, *dict;
; 2537 :     unsigned int h;
; 2538 : 
; 2539 :     if (MCACHE_CACHEABLE_NAME(name) &&
; 2540 :         PyType_HasFeature(type, Py_TPFLAGS_VALID_VERSION_TAG)) {

  0000b	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:PyUnicode_Type
  00012	48 8b fa	 mov	 rdi, rdx
  00015	4c 8b f1	 mov	 r14, rcx
  00018	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:method_cache
  0001f	48 39 6a 58	 cmp	 QWORD PTR [rdx+88], rbp
  00023	75 58		 jne	 SHORT $LN8@PyType_Loo
  00025	f6 42 70 80	 test	 BYTE PTR [rdx+112], 128	; 00000080H
  00029	75 0d		 jne	 SHORT $LN34@PyType_Loo
  0002b	48 8b ca	 mov	 rcx, rdx
  0002e	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00033	83 f8 ff	 cmp	 eax, -1
  00036	74 45		 je	 SHORT $LN8@PyType_Loo
$LN34@PyType_Loo:
  00038	48 83 7f 60 64	 cmp	 QWORD PTR [rdi+96], 100	; 00000064H
  0003d	7f 3e		 jg	 SHORT $LN8@PyType_Loo
  0003f	41 f7 86 00 01
	00 00 00 00 08
	00		 test	 DWORD PTR [r14+256], 524288 ; 00080000H
  0004a	74 31		 je	 SHORT $LN8@PyType_Loo

; 2541 :         /* fast path */
; 2542 :         h = MCACHE_HASH_METHOD(type, name);

  0004c	41 8b 8e d8 01
	00 00		 mov	 ecx, DWORD PTR [r14+472]
  00053	8b 47 68	 mov	 eax, DWORD PTR [rdi+104]
  00056	0f af c1	 imul	 eax, ecx
  00059	c1 e8 17	 shr	 eax, 23

; 2543 :         if (method_cache[h].version == type->tp_version_tag &&
; 2544 :             method_cache[h].name == name)

  0005c	48 8d 04 40	 lea	 rax, QWORD PTR [rax+rax*2]
  00060	41 39 0c c7	 cmp	 DWORD PTR [r15+rax*8], ecx
  00064	75 17		 jne	 SHORT $LN8@PyType_Loo
  00066	49 39 7c c7 08	 cmp	 QWORD PTR [r15+rax*8+8], rdi
  0006b	75 10		 jne	 SHORT $LN8@PyType_Loo

; 2545 :             return method_cache[h].value;

  0006d	49 8b 44 c7 10	 mov	 rax, QWORD PTR [r15+rax*8+16]

; 2585 : }

  00072	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00076	41 5f		 pop	 r15
  00078	41 5e		 pop	 r14
  0007a	5f		 pop	 rdi
  0007b	5d		 pop	 rbp
  0007c	c3		 ret	 0
$LN8@PyType_Loo:
  0007d	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx

; 2546 :     }
; 2547 : 
; 2548 :     /* Look in tp_dict of types in MRO */
; 2549 :     mro = type->tp_mro;

  00082	49 8b 9e b0 01
	00 00		 mov	 rbx, QWORD PTR [r14+432]

; 2550 : 
; 2551 :     /* If mro is NULL, the type is either not yet initialized
; 2552 :        by PyType_Ready(), or already cleared by type_clear().
; 2553 :        Either way the safest thing to do is to return NULL. */
; 2554 :     if (mro == NULL)

  00089	48 85 db	 test	 rbx, rbx
  0008c	75 12		 jne	 SHORT $LN7@PyType_Loo

; 2555 :         return NULL;

  0008e	33 c0		 xor	 eax, eax
  00090	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 2585 : }

  00095	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00099	41 5f		 pop	 r15
  0009b	41 5e		 pop	 r14
  0009d	5f		 pop	 rdi
  0009e	5d		 pop	 rbp
  0009f	c3		 ret	 0
$LN7@PyType_Loo:
  000a0	48 89 74 24 68	 mov	 QWORD PTR [rsp+104], rsi
  000a5	4c 89 64 24 70	 mov	 QWORD PTR [rsp+112], r12
  000aa	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13

; 2556 : 
; 2557 :     res = NULL;

  000af	45 33 e4	 xor	 r12d, r12d

; 2558 :     /* keep a strong reference to mro because type->tp_mro can be replaced
; 2559 :        during PyDict_GetItem(dict, name)  */
; 2560 :     Py_INCREF(mro);

  000b2	e8 00 00 00 00	 call	 _Py_PXCTX
  000b7	85 c0		 test	 eax, eax
  000b9	75 32		 jne	 SHORT $LN17@PyType_Loo
  000bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000c9	4c 8b cb	 mov	 r9, rbx
  000cc	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000d2	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000da	e8 00 00 00 00	 call	 _PyParallel_Guard
  000df	85 c0		 test	 eax, eax
  000e1	75 06		 jne	 SHORT $LN16@PyType_Loo
  000e3	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000e7	74 04		 je	 SHORT $LN17@PyType_Loo
$LN16@PyType_Loo:
  000e9	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN17@PyType_Loo:

; 2561 :     assert(PyTuple_Check(mro));
; 2562 :     n = PyTuple_GET_SIZE(mro);

  000ed	4c 8b 6b 60	 mov	 r13, QWORD PTR [rbx+96]

; 2563 :     for (i = 0; i < n; i++) {

  000f1	49 8b f4	 mov	 rsi, r12
  000f4	4d 85 ed	 test	 r13, r13
  000f7	7e 35		 jle	 SHORT $LN32@PyType_Loo

; 2561 :     assert(PyTuple_Check(mro));
; 2562 :     n = PyTuple_GET_SIZE(mro);

  000f9	48 8d 6b 70	 lea	 rbp, QWORD PTR [rbx+112]
  000fd	0f 1f 00	 npad	 3
$LL6@PyType_Loo:

; 2564 :         base = PyTuple_GET_ITEM(mro, i);
; 2565 :         assert(PyType_Check(base));
; 2566 :         dict = ((PyTypeObject *)base)->tp_dict;

  00100	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]

; 2567 :         assert(dict && PyDict_Check(dict));
; 2568 :         res = PyDict_GetItem(dict, name);

  00104	48 8b d7	 mov	 rdx, rdi
  00107	48 8b 88 60 01
	00 00		 mov	 rcx, QWORD PTR [rax+352]
  0010e	e8 00 00 00 00	 call	 PyDict_GetItem
  00113	4c 8b e0	 mov	 r12, rax

; 2569 :         if (res != NULL)

  00116	48 85 c0	 test	 rax, rax
  00119	75 0c		 jne	 SHORT $LN36@PyType_Loo

; 2563 :     for (i = 0; i < n; i++) {

  0011b	48 ff c6	 inc	 rsi
  0011e	48 83 c5 08	 add	 rbp, 8
  00122	49 3b f5	 cmp	 rsi, r13
  00125	7c d9		 jl	 SHORT $LL6@PyType_Loo
$LN36@PyType_Loo:
  00127	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:PyUnicode_Type
$LN32@PyType_Loo:

; 2570 :             break;
; 2571 :     }
; 2572 :     Py_DECREF(mro);

  0012e	e8 00 00 00 00	 call	 _Py_PXCTX
  00133	4c 8b 6c 24 30	 mov	 r13, QWORD PTR [rsp+48]
  00138	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  0013d	85 c0		 test	 eax, eax
  0013f	75 5c		 jne	 SHORT $LN30@PyType_Loo
  00141	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00145	a8 20		 test	 al, 32			; 00000020H
  00147	75 4c		 jne	 SHORT $LN24@PyType_Loo
  00149	84 c0		 test	 al, al
  0014b	78 48		 js	 SHORT $LN24@PyType_Loo
  0014d	a8 02		 test	 al, 2
  0014f	75 4c		 jne	 SHORT $LN30@PyType_Loo
  00151	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00155	75 46		 jne	 SHORT $LN30@PyType_Loo
  00157	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0015e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00165	4c 8b cb	 mov	 r9, rbx
  00168	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0016e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00176	e8 00 00 00 00	 call	 _PyParallel_Guard
  0017b	48 8b cb	 mov	 rcx, rbx
  0017e	85 c0		 test	 eax, eax
  00180	74 07		 je	 SHORT $LN29@PyType_Loo
  00182	e8 00 00 00 00	 call	 _Px_Dealloc
  00187	eb 14		 jmp	 SHORT $LN30@PyType_Loo
$LN29@PyType_Loo:
  00189	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0018d	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00193	eb 08		 jmp	 SHORT $LN30@PyType_Loo
$LN24@PyType_Loo:
  00195	48 8b cb	 mov	 rcx, rbx
  00198	e8 00 00 00 00	 call	 Px_DecRef
$LN30@PyType_Loo:

; 2573 : 
; 2574 :     Px_RETURN(res);

  0019d	e8 00 00 00 00	 call	 _Py_PXCTX
  001a2	85 c0		 test	 eax, eax
  001a4	75 60		 jne	 SHORT $LN1@PyType_Loo

; 2575 : 
; 2576 :     if (MCACHE_CACHEABLE_NAME(name) && assign_version_tag(type)) {

  001a6	48 39 6f 58	 cmp	 QWORD PTR [rdi+88], rbp
  001aa	75 5a		 jne	 SHORT $LN1@PyType_Loo
  001ac	f6 47 70 80	 test	 BYTE PTR [rdi+112], 128	; 00000080H
  001b0	75 0d		 jne	 SHORT $LN35@PyType_Loo
  001b2	48 8b cf	 mov	 rcx, rdi
  001b5	e8 00 00 00 00	 call	 _PyUnicode_Ready
  001ba	83 f8 ff	 cmp	 eax, -1
  001bd	74 47		 je	 SHORT $LN1@PyType_Loo
$LN35@PyType_Loo:
  001bf	48 83 7f 60 64	 cmp	 QWORD PTR [rdi+96], 100	; 00000064H
  001c4	7f 40		 jg	 SHORT $LN1@PyType_Loo
  001c6	49 8b ce	 mov	 rcx, r14
  001c9	e8 00 00 00 00	 call	 assign_version_tag
  001ce	85 c0		 test	 eax, eax
  001d0	74 34		 je	 SHORT $LN1@PyType_Loo

; 2577 :         h = MCACHE_HASH_METHOD(type, name);

  001d2	41 8b 8e d8 01
	00 00		 mov	 ecx, DWORD PTR [r14+472]
  001d9	8b 47 68	 mov	 eax, DWORD PTR [rdi+104]
  001dc	0f af c1	 imul	 eax, ecx
  001df	c1 e8 17	 shr	 eax, 23

; 2578 :         method_cache[h].version = type->tp_version_tag;

  001e2	48 8d 1c 40	 lea	 rbx, QWORD PTR [rax+rax*2]
  001e6	41 89 0c df	 mov	 DWORD PTR [r15+rbx*8], ecx

; 2579 :         method_cache[h].value = res;  /* borrowed */
; 2580 :         Py_INCREF(name);

  001ea	48 8b cf	 mov	 rcx, rdi
  001ed	4d 89 64 df 10	 mov	 QWORD PTR [r15+rbx*8+16], r12
  001f2	e8 00 00 00 00	 call	 _Py_IncRef

; 2581 :         Py_DECREF(method_cache[h].name);

  001f7	49 8b 4c df 08	 mov	 rcx, QWORD PTR [r15+rbx*8+8]
  001fc	e8 00 00 00 00	 call	 _Py_DecRef

; 2582 :         method_cache[h].name = name;

  00201	49 89 7c df 08	 mov	 QWORD PTR [r15+rbx*8+8], rdi
$LN1@PyType_Loo:

; 2583 :     }
; 2584 :     return res;

  00206	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  0020b	49 8b c4	 mov	 rax, r12
  0020e	4c 8b 64 24 70	 mov	 r12, QWORD PTR [rsp+112]

; 2585 : }

  00213	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00217	41 5f		 pop	 r15
  00219	41 5e		 pop	 r14
  0021b	5f		 pop	 rdi
  0021c	5d		 pop	 rbp
  0021d	c3		 ret	 0
_PyType_Lookup ENDP
_TEXT	ENDS
PUBLIC	_PyType_LookupId
EXTRN	_PyUnicode_FromId:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyType_LookupId DD imagerel $LN4
	DD	imagerel $LN4+44
	DD	imagerel $unwind$_PyType_LookupId
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyType_LookupId DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyType_LookupId
_TEXT	SEGMENT
type$ = 48
name$ = 56
_PyType_LookupId PROC					; COMDAT

; 2589 : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 2590 :     PyObject *oname;
; 2591 :     oname = _PyUnicode_FromId(name);   /* borrowed */

  00009	48 8b ca	 mov	 rcx, rdx
  0000c	e8 00 00 00 00	 call	 _PyUnicode_FromId

; 2592 :     if (oname == NULL)

  00011	48 85 c0	 test	 rax, rax
  00014	75 06		 jne	 SHORT $LN1@PyType_Loo@2

; 2595 : }

  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5b		 pop	 rbx
  0001b	c3		 ret	 0
$LN1@PyType_Loo@2:

; 2593 :         return NULL;
; 2594 :     return _PyType_Lookup(type, oname);

  0001c	48 8b d0	 mov	 rdx, rax
  0001f	48 8b cb	 mov	 rcx, rbx

; 2595 : }

  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5b		 pop	 rbx
  00027	e9 00 00 00 00	 jmp	 _PyType_Lookup
_PyType_LookupId ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@DJMMHABI@type_dealloc?$AA@		; `string'
EXTRN	_PyDictKeys_DecRef:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$type_dealloc DD imagerel type_dealloc
	DD	imagerel type_dealloc+1215
	DD	imagerel $unwind$type_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_dealloc DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0N@DJMMHABI@type_dealloc?$AA@
CONST	SEGMENT
??_C@_0N@DJMMHABI@type_dealloc?$AA@ DB 'type_dealloc', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
CONST	ENDS
;	COMDAT type_dealloc
_TEXT	SEGMENT
type$ = 64
type_dealloc PROC					; COMDAT

; 2701 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 2702 :     PyHeapTypeObject *et;
; 2703 : 
; 2704 :     /* Assert this is a heap-allocated type object */
; 2705 :     assert(type->tp_flags & Py_TPFLAGS_HEAPTYPE);
; 2706 :     _PyObject_GC_UNTRACK(type);

  0000d	4c 8b c9	 mov	 r9, rcx
  00010	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@DJMMHABI@type_dealloc?$AA@
  0001e	41 b8 92 0a 00
	00		 mov	 r8d, 2706		; 00000a92H
  00024	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0002c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00031	85 c0		 test	 eax, eax
  00033	75 54		 jne	 SHORT $LN38@type_deall
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@DJMMHABI@type_dealloc?$AA@
  00043	4c 8b cf	 mov	 r9, rdi
  00046	41 b8 92 0a 00
	00		 mov	 r8d, 2706		; 00000a92H
  0004c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00054	e8 00 00 00 00	 call	 _PyParallel_Guard
  00059	85 c0		 test	 eax, eax
  0005b	74 04		 je	 SHORT $LN44@type_deall
  0005d	33 d2		 xor	 edx, edx
  0005f	eb 04		 jmp	 SHORT $LN45@type_deall
$LN44@type_deall:
  00061	48 8d 57 e8	 lea	 rdx, QWORD PTR [rdi-24]
$LN45@type_deall:
  00065	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00068	48 8b 4a 08	 mov	 rcx, QWORD PTR [rdx+8]
  0006c	48 c7 42 10 fe
	ff ff ff	 mov	 QWORD PTR [rdx+16], -2
  00074	48 89 01	 mov	 QWORD PTR [rcx], rax
  00077	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  0007a	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0007e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00082	48 c7 02 00 00
	00 00		 mov	 QWORD PTR [rdx], 0
$LN38@type_deall:

; 2707 :     PyObject_ClearWeakRefs((PyObject *)type);

  00089	48 8b cf	 mov	 rcx, rdi
  0008c	e8 00 00 00 00	 call	 PyObject_ClearWeakRefs

; 2708 :     et = (PyHeapTypeObject *)type;
; 2709 :     Py_XDECREF(type->tp_base);

  00091	48 8b 9f 58 01
	00 00		 mov	 rbx, QWORD PTR [rdi+344]
  00098	48 85 db	 test	 rbx, rbx
  0009b	74 65		 je	 SHORT $LN36@type_deall
  0009d	e8 00 00 00 00	 call	 _Py_PXCTX
  000a2	85 c0		 test	 eax, eax
  000a4	75 5c		 jne	 SHORT $LN36@type_deall
  000a6	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000aa	a8 20		 test	 al, 32			; 00000020H
  000ac	75 4c		 jne	 SHORT $LN50@type_deall
  000ae	84 c0		 test	 al, al
  000b0	78 48		 js	 SHORT $LN50@type_deall
  000b2	a8 02		 test	 al, 2
  000b4	75 4c		 jne	 SHORT $LN36@type_deall
  000b6	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000ba	75 46		 jne	 SHORT $LN36@type_deall
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000ca	4c 8b cb	 mov	 r9, rbx
  000cd	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000d3	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000db	e8 00 00 00 00	 call	 _PyParallel_Guard
  000e0	48 8b cb	 mov	 rcx, rbx
  000e3	85 c0		 test	 eax, eax
  000e5	74 07		 je	 SHORT $LN55@type_deall
  000e7	e8 00 00 00 00	 call	 _Px_Dealloc
  000ec	eb 14		 jmp	 SHORT $LN36@type_deall
$LN55@type_deall:
  000ee	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000f2	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000f8	eb 08		 jmp	 SHORT $LN36@type_deall
$LN50@type_deall:
  000fa	48 8b cb	 mov	 rcx, rbx
  000fd	e8 00 00 00 00	 call	 Px_DecRef
$LN36@type_deall:

; 2710 :     Py_XDECREF(type->tp_dict);

  00102	48 8b 9f 60 01
	00 00		 mov	 rbx, QWORD PTR [rdi+352]
  00109	48 85 db	 test	 rbx, rbx
  0010c	74 65		 je	 SHORT $LN32@type_deall
  0010e	e8 00 00 00 00	 call	 _Py_PXCTX
  00113	85 c0		 test	 eax, eax
  00115	75 5c		 jne	 SHORT $LN32@type_deall
  00117	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0011b	a8 20		 test	 al, 32			; 00000020H
  0011d	75 4c		 jne	 SHORT $LN61@type_deall
  0011f	84 c0		 test	 al, al
  00121	78 48		 js	 SHORT $LN61@type_deall
  00123	a8 02		 test	 al, 2
  00125	75 4c		 jne	 SHORT $LN32@type_deall
  00127	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0012b	75 46		 jne	 SHORT $LN32@type_deall
  0012d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00134	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0013b	4c 8b cb	 mov	 r9, rbx
  0013e	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00144	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0014c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00151	48 8b cb	 mov	 rcx, rbx
  00154	85 c0		 test	 eax, eax
  00156	74 07		 je	 SHORT $LN66@type_deall
  00158	e8 00 00 00 00	 call	 _Px_Dealloc
  0015d	eb 14		 jmp	 SHORT $LN32@type_deall
$LN66@type_deall:
  0015f	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00163	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00169	eb 08		 jmp	 SHORT $LN32@type_deall
$LN61@type_deall:
  0016b	48 8b cb	 mov	 rcx, rbx
  0016e	e8 00 00 00 00	 call	 Px_DecRef
$LN32@type_deall:

; 2711 :     Py_XDECREF(type->tp_bases);

  00173	48 8b 9f a8 01
	00 00		 mov	 rbx, QWORD PTR [rdi+424]
  0017a	48 85 db	 test	 rbx, rbx
  0017d	74 65		 je	 SHORT $LN28@type_deall
  0017f	e8 00 00 00 00	 call	 _Py_PXCTX
  00184	85 c0		 test	 eax, eax
  00186	75 5c		 jne	 SHORT $LN28@type_deall
  00188	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0018c	a8 20		 test	 al, 32			; 00000020H
  0018e	75 4c		 jne	 SHORT $LN72@type_deall
  00190	84 c0		 test	 al, al
  00192	78 48		 js	 SHORT $LN72@type_deall
  00194	a8 02		 test	 al, 2
  00196	75 4c		 jne	 SHORT $LN28@type_deall
  00198	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0019c	75 46		 jne	 SHORT $LN28@type_deall
  0019e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001ac	4c 8b cb	 mov	 r9, rbx
  001af	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001b5	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001bd	e8 00 00 00 00	 call	 _PyParallel_Guard
  001c2	48 8b cb	 mov	 rcx, rbx
  001c5	85 c0		 test	 eax, eax
  001c7	74 07		 je	 SHORT $LN77@type_deall
  001c9	e8 00 00 00 00	 call	 _Px_Dealloc
  001ce	eb 14		 jmp	 SHORT $LN28@type_deall
$LN77@type_deall:
  001d0	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  001d4	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001da	eb 08		 jmp	 SHORT $LN28@type_deall
$LN72@type_deall:
  001dc	48 8b cb	 mov	 rcx, rbx
  001df	e8 00 00 00 00	 call	 Px_DecRef
$LN28@type_deall:

; 2712 :     Py_XDECREF(type->tp_mro);

  001e4	48 8b 9f b0 01
	00 00		 mov	 rbx, QWORD PTR [rdi+432]
  001eb	48 85 db	 test	 rbx, rbx
  001ee	74 65		 je	 SHORT $LN24@type_deall
  001f0	e8 00 00 00 00	 call	 _Py_PXCTX
  001f5	85 c0		 test	 eax, eax
  001f7	75 5c		 jne	 SHORT $LN24@type_deall
  001f9	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  001fd	a8 20		 test	 al, 32			; 00000020H
  001ff	75 4c		 jne	 SHORT $LN83@type_deall
  00201	84 c0		 test	 al, al
  00203	78 48		 js	 SHORT $LN83@type_deall
  00205	a8 02		 test	 al, 2
  00207	75 4c		 jne	 SHORT $LN24@type_deall
  00209	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0020d	75 46		 jne	 SHORT $LN24@type_deall
  0020f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00216	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0021d	4c 8b cb	 mov	 r9, rbx
  00220	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00226	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0022e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00233	48 8b cb	 mov	 rcx, rbx
  00236	85 c0		 test	 eax, eax
  00238	74 07		 je	 SHORT $LN88@type_deall
  0023a	e8 00 00 00 00	 call	 _Px_Dealloc
  0023f	eb 14		 jmp	 SHORT $LN24@type_deall
$LN88@type_deall:
  00241	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00245	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0024b	eb 08		 jmp	 SHORT $LN24@type_deall
$LN83@type_deall:
  0024d	48 8b cb	 mov	 rcx, rbx
  00250	e8 00 00 00 00	 call	 Px_DecRef
$LN24@type_deall:

; 2713 :     Py_XDECREF(type->tp_cache);

  00255	48 8b 9f b8 01
	00 00		 mov	 rbx, QWORD PTR [rdi+440]
  0025c	48 85 db	 test	 rbx, rbx
  0025f	74 65		 je	 SHORT $LN20@type_deall
  00261	e8 00 00 00 00	 call	 _Py_PXCTX
  00266	85 c0		 test	 eax, eax
  00268	75 5c		 jne	 SHORT $LN20@type_deall
  0026a	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0026e	a8 20		 test	 al, 32			; 00000020H
  00270	75 4c		 jne	 SHORT $LN94@type_deall
  00272	84 c0		 test	 al, al
  00274	78 48		 js	 SHORT $LN94@type_deall
  00276	a8 02		 test	 al, 2
  00278	75 4c		 jne	 SHORT $LN20@type_deall
  0027a	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0027e	75 46		 jne	 SHORT $LN20@type_deall
  00280	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00287	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0028e	4c 8b cb	 mov	 r9, rbx
  00291	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00297	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0029f	e8 00 00 00 00	 call	 _PyParallel_Guard
  002a4	48 8b cb	 mov	 rcx, rbx
  002a7	85 c0		 test	 eax, eax
  002a9	74 07		 je	 SHORT $LN99@type_deall
  002ab	e8 00 00 00 00	 call	 _Px_Dealloc
  002b0	eb 14		 jmp	 SHORT $LN20@type_deall
$LN99@type_deall:
  002b2	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  002b6	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  002bc	eb 08		 jmp	 SHORT $LN20@type_deall
$LN94@type_deall:
  002be	48 8b cb	 mov	 rcx, rbx
  002c1	e8 00 00 00 00	 call	 Px_DecRef
$LN20@type_deall:

; 2714 :     Py_XDECREF(type->tp_subclasses);

  002c6	48 8b 9f c0 01
	00 00		 mov	 rbx, QWORD PTR [rdi+448]
  002cd	48 85 db	 test	 rbx, rbx
  002d0	74 65		 je	 SHORT $LN16@type_deall
  002d2	e8 00 00 00 00	 call	 _Py_PXCTX
  002d7	85 c0		 test	 eax, eax
  002d9	75 5c		 jne	 SHORT $LN16@type_deall
  002db	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  002df	a8 20		 test	 al, 32			; 00000020H
  002e1	75 4c		 jne	 SHORT $LN105@type_deall
  002e3	84 c0		 test	 al, al
  002e5	78 48		 js	 SHORT $LN105@type_deall
  002e7	a8 02		 test	 al, 2
  002e9	75 4c		 jne	 SHORT $LN16@type_deall
  002eb	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  002ef	75 46		 jne	 SHORT $LN16@type_deall
  002f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  002f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  002ff	4c 8b cb	 mov	 r9, rbx
  00302	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00308	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00310	e8 00 00 00 00	 call	 _PyParallel_Guard
  00315	48 8b cb	 mov	 rcx, rbx
  00318	85 c0		 test	 eax, eax
  0031a	74 07		 je	 SHORT $LN110@type_deall
  0031c	e8 00 00 00 00	 call	 _Px_Dealloc
  00321	eb 14		 jmp	 SHORT $LN16@type_deall
$LN110@type_deall:
  00323	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00327	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0032d	eb 08		 jmp	 SHORT $LN16@type_deall
$LN105@type_deall:
  0032f	48 8b cb	 mov	 rcx, rbx
  00332	e8 00 00 00 00	 call	 Px_DecRef
$LN16@type_deall:

; 2715 :     /* A type's tp_doc is heap allocated, unlike the tp_doc slots
; 2716 :      * of most other objects.  It's okay to cast it to char *.
; 2717 :      */
; 2718 :     PyObject_Free((char *)type->tp_doc);

  00337	48 8b 8f 08 01
	00 00		 mov	 rcx, QWORD PTR [rdi+264]
  0033e	e8 00 00 00 00	 call	 PyObject_Free

; 2719 :     Py_XDECREF(et->ht_name);

  00343	48 8b 9f 68 03
	00 00		 mov	 rbx, QWORD PTR [rdi+872]
  0034a	48 85 db	 test	 rbx, rbx
  0034d	74 65		 je	 SHORT $LN12@type_deall
  0034f	e8 00 00 00 00	 call	 _Py_PXCTX
  00354	85 c0		 test	 eax, eax
  00356	75 5c		 jne	 SHORT $LN12@type_deall
  00358	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0035c	a8 20		 test	 al, 32			; 00000020H
  0035e	75 4c		 jne	 SHORT $LN116@type_deall
  00360	84 c0		 test	 al, al
  00362	78 48		 js	 SHORT $LN116@type_deall
  00364	a8 02		 test	 al, 2
  00366	75 4c		 jne	 SHORT $LN12@type_deall
  00368	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0036c	75 46		 jne	 SHORT $LN12@type_deall
  0036e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00375	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0037c	4c 8b cb	 mov	 r9, rbx
  0037f	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00385	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0038d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00392	48 8b cb	 mov	 rcx, rbx
  00395	85 c0		 test	 eax, eax
  00397	74 07		 je	 SHORT $LN121@type_deall
  00399	e8 00 00 00 00	 call	 _Px_Dealloc
  0039e	eb 14		 jmp	 SHORT $LN12@type_deall
$LN121@type_deall:
  003a0	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  003a4	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  003aa	eb 08		 jmp	 SHORT $LN12@type_deall
$LN116@type_deall:
  003ac	48 8b cb	 mov	 rcx, rbx
  003af	e8 00 00 00 00	 call	 Px_DecRef
$LN12@type_deall:

; 2720 :     Py_XDECREF(et->ht_qualname);

  003b4	48 8b 9f 78 03
	00 00		 mov	 rbx, QWORD PTR [rdi+888]
  003bb	48 85 db	 test	 rbx, rbx
  003be	74 65		 je	 SHORT $LN8@type_deall
  003c0	e8 00 00 00 00	 call	 _Py_PXCTX
  003c5	85 c0		 test	 eax, eax
  003c7	75 5c		 jne	 SHORT $LN8@type_deall
  003c9	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  003cd	a8 20		 test	 al, 32			; 00000020H
  003cf	75 4c		 jne	 SHORT $LN127@type_deall
  003d1	84 c0		 test	 al, al
  003d3	78 48		 js	 SHORT $LN127@type_deall
  003d5	a8 02		 test	 al, 2
  003d7	75 4c		 jne	 SHORT $LN8@type_deall
  003d9	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  003dd	75 46		 jne	 SHORT $LN8@type_deall
  003df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  003e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  003ed	4c 8b cb	 mov	 r9, rbx
  003f0	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  003f6	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  003fe	e8 00 00 00 00	 call	 _PyParallel_Guard
  00403	48 8b cb	 mov	 rcx, rbx
  00406	85 c0		 test	 eax, eax
  00408	74 07		 je	 SHORT $LN132@type_deall
  0040a	e8 00 00 00 00	 call	 _Px_Dealloc
  0040f	eb 14		 jmp	 SHORT $LN8@type_deall
$LN132@type_deall:
  00411	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00415	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0041b	eb 08		 jmp	 SHORT $LN8@type_deall
$LN127@type_deall:
  0041d	48 8b cb	 mov	 rcx, rbx
  00420	e8 00 00 00 00	 call	 Px_DecRef
$LN8@type_deall:

; 2721 :     Py_XDECREF(et->ht_slots);

  00425	48 8b 9f 70 03
	00 00		 mov	 rbx, QWORD PTR [rdi+880]
  0042c	48 85 db	 test	 rbx, rbx
  0042f	74 65		 je	 SHORT $LN4@type_deall
  00431	e8 00 00 00 00	 call	 _Py_PXCTX
  00436	85 c0		 test	 eax, eax
  00438	75 5c		 jne	 SHORT $LN4@type_deall
  0043a	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0043e	a8 20		 test	 al, 32			; 00000020H
  00440	75 4c		 jne	 SHORT $LN138@type_deall
  00442	84 c0		 test	 al, al
  00444	78 48		 js	 SHORT $LN138@type_deall
  00446	a8 02		 test	 al, 2
  00448	75 4c		 jne	 SHORT $LN4@type_deall
  0044a	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0044e	75 46		 jne	 SHORT $LN4@type_deall
  00450	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00457	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0045e	4c 8b cb	 mov	 r9, rbx
  00461	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00467	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0046f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00474	48 8b cb	 mov	 rcx, rbx
  00477	85 c0		 test	 eax, eax
  00479	74 07		 je	 SHORT $LN143@type_deall
  0047b	e8 00 00 00 00	 call	 _Px_Dealloc
  00480	eb 14		 jmp	 SHORT $LN4@type_deall
$LN143@type_deall:
  00482	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00486	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0048c	eb 08		 jmp	 SHORT $LN4@type_deall
$LN138@type_deall:
  0048e	48 8b cb	 mov	 rcx, rbx
  00491	e8 00 00 00 00	 call	 Px_DecRef
$LN4@type_deall:

; 2722 :     if (et->ht_cached_keys)

  00496	48 8b 8f 80 03
	00 00		 mov	 rcx, QWORD PTR [rdi+896]
  0049d	48 85 c9	 test	 rcx, rcx
  004a0	74 05		 je	 SHORT $LN1@type_deall

; 2723 :         _PyDictKeys_DecRef(et->ht_cached_keys);

  004a2	e8 00 00 00 00	 call	 _PyDictKeys_DecRef
$LN1@type_deall:

; 2724 :     Py_TYPE(type)->tp_free((PyObject *)type);

  004a7	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  004ab	48 8b cf	 mov	 rcx, rdi

; 2725 : }

  004ae	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  004b3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  004b7	5f		 pop	 rdi
  004b8	48 ff a0 98 01
	00 00		 rex_jmp QWORD PTR [rax+408]
type_dealloc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$type_subclasses DD imagerel type_subclasses
	DD	imagerel type_subclasses+51
	DD	imagerel $unwind$type_subclasses
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$type_subclasses DD imagerel type_subclasses+51
	DD	imagerel type_subclasses+146
	DD	imagerel $chain$2$type_subclasses
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$type_subclasses DD imagerel type_subclasses+146
	DD	imagerel type_subclasses+157
	DD	imagerel $chain$3$type_subclasses
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$type_subclasses DD imagerel type_subclasses+157
	DD	imagerel type_subclasses+169
	DD	imagerel $chain$4$type_subclasses
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$type_subclasses DD 060021H
	DD	08c400H
	DD	076400H
	DD	063400H
	DD	imagerel type_subclasses
	DD	imagerel type_subclasses+51
	DD	imagerel $unwind$type_subclasses
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$type_subclasses DD 021H
	DD	imagerel type_subclasses
	DD	imagerel type_subclasses+51
	DD	imagerel $unwind$type_subclasses
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$type_subclasses DD 061521H
	DD	08c415H
	DD	07640aH
	DD	063405H
	DD	imagerel type_subclasses
	DD	imagerel type_subclasses+51
	DD	imagerel $unwind$type_subclasses
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_subclasses DD 040a01H
	DD	09540aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT type_subclasses
_TEXT	SEGMENT
type$ = 48
args_ignored$ = 56
type_subclasses PROC					; COMDAT

; 2729 : {

  00000	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b e9	 mov	 rbp, rcx

; 2730 :     PyObject *list, *raw, *ref;
; 2731 :     Py_ssize_t i, n;
; 2732 : 
; 2733 :     list = PyList_New(0);

  0000d	33 c9		 xor	 ecx, ecx
  0000f	e8 00 00 00 00	 call	 PyList_New
  00014	48 8b f8	 mov	 rdi, rax

; 2734 :     if (list == NULL)

  00017	48 85 c0	 test	 rax, rax
  0001a	75 0b		 jne	 SHORT $LN7@type_subcl

; 2753 : }

  0001c	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5f		 pop	 rdi
  00026	c3		 ret	 0
$LN7@type_subcl:

; 2735 :         return NULL;
; 2736 :     raw = type->tp_subclasses;

  00027	48 8b ad c0 01
	00 00		 mov	 rbp, QWORD PTR [rbp+448]

; 2737 :     if (raw == NULL)

  0002e	48 85 ed	 test	 rbp, rbp

; 2738 :         return list;

  00031	74 5f		 je	 SHORT $LN8@type_subcl

; 2739 :     assert(PyList_Check(raw));
; 2740 :     n = PyList_GET_SIZE(raw);

  00033	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00038	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  0003d	48 8b 75 60	 mov	 rsi, QWORD PTR [rbp+96]

; 2741 :     for (i = 0; i < n; i++) {

  00041	33 db		 xor	 ebx, ebx
  00043	4c 89 64 24 40	 mov	 QWORD PTR [rsp+64], r12
  00048	48 85 f6	 test	 rsi, rsi
  0004b	7e 33		 jle	 SHORT $LN15@type_subcl
  0004d	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_Py_NoneStruct
$LL5@type_subcl:

; 2742 :         ref = PyList_GET_ITEM(raw, i);

  00054	48 8b 45 70	 mov	 rax, QWORD PTR [rbp+112]
  00058	48 8b 0c d8	 mov	 rcx, QWORD PTR [rax+rbx*8]

; 2743 :         assert(PyWeakref_CheckRef(ref));
; 2744 :         ref = PyWeakref_GET_OBJECT(ref);

  0005c	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00060	48 83 7a 50 00	 cmp	 QWORD PTR [rdx+80], 0
  00065	7e 11		 jle	 SHORT $LN4@type_subcl

; 2745 :         if (ref != Py_None) {

  00067	49 3b d4	 cmp	 rdx, r12
  0006a	74 0c		 je	 SHORT $LN4@type_subcl

; 2746 :             if (PyList_Append(list, ref) < 0) {

  0006c	48 8b cf	 mov	 rcx, rdi
  0006f	e8 00 00 00 00	 call	 PyList_Append
  00074	85 c0		 test	 eax, eax
  00076	78 25		 js	 SHORT $LN13@type_subcl
$LN4@type_subcl:

; 2741 :     for (i = 0; i < n; i++) {

  00078	48 ff c3	 inc	 rbx
  0007b	48 3b de	 cmp	 rbx, rsi
  0007e	7c d4		 jl	 SHORT $LL5@type_subcl
$LN15@type_subcl:

; 2749 :             }
; 2750 :         }
; 2751 :     }
; 2752 :     return list;

  00080	48 8b c7	 mov	 rax, rdi
$LN18@type_subcl:
  00083	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00088	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0008d	4c 8b 64 24 40	 mov	 r12, QWORD PTR [rsp+64]
$LN8@type_subcl:

; 2753 : }

  00092	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00097	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009b	5f		 pop	 rdi
  0009c	c3		 ret	 0
$LN13@type_subcl:

; 2747 :                 Py_DECREF(list);

  0009d	48 8b cf	 mov	 rcx, rdi
  000a0	e8 00 00 00 00	 call	 _Py_DecRef

; 2748 :                 return NULL;

  000a5	33 c0		 xor	 eax, eax
  000a7	eb da		 jmp	 SHORT $LN18@type_subcl
type_subclasses ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT type_prepare
_TEXT	SEGMENT
self$ = 8
args$ = 16
kwds$ = 24
type_prepare PROC					; COMDAT

; 2758 :     return PyDict_New();
; 2759 : }

  00000	e9 00 00 00 00	 jmp	 PyDict_New
type_prepare ENDP
_TEXT	ENDS
EXTRN	PySequence_GetItem:PROC
EXTRN	PySequence_Size:PROC
EXTRN	PyDict_Update:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$merge_class_dict DD imagerel merge_class_dict
	DD	imagerel merge_class_dict+440
	DD	imagerel $unwind$merge_class_dict
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$merge_class_dict DD 061101H
	DD	0b3411H
	DD	0700d5211H
	DD	0500b600cH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT merge_class_dict
_TEXT	SEGMENT
dict$ = 80
aclass$ = 88
n$1$ = 96
merge_class_dict PROC					; COMDAT

; 2771 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2772 :     PyObject *classdict;
; 2773 :     PyObject *bases;
; 2774 :     _Py_IDENTIFIER(__bases__);
; 2775 : 
; 2776 :     assert(PyDict_Check(dict));
; 2777 :     assert(aclass);
; 2778 : 
; 2779 :     /* Merge in the type's dict (if any). */
; 2780 :     classdict = _PyObject_GetAttrId(aclass, &PyId___dict__);

  00011	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00018	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00021	48 8b f2	 mov	 rsi, rdx
  00024	4a 8b 2c c0	 mov	 rbp, QWORD PTR [rax+r8*8]
  00028	48 8b d9	 mov	 rbx, rcx
  0002b	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId___dict__
  00030	48 03 d5	 add	 rdx, rbp
  00033	48 8b ce	 mov	 rcx, rsi
  00036	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  0003b	48 8b f8	 mov	 rdi, rax

; 2781 :     if (classdict == NULL)

  0003e	48 85 c0	 test	 rax, rax
  00041	75 07		 jne	 SHORT $LN12@merge_clas

; 2782 :         PyErr_Clear();

  00043	e8 00 00 00 00	 call	 PyErr_Clear

; 2783 :     else {

  00048	eb 22		 jmp	 SHORT $LN10@merge_clas
$LN12@merge_clas:

; 2784 :         int status = PyDict_Update(dict, classdict);

  0004a	48 8b d0	 mov	 rdx, rax
  0004d	48 8b cb	 mov	 rcx, rbx
  00050	e8 00 00 00 00	 call	 PyDict_Update

; 2785 :         Py_DECREF(classdict);

  00055	48 8b cf	 mov	 rcx, rdi
  00058	8b d8		 mov	 ebx, eax
  0005a	e8 00 00 00 00	 call	 _Py_DecRef

; 2786 :         if (status < 0)

  0005f	85 db		 test	 ebx, ebx

; 2787 :             return -1;

  00061	0f 88 11 01 00
	00		 js	 $LN31@merge_clas

; 2800 :         else {
; 2801 :             for (i = 0; i < n; i++) {

  00067	48 8b 5c 24 50	 mov	 rbx, QWORD PTR dict$[rsp]
$LN10@merge_clas:

; 2788 :     }
; 2789 : 
; 2790 :     /* Recursively merge in the base types' (if any) dicts. */
; 2791 :     bases = _PyObject_GetAttrId(aclass, &PyId___bases__);

  0006c	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___bases__@?1??merge_class_dict@@9@9
  00071	48 8b ce	 mov	 rcx, rsi
  00074	48 03 d5	 add	 rdx, rbp
  00077	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  0007c	48 8b f0	 mov	 rsi, rax

; 2792 :     if (bases == NULL)

  0007f	48 85 c0	 test	 rax, rax
  00082	75 14		 jne	 SHORT $LN9@merge_clas

; 2793 :         PyErr_Clear();

  00084	e8 00 00 00 00	 call	 PyErr_Clear

; 2817 :     }
; 2818 :     return 0;

  00089	33 c0		 xor	 eax, eax

; 2819 : }

  0008b	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00090	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00094	5f		 pop	 rdi
  00095	5e		 pop	 rsi
  00096	5d		 pop	 rbp
  00097	c3		 ret	 0
$LN9@merge_clas:

; 2794 :     else {
; 2795 :         /* We have no guarantee that bases is a real tuple */
; 2796 :         Py_ssize_t i, n;
; 2797 :         n = PySequence_Size(bases); /* This better be right */

  00098	48 8b c8	 mov	 rcx, rax
  0009b	e8 00 00 00 00	 call	 PySequence_Size
  000a0	48 89 44 24 60	 mov	 QWORD PTR n$1$[rsp], rax

; 2798 :         if (n < 0)

  000a5	48 85 c0	 test	 rax, rax
  000a8	79 77		 jns	 SHORT $LN7@merge_clas

; 2799 :             PyErr_Clear();

  000aa	e8 00 00 00 00	 call	 PyErr_Clear
$LN3@merge_clas:

; 2811 :                     Py_DECREF(bases);
; 2812 :                     return -1;
; 2813 :                 }
; 2814 :             }
; 2815 :         }
; 2816 :         Py_DECREF(bases);

  000af	e8 00 00 00 00	 call	 _Py_PXCTX
  000b4	85 c0		 test	 eax, eax
  000b6	0f 85 ed 00 00
	00		 jne	 $LN25@merge_clas
  000bc	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  000c0	a8 20		 test	 al, 32			; 00000020H
  000c2	0f 85 d9 00 00
	00		 jne	 $LN19@merge_clas
  000c8	84 c0		 test	 al, al
  000ca	0f 88 d1 00 00
	00		 js	 $LN19@merge_clas
  000d0	a8 02		 test	 al, 2
  000d2	0f 85 d1 00 00
	00		 jne	 $LN25@merge_clas
  000d8	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  000dc	0f 85 c7 00 00
	00		 jne	 $LN25@merge_clas
  000e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000f0	4c 8b ce	 mov	 r9, rsi
  000f3	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000f9	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00101	e8 00 00 00 00	 call	 _PyParallel_Guard
  00106	48 8b ce	 mov	 rcx, rsi
  00109	85 c0		 test	 eax, eax
  0010b	74 7b		 je	 SHORT $LN24@merge_clas
  0010d	e8 00 00 00 00	 call	 _Px_Dealloc

; 2817 :     }
; 2818 :     return 0;

  00112	33 c0		 xor	 eax, eax

; 2819 : }

  00114	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00119	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0011d	5f		 pop	 rdi
  0011e	5e		 pop	 rsi
  0011f	5d		 pop	 rbp
  00120	c3		 ret	 0
$LN7@merge_clas:

; 2800 :         else {
; 2801 :             for (i = 0; i < n; i++) {

  00121	33 ff		 xor	 edi, edi
  00123	48 85 c0	 test	 rax, rax
  00126	7e 87		 jle	 SHORT $LN3@merge_clas
  00128	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL5@merge_clas:

; 2802 :                 int status;
; 2803 :                 PyObject *base = PySequence_GetItem(bases, i);

  00130	48 8b d7	 mov	 rdx, rdi
  00133	48 8b ce	 mov	 rcx, rsi
  00136	e8 00 00 00 00	 call	 PySequence_GetItem
  0013b	48 8b e8	 mov	 rbp, rax

; 2804 :                 if (base == NULL) {

  0013e	48 85 c0	 test	 rax, rax
  00141	74 2d		 je	 SHORT $LN27@merge_clas

; 2807 :                 }
; 2808 :                 status = merge_class_dict(dict, base);

  00143	48 8b d0	 mov	 rdx, rax
  00146	48 8b cb	 mov	 rcx, rbx
  00149	e8 00 00 00 00	 call	 merge_class_dict

; 2809 :                 Py_DECREF(base);

  0014e	48 8b cd	 mov	 rcx, rbp
  00151	8b d8		 mov	 ebx, eax
  00153	e8 00 00 00 00	 call	 _Py_DecRef

; 2810 :                 if (status < 0) {

  00158	85 db		 test	 ebx, ebx
  0015a	78 14		 js	 SHORT $LN27@merge_clas

; 2800 :         else {
; 2801 :             for (i = 0; i < n; i++) {

  0015c	48 8b 5c 24 50	 mov	 rbx, QWORD PTR dict$[rsp]
  00161	48 ff c7	 inc	 rdi
  00164	48 3b 7c 24 60	 cmp	 rdi, QWORD PTR n$1$[rsp]
  00169	7c c5		 jl	 SHORT $LL5@merge_clas

; 2810 :                 if (status < 0) {

  0016b	e9 3f ff ff ff	 jmp	 $LN3@merge_clas
$LN27@merge_clas:

; 2805 :                     Py_DECREF(bases);

  00170	48 8b ce	 mov	 rcx, rsi
  00173	e8 00 00 00 00	 call	 _Py_DecRef
$LN31@merge_clas:

; 2806 :                     return -1;

  00178	83 c8 ff	 or	 eax, -1

; 2819 : }

  0017b	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00180	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00184	5f		 pop	 rdi
  00185	5e		 pop	 rsi
  00186	5d		 pop	 rbp
  00187	c3		 ret	 0

; 2811 :                     Py_DECREF(bases);
; 2812 :                     return -1;
; 2813 :                 }
; 2814 :             }
; 2815 :         }
; 2816 :         Py_DECREF(bases);

$LN24@merge_clas:
  00188	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  0018c	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 2817 :     }
; 2818 :     return 0;

  00192	33 c0		 xor	 eax, eax

; 2819 : }

  00194	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00199	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0019d	5f		 pop	 rdi
  0019e	5e		 pop	 rsi
  0019f	5d		 pop	 rbp
  001a0	c3		 ret	 0

; 2811 :                     Py_DECREF(bases);
; 2812 :                     return -1;
; 2813 :                 }
; 2814 :             }
; 2815 :         }
; 2816 :         Py_DECREF(bases);

$LN19@merge_clas:
  001a1	48 8b ce	 mov	 rcx, rsi
  001a4	e8 00 00 00 00	 call	 Px_DecRef
$LN25@merge_clas:

; 2817 :     }
; 2818 :     return 0;

  001a9	33 c0		 xor	 eax, eax

; 2819 : }

  001ab	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  001b0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001b4	5f		 pop	 rdi
  001b5	5e		 pop	 rsi
  001b6	5d		 pop	 rbp
  001b7	c3		 ret	 0
merge_class_dict ENDP
_TEXT	ENDS
EXTRN	PyDict_Keys:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$type_dir DD imagerel type_dir
	DD	imagerel type_dir+217
	DD	imagerel $unwind$type_dir
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_dir DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT type_dir
_TEXT	SEGMENT
self$ = 64
args$ = 72
type_dir PROC						; COMDAT

; 2827 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b f1	 mov	 rsi, rcx

; 2828 :     PyObject *result = NULL;

  00012	33 db		 xor	 ebx, ebx

; 2829 :     PyObject *dict = PyDict_New();

  00014	e8 00 00 00 00	 call	 PyDict_New
  00019	48 8b f8	 mov	 rdi, rax

; 2830 : 
; 2831 :     if (dict != NULL && merge_class_dict(dict, self) == 0)

  0001c	48 85 c0	 test	 rax, rax
  0001f	0f 84 a1 00 00
	00		 je	 $LN22@type_dir
  00025	48 8b d6	 mov	 rdx, rsi
  00028	48 8b c8	 mov	 rcx, rax
  0002b	e8 00 00 00 00	 call	 merge_class_dict
  00030	85 c0		 test	 eax, eax
  00032	75 0b		 jne	 SHORT $LN4@type_dir

; 2832 :         result = PyDict_Keys(dict);

  00034	48 8b cf	 mov	 rcx, rdi
  00037	e8 00 00 00 00	 call	 PyDict_Keys
  0003c	48 8b d8	 mov	 rbx, rax
$LN4@type_dir:

; 2833 : 
; 2834 :     Py_XDECREF(dict);

  0003f	e8 00 00 00 00	 call	 _Py_PXCTX
  00044	85 c0		 test	 eax, eax
  00046	75 7e		 jne	 SHORT $LN22@type_dir
  00048	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0004c	a8 20		 test	 al, 32			; 00000020H
  0004e	75 6e		 jne	 SHORT $LN12@type_dir
  00050	84 c0		 test	 al, al
  00052	78 6a		 js	 SHORT $LN12@type_dir
  00054	a8 02		 test	 al, 2
  00056	75 6e		 jne	 SHORT $LN22@type_dir
  00058	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0005c	75 68		 jne	 SHORT $LN22@type_dir
  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00065	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0006c	4c 8b cf	 mov	 r9, rdi
  0006f	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00075	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0007d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00082	48 8b cf	 mov	 rcx, rdi
  00085	85 c0		 test	 eax, eax
  00087	74 18		 je	 SHORT $LN17@type_dir
  00089	e8 00 00 00 00	 call	 _Px_Dealloc

; 2835 :     return result;

  0008e	48 8b c3	 mov	 rax, rbx

; 2836 : }

  00091	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00096	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0009b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009f	5f		 pop	 rdi
  000a0	c3		 ret	 0

; 2833 : 
; 2834 :     Py_XDECREF(dict);

$LN17@type_dir:
  000a1	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  000a5	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 2835 :     return result;

  000ab	48 8b c3	 mov	 rax, rbx

; 2836 : }

  000ae	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b3	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000b8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000bc	5f		 pop	 rdi
  000bd	c3		 ret	 0

; 2833 : 
; 2834 :     Py_XDECREF(dict);

$LN12@type_dir:
  000be	48 8b cf	 mov	 rcx, rdi
  000c1	e8 00 00 00 00	 call	 Px_DecRef
$LN22@type_dir:

; 2836 : }

  000c6	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000cb	48 8b c3	 mov	 rax, rbx
  000ce	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d7	5f		 pop	 rdi
  000d8	c3		 ret	 0
type_dir ENDP
_TEXT	ENDS
EXTRN	PyLong_FromSsize_t:PROC
EXTRN	_PyDict_KeysSize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$type_sizeof DD imagerel type_sizeof
	DD	imagerel type_sizeof+74
	DD	imagerel $unwind$type_sizeof
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_sizeof DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT type_sizeof
_TEXT	SEGMENT
self$ = 48
args_unused$ = 56
type_sizeof PROC					; COMDAT

; 2840 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2841 :     Py_ssize_t size;
; 2842 :     PyTypeObject *type = (PyTypeObject*)self;
; 2843 :     if (type->tp_flags & Py_TPFLAGS_HEAPTYPE) {

  00006	f7 81 00 01 00
	00 00 02 00 00	 test	 DWORD PTR [rcx+256], 512 ; 00000200H
  00010	74 26		 je	 SHORT $LN3@type_sizeo

; 2844 :         PyHeapTypeObject* et = (PyHeapTypeObject*)type;
; 2845 :         size = sizeof(PyHeapTypeObject);
; 2846 :         if (et->ht_cached_keys)

  00012	48 8b 89 80 03
	00 00		 mov	 rcx, QWORD PTR [rcx+896]
  00019	bb 90 03 00 00	 mov	 ebx, 912		; 00000390H
  0001e	48 85 c9	 test	 rcx, rcx
  00021	74 1a		 je	 SHORT $LN1@type_sizeo

; 2847 :             size += _PyDict_KeysSize(et->ht_cached_keys);

  00023	e8 00 00 00 00	 call	 _PyDict_KeysSize
  00028	48 03 d8	 add	 rbx, rax

; 2851 :     return PyLong_FromSsize_t(size);

  0002b	48 8b cb	 mov	 rcx, rbx

; 2852 : }

  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5b		 pop	 rbx
  00033	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
$LN3@type_sizeo:

; 2848 :     }
; 2849 :     else
; 2850 :         size = sizeof(PyTypeObject);

  00038	bb e0 01 00 00	 mov	 ebx, 480		; 000001e0H
$LN1@type_sizeo:

; 2851 :     return PyLong_FromSsize_t(size);

  0003d	48 8b cb	 mov	 rcx, rbx

; 2852 : }

  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5b		 pop	 rbx
  00045	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
type_sizeof ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@MAGJNODJ@type_traverse?$AA@		; `string'
PUBLIC	??_C@_0DC@IIFMCDJF@type_traverse?$CI?$CJ?5called?5for?5non?9h@ ; `string'
EXTRN	__imp_sprintf:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$type_traverse DD imagerel type_traverse
	DD	imagerel type_traverse+392
	DD	imagerel $unwind$type_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_traverse DD 071201H
	DD	0216412H
	DD	0203412H
	DD	01e0112H
	DD	0700bH
xdata	ENDS
;	COMDAT ??_C@_0O@MAGJNODJ@type_traverse?$AA@
CONST	SEGMENT
??_C@_0O@MAGJNODJ@type_traverse?$AA@ DB 'type_traverse', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@IIFMCDJF@type_traverse?$CI?$CJ?5called?5for?5non?9h@
CONST	SEGMENT
??_C@_0DC@IIFMCDJF@type_traverse?$CI?$CJ?5called?5for?5non?9h@ DB 'type_t'
	DB	'raverse() called for non-heap type ''%.100s''', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT type_traverse
_TEXT	SEGMENT
msg$22695 = 32
type$ = 256
visit$ = 264
arg$ = 272
type_traverse PROC					; COMDAT

; 2880 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec f0 00
	00 00		 sub	 rsp, 240		; 000000f0H

; 2881 :     /* Because of type_is_gc(), the collector only calls this
; 2882 :        for heaptypes. */
; 2883 :     if (!(type->tp_flags & Py_TPFLAGS_HEAPTYPE)) {

  00012	f7 81 00 01 00
	00 00 02 00 00	 test	 DWORD PTR [rcx+256], 512 ; 00000200H
  0001c	49 8b f8	 mov	 rdi, r8
  0001f	48 8b f2	 mov	 rsi, rdx
  00022	48 8b d9	 mov	 rbx, rcx
  00025	75 20		 jne	 SHORT $LN30@type_trave

; 2884 :         char msg[200];
; 2885 :         sprintf(msg, "type_traverse() called for non-heap type '%.100s'",
; 2886 :                 type->tp_name);

  00027	4c 8b 41 70	 mov	 r8, QWORD PTR [rcx+112]
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@IIFMCDJF@type_traverse?$CI?$CJ?5called?5for?5non?9h@
  00032	48 8d 4c 24 20	 lea	 rcx, QWORD PTR msg$22695[rsp]
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf

; 2887 :         Py_FatalError(msg);

  0003d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR msg$22695[rsp]
  00042	e8 00 00 00 00	 call	 Py_FatalError
$LN30@type_trave:

; 2888 :     }
; 2889 : 
; 2890 :     Py_VISIT(type->tp_dict);

  00047	e8 00 00 00 00	 call	 _Py_PXCTX
  0004c	85 c0		 test	 eax, eax
  0004e	74 1c		 je	 SHORT $LN27@type_trave
  00050	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  00057	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MAGJNODJ@type_traverse?$AA@
  0005e	45 33 c9	 xor	 r9d, r9d
  00061	41 b8 4a 0b 00
	00		 mov	 r8d, 2890		; 00000b4aH
  00067	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN27@type_trave:
  0006c	48 8b 8b 60 01
	00 00		 mov	 rcx, QWORD PTR [rbx+352]
  00073	48 85 c9	 test	 rcx, rcx
  00076	74 0d		 je	 SHORT $LN29@type_trave
  00078	48 8b d7	 mov	 rdx, rdi
  0007b	ff d6		 call	 rsi
  0007d	85 c0		 test	 eax, eax
  0007f	0f 85 ee 00 00
	00		 jne	 $LN32@type_trave
$LN29@type_trave:

; 2891 :     Py_VISIT(type->tp_cache);

  00085	e8 00 00 00 00	 call	 _Py_PXCTX
  0008a	85 c0		 test	 eax, eax
  0008c	74 1c		 je	 SHORT $LN21@type_trave
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MAGJNODJ@type_traverse?$AA@
  0009c	45 33 c9	 xor	 r9d, r9d
  0009f	41 b8 4b 0b 00
	00		 mov	 r8d, 2891		; 00000b4bH
  000a5	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN21@type_trave:
  000aa	48 8b 8b b8 01
	00 00		 mov	 rcx, QWORD PTR [rbx+440]
  000b1	48 85 c9	 test	 rcx, rcx
  000b4	74 0d		 je	 SHORT $LN23@type_trave
  000b6	48 8b d7	 mov	 rdx, rdi
  000b9	ff d6		 call	 rsi
  000bb	85 c0		 test	 eax, eax
  000bd	0f 85 b0 00 00
	00		 jne	 $LN32@type_trave
$LN23@type_trave:

; 2892 :     Py_VISIT(type->tp_mro);

  000c3	e8 00 00 00 00	 call	 _Py_PXCTX
  000c8	85 c0		 test	 eax, eax
  000ca	74 1c		 je	 SHORT $LN15@type_trave
  000cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  000d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MAGJNODJ@type_traverse?$AA@
  000da	45 33 c9	 xor	 r9d, r9d
  000dd	41 b8 4c 0b 00
	00		 mov	 r8d, 2892		; 00000b4cH
  000e3	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN15@type_trave:
  000e8	48 8b 8b b0 01
	00 00		 mov	 rcx, QWORD PTR [rbx+432]
  000ef	48 85 c9	 test	 rcx, rcx
  000f2	74 09		 je	 SHORT $LN17@type_trave
  000f4	48 8b d7	 mov	 rdx, rdi
  000f7	ff d6		 call	 rsi
  000f9	85 c0		 test	 eax, eax
  000fb	75 76		 jne	 SHORT $LN32@type_trave
$LN17@type_trave:

; 2893 :     Py_VISIT(type->tp_bases);

  000fd	e8 00 00 00 00	 call	 _Py_PXCTX
  00102	85 c0		 test	 eax, eax
  00104	74 1c		 je	 SHORT $LN9@type_trave
  00106	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  0010d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MAGJNODJ@type_traverse?$AA@
  00114	45 33 c9	 xor	 r9d, r9d
  00117	41 b8 4d 0b 00
	00		 mov	 r8d, 2893		; 00000b4dH
  0011d	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@type_trave:
  00122	48 8b 8b a8 01
	00 00		 mov	 rcx, QWORD PTR [rbx+424]
  00129	48 85 c9	 test	 rcx, rcx
  0012c	74 09		 je	 SHORT $LN11@type_trave
  0012e	48 8b d7	 mov	 rdx, rdi
  00131	ff d6		 call	 rsi
  00133	85 c0		 test	 eax, eax
  00135	75 3c		 jne	 SHORT $LN32@type_trave
$LN11@type_trave:

; 2894 :     Py_VISIT(type->tp_base);

  00137	e8 00 00 00 00	 call	 _Py_PXCTX
  0013c	85 c0		 test	 eax, eax
  0013e	74 1c		 je	 SHORT $LN3@type_trave
  00140	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  00147	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MAGJNODJ@type_traverse?$AA@
  0014e	45 33 c9	 xor	 r9d, r9d
  00151	41 b8 4e 0b 00
	00		 mov	 r8d, 2894		; 00000b4eH
  00157	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@type_trave:
  0015c	48 8b 8b 58 01
	00 00		 mov	 rcx, QWORD PTR [rbx+344]
  00163	48 85 c9	 test	 rcx, rcx
  00166	74 09		 je	 SHORT $LN5@type_trave
  00168	48 8b d7	 mov	 rdx, rdi
  0016b	ff d6		 call	 rsi
  0016d	85 c0		 test	 eax, eax
  0016f	75 02		 jne	 SHORT $LN32@type_trave
$LN5@type_trave:

; 2895 : 
; 2896 :     /* There's no need to visit type->tp_subclasses or
; 2897 :        ((PyHeapTypeObject *)type)->ht_slots, because they can't be involved
; 2898 :        in cycles; tp_subclasses is a list of weak references,
; 2899 :        and slots is a tuple of strings. */
; 2900 : 
; 2901 :     return 0;

  00171	33 c0		 xor	 eax, eax
$LN32@type_trave:

; 2902 : }

  00173	4c 8d 9c 24 f0
	00 00 00	 lea	 r11, QWORD PTR [rsp+240]
  0017b	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  0017f	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  00183	49 8b e3	 mov	 rsp, r11
  00186	5f		 pop	 rdi
  00187	c3		 ret	 0
type_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@OHKMGPIO@type_clear?$AA@		; `string'
EXTRN	PyDict_Clear:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$type_clear DD imagerel type_clear
	DD	imagerel type_clear+116
	DD	imagerel $unwind$type_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$type_clear DD imagerel type_clear+116
	DD	imagerel type_clear+231
	DD	imagerel $chain$0$type_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$type_clear DD imagerel type_clear+231
	DD	imagerel type_clear+254
	DD	imagerel $chain$2$type_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$type_clear DD imagerel type_clear+254
	DD	imagerel type_clear+267
	DD	imagerel $chain$4$type_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$type_clear DD imagerel type_clear+267
	DD	imagerel type_clear+275
	DD	imagerel $chain$5$type_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$type_clear DD 021H
	DD	imagerel type_clear
	DD	imagerel type_clear+116
	DD	imagerel $unwind$type_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$type_clear DD 020021H
	DD	083400H
	DD	imagerel type_clear
	DD	imagerel type_clear+116
	DD	imagerel $unwind$type_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$type_clear DD 020021H
	DD	083400H
	DD	imagerel type_clear
	DD	imagerel type_clear+116
	DD	imagerel $unwind$type_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$type_clear DD 020521H
	DD	083405H
	DD	imagerel type_clear
	DD	imagerel type_clear+116
	DD	imagerel $unwind$type_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_clear DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT ??_C@_0L@OHKMGPIO@type_clear?$AA@
CONST	SEGMENT
??_C@_0L@OHKMGPIO@type_clear?$AA@ DB 'type_clear', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
CONST	ENDS
;	COMDAT type_clear
_TEXT	SEGMENT
type$ = 64
type_clear PROC						; COMDAT

; 2906 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b f9	 mov	 rdi, rcx

; 2907 :     PyDictKeysObject *cached_keys;
; 2908 :     /* Because of type_is_gc(), the collector only calls this
; 2909 :        for heaptypes. */
; 2910 :     assert(type->tp_flags & Py_TPFLAGS_HEAPTYPE);
; 2911 : 
; 2912 :     /* We need to invalidate the method cache carefully before clearing
; 2913 :        the dict, so that other objects caught in a reference cycle
; 2914 :        don't start calling destroyed methods.
; 2915 : 
; 2916 :        Otherwise, the only field we need to clear is tp_mro, which is
; 2917 :        part of a hard cycle (its first element is the class itself) that
; 2918 :        won't be broken otherwise (it's a tuple and tuples don't have a
; 2919 :        tp_clear handler).  None of the other fields need to be
; 2920 :        cleared, and here's why:
; 2921 : 
; 2922 :        tp_cache:
; 2923 :            Not used; if it were, it would be a dict.
; 2924 : 
; 2925 :        tp_bases, tp_base:
; 2926 :            If these are involved in a cycle, there must be at least
; 2927 :            one other, mutable object in the cycle, e.g. a base
; 2928 :            class's dict; the cycle will be broken that way.
; 2929 : 
; 2930 :        tp_subclasses:
; 2931 :            A list of weak references can't be part of a cycle; and
; 2932 :            lists have their own tp_clear.
; 2933 : 
; 2934 :        slots (in PyHeapTypeObject):
; 2935 :            A tuple of strings can't be part of a cycle.
; 2936 :     */
; 2937 : 
; 2938 :     PyType_Modified(type);

  00009	e8 00 00 00 00	 call	 PyType_Modified

; 2939 :     cached_keys = ((PyHeapTypeObject *)type)->ht_cached_keys;

  0000e	48 8b 8f 80 03
	00 00		 mov	 rcx, QWORD PTR [rdi+896]

; 2940 :     if (cached_keys != NULL) {

  00015	48 85 c9	 test	 rcx, rcx
  00018	74 10		 je	 SHORT $LN6@type_clear

; 2941 :         ((PyHeapTypeObject *)type)->ht_cached_keys = NULL;

  0001a	48 c7 87 80 03
	00 00 00 00 00
	00		 mov	 QWORD PTR [rdi+896], 0

; 2942 :         _PyDictKeys_DecRef(cached_keys);

  00025	e8 00 00 00 00	 call	 _PyDictKeys_DecRef
$LN6@type_clear:

; 2943 :     }
; 2944 :     if (type->tp_dict)

  0002a	48 8b 8f 60 01
	00 00		 mov	 rcx, QWORD PTR [rdi+352]
  00031	48 85 c9	 test	 rcx, rcx
  00034	74 05		 je	 SHORT $LN4@type_clear

; 2945 :         PyDict_Clear(type->tp_dict);

  00036	e8 00 00 00 00	 call	 PyDict_Clear
$LN4@type_clear:

; 2946 :     Py_CLEAR(type->tp_mro);

  0003b	4c 8b 8f b0 01
	00 00		 mov	 r9, QWORD PTR [rdi+432]
  00042	4d 85 c9	 test	 r9, r9
  00045	0f 84 c0 00 00
	00		 je	 $LN23@type_clear
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@OHKMGPIO@type_clear?$AA@
  00059	41 b8 82 0b 00
	00		 mov	 r8d, 2946		; 00000b82H
  0005f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00067	e8 00 00 00 00	 call	 _PyParallel_Guard
  0006c	85 c0		 test	 eax, eax
  0006e	0f 85 97 00 00
	00		 jne	 $LN23@type_clear
  00074	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00079	48 8b 9f b0 01
	00 00		 mov	 rbx, QWORD PTR [rdi+432]
  00080	48 c7 87 b0 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rdi+432], 0
  0008b	e8 00 00 00 00	 call	 _Py_PXCTX
  00090	85 c0		 test	 eax, eax
  00092	75 72		 jne	 SHORT $LN24@type_clear
  00094	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00098	a8 20		 test	 al, 32			; 00000020H
  0009a	75 62		 jne	 SHORT $LN13@type_clear
  0009c	84 c0		 test	 al, al
  0009e	78 5e		 js	 SHORT $LN13@type_clear
  000a0	a8 02		 test	 al, 2
  000a2	75 62		 jne	 SHORT $LN24@type_clear
  000a4	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000a8	75 5c		 jne	 SHORT $LN24@type_clear
  000aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000b8	4c 8b cb	 mov	 r9, rbx
  000bb	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000c1	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000c9	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ce	48 8b cb	 mov	 rcx, rbx
  000d1	85 c0		 test	 eax, eax
  000d3	74 12		 je	 SHORT $LN18@type_clear
  000d5	e8 00 00 00 00	 call	 _Px_Dealloc
  000da	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 2947 : 
; 2948 :     return 0;

  000df	33 c0		 xor	 eax, eax

; 2949 : }

  000e1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e5	5f		 pop	 rdi
  000e6	c3		 ret	 0

; 2946 :     Py_CLEAR(type->tp_mro);

$LN18@type_clear:
  000e7	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000eb	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000f1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 2947 : 
; 2948 :     return 0;

  000f6	33 c0		 xor	 eax, eax

; 2949 : }

  000f8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000fc	5f		 pop	 rdi
  000fd	c3		 ret	 0

; 2946 :     Py_CLEAR(type->tp_mro);

$LN13@type_clear:
  000fe	48 8b cb	 mov	 rcx, rbx
  00101	e8 00 00 00 00	 call	 Px_DecRef
$LN24@type_clear:
  00106	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN23@type_clear:

; 2947 : 
; 2948 :     return 0;

  0010b	33 c0		 xor	 eax, eax

; 2949 : }

  0010d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00111	5f		 pop	 rdi
  00112	c3		 ret	 0
type_clear ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT type_is_gc
_TEXT	SEGMENT
type$ = 8
type_is_gc PROC						; COMDAT

; 2954 :     return type->tp_flags & Py_TPFLAGS_HEAPTYPE;

  00000	8b 81 00 01 00
	00		 mov	 eax, DWORD PTR [rcx+256]
  00006	25 00 02 00 00	 and	 eax, 512		; 00000200H

; 2955 : }

  0000b	c3		 ret	 0
type_is_gc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$excess_args DD imagerel excess_args
	DD	imagerel excess_args+62
	DD	imagerel $unwind$excess_args
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$excess_args DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT excess_args
_TEXT	SEGMENT
args$ = 48
kwds$ = 56
excess_args PROC					; COMDAT

; 3050 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3051 :     return PyTuple_GET_SIZE(args) ||
; 3052 :         (kwds && PyDict_Check(kwds) && PyDict_Size(kwds));

  00004	48 83 79 60 00	 cmp	 QWORD PTR [rcx+96], 0
  00009	75 29		 jne	 SHORT $LN4@excess_arg
  0000b	48 85 d2	 test	 rdx, rdx
  0000e	74 1d		 je	 SHORT $LN3@excess_arg
  00010	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00014	f7 80 00 01 00
	00 00 00 00 20	 test	 DWORD PTR [rax+256], 536870912 ; 20000000H
  0001e	74 0d		 je	 SHORT $LN3@excess_arg
  00020	48 8b ca	 mov	 rcx, rdx
  00023	e8 00 00 00 00	 call	 PyDict_Size
  00028	48 85 c0	 test	 rax, rax
  0002b	75 07		 jne	 SHORT $LN4@excess_arg
$LN3@excess_arg:
  0002d	33 c0		 xor	 eax, eax

; 3053 : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
$LN4@excess_arg:

; 3051 :     return PyTuple_GET_SIZE(args) ||
; 3052 :         (kwds && PyDict_Check(kwds) && PyDict_Size(kwds));

  00034	b8 01 00 00 00	 mov	 eax, 1

; 3053 : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
excess_args ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@NDEKFCCG@object?4__init__?$CI?$CJ?5takes?5no?5param@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$object_init DD imagerel object_init
	DD	imagerel object_init+96
	DD	imagerel $unwind$object_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$object_init DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CG@NDEKFCCG@object?4__init__?$CI?$CJ?5takes?5no?5param@
CONST	SEGMENT
??_C@_0CG@NDEKFCCG@object?4__init__?$CI?$CJ?5takes?5no?5param@ DB 'object'
	DB	'.__init__() takes no parameters', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT object_init
_TEXT	SEGMENT
self$ = 48
args$ = 56
kwds$ = 64
object_init PROC					; COMDAT

; 3057 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3058 :     int err = 0;
; 3059 :     PyTypeObject *type = Py_TYPE(self);

  00006	48 8b 59 58	 mov	 rbx, QWORD PTR [rcx+88]
  0000a	4c 8b ca	 mov	 r9, rdx

; 3060 :     if (excess_args(args, kwds) &&
; 3061 :         (type->tp_new == object_new || type->tp_init != object_init)) {

  0000d	49 8b d0	 mov	 rdx, r8
  00010	49 8b c9	 mov	 rcx, r9
  00013	e8 00 00 00 00	 call	 excess_args
  00018	85 c0		 test	 eax, eax
  0001a	74 3c		 je	 SHORT $LN5@object_ini
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:object_new
  00023	48 39 8b 90 01
	00 00		 cmp	 QWORD PTR [rbx+400], rcx
  0002a	74 10		 je	 SHORT $LN1@object_ini
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:object_init
  00033	48 39 8b 80 01
	00 00		 cmp	 QWORD PTR [rbx+384], rcx

; 3063 :         err = -1;

  0003a	74 1c		 je	 SHORT $LN5@object_ini
$LN1@object_ini:

; 3062 :         PyErr_SetString(PyExc_TypeError, "object.__init__() takes no parameters");

  0003c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@NDEKFCCG@object?4__init__?$CI?$CJ?5takes?5no?5param@
  0004a	e8 00 00 00 00	 call	 PyErr_SetString

; 3064 :     }
; 3065 :     return err;

  0004f	83 c8 ff	 or	 eax, -1

; 3066 : }

  00052	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00056	5b		 pop	 rbx
  00057	c3		 ret	 0
$LN5@object_ini:

; 3064 :     }
; 3065 :     return err;

  00058	33 c0		 xor	 eax, eax

; 3066 : }

  0005a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005e	5b		 pop	 rbx
  0005f	c3		 ret	 0
object_init ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DN@EFMEECOC@Can?8t?5instantiate?5abstract?5class@ ; `string'
PUBLIC	??_C@_0BN@NPFLIDJG@object?$CI?$CJ?5takes?5no?5parameters?$AA@ ; `string'
EXTRN	PyUnicode_Join:PROC
EXTRN	PyObject_CallFunctionObjArgs:PROC
EXTRN	PyEval_GetBuiltins:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$object_new DD imagerel object_new
	DD	imagerel object_new+107
	DD	imagerel $unwind$object_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$object_new DD imagerel object_new+107
	DD	imagerel object_new+158
	DD	imagerel $chain$0$object_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$object_new DD imagerel object_new+158
	DD	imagerel object_new+197
	DD	imagerel $chain$1$object_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$object_new DD imagerel object_new+197
	DD	imagerel object_new+299
	DD	imagerel $chain$2$object_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$object_new DD imagerel object_new+299
	DD	imagerel object_new+304
	DD	imagerel $chain$3$object_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$object_new DD imagerel object_new+304
	DD	imagerel object_new+325
	DD	imagerel $chain$4$object_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$object_new DD imagerel object_new+325
	DD	imagerel object_new+340
	DD	imagerel $chain$5$object_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$object_new DD 021H
	DD	imagerel object_new
	DD	imagerel object_new+107
	DD	imagerel $unwind$object_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$object_new DD 021H
	DD	imagerel object_new+107
	DD	imagerel object_new+158
	DD	imagerel $chain$0$object_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$object_new DD 021H
	DD	imagerel object_new+158
	DD	imagerel object_new+197
	DD	imagerel $chain$1$object_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$object_new DD 020521H
	DD	076405H
	DD	imagerel object_new+158
	DD	imagerel object_new+197
	DD	imagerel $chain$1$object_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$object_new DD 020521H
	DD	065405H
	DD	imagerel object_new+107
	DD	imagerel object_new+158
	DD	imagerel $chain$0$object_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$object_new DD 020521H
	DD	087405H
	DD	imagerel object_new
	DD	imagerel object_new+107
	DD	imagerel $unwind$object_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$object_new DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0DN@EFMEECOC@Can?8t?5instantiate?5abstract?5class@
CONST	SEGMENT
??_C@_0DN@EFMEECOC@Can?8t?5instantiate?5abstract?5class@ DB 'Can''t insta'
	DB	'ntiate abstract class %s with abstract methods %U', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NPFLIDJG@object?$CI?$CJ?5takes?5no?5parameters?$AA@
CONST	SEGMENT
??_C@_0BN@NPFLIDJG@object?$CI?$CJ?5takes?5no?5parameters?$AA@ DB 'object('
	DB	') takes no parameters', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT object_new
_TEXT	SEGMENT
type$ = 48
args$ = 56
kwds$ = 64
object_new PROC						; COMDAT

; 3070 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 3071 :     if (excess_args(args, kwds) &&
; 3072 :         (type->tp_init == object_init || type->tp_new != object_new)) {

  0000c	49 8b d0	 mov	 rdx, r8
  0000f	48 8b c8	 mov	 rcx, rax
  00012	e8 00 00 00 00	 call	 excess_args
  00017	85 c0		 test	 eax, eax
  00019	74 3b		 je	 SHORT $LN21@object_new
  0001b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:object_init
  00022	48 39 83 80 01
	00 00		 cmp	 QWORD PTR [rbx+384], rax
  00029	74 10		 je	 SHORT $LN20@object_new
  0002b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:object_new
  00032	48 39 83 90 01
	00 00		 cmp	 QWORD PTR [rbx+400], rax
  00039	74 1b		 je	 SHORT $LN21@object_new
$LN20@object_new:

; 3073 :         PyErr_SetString(PyExc_TypeError, "object() takes no parameters");

  0003b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@NPFLIDJG@object?$CI?$CJ?5takes?5no?5parameters?$AA@
  00049	e8 00 00 00 00	 call	 PyErr_SetString

; 3074 :         return NULL;

  0004e	33 c0		 xor	 eax, eax

; 3120 :     }
; 3121 :     return type->tp_alloc(type, 0);
; 3122 : }

  00050	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00054	5b		 pop	 rbx
  00055	c3		 ret	 0
$LN21@object_new:

; 3075 :     }
; 3076 : 
; 3077 :     if (type->tp_flags & Py_TPFLAGS_IS_ABSTRACT) {
; 3078 :         PyObject *abstract_methods = NULL;
; 3079 :         PyObject *builtins;
; 3080 :         PyObject *sorted;
; 3081 :         PyObject *sorted_methods = NULL;
; 3082 :         PyObject *joined = NULL;
; 3083 :         PyObject *comma;
; 3084 :         _Py_static_string(comma_id, ", ");
; 3085 :         _Py_IDENTIFIER(sorted);
; 3086 : 
; 3087 :         /* Compute ", ".join(sorted(type.__abstractmethods__))
; 3088 :            into joined. */
; 3089 :         abstract_methods = type_abstractmethods(type, NULL);

  00056	33 d2		 xor	 edx, edx
  00058	f7 83 00 01 00
	00 00 00 10 00	 test	 DWORD PTR [rbx+256], 1048576 ; 00100000H
  00062	48 8b cb	 mov	 rcx, rbx
  00065	0f 84 da 00 00
	00		 je	 $LN19@object_new
  0006b	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00070	e8 00 00 00 00	 call	 type_abstractmethods
  00075	48 8b f8	 mov	 rdi, rax

; 3090 :         if (abstract_methods == NULL)

  00078	48 85 c0	 test	 rax, rax
  0007b	0f 84 b7 00 00
	00		 je	 $LN3@object_new

; 3091 :             goto error;
; 3092 :         builtins = PyEval_GetBuiltins();

  00081	e8 00 00 00 00	 call	 PyEval_GetBuiltins

; 3093 :         if (builtins == NULL)

  00086	48 85 c0	 test	 rax, rax
  00089	0f 84 a1 00 00
	00		 je	 $LN7@object_new

; 3094 :             goto error;
; 3095 :         sorted = _PyDict_GetItemId(builtins, &PyId_sorted);

  0008f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00095	65 48 8b 0c 25
	58 00 00 00	 mov	 rcx, QWORD PTR gs:88
  0009e	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  000a3	48 8b 2c d1	 mov	 rbp, QWORD PTR [rcx+rdx*8]
  000a7	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_sorted@?3??object_new@@9@9
  000ac	48 8b c8	 mov	 rcx, rax
  000af	48 03 d5	 add	 rdx, rbp
  000b2	e8 00 00 00 00	 call	 _PyDict_GetItemId

; 3096 :         if (sorted == NULL)

  000b7	48 85 c0	 test	 rax, rax
  000ba	74 6f		 je	 SHORT $LN24@object_new

; 3097 :             goto error;
; 3098 :         sorted_methods = PyObject_CallFunctionObjArgs(sorted,
; 3099 :                                                       abstract_methods,
; 3100 :                                                       NULL);

  000bc	45 33 c0	 xor	 r8d, r8d
  000bf	48 8b d7	 mov	 rdx, rdi
  000c2	48 8b c8	 mov	 rcx, rax
  000c5	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  000ca	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  000cf	48 8b f0	 mov	 rsi, rax

; 3101 :         if (sorted_methods == NULL)

  000d2	48 85 c0	 test	 rax, rax
  000d5	74 4f		 je	 SHORT $LN25@object_new

; 3102 :             goto error;
; 3103 :         comma = _PyUnicode_FromId(&comma_id);

  000d7	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?comma_id@?3??object_new@@9@9
  000dc	48 03 cd	 add	 rcx, rbp
  000df	e8 00 00 00 00	 call	 _PyUnicode_FromId

; 3104 :         if (comma == NULL)

  000e4	48 85 c0	 test	 rax, rax
  000e7	74 35		 je	 SHORT $LN11@object_new

; 3105 :             goto error;
; 3106 :         joined = PyUnicode_Join(comma, sorted_methods);

  000e9	48 8b d6	 mov	 rdx, rsi
  000ec	48 8b c8	 mov	 rcx, rax
  000ef	e8 00 00 00 00	 call	 PyUnicode_Join
  000f4	48 8b e8	 mov	 rbp, rax

; 3107 :         if (joined == NULL)

  000f7	48 85 c0	 test	 rax, rax
  000fa	74 22		 je	 SHORT $LN11@object_new

; 3108 :             goto error;
; 3109 : 
; 3110 :         PyErr_Format(PyExc_TypeError,
; 3111 :                      "Can't instantiate abstract class %s "
; 3112 :                      "with abstract methods %U",
; 3113 :                      type->tp_name,
; 3114 :                      joined);

  000fc	4c 8b 43 70	 mov	 r8, QWORD PTR [rbx+112]
  00100	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00107	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DN@EFMEECOC@Can?8t?5instantiate?5abstract?5class@
  0010e	4c 8b c8	 mov	 r9, rax
  00111	e8 00 00 00 00	 call	 PyErr_Format

; 3115 :     error:
; 3116 :         Py_XDECREF(joined);

  00116	48 8b cd	 mov	 rcx, rbp
$error$22850:
  00119	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@object_new:

; 3117 :         Py_XDECREF(sorted_methods);

  0011e	48 8b ce	 mov	 rcx, rsi
  00121	e8 00 00 00 00	 call	 _Py_DecRef
$LN25@object_new:
  00126	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
$LN24@object_new:
  0012b	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
$LN7@object_new:

; 3118 :         Py_XDECREF(abstract_methods);

  00130	48 8b cf	 mov	 rcx, rdi
  00133	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@object_new:

; 3119 :         return NULL;

  00138	33 c0		 xor	 eax, eax
  0013a	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 3120 :     }
; 3121 :     return type->tp_alloc(type, 0);
; 3122 : }

  0013f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00143	5b		 pop	 rbx
  00144	c3		 ret	 0
$LN19@object_new:
  00145	48 8b 83 88 01
	00 00		 mov	 rax, QWORD PTR [rbx+392]
  0014c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00150	5b		 pop	 rbx
  00151	48 ff e0	 rex_jmp rax
object_new ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT object_dealloc
_TEXT	SEGMENT
self$ = 8
object_dealloc PROC					; COMDAT

; 3127 :     Py_TYPE(self)->tp_free(self);

  00000	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]

; 3128 : }

  00004	48 ff a0 98 01
	00 00		 rex_jmp QWORD PTR [rax+408]
object_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@JEBMOEBF@?$DM?$CFs?5object?5at?5?$CFp?$DO?$AA@ ; `string'
PUBLIC	??_C@_0BF@GHELCLKE@?$DM?$CFU?4?$CFU?5object?5at?5?$CFp?$DO?$AA@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$object_repr DD imagerel object_repr
	DD	imagerel object_repr+426
	DD	imagerel $unwind$object_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$object_repr DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT ??_C@_0BC@JEBMOEBF@?$DM?$CFs?5object?5at?5?$CFp?$DO?$AA@
CONST	SEGMENT
??_C@_0BC@JEBMOEBF@?$DM?$CFs?5object?5at?5?$CFp?$DO?$AA@ DB '<%s object a'
	DB	't %p>', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GHELCLKE@?$DM?$CFU?4?$CFU?5object?5at?5?$CFp?$DO?$AA@
CONST	SEGMENT
??_C@_0BF@GHELCLKE@?$DM?$CFU?4?$CFU?5object?5at?5?$CFp?$DO?$AA@ DB '<%U.%'
	DB	'U object at %p>', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
CONST	ENDS
;	COMDAT object_repr
_TEXT	SEGMENT
self$ = 64
object_repr PROC					; COMDAT

; 3132 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3133 :     PyTypeObject *type;
; 3134 :     PyObject *mod, *name, *rtn;
; 3135 : 
; 3136 :     type = Py_TYPE(self);

  00014	48 8b 79 58	 mov	 rdi, QWORD PTR [rcx+88]
  00018	48 8b e9	 mov	 rbp, rcx

; 3137 :     mod = type_module(type, NULL);

  0001b	33 d2		 xor	 edx, edx
  0001d	48 8b cf	 mov	 rcx, rdi
  00020	e8 00 00 00 00	 call	 type_module
  00025	48 8b d8	 mov	 rbx, rax

; 3138 :     if (mod == NULL)

  00028	48 85 c0	 test	 rax, rax
  0002b	75 07		 jne	 SHORT $LN14@object_rep

; 3139 :         PyErr_Clear();

  0002d	e8 00 00 00 00	 call	 PyErr_Clear
  00032	eb 1a		 jmp	 SHORT $LN12@object_rep
$LN14@object_rep:

; 3140 :     else if (!PyUnicode_Check(mod)) {

  00034	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00038	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00042	75 0a		 jne	 SHORT $LN12@object_rep

; 3141 :         Py_DECREF(mod);

  00044	48 8b cb	 mov	 rcx, rbx
  00047	e8 00 00 00 00	 call	 _Py_DecRef

; 3142 :         mod = NULL;

  0004c	33 db		 xor	 ebx, ebx
$LN12@object_rep:

; 3143 :     }
; 3144 :     name = type_qualname(type, NULL);

  0004e	33 d2		 xor	 edx, edx
  00050	48 8b cf	 mov	 rcx, rdi
  00053	e8 00 00 00 00	 call	 type_qualname
  00058	48 8b f0	 mov	 rsi, rax

; 3145 :     if (name == NULL) {

  0005b	48 85 c0	 test	 rax, rax
  0005e	75 7b		 jne	 SHORT $LN11@object_rep

; 3146 :         Py_XDECREF(mod);

  00060	48 85 db	 test	 rbx, rbx
  00063	74 6f		 je	 SHORT $LN9@object_rep
  00065	e8 00 00 00 00	 call	 _Py_PXCTX
  0006a	85 c0		 test	 eax, eax
  0006c	75 66		 jne	 SHORT $LN9@object_rep
  0006e	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00072	a8 20		 test	 al, 32			; 00000020H
  00074	75 56		 jne	 SHORT $LN21@object_rep
  00076	84 c0		 test	 al, al
  00078	78 52		 js	 SHORT $LN21@object_rep
  0007a	a8 02		 test	 al, 2
  0007c	75 56		 jne	 SHORT $LN9@object_rep
  0007e	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00082	75 50		 jne	 SHORT $LN9@object_rep
  00084	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0008b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00092	4c 8b cb	 mov	 r9, rbx
  00095	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0009b	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000a3	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a8	48 8b cb	 mov	 rcx, rbx
  000ab	85 c0		 test	 eax, eax
  000ad	74 0c		 je	 SHORT $LN26@object_rep
  000af	e8 00 00 00 00	 call	 _Px_Dealloc

; 3147 :         return NULL;

  000b4	33 c0		 xor	 eax, eax
  000b6	e9 da 00 00 00	 jmp	 $LN15@object_rep

; 3146 :         Py_XDECREF(mod);

$LN26@object_rep:
  000bb	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000bf	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 3147 :         return NULL;

  000c5	33 c0		 xor	 eax, eax
  000c7	e9 c9 00 00 00	 jmp	 $LN15@object_rep

; 3146 :         Py_XDECREF(mod);

$LN21@object_rep:
  000cc	48 8b cb	 mov	 rcx, rbx
  000cf	e8 00 00 00 00	 call	 Px_DecRef
$LN9@object_rep:

; 3147 :         return NULL;

  000d4	33 c0		 xor	 eax, eax
  000d6	e9 ba 00 00 00	 jmp	 $LN15@object_rep
$LN11@object_rep:

; 3148 :     }
; 3149 :     if (mod != NULL && PyUnicode_CompareWithASCIIString(mod, "builtins"))

  000db	48 85 db	 test	 rbx, rbx
  000de	74 2a		 je	 SHORT $LN6@object_rep
  000e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08OCOMCJAJ@builtins?$AA@
  000e7	48 8b cb	 mov	 rcx, rbx
  000ea	e8 00 00 00 00	 call	 PyUnicode_CompareWithASCIIString
  000ef	85 c0		 test	 eax, eax
  000f1	74 17		 je	 SHORT $LN6@object_rep

; 3150 :         rtn = PyUnicode_FromFormat("<%U.%U object at %p>", mod, name, self);

  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@GHELCLKE@?$DM?$CFU?4?$CFU?5object?5at?5?$CFp?$DO?$AA@
  000fa	4c 8b cd	 mov	 r9, rbp
  000fd	4c 8b c6	 mov	 r8, rsi
  00100	48 8b d3	 mov	 rdx, rbx
  00103	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 3151 :     else

  00108	eb 13		 jmp	 SHORT $LN39@object_rep
$LN6@object_rep:

; 3152 :         rtn = PyUnicode_FromFormat("<%s object at %p>",
; 3153 :                                   type->tp_name, self);

  0010a	48 8b 57 70	 mov	 rdx, QWORD PTR [rdi+112]
  0010e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@JEBMOEBF@?$DM?$CFs?5object?5at?5?$CFp?$DO?$AA@
  00115	4c 8b c5	 mov	 r8, rbp
  00118	e8 00 00 00 00	 call	 PyUnicode_FromFormat
$LN39@object_rep:
  0011d	48 8b f8	 mov	 rdi, rax

; 3154 :     Py_XDECREF(mod);

  00120	48 85 db	 test	 rbx, rbx
  00123	74 65		 je	 SHORT $LN3@object_rep
  00125	e8 00 00 00 00	 call	 _Py_PXCTX
  0012a	85 c0		 test	 eax, eax
  0012c	75 5c		 jne	 SHORT $LN3@object_rep
  0012e	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00132	a8 20		 test	 al, 32			; 00000020H
  00134	75 4c		 jne	 SHORT $LN32@object_rep
  00136	84 c0		 test	 al, al
  00138	78 48		 js	 SHORT $LN32@object_rep
  0013a	a8 02		 test	 al, 2
  0013c	75 4c		 jne	 SHORT $LN3@object_rep
  0013e	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00142	75 46		 jne	 SHORT $LN3@object_rep
  00144	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0014b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00152	4c 8b cb	 mov	 r9, rbx
  00155	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0015b	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00163	e8 00 00 00 00	 call	 _PyParallel_Guard
  00168	48 8b cb	 mov	 rcx, rbx
  0016b	85 c0		 test	 eax, eax
  0016d	74 07		 je	 SHORT $LN37@object_rep
  0016f	e8 00 00 00 00	 call	 _Px_Dealloc
  00174	eb 14		 jmp	 SHORT $LN3@object_rep
$LN37@object_rep:
  00176	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0017a	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00180	eb 08		 jmp	 SHORT $LN3@object_rep
$LN32@object_rep:
  00182	48 8b cb	 mov	 rcx, rbx
  00185	e8 00 00 00 00	 call	 Px_DecRef
$LN3@object_rep:

; 3155 :     Py_DECREF(name);

  0018a	48 8b ce	 mov	 rcx, rsi
  0018d	e8 00 00 00 00	 call	 _Py_DecRef

; 3156 :     return rtn;

  00192	48 8b c7	 mov	 rax, rdi
$LN15@object_rep:

; 3157 : }

  00195	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0019a	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0019f	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  001a4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001a8	5f		 pop	 rdi
  001a9	c3		 ret	 0
object_repr ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT object_str
_TEXT	SEGMENT
self$ = 8
object_str PROC						; COMDAT

; 3162 :     unaryfunc f;
; 3163 : 
; 3164 :     f = Py_TYPE(self)->tp_repr;

  00000	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00004	48 8b 90 b0 00
	00 00		 mov	 rdx, QWORD PTR [rax+176]

; 3165 :     if (f == NULL)

  0000b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:object_repr
  00012	48 85 d2	 test	 rdx, rdx
  00015	48 0f 44 d0	 cmove	 rdx, rax

; 3166 :         f = object_repr;
; 3167 :     return f(self);
; 3168 : }

  00019	48 ff e2	 rex_jmp rdx
object_str ENDP
_TEXT	ENDS
EXTRN	PyObject_RichCompare:PROC
EXTRN	_Py_NotImplementedStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$object_richcompare DD imagerel object_richcompare
	DD	imagerel object_richcompare+334
	DD	imagerel $unwind$object_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$object_richcompare DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT object_richcompare
_TEXT	SEGMENT
self$ = 64
other$ = 72
op$ = 80
object_richcompare PROC					; COMDAT

; 3172 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3173 :     PyObject *res;
; 3174 : 
; 3175 :     switch (op) {

  0000a	41 83 e8 02	 sub	 r8d, 2
  0000e	0f 84 dc 00 00
	00		 je	 $LN8@object_ric
  00014	41 ff c8	 dec	 r8d
  00017	74 61		 je	 SHORT $LN7@object_ric

; 3200 :             }
; 3201 :         }
; 3202 :         break;
; 3203 : 
; 3204 :     default:
; 3205 :         res = Py_NotImplemented;

  00019	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NotImplementedStruct
  00020	48 8b df	 mov	 rbx, rdi

; 3206 :         Py_INCREF(res);

  00023	e8 00 00 00 00	 call	 _Py_PXCTX
  00028	85 c0		 test	 eax, eax
  0002a	0f 85 10 01 00
	00		 jne	 $LN14@object_ric
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0003e	4c 8b cf	 mov	 r9, rdi
  00041	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00047	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0004f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00054	85 c0		 test	 eax, eax
  00056	75 0d		 jne	 SHORT $LN17@object_ric
  00058	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  0005f	0f 84 db 00 00
	00		 je	 $LN14@object_ric
$LN17@object_ric:
  00065	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80

; 3207 :         break;
; 3208 :     }
; 3209 : 
; 3210 :     return res;

  0006c	48 8b c3	 mov	 rax, rbx

; 3211 : }

  0006f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00074	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
$LN7@object_ric:

; 3183 :         break;
; 3184 : 
; 3185 :     case Py_NE:
; 3186 :         /* By default, != returns the opposite of ==,
; 3187 :            unless the latter returns NotImplemented. */
; 3188 :         res = PyObject_RichCompare(self, other, Py_EQ);

  0007a	41 b8 02 00 00
	00		 mov	 r8d, 2
  00080	e8 00 00 00 00	 call	 PyObject_RichCompare
  00085	48 8b d8	 mov	 rbx, rax

; 3189 :         if (res != NULL && res != Py_NotImplemented) {

  00088	48 85 c0	 test	 rax, rax
  0008b	0f 84 af 00 00
	00		 je	 $LN14@object_ric
  00091	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NotImplementedStruct
  00098	48 3b c7	 cmp	 rax, rdi
  0009b	0f 84 9f 00 00
	00		 je	 $LN14@object_ric

; 3190 :             int ok = PyObject_IsTrue(res);

  000a1	48 8b c8	 mov	 rcx, rax
  000a4	e8 00 00 00 00	 call	 PyObject_IsTrue

; 3191 :             Py_DECREF(res);

  000a9	48 8b cb	 mov	 rcx, rbx
  000ac	8b f8		 mov	 edi, eax
  000ae	e8 00 00 00 00	 call	 _Py_DecRef

; 3192 :             if (ok < 0)

  000b3	85 ff		 test	 edi, edi
  000b5	79 0f		 jns	 SHORT $LN5@object_ric

; 3193 :                 res = NULL;

  000b7	33 db		 xor	 ebx, ebx

; 3207 :         break;
; 3208 :     }
; 3209 : 
; 3210 :     return res;

  000b9	8b c3		 mov	 eax, ebx

; 3211 : }

  000bb	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c4	5f		 pop	 rdi
  000c5	c3		 ret	 0
$LN5@object_ric:

; 3194 :             else {
; 3195 :                 if (ok)

  000c6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  000cd	85 ff		 test	 edi, edi
  000cf	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_FalseStruct
  000d6	48 0f 44 d8	 cmove	 rbx, rax

; 3196 :                     res = Py_False;
; 3197 :                 else
; 3198 :                     res = Py_True;
; 3199 :                 Py_INCREF(res);

  000da	48 8b cb	 mov	 rcx, rbx
  000dd	e8 00 00 00 00	 call	 _Py_IncRef

; 3207 :         break;
; 3208 :     }
; 3209 : 
; 3210 :     return res;

  000e2	48 8b c3	 mov	 rax, rbx

; 3211 : }

  000e5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ea	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ee	5f		 pop	 rdi
  000ef	c3		 ret	 0
$LN8@object_ric:

; 3176 : 
; 3177 :     case Py_EQ:
; 3178 :         /* Return NotImplemented instead of False, so if two
; 3179 :            objects are compared, both get a chance at the
; 3180 :            comparison.  See issue #1393. */
; 3181 :         res = (self == other) ? Py_True : Py_NotImplemented;

  000f0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  000f7	48 3b ca	 cmp	 rcx, rdx
  000fa	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NotImplementedStruct
  00101	48 0f 44 d8	 cmove	 rbx, rax

; 3182 :         Py_INCREF(res);

  00105	e8 00 00 00 00	 call	 _Py_PXCTX
  0010a	85 c0		 test	 eax, eax
  0010c	75 32		 jne	 SHORT $LN14@object_ric
  0010e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00115	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0011c	4c 8b cb	 mov	 r9, rbx
  0011f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00125	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0012d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00132	85 c0		 test	 eax, eax
  00134	75 06		 jne	 SHORT $LN13@object_ric
  00136	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0013a	74 04		 je	 SHORT $LN14@object_ric
$LN13@object_ric:
  0013c	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN14@object_ric:

; 3207 :         break;
; 3208 :     }
; 3209 : 
; 3210 :     return res;

  00140	48 8b c3	 mov	 rax, rbx

; 3211 : }

  00143	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00148	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0014c	5f		 pop	 rdi
  0014d	c3		 ret	 0
object_richcompare ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$object_get_class DD imagerel object_get_class
	DD	imagerel object_get_class+91
	DD	imagerel $unwind$object_get_class
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$object_get_class DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT object_get_class
_TEXT	SEGMENT
self$ = 64
closure$ = 72
object_get_class PROC					; COMDAT

; 3215 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3216 :     Py_INCREF(Py_TYPE(self));

  0000a	48 8b 79 58	 mov	 rdi, QWORD PTR [rcx+88]
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	e8 00 00 00 00	 call	 _Py_PXCTX
  00016	85 c0		 test	 eax, eax
  00018	75 32		 jne	 SHORT $LN7@object_get
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00028	4c 8b cf	 mov	 r9, rdi
  0002b	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00031	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00039	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003e	85 c0		 test	 eax, eax
  00040	75 06		 jne	 SHORT $LN3@object_get
  00042	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  00046	74 04		 je	 SHORT $LN7@object_get
$LN3@object_get:
  00048	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN7@object_get:

; 3217 :     return (PyObject *)(Py_TYPE(self));

  0004c	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 3218 : }

  00050	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00055	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00059	5f		 pop	 rdi
  0005a	c3		 ret	 0
object_get_class ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT equiv_structs
_TEXT	SEGMENT
a$ = 8
b$ = 16
equiv_structs PROC					; COMDAT

; 3223 :     return a == b ||
; 3224 :            (a != NULL &&
; 3225 :         b != NULL &&
; 3226 :         a->tp_basicsize == b->tp_basicsize &&
; 3227 :         a->tp_itemsize == b->tp_itemsize &&
; 3228 :         a->tp_dictoffset == b->tp_dictoffset &&
; 3229 :         a->tp_weaklistoffset == b->tp_weaklistoffset &&
; 3230 :         ((a->tp_flags & Py_TPFLAGS_HAVE_GC) ==
; 3231 :          (b->tp_flags & Py_TPFLAGS_HAVE_GC)));

  00000	48 3b ca	 cmp	 rcx, rdx
  00003	74 59		 je	 SHORT $LN4@equiv_stru
  00005	48 85 c9	 test	 rcx, rcx
  00008	74 51		 je	 SHORT $LN3@equiv_stru
  0000a	48 85 d2	 test	 rdx, rdx
  0000d	74 4c		 je	 SHORT $LN3@equiv_stru
  0000f	48 8b 42 78	 mov	 rax, QWORD PTR [rdx+120]
  00013	48 39 41 78	 cmp	 QWORD PTR [rcx+120], rax
  00017	75 42		 jne	 SHORT $LN3@equiv_stru
  00019	48 8b 82 80 00
	00 00		 mov	 rax, QWORD PTR [rdx+128]
  00020	48 39 81 80 00
	00 00		 cmp	 QWORD PTR [rcx+128], rax
  00027	75 32		 jne	 SHORT $LN3@equiv_stru
  00029	48 8b 82 78 01
	00 00		 mov	 rax, QWORD PTR [rdx+376]
  00030	48 39 81 78 01
	00 00		 cmp	 QWORD PTR [rcx+376], rax
  00037	75 22		 jne	 SHORT $LN3@equiv_stru
  00039	48 8b 82 28 01
	00 00		 mov	 rax, QWORD PTR [rdx+296]
  00040	48 39 81 28 01
	00 00		 cmp	 QWORD PTR [rcx+296], rax
  00047	75 12		 jne	 SHORT $LN3@equiv_stru
  00049	8b 81 00 01 00
	00		 mov	 eax, DWORD PTR [rcx+256]
  0004f	33 82 00 01 00
	00		 xor	 eax, DWORD PTR [rdx+256]
  00055	0f ba e0 0e	 bt	 eax, 14
  00059	73 03		 jae	 SHORT $LN4@equiv_stru
$LN3@equiv_stru:
  0005b	33 c0		 xor	 eax, eax

; 3232 : }

  0005d	c3		 ret	 0
$LN4@equiv_stru:

; 3223 :     return a == b ||
; 3224 :            (a != NULL &&
; 3225 :         b != NULL &&
; 3226 :         a->tp_basicsize == b->tp_basicsize &&
; 3227 :         a->tp_itemsize == b->tp_itemsize &&
; 3228 :         a->tp_dictoffset == b->tp_dictoffset &&
; 3229 :         a->tp_weaklistoffset == b->tp_weaklistoffset &&
; 3230 :         ((a->tp_flags & Py_TPFLAGS_HAVE_GC) ==
; 3231 :          (b->tp_flags & Py_TPFLAGS_HAVE_GC)));

  0005e	b8 01 00 00 00	 mov	 eax, 1

; 3232 : }

  00063	c3		 ret	 0
equiv_structs ENDP
_TEXT	ENDS
EXTRN	PyObject_RichCompareBool:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$same_slots_added DD imagerel same_slots_added
	DD	imagerel same_slots_added+174
	DD	imagerel $unwind$same_slots_added
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$same_slots_added DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT same_slots_added
_TEXT	SEGMENT
a$ = 48
b$ = 56
same_slots_added PROC					; COMDAT

; 3236 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3237 :     PyTypeObject *base = a->tp_base;
; 3238 :     Py_ssize_t size;
; 3239 :     PyObject *slots_a, *slots_b;
; 3240 : 
; 3241 :     assert(base == b->tp_base);
; 3242 :     size = base->tp_basicsize;

  00014	48 8b 81 58 01
	00 00		 mov	 rax, QWORD PTR [rcx+344]
  0001b	48 8b f2	 mov	 rsi, rdx
  0001e	48 8b f9	 mov	 rdi, rcx
  00021	48 8b 58 78	 mov	 rbx, QWORD PTR [rax+120]

; 3243 :     if (a->tp_dictoffset == size && b->tp_dictoffset == size)

  00025	48 39 99 78 01
	00 00		 cmp	 QWORD PTR [rcx+376], rbx
  0002c	75 0d		 jne	 SHORT $LN4@same_slots
  0002e	48 39 9a 78 01
	00 00		 cmp	 QWORD PTR [rdx+376], rbx
  00035	75 04		 jne	 SHORT $LN4@same_slots

; 3244 :         size += sizeof(PyObject *);

  00037	48 83 c3 08	 add	 rbx, 8
$LN4@same_slots:

; 3245 :     if (a->tp_weaklistoffset == size && b->tp_weaklistoffset == size)

  0003b	48 39 99 28 01
	00 00		 cmp	 QWORD PTR [rcx+296], rbx
  00042	75 0d		 jne	 SHORT $LN3@same_slots
  00044	48 39 9a 28 01
	00 00		 cmp	 QWORD PTR [rdx+296], rbx
  0004b	75 04		 jne	 SHORT $LN3@same_slots

; 3246 :         size += sizeof(PyObject *);

  0004d	48 83 c3 08	 add	 rbx, 8
$LN3@same_slots:

; 3247 : 
; 3248 :     /* Check slots compliance */
; 3249 :     slots_a = ((PyHeapTypeObject *)a)->ht_slots;

  00051	48 8b a9 70 03
	00 00		 mov	 rbp, QWORD PTR [rcx+880]

; 3250 :     slots_b = ((PyHeapTypeObject *)b)->ht_slots;

  00058	48 8b 92 70 03
	00 00		 mov	 rdx, QWORD PTR [rdx+880]

; 3251 :     if (slots_a && slots_b) {

  0005f	48 85 ed	 test	 rbp, rbp
  00062	74 20		 je	 SHORT $LN2@same_slots
  00064	48 85 d2	 test	 rdx, rdx
  00067	74 1b		 je	 SHORT $LN2@same_slots

; 3252 :         if (PyObject_RichCompareBool(slots_a, slots_b, Py_EQ) != 1)

  00069	41 b8 02 00 00
	00		 mov	 r8d, 2
  0006f	48 8b cd	 mov	 rcx, rbp
  00072	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  00077	83 f8 01	 cmp	 eax, 1

; 3253 :             return 0;

  0007a	75 1b		 jne	 SHORT $LN7@same_slots

; 3254 :         size += sizeof(PyObject *) * PyTuple_GET_SIZE(slots_a);

  0007c	48 8b 45 60	 mov	 rax, QWORD PTR [rbp+96]
  00080	48 8d 1c c3	 lea	 rbx, QWORD PTR [rbx+rax*8]
$LN2@same_slots:

; 3255 :     }
; 3256 :     return size == a->tp_basicsize && size == b->tp_basicsize;

  00084	48 3b 5f 78	 cmp	 rbx, QWORD PTR [rdi+120]
  00088	75 0d		 jne	 SHORT $LN7@same_slots
  0008a	48 3b 5e 78	 cmp	 rbx, QWORD PTR [rsi+120]
  0008e	75 07		 jne	 SHORT $LN7@same_slots
  00090	b8 01 00 00 00	 mov	 eax, 1
  00095	eb 02		 jmp	 SHORT $LN8@same_slots
$LN7@same_slots:
  00097	33 c0		 xor	 eax, eax
$LN8@same_slots:

; 3257 : }

  00099	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009e	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000a3	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000a8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ac	5f		 pop	 rdi
  000ad	c3		 ret	 0
same_slots_added ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DC@KBBFLPNI@?$CFs?5assignment?3?5?8?$CFs?8?5deallocator?5@ ; `string'
PUBLIC	??_C@_0DE@OBFNLFFK@?$CFs?5assignment?3?5?8?$CFs?8?5object?5layou@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compatible_for_assignment DD imagerel compatible_for_assignment
	DD	imagerel compatible_for_assignment+293
	DD	imagerel $unwind$compatible_for_assignment
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compatible_for_assignment DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0DC@KBBFLPNI@?$CFs?5assignment?3?5?8?$CFs?8?5deallocator?5@
CONST	SEGMENT
??_C@_0DC@KBBFLPNI@?$CFs?5assignment?3?5?8?$CFs?8?5deallocator?5@ DB '%s '
	DB	'assignment: ''%s'' deallocator differs from ''%s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@OBFNLFFK@?$CFs?5assignment?3?5?8?$CFs?8?5object?5layou@
CONST	SEGMENT
??_C@_0DE@OBFNLFFK@?$CFs?5assignment?3?5?8?$CFs?8?5object?5layou@ DB '%s '
	DB	'assignment: ''%s'' object layout differs from ''%s''', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT compatible_for_assignment
_TEXT	SEGMENT
oldto$ = 64
newto$ = 72
attr$ = 80
compatible_for_assignment PROC				; COMDAT

; 3261 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3262 :     PyTypeObject *newbase, *oldbase;
; 3263 : 
; 3264 :     if (newto->tp_dealloc != oldto->tp_dealloc ||
; 3265 :         newto->tp_free != oldto->tp_free)

  0000f	48 8b 81 88 00
	00 00		 mov	 rax, QWORD PTR [rcx+136]
  00016	49 8b f0	 mov	 rsi, r8
  00019	48 8b fa	 mov	 rdi, rdx
  0001c	48 8b d9	 mov	 rbx, rcx
  0001f	48 39 82 88 00
	00 00		 cmp	 QWORD PTR [rdx+136], rax
  00026	0f 85 c7 00 00
	00		 jne	 $LN7@compatible
  0002c	48 8b 81 98 01
	00 00		 mov	 rax, QWORD PTR [rcx+408]
  00033	48 39 82 98 01
	00 00		 cmp	 QWORD PTR [rdx+408], rax
  0003a	0f 85 b3 00 00
	00		 jne	 $LN7@compatible

; 3273 :         return 0;
; 3274 :     }
; 3275 :     newbase = newto;

  00040	4c 8b ca	 mov	 r9, rdx

; 3276 :     oldbase = oldto;
; 3277 :     while (equiv_structs(newbase, newbase->tp_base))

  00043	48 8b 92 58 01
	00 00		 mov	 rdx, QWORD PTR [rdx+344]
  0004a	4c 8b d1	 mov	 r10, rcx
  0004d	49 8b c9	 mov	 rcx, r9
  00050	e8 00 00 00 00	 call	 equiv_structs
  00055	85 c0		 test	 eax, eax
  00057	74 1d		 je	 SHORT $LN12@compatible
  00059	0f 1f 80 00 00
	00 00		 npad	 7
$LL6@compatible:

; 3278 :         newbase = newbase->tp_base;

  00060	4c 8b ca	 mov	 r9, rdx
  00063	48 8b 92 58 01
	00 00		 mov	 rdx, QWORD PTR [rdx+344]
  0006a	49 8b c9	 mov	 rcx, r9
  0006d	e8 00 00 00 00	 call	 equiv_structs
  00072	85 c0		 test	 eax, eax
  00074	75 ea		 jne	 SHORT $LL6@compatible
$LN12@compatible:

; 3279 :     while (equiv_structs(oldbase, oldbase->tp_base))

  00076	48 8b 93 58 01
	00 00		 mov	 rdx, QWORD PTR [rbx+344]
  0007d	48 8b cb	 mov	 rcx, rbx
  00080	e8 00 00 00 00	 call	 equiv_structs
  00085	85 c0		 test	 eax, eax
  00087	74 1d		 je	 SHORT $LN3@compatible
  00089	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@compatible:

; 3280 :         oldbase = oldbase->tp_base;

  00090	4c 8b d2	 mov	 r10, rdx
  00093	48 8b 92 58 01
	00 00		 mov	 rdx, QWORD PTR [rdx+344]
  0009a	49 8b ca	 mov	 rcx, r10
  0009d	e8 00 00 00 00	 call	 equiv_structs
  000a2	85 c0		 test	 eax, eax
  000a4	75 ea		 jne	 SHORT $LL4@compatible
$LN3@compatible:

; 3281 :     if (newbase != oldbase &&
; 3282 :         (newbase->tp_base != oldbase->tp_base ||
; 3283 :          !same_slots_added(newbase, oldbase))) {

  000a6	4d 3b ca	 cmp	 r9, r10
  000a9	74 33		 je	 SHORT $LN2@compatible
  000ab	49 8b 82 58 01
	00 00		 mov	 rax, QWORD PTR [r10+344]
  000b2	49 39 81 58 01
	00 00		 cmp	 QWORD PTR [r9+344], rax
  000b9	75 0f		 jne	 SHORT $LN1@compatible
  000bb	49 8b d2	 mov	 rdx, r10
  000be	49 8b c9	 mov	 rcx, r9
  000c1	e8 00 00 00 00	 call	 same_slots_added
  000c6	85 c0		 test	 eax, eax
  000c8	75 14		 jne	 SHORT $LN2@compatible
$LN1@compatible:

; 3284 :         PyErr_Format(PyExc_TypeError,
; 3285 :                      "%s assignment: "
; 3286 :                      "'%s' object layout differs from '%s'",
; 3287 :                      attr,
; 3288 :                      newto->tp_name,
; 3289 :                      oldto->tp_name);

  000ca	48 8b 43 70	 mov	 rax, QWORD PTR [rbx+112]
  000ce	4c 8b 4f 70	 mov	 r9, QWORD PTR [rdi+112]
  000d2	4c 8b c6	 mov	 r8, rsi
  000d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@OBFNLFFK@?$CFs?5assignment?3?5?8?$CFs?8?5object?5layou@

; 3290 :         return 0;

  000dc	eb 24		 jmp	 SHORT $LN15@compatible
$LN2@compatible:

; 3291 :     }
; 3292 : 
; 3293 :     return 1;

  000de	b8 01 00 00 00	 mov	 eax, 1

; 3294 : }

  000e3	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e8	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000ed	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f1	5f		 pop	 rdi
  000f2	c3		 ret	 0
$LN7@compatible:

; 3266 :     {
; 3267 :         PyErr_Format(PyExc_TypeError,
; 3268 :                      "%s assignment: "
; 3269 :                      "'%s' deallocator differs from '%s'",
; 3270 :                      attr,
; 3271 :                      newto->tp_name,
; 3272 :                      oldto->tp_name);

  000f3	4c 8b 4a 70	 mov	 r9, QWORD PTR [rdx+112]
  000f7	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  000fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@KBBFLPNI@?$CFs?5assignment?3?5?8?$CFs?8?5deallocator?5@
$LN15@compatible:
  00102	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00109	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0010e	e8 00 00 00 00	 call	 PyErr_Format

; 3294 : }

  00113	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00118	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0011d	33 c0		 xor	 eax, eax
  0011f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00123	5f		 pop	 rdi
  00124	c3		 ret	 0
compatible_for_assignment ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@PPLOJBJJ@__class__?5assignment?3?5only?5for?5h@ ; `string'
PUBLIC	??_C@_0DC@BPCOACP@__class__?5must?5be?5set?5to?5a?5class@ ; `string'
PUBLIC	??_C@_0CB@KKCPDMPJ@can?8t?5delete?5__class__?5attribute@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$object_set_class DD imagerel object_set_class
	DD	imagerel object_set_class+249
	DD	imagerel $unwind$object_set_class
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$object_set_class DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0CK@PPLOJBJJ@__class__?5assignment?3?5only?5for?5h@
CONST	SEGMENT
??_C@_0CK@PPLOJBJJ@__class__?5assignment?3?5only?5for?5h@ DB '__class__ a'
	DB	'ssignment: only for heap types', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@BPCOACP@__class__?5must?5be?5set?5to?5a?5class@
CONST	SEGMENT
??_C@_0DC@BPCOACP@__class__?5must?5be?5set?5to?5a?5class@ DB '__class__ m'
	DB	'ust be set to a class, not ''%s'' object', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KKCPDMPJ@can?8t?5delete?5__class__?5attribute@
CONST	SEGMENT
??_C@_0CB@KKCPDMPJ@can?8t?5delete?5__class__?5attribute@ DB 'can''t delet'
	DB	'e __class__ attribute', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT object_set_class
_TEXT	SEGMENT
self$ = 48
value$ = 56
closure$ = 64
object_set_class PROC					; COMDAT

; 3298 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3299 :     PyTypeObject *oldto = Py_TYPE(self);

  0000f	48 8b 79 58	 mov	 rdi, QWORD PTR [rcx+88]
  00013	48 8b da	 mov	 rbx, rdx
  00016	48 8b f1	 mov	 rsi, rcx

; 3300 :     PyTypeObject *newto;
; 3301 : 
; 3302 :     if (value == NULL) {

  00019	48 85 d2	 test	 rdx, rdx
  0001c	75 26		 jne	 SHORT $LN6@object_set

; 3303 :         PyErr_SetString(PyExc_TypeError,
; 3304 :                         "can't delete __class__ attribute");

  0001e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@KKCPDMPJ@can?8t?5delete?5__class__?5attribute@
  0002c	e8 00 00 00 00	 call	 PyErr_SetString

; 3319 :         return -1;

  00031	83 c8 ff	 or	 eax, -1

; 3326 :     }
; 3327 :     else {
; 3328 :         return -1;
; 3329 :     }
; 3330 : }

  00034	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00039	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0003e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00042	5f		 pop	 rdi
  00043	c3		 ret	 0
$LN6@object_set:

; 3305 :         return -1;
; 3306 :     }
; 3307 :     if (!PyType_Check(value)) {

  00044	4c 8b 42 58	 mov	 r8, QWORD PTR [rdx+88]
  00048	41 f7 80 00 01
	00 00 00 00 00
	80		 test	 DWORD PTR [r8+256], -2147483648 ; ffffffff80000000H
  00053	75 2a		 jne	 SHORT $LN5@object_set

; 3308 :         PyErr_Format(PyExc_TypeError,
; 3309 :           "__class__ must be set to a class, not '%s' object",
; 3310 :           Py_TYPE(value)->tp_name);

  00055	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00059	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00060	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@BPCOACP@__class__?5must?5be?5set?5to?5a?5class@
  00067	e8 00 00 00 00	 call	 PyErr_Format

; 3319 :         return -1;

  0006c	83 c8 ff	 or	 eax, -1

; 3326 :     }
; 3327 :     else {
; 3328 :         return -1;
; 3329 :     }
; 3330 : }

  0006f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00074	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00079	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007d	5f		 pop	 rdi
  0007e	c3		 ret	 0
$LN5@object_set:

; 3311 :         return -1;
; 3312 :     }
; 3313 :     newto = (PyTypeObject *)value;
; 3314 :     if (!(newto->tp_flags & Py_TPFLAGS_HEAPTYPE) ||
; 3315 :         !(oldto->tp_flags & Py_TPFLAGS_HEAPTYPE))

  0007f	f7 82 00 01 00
	00 00 02 00 00	 test	 DWORD PTR [rdx+256], 512 ; 00000200H
  00089	74 48		 je	 SHORT $LN3@object_set
  0008b	f7 87 00 01 00
	00 00 02 00 00	 test	 DWORD PTR [rdi+256], 512 ; 00000200H
  00095	74 3c		 je	 SHORT $LN3@object_set

; 3320 :     }
; 3321 :     if (compatible_for_assignment(newto, oldto, "__class__")) {

  00097	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_09LFGACEKG@__class__?$AA@
  0009e	48 8b d7	 mov	 rdx, rdi
  000a1	48 8b cb	 mov	 rcx, rbx
  000a4	e8 00 00 00 00	 call	 compatible_for_assignment
  000a9	85 c0		 test	 eax, eax
  000ab	74 39		 je	 SHORT $LN9@object_set

; 3322 :         Py_INCREF(newto);

  000ad	48 8b cb	 mov	 rcx, rbx
  000b0	e8 00 00 00 00	 call	 _Py_IncRef

; 3323 :         Py_TYPE(self) = newto;
; 3324 :         Py_DECREF(oldto);

  000b5	48 8b cf	 mov	 rcx, rdi
  000b8	48 89 5e 58	 mov	 QWORD PTR [rsi+88], rbx
  000bc	e8 00 00 00 00	 call	 _Py_DecRef

; 3325 :         return 0;

  000c1	33 c0		 xor	 eax, eax

; 3326 :     }
; 3327 :     else {
; 3328 :         return -1;
; 3329 :     }
; 3330 : }

  000c3	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000c8	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000cd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d1	5f		 pop	 rdi
  000d2	c3		 ret	 0
$LN3@object_set:

; 3316 :     {
; 3317 :         PyErr_Format(PyExc_TypeError,
; 3318 :                      "__class__ assignment: only for heap types");

  000d3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@PPLOJBJJ@__class__?5assignment?3?5only?5for?5h@
  000e1	e8 00 00 00 00	 call	 PyErr_Format
$LN9@object_set:

; 3326 :     }
; 3327 :     else {
; 3328 :         return -1;
; 3329 :     }
; 3330 : }

  000e6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000eb	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000f0	83 c8 ff	 or	 eax, -1
  000f3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f7	5f		 pop	 rdi
  000f8	c3		 ret	 0
object_set_class ENDP
_TEXT	ENDS
EXTRN	PyImport_Import:PROC
EXTRN	PyErr_Occurred:PROC
EXTRN	PyDict_GetItemWithError:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$import_copyreg DD imagerel import_copyreg
	DD	imagerel import_copyreg+208
	DD	imagerel $unwind$import_copyreg
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$import_copyreg DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT import_copyreg
_TEXT	SEGMENT
import_copyreg PROC					; COMDAT

; 3348 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3349 :     PyObject *copyreg_str;
; 3350 :     PyObject *copyreg_module;
; 3351 :     PyInterpreterState *interp = PyThreadState_GET()->interp;

  0000a	e8 00 00 00 00	 call	 _Py_PXCTX
  0000f	85 c0		 test	 eax, eax
  00011	74 07		 je	 SHORT $LN6@import_cop
  00013	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00018	eb 07		 jmp	 SHORT $LN7@import_cop
$LN6@import_cop:
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN7@import_cop:
  00021	48 8b 58 08	 mov	 rbx, QWORD PTR [rax+8]

; 3352 :     _Py_IDENTIFIER(copyreg);
; 3353 : 
; 3354 :     copyreg_str = _PyUnicode_FromId(&PyId_copyreg);

  00025	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  0002b	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00034	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PyId_copyreg@?1??import_copyreg@@9@9
  00039	48 03 0c d0	 add	 rcx, QWORD PTR [rax+rdx*8]
  0003d	e8 00 00 00 00	 call	 _PyUnicode_FromId
  00042	48 8b f8	 mov	 rdi, rax

; 3355 :     if (copyreg_str == NULL) {

  00045	48 85 c0	 test	 rax, rax
  00048	75 0d		 jne	 SHORT $LN3@import_cop
$LN12@import_cop:

; 3356 :         return NULL;

  0004a	33 c0		 xor	 eax, eax

; 3372 : }

  0004c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00051	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00055	5f		 pop	 rdi
  00056	c3		 ret	 0
$LN3@import_cop:

; 3357 :     }
; 3358 :     /* Try to fetch cached copy of copyreg from sys.modules first in an
; 3359 :        attempt to avoid the import overhead. Previously this was implemented
; 3360 :        by storing a reference to the cached module in a static variable, but
; 3361 :        this broke when multiple embeded interpreters were in use (see issue
; 3362 :        #17408 and #19088). */
; 3363 :     copyreg_module = PyDict_GetItemWithError(interp->modules, copyreg_str);

  00057	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0005b	48 8b d0	 mov	 rdx, rax
  0005e	e8 00 00 00 00	 call	 PyDict_GetItemWithError
  00063	48 8b d8	 mov	 rbx, rax

; 3364 :     if (copyreg_module != NULL) {

  00066	48 85 c0	 test	 rax, rax
  00069	74 49		 je	 SHORT $LN2@import_cop

; 3365 :         Py_INCREF(copyreg_module);

  0006b	e8 00 00 00 00	 call	 _Py_PXCTX
  00070	85 c0		 test	 eax, eax
  00072	75 32		 jne	 SHORT $LN9@import_cop
  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00082	4c 8b cb	 mov	 r9, rbx
  00085	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0008b	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00093	e8 00 00 00 00	 call	 _PyParallel_Guard
  00098	85 c0		 test	 eax, eax
  0009a	75 06		 jne	 SHORT $LN8@import_cop
  0009c	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000a0	74 04		 je	 SHORT $LN9@import_cop
$LN8@import_cop:
  000a2	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN9@import_cop:

; 3366 :         return copyreg_module;

  000a6	48 8b c3	 mov	 rax, rbx

; 3372 : }

  000a9	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ae	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b2	5f		 pop	 rdi
  000b3	c3		 ret	 0
$LN2@import_cop:

; 3367 :     }
; 3368 :     if (PyErr_Occurred()) {

  000b4	e8 00 00 00 00	 call	 PyErr_Occurred
  000b9	48 85 c0	 test	 rax, rax

; 3369 :         return NULL;

  000bc	75 8c		 jne	 SHORT $LN12@import_cop

; 3370 :     }
; 3371 :     return PyImport_Import(copyreg_str);

  000be	48 8b cf	 mov	 rcx, rdi

; 3372 : }

  000c1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ca	5f		 pop	 rdi
  000cb	e9 00 00 00 00	 jmp	 PyImport_Import
import_copyreg ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@ELALBNKF@copyreg?4_slotnames?5didn?8t?5return@ ; `string'
PUBLIC	??_C@_01MJMHLOMK@O?$AA@				; `string'
EXTRN	_PyObject_CallMethodId:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$slotnames DD imagerel slotnames
	DD	imagerel slotnames+300
	DD	imagerel $unwind$slotnames
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slotnames DD 08a401H
	DD	0874a4H
	DD	0a540fH
	DD	09340fH
	DD	0600b520fH
xdata	ENDS
;	COMDAT ??_C@_0DA@ELALBNKF@copyreg?4_slotnames?5didn?8t?5return@
CONST	SEGMENT
??_C@_0DA@ELALBNKF@copyreg?4_slotnames?5didn?8t?5return@ DB 'copyreg._slo'
	DB	'tnames didn''t return a list or None', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01MJMHLOMK@O?$AA@
CONST	SEGMENT
??_C@_01MJMHLOMK@O?$AA@ DB 'O', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
CONST	ENDS
;	COMDAT slotnames
_TEXT	SEGMENT
cls$ = 64
slotnames PROC						; COMDAT

; 3376 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3377 :     PyObject *clsdict;
; 3378 :     PyObject *copyreg;
; 3379 :     PyObject *slotnames;
; 3380 :     _Py_IDENTIFIER(__slotnames__);
; 3381 :     _Py_IDENTIFIER(_slotnames);
; 3382 : 
; 3383 :     clsdict = ((PyTypeObject *)cls)->tp_dict;
; 3384 :     slotnames = _PyDict_GetItemId(clsdict, &PyId___slotnames__);

  0000f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00015	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0001e	48 8b f1	 mov	 rsi, rcx
  00021	48 8b 2c d0	 mov	 rbp, QWORD PTR [rax+rdx*8]
  00025	48 8b 89 60 01
	00 00		 mov	 rcx, QWORD PTR [rcx+352]
  0002c	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___slotnames__@?1??slotnames@@9@9
  00031	48 03 d5	 add	 rdx, rbp
  00034	e8 00 00 00 00	 call	 _PyDict_GetItemId
  00039	48 8b d8	 mov	 rbx, rax

; 3385 :     if (slotnames != NULL && PyList_Check(slotnames)) {

  0003c	48 85 c0	 test	 rax, rax
  0003f	74 5e		 je	 SHORT $LN3@slotnames
  00041	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00045	f7 81 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rcx+256], 33554432 ; 02000000H
  0004f	74 4e		 je	 SHORT $LN3@slotnames

; 3386 :         Py_INCREF(slotnames);

  00051	e8 00 00 00 00	 call	 _Py_PXCTX
  00056	85 c0		 test	 eax, eax
  00058	75 32		 jne	 SHORT $LN7@slotnames
  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00068	4c 8b cb	 mov	 r9, rbx
  0006b	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00071	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00079	e8 00 00 00 00	 call	 _PyParallel_Guard
  0007e	85 c0		 test	 eax, eax
  00080	75 06		 jne	 SHORT $LN6@slotnames
  00082	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00086	74 04		 je	 SHORT $LN7@slotnames
$LN6@slotnames:
  00088	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN7@slotnames:

; 3387 :         return slotnames;

  0008c	48 8b c3	 mov	 rax, rbx

; 3407 : }

  0008f	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00094	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00099	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009d	5e		 pop	 rsi
  0009e	c3		 ret	 0
$LN3@slotnames:
  0009f	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi

; 3388 :     }
; 3389 : 
; 3390 :     copyreg = import_copyreg();

  000a4	e8 00 00 00 00	 call	 import_copyreg
  000a9	48 8b f8	 mov	 rdi, rax

; 3391 :     if (copyreg == NULL)

  000ac	48 85 c0	 test	 rax, rax
  000af	74 66		 je	 SHORT $LN10@slotnames
$LN2@slotnames:

; 3392 :         return NULL;
; 3393 : 
; 3394 :     slotnames = _PyObject_CallMethodId(copyreg, &PyId__slotnames, "O", cls);

  000b1	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId__slotnames@?1??slotnames@@9@9
  000b6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MJMHLOMK@O?$AA@
  000bd	4c 8b ce	 mov	 r9, rsi
  000c0	48 03 d5	 add	 rdx, rbp
  000c3	48 8b c8	 mov	 rcx, rax
  000c6	e8 00 00 00 00	 call	 _PyObject_CallMethodId

; 3395 :     Py_DECREF(copyreg);

  000cb	48 8b cf	 mov	 rcx, rdi
  000ce	48 8b d8	 mov	 rbx, rax
  000d1	e8 00 00 00 00	 call	 _Py_DecRef

; 3396 :     if (slotnames != NULL &&
; 3397 :         slotnames != Py_None &&
; 3398 :         !PyList_Check(slotnames))

  000d6	48 85 db	 test	 rbx, rbx
  000d9	74 39		 je	 SHORT $LN1@slotnames
  000db	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000e2	48 3b d8	 cmp	 rbx, rax
  000e5	74 2d		 je	 SHORT $LN1@slotnames
  000e7	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  000eb	f7 81 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rcx+256], 33554432 ; 02000000H
  000f5	75 1d		 jne	 SHORT $LN1@slotnames

; 3399 :     {
; 3400 :         PyErr_SetString(PyExc_TypeError,
; 3401 :             "copyreg._slotnames didn't return a list or None");

  000f7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@ELALBNKF@copyreg?4_slotnames?5didn?8t?5return@
  00105	e8 00 00 00 00	 call	 PyErr_SetString

; 3402 :         Py_DECREF(slotnames);

  0010a	48 8b cb	 mov	 rcx, rbx
  0010d	e8 00 00 00 00	 call	 _Py_DecRef

; 3403 :         slotnames = NULL;

  00112	33 db		 xor	 ebx, ebx
$LN1@slotnames:

; 3404 :     }
; 3405 : 
; 3406 :     return slotnames;

  00114	48 8b c3	 mov	 rax, rbx
$LN10@slotnames:
  00117	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 3407 : }

  0011c	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00121	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00126	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0012a	5e		 pop	 rsi
  0012b	c3		 ret	 0
slotnames ENDP
_TEXT	ENDS
PUBLIC	??_C@_04IMCHBGDP@?$CINO?$CJ?$AA@		; `string'
PUBLIC	??_C@_0DD@ENMFPKMH@__getnewargs__?5should?5return?5a?5t@ ; `string'
EXTRN	PyTuple_Pack:PROC
EXTRN	PyObject_GetIter:PROC
EXTRN	PyObject_GetAttr:PROC
EXTRN	PyTuple_New:PROC
EXTRN	PyObject_CallObject:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$reduce_2 DD imagerel reduce_2
	DD	imagerel reduce_2+2070
	DD	imagerel $unwind$reduce_2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$reduce_2 DD 091501H
	DD	0f011c215H
	DD	0d00de00fH
	DD	07009c00bH
	DD	050076008H
	DD	03006H
xdata	ENDS
;	COMDAT ??_C@_04IMCHBGDP@?$CINO?$CJ?$AA@
CONST	SEGMENT
??_C@_04IMCHBGDP@?$CINO?$CJ?$AA@ DB '(NO)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@ENMFPKMH@__getnewargs__?5should?5return?5a?5t@
CONST	SEGMENT
??_C@_0DD@ENMFPKMH@__getnewargs__?5should?5return?5a?5t@ DB '__getnewargs'
	DB	'__ should return a tuple, not ''%.200s''', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
CONST	ENDS
;	COMDAT reduce_2
_TEXT	SEGMENT
listitems$1$ = 48
tv1025 = 56
cls$1$ = 64
copyreg$1$ = 72
res$1$ = 80
obj$ = 176
dictitems$1$ = 184
newobj$1$ = 192
slots$1$ = 200
reduce_2 PROC						; COMDAT

; 3411 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	41 57		 push	 r15
  00011	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3412 :     PyObject *cls, *getnewargs;
; 3413 :     PyObject *args = NULL, *args2 = NULL;
; 3414 :     PyObject *getstate = NULL, *state = NULL, *names = NULL;
; 3415 :     PyObject *slots = NULL, *listitems = NULL, *dictitems = NULL;
; 3416 :     PyObject *copyreg = NULL, *newobj = NULL, *res = NULL;
; 3417 :     Py_ssize_t i, n;
; 3418 :     _Py_IDENTIFIER(__getnewargs__);
; 3419 :     _Py_IDENTIFIER(__getstate__);
; 3420 :     _Py_IDENTIFIER(__newobj__);
; 3421 : 
; 3422 :     cls = (PyObject *) Py_TYPE(obj);

  00015	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]

; 3423 : 
; 3424 :     getnewargs = _PyObject_GetAttrId(obj, &PyId___getnewargs__);

  00019	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  0001f	33 ed		 xor	 ebp, ebp
  00021	48 89 44 24 40	 mov	 QWORD PTR cls$1$[rsp], rax
  00026	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0002f	4c 8b e9	 mov	 r13, rcx
  00032	48 8b 04 d0	 mov	 rax, QWORD PTR [rax+rdx*8]
  00036	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___getnewargs__@?1??reduce_2@@9@9
  0003b	44 8b e5	 mov	 r12d, ebp
  0003e	48 03 d0	 add	 rdx, rax
  00041	44 8b f5	 mov	 r14d, ebp
  00044	8b fd		 mov	 edi, ebp
  00046	48 89 ac 24 c8
	00 00 00	 mov	 QWORD PTR slots$1$[rsp], rbp
  0004e	8b f5		 mov	 esi, ebp
  00050	48 89 6c 24 48	 mov	 QWORD PTR copyreg$1$[rsp], rbp
  00055	48 89 6c 24 50	 mov	 QWORD PTR res$1$[rsp], rbp
  0005a	48 89 44 24 38	 mov	 QWORD PTR tv1025[rsp], rax
  0005f	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00064	48 8b d8	 mov	 rbx, rax

; 3425 :     if (getnewargs != NULL) {

  00067	48 85 c0	 test	 rax, rax
  0006a	0f 84 be 00 00
	00		 je	 $LN69@reduce_2

; 3426 :         args = PyObject_CallObject(getnewargs, NULL);

  00070	33 d2		 xor	 edx, edx
  00072	48 8b c8	 mov	 rcx, rax
  00075	e8 00 00 00 00	 call	 PyObject_CallObject

; 3427 :         Py_DECREF(getnewargs);

  0007a	48 8b cb	 mov	 rcx, rbx
  0007d	4c 8b f8	 mov	 r15, rax
  00080	e8 00 00 00 00	 call	 _Py_DecRef

; 3428 :         if (args != NULL && !PyTuple_Check(args)) {

  00085	4d 85 ff	 test	 r15, r15
  00088	0f 84 72 07 00
	00		 je	 $LN3@reduce_2
  0008e	4d 8b 47 58	 mov	 r8, QWORD PTR [r15+88]
  00092	41 f7 80 00 01
	00 00 00 00 00
	04		 test	 DWORD PTR [r8+256], 67108864 ; 04000000H
  0009d	0f 85 9a 00 00
	00		 jne	 $LN67@reduce_2

; 3429 :             PyErr_Format(PyExc_TypeError,
; 3430 :                 "__getnewargs__ should return a tuple, "
; 3431 :                 "not '%.200s'", Py_TYPE(args)->tp_name);

  000a3	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  000a7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@ENMFPKMH@__getnewargs__?5should?5return?5a?5t@
  000b5	e8 00 00 00 00	 call	 PyErr_Format
$LN193@reduce_2:

; 3462 :             assert(PyList_Check(names));
; 3463 :             slots = PyDict_New();

  000ba	48 8b de	 mov	 rbx, rsi
$LN195@reduce_2:
  000bd	4c 8b eb	 mov	 r13, rbx
$end$23145:

; 3538 : 
; 3539 :   end:
; 3540 :     Py_XDECREF(args);

  000c0	e8 00 00 00 00	 call	 _Py_PXCTX
  000c5	85 c0		 test	 eax, eax
  000c7	0f 85 db 03 00
	00		 jne	 $LN35@reduce_2
  000cd	49 8b 4f 20	 mov	 rcx, QWORD PTR [r15+32]
  000d1	f6 c1 20	 test	 cl, 32			; 00000020H
  000d4	0f 85 c6 03 00
	00		 jne	 $LN80@reduce_2
  000da	84 c9		 test	 cl, cl
  000dc	0f 88 be 03 00
	00		 js	 $LN80@reduce_2
  000e2	f6 c1 02	 test	 cl, 2
  000e5	0f 85 bd 03 00
	00		 jne	 $LN35@reduce_2
  000eb	49 ff 4f 50	 dec	 QWORD PTR [r15+80]
  000ef	0f 85 b3 03 00
	00		 jne	 $LN35@reduce_2
  000f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00103	4d 8b cf	 mov	 r9, r15
  00106	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0010c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00114	e8 00 00 00 00	 call	 _PyParallel_Guard
  00119	49 8b cf	 mov	 rcx, r15
  0011c	85 c0		 test	 eax, eax
  0011e	0f 84 70 03 00
	00		 je	 $LN85@reduce_2
  00124	e8 00 00 00 00	 call	 _Px_Dealloc
  00129	e9 7a 03 00 00	 jmp	 $LN35@reduce_2
$LN69@reduce_2:

; 3432 :             goto end;
; 3433 :         }
; 3434 :     }
; 3435 :     else {
; 3436 :         PyErr_Clear();

  0012e	e8 00 00 00 00	 call	 PyErr_Clear

; 3437 :         args = PyTuple_New(0);

  00133	33 c9		 xor	 ecx, ecx
  00135	e8 00 00 00 00	 call	 PyTuple_New
  0013a	4c 8b f8	 mov	 r15, rax
$LN67@reduce_2:

; 3438 :     }
; 3439 :     if (args == NULL)

  0013d	4d 85 ff	 test	 r15, r15
  00140	0f 84 ba 06 00
	00		 je	 $LN3@reduce_2

; 3440 :         goto end;
; 3441 : 
; 3442 :     getstate = _PyObject_GetAttrId(obj, &PyId___getstate__);

  00146	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___getstate__@?1??reduce_2@@9@9
  0014b	49 8b cd	 mov	 rcx, r13
  0014e	48 03 54 24 38	 add	 rdx, QWORD PTR tv1025[rsp]
  00153	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00158	48 8b d8	 mov	 rbx, rax

; 3443 :     if (getstate != NULL) {

  0015b	48 85 c0	 test	 rax, rax
  0015e	74 23		 je	 SHORT $LN65@reduce_2

; 3444 :         state = PyObject_CallObject(getstate, NULL);

  00160	33 d2		 xor	 edx, edx
  00162	48 8b c8	 mov	 rcx, rax
  00165	e8 00 00 00 00	 call	 PyObject_CallObject

; 3445 :         Py_DECREF(getstate);

  0016a	48 8b cb	 mov	 rcx, rbx
  0016d	4c 8b e0	 mov	 r12, rax
  00170	e8 00 00 00 00	 call	 _Py_DecRef

; 3446 :         if (state == NULL)

  00175	4d 85 e4	 test	 r12, r12
  00178	0f 84 3c ff ff
	ff		 je	 $LN193@reduce_2

; 3447 :             goto end;
; 3448 :     }
; 3449 :     else {

  0017e	e9 4b 01 00 00	 jmp	 $LN194@reduce_2
$LN65@reduce_2:

; 3450 :         PyObject **dict;
; 3451 :         PyErr_Clear();

  00183	e8 00 00 00 00	 call	 PyErr_Clear

; 3452 :         dict = _PyObject_GetDictPtr(obj);

  00188	49 8b cd	 mov	 rcx, r13
  0018b	e8 00 00 00 00	 call	 _PyObject_GetDictPtr

; 3453 :         if (dict && *dict)

  00190	48 85 c0	 test	 rax, rax
  00193	74 11		 je	 SHORT $LN62@reduce_2
  00195	4c 8b 20	 mov	 r12, QWORD PTR [rax]
  00198	4d 85 e4	 test	 r12, r12
  0019b	74 09		 je	 SHORT $LN62@reduce_2

; 3454 :             state = *dict;
; 3455 :         else

  0019d	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  001a4	eb 0a		 jmp	 SHORT $LN61@reduce_2
$LN62@reduce_2:

; 3456 :             state = Py_None;

  001a6	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  001ad	4c 8b e3	 mov	 r12, rbx
$LN61@reduce_2:

; 3457 :         Py_INCREF(state);

  001b0	e8 00 00 00 00	 call	 _Py_PXCTX
  001b5	85 c0		 test	 eax, eax
  001b7	75 35		 jne	 SHORT $LN73@reduce_2
  001b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  001c7	4d 8b cc	 mov	 r9, r12
  001ca	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  001d0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001d8	e8 00 00 00 00	 call	 _PyParallel_Guard
  001dd	85 c0		 test	 eax, eax
  001df	75 08		 jne	 SHORT $LN72@reduce_2
  001e1	41 f6 44 24 20
	20		 test	 BYTE PTR [r12+32], 32	; 00000020H
  001e7	74 05		 je	 SHORT $LN73@reduce_2
$LN72@reduce_2:
  001e9	49 ff 44 24 50	 inc	 QWORD PTR [r12+80]
$LN73@reduce_2:

; 3458 :         names = slotnames(cls);

  001ee	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cls$1$[rsp]
  001f3	e8 00 00 00 00	 call	 slotnames
  001f8	4c 8b f0	 mov	 r14, rax

; 3459 :         if (names == NULL)

  001fb	48 85 c0	 test	 rax, rax
  001fe	0f 84 b6 fe ff
	ff		 je	 $LN193@reduce_2

; 3460 :             goto end;
; 3461 :         if (names != Py_None && PyList_GET_SIZE(names) > 0) {

  00204	48 3b c3	 cmp	 rax, rbx
  00207	0f 84 c8 00 00
	00		 je	 $LN50@reduce_2
  0020d	48 39 70 60	 cmp	 QWORD PTR [rax+96], rsi
  00211	0f 8e be 00 00
	00		 jle	 $LN50@reduce_2

; 3462 :             assert(PyList_Check(names));
; 3463 :             slots = PyDict_New();

  00217	e8 00 00 00 00	 call	 PyDict_New
  0021c	48 8b f8	 mov	 rdi, rax
  0021f	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR slots$1$[rsp], rax

; 3464 :             if (slots == NULL)

  00227	48 85 c0	 test	 rax, rax
  0022a	0f 84 8a fe ff
	ff		 je	 $LN193@reduce_2

; 3465 :                 goto end;
; 3466 :             n = 0;
; 3467 :             /* Can't pre-compute the list size; the list
; 3468 :                is stored on the class so accessible to other
; 3469 :                threads, which may be run by DECREF */
; 3470 :             for (i = 0; i < PyList_GET_SIZE(names); i++) {

  00230	48 8b fd	 mov	 rdi, rbp
  00233	49 39 76 60	 cmp	 QWORD PTR [r14+96], rsi
  00237	0f 8e ba 00 00
	00		 jle	 $LN181@reduce_2
  0023d	0f 1f 00	 npad	 3
$LL57@reduce_2:

; 3471 :                 PyObject *name, *value;
; 3472 :                 name = PyList_GET_ITEM(names, i);

  00240	49 8b 46 70	 mov	 rax, QWORD PTR [r14+112]

; 3473 :                 value = PyObject_GetAttr(obj, name);

  00244	49 8b cd	 mov	 rcx, r13
  00247	48 8b 1c f8	 mov	 rbx, QWORD PTR [rax+rdi*8]
  0024b	48 8b d3	 mov	 rdx, rbx
  0024e	e8 00 00 00 00	 call	 PyObject_GetAttr
  00253	4c 8b e8	 mov	 r13, rax

; 3474 :                 if (value == NULL)

  00256	48 85 c0	 test	 rax, rax
  00259	75 07		 jne	 SHORT $LN54@reduce_2

; 3475 :                     PyErr_Clear();

  0025b	e8 00 00 00 00	 call	 PyErr_Clear

; 3476 :                 else {

  00260	eb 28		 jmp	 SHORT $LN56@reduce_2
$LN54@reduce_2:

; 3477 :                     int err = PyDict_SetItem(slots, name,
; 3478 :                                              value);

  00262	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR slots$1$[rsp]
  0026a	4c 8b c0	 mov	 r8, rax
  0026d	48 8b d3	 mov	 rdx, rbx
  00270	e8 00 00 00 00	 call	 PyDict_SetItem

; 3479 :                     Py_DECREF(value);

  00275	49 8b cd	 mov	 rcx, r13
  00278	8b d8		 mov	 ebx, eax
  0027a	e8 00 00 00 00	 call	 _Py_DecRef

; 3480 :                     if (err)

  0027f	85 db		 test	 ebx, ebx
  00281	0f 85 c8 01 00
	00		 jne	 $LN180@reduce_2

; 3481 :                         goto end;
; 3482 :                     n++;

  00287	48 ff c6	 inc	 rsi
$LN56@reduce_2:

; 3465 :                 goto end;
; 3466 :             n = 0;
; 3467 :             /* Can't pre-compute the list size; the list
; 3468 :                is stored on the class so accessible to other
; 3469 :                threads, which may be run by DECREF */
; 3470 :             for (i = 0; i < PyList_GET_SIZE(names); i++) {

  0028a	4c 8b ac 24 b0
	00 00 00	 mov	 r13, QWORD PTR obj$[rsp]
  00292	48 ff c7	 inc	 rdi
  00295	49 3b 7e 60	 cmp	 rdi, QWORD PTR [r14+96]
  00299	7c a5		 jl	 SHORT $LL57@reduce_2

; 3483 :                 }
; 3484 :             }
; 3485 :             if (n) {
; 3486 :                 state = Py_BuildValue("(NO)", state, slots);

  0029b	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR slots$1$[rsp]
  002a3	48 85 f6	 test	 rsi, rsi
  002a6	74 1e		 je	 SHORT $LN183@reduce_2
  002a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04IMCHBGDP@?$CINO?$CJ?$AA@
  002af	4c 8b c7	 mov	 r8, rdi
  002b2	49 8b d4	 mov	 rdx, r12
  002b5	e8 00 00 00 00	 call	 Py_BuildValue
  002ba	4c 8b e0	 mov	 r12, rax

; 3487 :                 if (state == NULL)

  002bd	48 85 c0	 test	 rax, rax
  002c0	0f 84 91 01 00
	00		 je	 $LN185@reduce_2
$LN183@reduce_2:

; 3411 : {

  002c6	4c 8b ac 24 b0
	00 00 00	 mov	 r13, QWORD PTR obj$[rsp]
$LN194@reduce_2:
  002ce	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
$LN50@reduce_2:

; 3488 :                     goto end;
; 3489 :             }
; 3490 :         }
; 3491 :     }
; 3492 : 
; 3493 :     if (!PyList_Check(obj)) {

  002d5	49 8b 45 58	 mov	 rax, QWORD PTR [r13+88]
  002d9	f7 80 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rax+256], 33554432 ; 02000000H
  002e3	75 17		 jne	 SHORT $LN49@reduce_2

; 3494 :         listitems = Py_None;
; 3495 :         Py_INCREF(listitems);

  002e5	48 8b cb	 mov	 rcx, rbx
  002e8	48 8b f3	 mov	 rsi, rbx
  002eb	48 89 5c 24 30	 mov	 QWORD PTR listitems$1$[rsp], rbx
  002f0	e8 00 00 00 00	 call	 _Py_IncRef

; 3496 :     }
; 3497 :     else {

  002f5	eb 1e		 jmp	 SHORT $LN47@reduce_2
$LN181@reduce_2:

; 3462 :             assert(PyList_Check(names));
; 3463 :             slots = PyDict_New();

  002f7	48 8b f8	 mov	 rdi, rax
  002fa	eb d9		 jmp	 SHORT $LN50@reduce_2
$LN49@reduce_2:

; 3498 :         listitems = PyObject_GetIter(obj);

  002fc	49 8b cd	 mov	 rcx, r13
  002ff	e8 00 00 00 00	 call	 PyObject_GetIter
  00304	48 8b f0	 mov	 rsi, rax
  00307	48 89 44 24 30	 mov	 QWORD PTR listitems$1$[rsp], rax

; 3499 :         if (listitems == NULL)

  0030c	48 85 c0	 test	 rax, rax
  0030f	0f 84 77 01 00
	00		 je	 $LN189@reduce_2
$LN47@reduce_2:

; 3500 :             goto end;
; 3501 :     }
; 3502 : 
; 3503 :     if (!PyDict_Check(obj)) {

  00315	49 8b 45 58	 mov	 rax, QWORD PTR [r13+88]
  00319	f7 80 00 01 00
	00 00 00 00 20	 test	 DWORD PTR [rax+256], 536870912 ; 20000000H
  00323	75 12		 jne	 SHORT $LN46@reduce_2

; 3504 :         dictitems = Py_None;
; 3505 :         Py_INCREF(dictitems);

  00325	48 8b cb	 mov	 rcx, rbx
  00328	48 89 9c 24 b8
	00 00 00	 mov	 QWORD PTR dictitems$1$[rsp], rbx
  00330	e8 00 00 00 00	 call	 _Py_IncRef

; 3506 :     }
; 3507 :     else {

  00335	eb 49		 jmp	 SHORT $LN43@reduce_2
$LN46@reduce_2:

; 3508 :         _Py_IDENTIFIER(items);
; 3509 :         PyObject *items = _PyObject_CallMethodId(obj, &PyId_items, "");

  00337	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_items@?P@??reduce_2@@9@9
  0033c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00343	49 8b cd	 mov	 rcx, r13
  00346	48 03 54 24 38	 add	 rdx, QWORD PTR tv1025[rsp]
  0034b	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  00350	48 8b d8	 mov	 rbx, rax

; 3510 :         if (items == NULL)

  00353	48 85 c0	 test	 rax, rax
  00356	0f 84 30 01 00
	00		 je	 $LN189@reduce_2

; 3511 :             goto end;
; 3512 :         dictitems = PyObject_GetIter(items);

  0035c	48 8b c8	 mov	 rcx, rax
  0035f	e8 00 00 00 00	 call	 PyObject_GetIter

; 3513 :         Py_DECREF(items);

  00364	48 8b cb	 mov	 rcx, rbx
  00367	4c 8b e8	 mov	 r13, rax
  0036a	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR dictitems$1$[rsp], rax
  00372	e8 00 00 00 00	 call	 _Py_DecRef

; 3514 :         if (dictitems == NULL)

  00377	4d 85 ed	 test	 r13, r13
  0037a	0f 84 01 01 00
	00		 je	 $LN188@reduce_2
$LN43@reduce_2:

; 3515 :             goto end;
; 3516 :     }
; 3517 : 
; 3518 :     copyreg = import_copyreg();

  00380	e8 00 00 00 00	 call	 import_copyreg
  00385	48 89 44 24 48	 mov	 QWORD PTR copyreg$1$[rsp], rax

; 3519 :     if (copyreg == NULL)

  0038a	48 85 c0	 test	 rax, rax
  0038d	0f 84 de 00 00
	00		 je	 $LN187@reduce_2

; 3520 :         goto end;
; 3521 :     newobj = _PyObject_GetAttrId(copyreg, &PyId___newobj__);

  00393	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___newobj__@?1??reduce_2@@9@9
  00398	48 8b c8	 mov	 rcx, rax
  0039b	48 03 54 24 38	 add	 rdx, QWORD PTR tv1025[rsp]
  003a0	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  003a5	4c 8b e8	 mov	 r13, rax
  003a8	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR newobj$1$[rsp], rax

; 3522 :     if (newobj == NULL)

  003b0	48 85 c0	 test	 rax, rax
  003b3	0f 84 ab 00 00
	00		 je	 $LN186@reduce_2

; 3523 :         goto end;
; 3524 : 
; 3525 :     n = PyTuple_GET_SIZE(args);

  003b9	49 8b 77 60	 mov	 rsi, QWORD PTR [r15+96]

; 3526 :     args2 = PyTuple_New(n+1);

  003bd	48 8d 4e 01	 lea	 rcx, QWORD PTR [rsi+1]
  003c1	e8 00 00 00 00	 call	 PyTuple_New
  003c6	48 8b e8	 mov	 rbp, rax

; 3527 :     if (args2 == NULL)

  003c9	48 85 c0	 test	 rax, rax
  003cc	0f 84 8d 00 00
	00		 je	 $LN184@reduce_2

; 3528 :         goto end;
; 3529 :     Py_INCREF(cls);

  003d2	48 8b 5c 24 40	 mov	 rbx, QWORD PTR cls$1$[rsp]
  003d7	48 8b cb	 mov	 rcx, rbx
  003da	e8 00 00 00 00	 call	 _Py_IncRef

; 3530 :     PyTuple_SET_ITEM(args2, 0, cls);

  003df	48 89 5d 70	 mov	 QWORD PTR [rbp+112], rbx

; 3531 :     for (i = 0; i < n; i++) {

  003e3	48 85 f6	 test	 rsi, rsi
  003e6	7e 2b		 jle	 SHORT $LN37@reduce_2
  003e8	4d 8b ef	 mov	 r13, r15
  003eb	48 8d 7d 78	 lea	 rdi, QWORD PTR [rbp+120]
  003ef	4c 2b ed	 sub	 r13, rbp
$LL39@reduce_2:

; 3532 :         PyObject *v = PyTuple_GET_ITEM(args, i);

  003f2	49 8b 5c 3d f8	 mov	 rbx, QWORD PTR [r13+rdi-8]

; 3533 :         Py_INCREF(v);

  003f7	48 8b cb	 mov	 rcx, rbx
  003fa	e8 00 00 00 00	 call	 _Py_IncRef

; 3534 :         PyTuple_SET_ITEM(args2, i+1, v);

  003ff	48 89 1f	 mov	 QWORD PTR [rdi], rbx
  00402	48 83 c7 08	 add	 rdi, 8
  00406	48 ff ce	 dec	 rsi
  00409	75 e7		 jne	 SHORT $LL39@reduce_2
  0040b	4c 8b ac 24 c0
	00 00 00	 mov	 r13, QWORD PTR newobj$1$[rsp]
$LN37@reduce_2:

; 3535 :     }
; 3536 : 
; 3537 :     res = PyTuple_Pack(5, newobj, args2, state, listitems, dictitems);

  00413	48 8b 9c 24 b8
	00 00 00	 mov	 rbx, QWORD PTR dictitems$1$[rsp]
  0041b	48 8b 74 24 30	 mov	 rsi, QWORD PTR listitems$1$[rsp]
  00420	4d 8b cc	 mov	 r9, r12
  00423	4c 8b c5	 mov	 r8, rbp
  00426	49 8b d5	 mov	 rdx, r13
  00429	b9 05 00 00 00	 mov	 ecx, 5
  0042e	48 89 5c 24 28	 mov	 QWORD PTR [rsp+40], rbx
  00433	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00438	e8 00 00 00 00	 call	 PyTuple_Pack
  0043d	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR slots$1$[rsp]
  00445	48 89 44 24 50	 mov	 QWORD PTR res$1$[rsp], rax
  0044a	e9 71 fc ff ff	 jmp	 $end$23145
$LN180@reduce_2:

; 3462 :             assert(PyList_Check(names));
; 3463 :             slots = PyDict_New();

  0044f	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR slots$1$[rsp]
$LN185@reduce_2:
  00457	48 8b f5	 mov	 rsi, rbp
  0045a	e9 5b fc ff ff	 jmp	 $LN193@reduce_2
$LN184@reduce_2:
  0045f	48 8b 74 24 30	 mov	 rsi, QWORD PTR listitems$1$[rsp]
$LN186@reduce_2:
  00464	48 8b 9c 24 b8
	00 00 00	 mov	 rbx, QWORD PTR dictitems$1$[rsp]
  0046c	e9 4f fc ff ff	 jmp	 $end$23145
$LN187@reduce_2:
  00471	48 8b 9c 24 b8
	00 00 00	 mov	 rbx, QWORD PTR dictitems$1$[rsp]
  00479	4c 8b ed	 mov	 r13, rbp
  0047c	e9 3f fc ff ff	 jmp	 $end$23145
$LN188@reduce_2:
  00481	49 8b dd	 mov	 rbx, r13
  00484	4c 8b ed	 mov	 r13, rbp
  00487	e9 34 fc ff ff	 jmp	 $end$23145
$LN189@reduce_2:
  0048c	48 8b dd	 mov	 rbx, rbp
  0048f	e9 29 fc ff ff	 jmp	 $LN195@reduce_2

; 3538 : 
; 3539 :   end:
; 3540 :     Py_XDECREF(args);

$LN85@reduce_2:
  00494	49 8b 47 58	 mov	 rax, QWORD PTR [r15+88]
  00498	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0049e	eb 08		 jmp	 SHORT $LN35@reduce_2
$LN80@reduce_2:
  004a0	49 8b cf	 mov	 rcx, r15
  004a3	e8 00 00 00 00	 call	 Px_DecRef
$LN35@reduce_2:

; 3541 :     Py_XDECREF(args2);

  004a8	48 85 ed	 test	 rbp, rbp
  004ab	74 65		 je	 SHORT $LN31@reduce_2
  004ad	e8 00 00 00 00	 call	 _Py_PXCTX
  004b2	85 c0		 test	 eax, eax
  004b4	75 5c		 jne	 SHORT $LN31@reduce_2
  004b6	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  004ba	a8 20		 test	 al, 32			; 00000020H
  004bc	75 4c		 jne	 SHORT $LN91@reduce_2
  004be	84 c0		 test	 al, al
  004c0	78 48		 js	 SHORT $LN91@reduce_2
  004c2	a8 02		 test	 al, 2
  004c4	75 4c		 jne	 SHORT $LN31@reduce_2
  004c6	48 ff 4d 50	 dec	 QWORD PTR [rbp+80]
  004ca	75 46		 jne	 SHORT $LN31@reduce_2
  004cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  004d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  004da	4c 8b cd	 mov	 r9, rbp
  004dd	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  004e3	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  004eb	e8 00 00 00 00	 call	 _PyParallel_Guard
  004f0	48 8b cd	 mov	 rcx, rbp
  004f3	85 c0		 test	 eax, eax
  004f5	74 07		 je	 SHORT $LN96@reduce_2
  004f7	e8 00 00 00 00	 call	 _Px_Dealloc
  004fc	eb 14		 jmp	 SHORT $LN31@reduce_2
$LN96@reduce_2:
  004fe	48 8b 45 58	 mov	 rax, QWORD PTR [rbp+88]
  00502	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00508	eb 08		 jmp	 SHORT $LN31@reduce_2
$LN91@reduce_2:
  0050a	48 8b cd	 mov	 rcx, rbp
  0050d	e8 00 00 00 00	 call	 Px_DecRef
$LN31@reduce_2:

; 3542 :     Py_XDECREF(slots);

  00512	48 85 ff	 test	 rdi, rdi
  00515	74 65		 je	 SHORT $LN27@reduce_2
  00517	e8 00 00 00 00	 call	 _Py_PXCTX
  0051c	85 c0		 test	 eax, eax
  0051e	75 5c		 jne	 SHORT $LN27@reduce_2
  00520	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00524	a8 20		 test	 al, 32			; 00000020H
  00526	75 4c		 jne	 SHORT $LN102@reduce_2
  00528	84 c0		 test	 al, al
  0052a	78 48		 js	 SHORT $LN102@reduce_2
  0052c	a8 02		 test	 al, 2
  0052e	75 4c		 jne	 SHORT $LN27@reduce_2
  00530	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00534	75 46		 jne	 SHORT $LN27@reduce_2
  00536	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0053d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00544	4c 8b cf	 mov	 r9, rdi
  00547	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0054d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00555	e8 00 00 00 00	 call	 _PyParallel_Guard
  0055a	48 8b cf	 mov	 rcx, rdi
  0055d	85 c0		 test	 eax, eax
  0055f	74 07		 je	 SHORT $LN107@reduce_2
  00561	e8 00 00 00 00	 call	 _Px_Dealloc
  00566	eb 14		 jmp	 SHORT $LN27@reduce_2
$LN107@reduce_2:
  00568	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0056c	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00572	eb 08		 jmp	 SHORT $LN27@reduce_2
$LN102@reduce_2:
  00574	48 8b cf	 mov	 rcx, rdi
  00577	e8 00 00 00 00	 call	 Px_DecRef
$LN27@reduce_2:

; 3543 :     Py_XDECREF(state);

  0057c	4d 85 e4	 test	 r12, r12
  0057f	74 68		 je	 SHORT $LN23@reduce_2
  00581	e8 00 00 00 00	 call	 _Py_PXCTX
  00586	85 c0		 test	 eax, eax
  00588	75 5f		 jne	 SHORT $LN23@reduce_2
  0058a	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  0058f	a8 20		 test	 al, 32			; 00000020H
  00591	75 4e		 jne	 SHORT $LN113@reduce_2
  00593	84 c0		 test	 al, al
  00595	78 4a		 js	 SHORT $LN113@reduce_2
  00597	a8 02		 test	 al, 2
  00599	75 4e		 jne	 SHORT $LN23@reduce_2
  0059b	49 ff 4c 24 50	 dec	 QWORD PTR [r12+80]
  005a0	75 47		 jne	 SHORT $LN23@reduce_2
  005a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  005a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  005b0	4d 8b cc	 mov	 r9, r12
  005b3	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  005b9	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  005c1	e8 00 00 00 00	 call	 _PyParallel_Guard
  005c6	49 8b cc	 mov	 rcx, r12
  005c9	85 c0		 test	 eax, eax
  005cb	74 07		 je	 SHORT $LN118@reduce_2
  005cd	e8 00 00 00 00	 call	 _Px_Dealloc
  005d2	eb 15		 jmp	 SHORT $LN23@reduce_2
$LN118@reduce_2:
  005d4	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  005d9	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  005df	eb 08		 jmp	 SHORT $LN23@reduce_2
$LN113@reduce_2:
  005e1	49 8b cc	 mov	 rcx, r12
  005e4	e8 00 00 00 00	 call	 Px_DecRef
$LN23@reduce_2:

; 3544 :     Py_XDECREF(names);

  005e9	4d 85 f6	 test	 r14, r14
  005ec	74 65		 je	 SHORT $LN19@reduce_2
  005ee	e8 00 00 00 00	 call	 _Py_PXCTX
  005f3	85 c0		 test	 eax, eax
  005f5	75 5c		 jne	 SHORT $LN19@reduce_2
  005f7	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  005fb	a8 20		 test	 al, 32			; 00000020H
  005fd	75 4c		 jne	 SHORT $LN124@reduce_2
  005ff	84 c0		 test	 al, al
  00601	78 48		 js	 SHORT $LN124@reduce_2
  00603	a8 02		 test	 al, 2
  00605	75 4c		 jne	 SHORT $LN19@reduce_2
  00607	49 ff 4e 50	 dec	 QWORD PTR [r14+80]
  0060b	75 46		 jne	 SHORT $LN19@reduce_2
  0060d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00614	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0061b	4d 8b ce	 mov	 r9, r14
  0061e	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00624	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0062c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00631	49 8b ce	 mov	 rcx, r14
  00634	85 c0		 test	 eax, eax
  00636	74 07		 je	 SHORT $LN129@reduce_2
  00638	e8 00 00 00 00	 call	 _Px_Dealloc
  0063d	eb 14		 jmp	 SHORT $LN19@reduce_2
$LN129@reduce_2:
  0063f	49 8b 46 58	 mov	 rax, QWORD PTR [r14+88]
  00643	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00649	eb 08		 jmp	 SHORT $LN19@reduce_2
$LN124@reduce_2:
  0064b	49 8b ce	 mov	 rcx, r14
  0064e	e8 00 00 00 00	 call	 Px_DecRef
$LN19@reduce_2:

; 3545 :     Py_XDECREF(listitems);

  00653	48 85 f6	 test	 rsi, rsi
  00656	74 65		 je	 SHORT $LN15@reduce_2
  00658	e8 00 00 00 00	 call	 _Py_PXCTX
  0065d	85 c0		 test	 eax, eax
  0065f	75 5c		 jne	 SHORT $LN15@reduce_2
  00661	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  00665	a8 20		 test	 al, 32			; 00000020H
  00667	75 4c		 jne	 SHORT $LN135@reduce_2
  00669	84 c0		 test	 al, al
  0066b	78 48		 js	 SHORT $LN135@reduce_2
  0066d	a8 02		 test	 al, 2
  0066f	75 4c		 jne	 SHORT $LN15@reduce_2
  00671	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  00675	75 46		 jne	 SHORT $LN15@reduce_2
  00677	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0067e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00685	4c 8b ce	 mov	 r9, rsi
  00688	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0068e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00696	e8 00 00 00 00	 call	 _PyParallel_Guard
  0069b	48 8b ce	 mov	 rcx, rsi
  0069e	85 c0		 test	 eax, eax
  006a0	74 07		 je	 SHORT $LN140@reduce_2
  006a2	e8 00 00 00 00	 call	 _Px_Dealloc
  006a7	eb 14		 jmp	 SHORT $LN15@reduce_2
$LN140@reduce_2:
  006a9	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  006ad	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  006b3	eb 08		 jmp	 SHORT $LN15@reduce_2
$LN135@reduce_2:
  006b5	48 8b ce	 mov	 rcx, rsi
  006b8	e8 00 00 00 00	 call	 Px_DecRef
$LN15@reduce_2:

; 3546 :     Py_XDECREF(dictitems);

  006bd	48 85 db	 test	 rbx, rbx
  006c0	74 65		 je	 SHORT $LN11@reduce_2
  006c2	e8 00 00 00 00	 call	 _Py_PXCTX
  006c7	85 c0		 test	 eax, eax
  006c9	75 5c		 jne	 SHORT $LN11@reduce_2
  006cb	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  006cf	a8 20		 test	 al, 32			; 00000020H
  006d1	75 4c		 jne	 SHORT $LN146@reduce_2
  006d3	84 c0		 test	 al, al
  006d5	78 48		 js	 SHORT $LN146@reduce_2
  006d7	a8 02		 test	 al, 2
  006d9	75 4c		 jne	 SHORT $LN11@reduce_2
  006db	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  006df	75 46		 jne	 SHORT $LN11@reduce_2
  006e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  006e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  006ef	4c 8b cb	 mov	 r9, rbx
  006f2	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  006f8	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00700	e8 00 00 00 00	 call	 _PyParallel_Guard
  00705	48 8b cb	 mov	 rcx, rbx
  00708	85 c0		 test	 eax, eax
  0070a	74 07		 je	 SHORT $LN151@reduce_2
  0070c	e8 00 00 00 00	 call	 _Px_Dealloc
  00711	eb 14		 jmp	 SHORT $LN11@reduce_2
$LN151@reduce_2:
  00713	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00717	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0071d	eb 08		 jmp	 SHORT $LN11@reduce_2
$LN146@reduce_2:
  0071f	48 8b cb	 mov	 rcx, rbx
  00722	e8 00 00 00 00	 call	 Px_DecRef
$LN11@reduce_2:

; 3547 :     Py_XDECREF(copyreg);

  00727	48 8b 5c 24 48	 mov	 rbx, QWORD PTR copyreg$1$[rsp]
  0072c	48 85 db	 test	 rbx, rbx
  0072f	74 65		 je	 SHORT $LN7@reduce_2
  00731	e8 00 00 00 00	 call	 _Py_PXCTX
  00736	85 c0		 test	 eax, eax
  00738	75 5c		 jne	 SHORT $LN7@reduce_2
  0073a	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0073e	a8 20		 test	 al, 32			; 00000020H
  00740	75 4c		 jne	 SHORT $LN157@reduce_2
  00742	84 c0		 test	 al, al
  00744	78 48		 js	 SHORT $LN157@reduce_2
  00746	a8 02		 test	 al, 2
  00748	75 4c		 jne	 SHORT $LN7@reduce_2
  0074a	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0074e	75 46		 jne	 SHORT $LN7@reduce_2
  00750	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00757	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0075e	4c 8b cb	 mov	 r9, rbx
  00761	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00767	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0076f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00774	48 8b cb	 mov	 rcx, rbx
  00777	85 c0		 test	 eax, eax
  00779	74 07		 je	 SHORT $LN162@reduce_2
  0077b	e8 00 00 00 00	 call	 _Px_Dealloc
  00780	eb 14		 jmp	 SHORT $LN7@reduce_2
$LN162@reduce_2:
  00782	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00786	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0078c	eb 08		 jmp	 SHORT $LN7@reduce_2
$LN157@reduce_2:
  0078e	48 8b cb	 mov	 rcx, rbx
  00791	e8 00 00 00 00	 call	 Px_DecRef
$LN7@reduce_2:

; 3548 :     Py_XDECREF(newobj);

  00796	4d 85 ed	 test	 r13, r13
  00799	74 65		 je	 SHORT $LN3@reduce_2
  0079b	e8 00 00 00 00	 call	 _Py_PXCTX
  007a0	85 c0		 test	 eax, eax
  007a2	75 5c		 jne	 SHORT $LN3@reduce_2
  007a4	49 8b 45 20	 mov	 rax, QWORD PTR [r13+32]
  007a8	a8 20		 test	 al, 32			; 00000020H
  007aa	75 4c		 jne	 SHORT $LN168@reduce_2
  007ac	84 c0		 test	 al, al
  007ae	78 48		 js	 SHORT $LN168@reduce_2
  007b0	a8 02		 test	 al, 2
  007b2	75 4c		 jne	 SHORT $LN3@reduce_2
  007b4	49 ff 4d 50	 dec	 QWORD PTR [r13+80]
  007b8	75 46		 jne	 SHORT $LN3@reduce_2
  007ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  007c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  007c8	4d 8b cd	 mov	 r9, r13
  007cb	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  007d1	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  007d9	e8 00 00 00 00	 call	 _PyParallel_Guard
  007de	49 8b cd	 mov	 rcx, r13
  007e1	85 c0		 test	 eax, eax
  007e3	74 07		 je	 SHORT $LN173@reduce_2
  007e5	e8 00 00 00 00	 call	 _Px_Dealloc
  007ea	eb 14		 jmp	 SHORT $LN3@reduce_2
$LN173@reduce_2:
  007ec	49 8b 45 58	 mov	 rax, QWORD PTR [r13+88]
  007f0	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  007f6	eb 08		 jmp	 SHORT $LN3@reduce_2
$LN168@reduce_2:
  007f8	49 8b cd	 mov	 rcx, r13
  007fb	e8 00 00 00 00	 call	 Px_DecRef
$LN3@reduce_2:

; 3549 :     return res;

  00800	48 8b 44 24 50	 mov	 rax, QWORD PTR res$1$[rsp]

; 3550 : }

  00805	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00809	41 5f		 pop	 r15
  0080b	41 5e		 pop	 r14
  0080d	41 5d		 pop	 r13
  0080f	41 5c		 pop	 r12
  00811	5f		 pop	 rdi
  00812	5e		 pop	 rsi
  00813	5d		 pop	 rbp
  00814	5b		 pop	 rbx
  00815	c3		 ret	 0
reduce_2 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@JEKBMHHK@_reduce_ex?$AA@		; `string'
PUBLIC	??_C@_04IFLELAI@?$CIOi?$CJ?$AA@			; `string'
EXTRN	PyEval_CallMethod:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_common_reduce DD imagerel _common_reduce
	DD	imagerel _common_reduce+35
	DD	imagerel $unwind$_common_reduce
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_common_reduce DD imagerel _common_reduce+35
	DD	imagerel _common_reduce+69
	DD	imagerel $chain$0$_common_reduce
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_common_reduce DD imagerel _common_reduce+69
	DD	imagerel _common_reduce+128
	DD	imagerel $chain$2$_common_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_common_reduce DD 020021H
	DD	087400H
	DD	imagerel _common_reduce
	DD	imagerel _common_reduce+35
	DD	imagerel $unwind$_common_reduce
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_common_reduce DD 020521H
	DD	087405H
	DD	imagerel _common_reduce
	DD	imagerel _common_reduce+35
	DD	imagerel $unwind$_common_reduce
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_common_reduce DD 040a01H
	DD	09340aH
	DD	06006520aH
xdata	ENDS
;	COMDAT ??_C@_0L@JEKBMHHK@_reduce_ex?$AA@
CONST	SEGMENT
??_C@_0L@JEKBMHHK@_reduce_ex?$AA@ DB '_reduce_ex', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04IFLELAI@?$CIOi?$CJ?$AA@
CONST	SEGMENT
??_C@_04IFLELAI@?$CIOi?$CJ?$AA@ DB '(Oi)', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _common_reduce
_TEXT	SEGMENT
self$ = 64
proto$ = 72
_common_reduce PROC					; COMDAT

; 3569 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	8b da		 mov	 ebx, edx
  0000c	48 8b f1	 mov	 rsi, rcx

; 3570 :     PyObject *copyreg, *res;
; 3571 : 
; 3572 :     if (proto >= 2)

  0000f	83 fa 02	 cmp	 edx, 2
  00012	7c 0f		 jl	 SHORT $LN2@common_red

; 3583 : }

  00014	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00019	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0001d	5e		 pop	 rsi
  0001e	e9 00 00 00 00	 jmp	 reduce_2
$LN2@common_red:
  00023	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi

; 3573 :         return reduce_2(self);
; 3574 : 
; 3575 :     copyreg = import_copyreg();

  00028	e8 00 00 00 00	 call	 import_copyreg
  0002d	48 8b f8	 mov	 rdi, rax

; 3576 :     if (!copyreg)

  00030	48 85 c0	 test	 rax, rax
  00033	75 10		 jne	 SHORT $LN1@common_red
  00035	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 3583 : }

  0003a	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0003f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00043	5e		 pop	 rsi
  00044	c3		 ret	 0
$LN1@common_red:

; 3577 :         return NULL;
; 3578 : 
; 3579 :     res = PyEval_CallMethod(copyreg, "_reduce_ex", "(Oi)", self, proto);

  00045	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04IFLELAI@?$CIOi?$CJ?$AA@
  0004c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@JEKBMHHK@_reduce_ex?$AA@
  00053	4c 8b ce	 mov	 r9, rsi
  00056	48 8b c8	 mov	 rcx, rax
  00059	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  0005d	e8 00 00 00 00	 call	 PyEval_CallMethod

; 3580 :     Py_DECREF(copyreg);

  00062	48 8b cf	 mov	 rcx, rdi
  00065	48 8b d8	 mov	 rbx, rax
  00068	e8 00 00 00 00	 call	 _Py_DecRef
  0006d	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 3581 : 
; 3582 :     return res;

  00072	48 8b c3	 mov	 rax, rbx

; 3583 : }

  00075	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0007a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007e	5e		 pop	 rsi
  0007f	c3		 ret	 0
_common_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@NABOMNBG@?$HMi?3__reduce__?$AA@	; `string'
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$object_reduce DD imagerel object_reduce
	DD	imagerel object_reduce+70
	DD	imagerel $unwind$object_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$object_reduce DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0O@NABOMNBG@?$HMi?3__reduce__?$AA@
CONST	SEGMENT
??_C@_0O@NABOMNBG@?$HMi?3__reduce__?$AA@ DB '|i:__reduce__', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT object_reduce
_TEXT	SEGMENT
self$ = 48
args$ = 56
proto$ = 64
object_reduce PROC					; COMDAT

; 3587 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 3588 :     int proto = 0;
; 3589 : 
; 3590 :     if (!PyArg_ParseTuple(args, "|i:__reduce__", &proto))

  0000c	4c 8d 44 24 40	 lea	 r8, QWORD PTR proto$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@NABOMNBG@?$HMi?3__reduce__?$AA@
  00018	48 8b c8	 mov	 rcx, rax
  0001b	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR proto$[rsp], 0
  00023	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00028	85 c0		 test	 eax, eax
  0002a	75 08		 jne	 SHORT $LN1@object_red@2

; 3591 :         return NULL;

  0002c	33 c0		 xor	 eax, eax

; 3594 : }

  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5b		 pop	 rbx
  00033	c3		 ret	 0
$LN1@object_red@2:

; 3592 : 
; 3593 :     return _common_reduce(self, proto);

  00034	8b 54 24 40	 mov	 edx, DWORD PTR proto$[rsp]
  00038	48 8b cb	 mov	 rcx, rbx
  0003b	e8 00 00 00 00	 call	 _common_reduce

; 3594 : }

  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5b		 pop	 rbx
  00045	c3		 ret	 0
object_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@IDCJELDA@?$HMi?3__reduce_ex__?$AA@	; `string'
_BSS	SEGMENT
?objreduce@?1??object_reduce_ex@@9@9 DQ 01H DUP (?)	; `object_reduce_ex'::`2'::objreduce
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$object_reduce_ex DD imagerel object_reduce_ex
	DD	imagerel object_reduce_ex+287
	DD	imagerel $unwind$object_reduce_ex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$object_reduce_ex DD 084c01H
	DD	07744cH
	DD	065447H
	DD	09340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT ??_C@_0BB@IDCJELDA@?$HMi?3__reduce_ex__?$AA@
CONST	SEGMENT
??_C@_0BB@IDCJELDA@?$HMi?3__reduce_ex__?$AA@ DB '|i:__reduce_ex__', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT object_reduce_ex
_TEXT	SEGMENT
self$ = 48
args$ = 56
proto$ = 64
object_reduce_ex PROC					; COMDAT

; 3598 : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b c2	 mov	 rax, rdx
  0000d	48 8b f1	 mov	 rsi, rcx

; 3599 :     static PyObject *objreduce;
; 3600 :     PyObject *reduce, *res;
; 3601 :     int proto = 0;
; 3602 :     _Py_IDENTIFIER(__reduce__);
; 3603 : 
; 3604 :     if (!PyArg_ParseTuple(args, "|i:__reduce_ex__", &proto))

  00010	4c 8d 44 24 40	 lea	 r8, QWORD PTR proto$[rsp]
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@IDCJELDA@?$HMi?3__reduce_ex__?$AA@
  0001c	33 db		 xor	 ebx, ebx
  0001e	48 8b c8	 mov	 rcx, rax
  00021	89 5c 24 40	 mov	 DWORD PTR proto$[rsp], ebx
  00025	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0002a	85 c0		 test	 eax, eax
  0002c	75 0d		 jne	 SHORT $LN8@object_red@3

; 3605 :         return NULL;

  0002e	33 c0		 xor	 eax, eax

; 3639 : }

  00030	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5e		 pop	 rsi
  0003a	c3		 ret	 0
$LN8@object_red@3:

; 3606 : 
; 3607 :     if (objreduce == NULL) {

  0003b	48 39 1d 00 00
	00 00		 cmp	 QWORD PTR ?objreduce@?1??object_reduce_ex@@9@9, rbx
  00042	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00047	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0004c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _tls_index
  00052	bd 00 00 00 00	 mov	 ebp, OFFSET FLAT:?PyId___reduce__@?1??object_reduce_ex@@9@9
  00057	75 27		 jne	 SHORT $LN6@object_red@3

; 3608 :         objreduce = _PyDict_GetItemId(PyBaseObject_Type.tp_dict,
; 3609 :                                       &PyId___reduce__);

  00059	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00062	48 8b 0d 60 01
	00 00		 mov	 rcx, QWORD PTR PyBaseObject_Type+352
  00069	8b d5		 mov	 edx, ebp
  0006b	48 03 14 f8	 add	 rdx, QWORD PTR [rax+rdi*8]
  0006f	e8 00 00 00 00	 call	 _PyDict_GetItemId
  00074	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?objreduce@?1??object_reduce_ex@@9@9, rax

; 3610 :         if (objreduce == NULL)

  0007b	48 85 c0	 test	 rax, rax

; 3611 :             return NULL;

  0007e	74 45		 je	 SHORT $LN13@object_red@3
$LN6@object_red@3:

; 3612 :     }
; 3613 : 
; 3614 :     reduce = _PyObject_GetAttrId(self, &PyId___reduce__);

  00080	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00089	8b cd		 mov	 ecx, ebp
  0008b	48 8b 2c f8	 mov	 rbp, QWORD PTR [rax+rdi*8]
  0008f	48 03 e9	 add	 rbp, rcx
  00092	48 8b ce	 mov	 rcx, rsi
  00095	48 8b d5	 mov	 rdx, rbp
  00098	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  0009d	48 8b f8	 mov	 rdi, rax

; 3615 :     if (reduce == NULL)

  000a0	48 85 c0	 test	 rax, rax
  000a3	75 07		 jne	 SHORT $LN5@object_red@3

; 3616 :         PyErr_Clear();

  000a5	e8 00 00 00 00	 call	 PyErr_Clear

; 3617 :     else {

  000aa	eb 52		 jmp	 SHORT $LN1@object_red@3
$LN5@object_red@3:

; 3618 :         PyObject *cls, *clsreduce;
; 3619 :         int override;
; 3620 : 
; 3621 :         cls = (PyObject *) Py_TYPE(self);
; 3622 :         clsreduce = _PyObject_GetAttrId(cls, &PyId___reduce__);

  000ac	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  000b0	48 8b d5	 mov	 rdx, rbp
  000b3	e8 00 00 00 00	 call	 _PyObject_GetAttrId

; 3623 :         if (clsreduce == NULL) {

  000b8	48 85 c0	 test	 rax, rax
  000bb	75 0c		 jne	 SHORT $LN3@object_red@3

; 3624 :             Py_DECREF(reduce);

  000bd	48 8b cf	 mov	 rcx, rdi
  000c0	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@object_red@3:

; 3625 :             return NULL;

  000c5	33 c0		 xor	 eax, eax
  000c7	eb 41		 jmp	 SHORT $LN12@object_red@3
$LN3@object_red@3:

; 3626 :         }
; 3627 :         override = (clsreduce != objreduce);

  000c9	48 3b 05 00 00
	00 00		 cmp	 rax, QWORD PTR ?objreduce@?1??object_reduce_ex@@9@9

; 3628 :         Py_DECREF(clsreduce);

  000d0	48 8b c8	 mov	 rcx, rax
  000d3	0f 95 c3	 setne	 bl
  000d6	e8 00 00 00 00	 call	 _Py_DecRef

; 3629 :         if (override) {
; 3630 :             res = PyObject_CallObject(reduce, NULL);

  000db	48 8b cf	 mov	 rcx, rdi
  000de	85 db		 test	 ebx, ebx
  000e0	74 17		 je	 SHORT $LN2@object_red@3
  000e2	33 d2		 xor	 edx, edx
  000e4	e8 00 00 00 00	 call	 PyObject_CallObject

; 3631 :             Py_DECREF(reduce);

  000e9	48 8b cf	 mov	 rcx, rdi
  000ec	48 8b d8	 mov	 rbx, rax
  000ef	e8 00 00 00 00	 call	 _Py_DecRef

; 3632 :             return res;

  000f4	48 8b c3	 mov	 rax, rbx
  000f7	eb 11		 jmp	 SHORT $LN12@object_red@3
$LN2@object_red@3:

; 3633 :         }
; 3634 :         else
; 3635 :             Py_DECREF(reduce);

  000f9	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@object_red@3:

; 3636 :     }
; 3637 : 
; 3638 :     return _common_reduce(self, proto);

  000fe	8b 54 24 40	 mov	 edx, DWORD PTR proto$[rsp]
  00102	48 8b ce	 mov	 rcx, rsi
  00105	e8 00 00 00 00	 call	 _common_reduce
$LN12@object_red@3:

; 3639 : }

  0010a	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  0010f	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  00114	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00119	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011d	5e		 pop	 rsi
  0011e	c3		 ret	 0
object_reduce_ex ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$object_subclasshook DD imagerel object_subclasshook
	DD	imagerel object_subclasshook+100
	DD	imagerel $unwind$object_subclasshook
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$object_subclasshook DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT object_subclasshook
_TEXT	SEGMENT
cls$ = 64
args$ = 72
object_subclasshook PROC				; COMDAT

; 3643 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3644 :     Py_RETURN_NOTIMPLEMENTED;

  00006	e8 00 00 00 00	 call	 _Py_PXCTX
  0000b	85 c0		 test	 eax, eax
  0000d	75 48		 jne	 SHORT $LN7@object_sub
  0000f	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NotImplementedStruct
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00024	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0002a	4c 8b cb	 mov	 r9, rbx
  0002d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00035	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003a	85 c0		 test	 eax, eax
  0003c	75 09		 jne	 SHORT $LN3@object_sub
  0003e	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  00045	74 07		 je	 SHORT $LN9@object_sub
$LN3@object_sub:
  00047	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN9@object_sub:
  0004e	48 8b c3	 mov	 rax, rbx

; 3645 : }

  00051	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00055	5b		 pop	 rbx
  00056	c3		 ret	 0
$LN7@object_sub:

; 3644 :     Py_RETURN_NOTIMPLEMENTED;

  00057	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 3645 : }

  0005e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00062	5b		 pop	 rbx
  00063	c3		 ret	 0
object_subclasshook ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DP@MPDCLJEC@object?4__format__?5with?5a?5non?9emp@ ; `string'
PUBLIC	??_C@_0N@EKIKMBMC@U?3__format__?$AA@		; `string'
EXTRN	PyObject_Format:PROC
EXTRN	PyErr_WarnEx:PROC
EXTRN	PyExc_DeprecationWarning:QWORD
EXTRN	PyObject_Str:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$object_format DD imagerel object_format
	DD	imagerel object_format+272
	DD	imagerel $unwind$object_format
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$object_format DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0DP@MPDCLJEC@object?4__format__?5with?5a?5non?9emp@
CONST	SEGMENT
??_C@_0DP@MPDCLJEC@object?4__format__?5with?5a?5non?9emp@ DB 'object.__fo'
	DB	'rmat__ with a non-empty format string is deprecated', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EKIKMBMC@U?3__format__?$AA@
CONST	SEGMENT
??_C@_0N@EKIKMBMC@U?3__format__?$AA@ DB 'U:__format__', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
CONST	ENDS
;	COMDAT object_format
_TEXT	SEGMENT
self$ = 64
args$ = 72
format_spec$ = 80
object_format PROC					; COMDAT

; 3664 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b c2	 mov	 rax, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 3665 :     PyObject *format_spec;
; 3666 :     PyObject *self_as_str = NULL;
; 3667 :     PyObject *result = NULL;
; 3668 : 
; 3669 :     if (!PyArg_ParseTuple(args, "U:__format__", &format_spec))

  00010	4c 8d 44 24 50	 lea	 r8, QWORD PTR format_spec$[rsp]
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@EKIKMBMC@U?3__format__?$AA@
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	33 ff		 xor	 edi, edi
  00021	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00026	85 c0		 test	 eax, eax
  00028	75 0d		 jne	 SHORT $LN8@object_for

; 3670 :         return NULL;

  0002a	33 c0		 xor	 eax, eax

; 3696 : }

  0002c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00031	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00035	5f		 pop	 rdi
  00036	c3		 ret	 0
$LN8@object_for:

; 3671 : 
; 3672 :     self_as_str = PyObject_Str(self);

  00037	48 8b cb	 mov	 rcx, rbx
  0003a	e8 00 00 00 00	 call	 PyObject_Str
  0003f	48 8b d8	 mov	 rbx, rax

; 3673 :     if (self_as_str != NULL) {

  00042	48 85 c0	 test	 rax, rax
  00045	0f 84 b7 00 00
	00		 je	 $LN3@object_for

; 3674 :         /* Issue 7994: If we're converting to a string, we
; 3675 :            should reject format specifications */
; 3676 :         if (PyUnicode_GET_LENGTH(format_spec) > 0) {

  0004b	48 8b 54 24 50	 mov	 rdx, QWORD PTR format_spec$[rsp]
  00050	48 39 7a 60	 cmp	 QWORD PTR [rdx+96], rdi
  00054	7e 22		 jle	 SHORT $LN5@object_for

; 3677 :             if (PyErr_WarnEx(PyExc_DeprecationWarning,
; 3678 :                              "object.__format__ with a non-empty format "
; 3679 :                              "string is deprecated", 1) < 0) {

  00056	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_DeprecationWarning
  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DP@MPDCLJEC@object?4__format__?5with?5a?5non?9emp@
  00064	41 b8 01 00 00
	00		 mov	 r8d, 1
  0006a	e8 00 00 00 00	 call	 PyErr_WarnEx
  0006f	85 c0		 test	 eax, eax
  00071	78 10		 js	 SHORT $done$23358
  00073	48 8b 54 24 50	 mov	 rdx, QWORD PTR format_spec$[rsp]
$LN5@object_for:

; 3680 :               goto done;
; 3681 :             }
; 3682 :             /* Eventually this will become an error:
; 3683 :                PyErr_Format(PyExc_TypeError,
; 3684 :                "non-empty format string passed to object.__format__");
; 3685 :                goto done;
; 3686 :             */
; 3687 :         }
; 3688 : 
; 3689 :         result = PyObject_Format(self_as_str, format_spec);

  00078	48 8b cb	 mov	 rcx, rbx
  0007b	e8 00 00 00 00	 call	 PyObject_Format
  00080	48 8b f8	 mov	 rdi, rax
$done$23358:

; 3690 :     }
; 3691 : 
; 3692 : done:
; 3693 :     Py_XDECREF(self_as_str);

  00083	e8 00 00 00 00	 call	 _Py_PXCTX
  00088	85 c0		 test	 eax, eax
  0008a	75 76		 jne	 SHORT $LN3@object_for
  0008c	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00090	f6 c1 20	 test	 cl, 32			; 00000020H
  00093	75 65		 jne	 SHORT $LN15@object_for
  00095	84 c9		 test	 cl, cl
  00097	78 61		 js	 SHORT $LN15@object_for
  00099	f6 c1 02	 test	 cl, 2
  0009c	75 64		 jne	 SHORT $LN3@object_for
  0009e	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000a2	75 5e		 jne	 SHORT $LN3@object_for
  000a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000b2	4c 8b cb	 mov	 r9, rbx
  000b5	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000bb	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000c3	e8 00 00 00 00	 call	 _PyParallel_Guard
  000c8	48 8b cb	 mov	 rcx, rbx
  000cb	85 c0		 test	 eax, eax
  000cd	74 13		 je	 SHORT $LN20@object_for
  000cf	e8 00 00 00 00	 call	 _Px_Dealloc

; 3694 : 
; 3695 :     return result;

  000d4	48 8b c7	 mov	 rax, rdi

; 3696 : }

  000d7	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000dc	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e0	5f		 pop	 rdi
  000e1	c3		 ret	 0

; 3690 :     }
; 3691 : 
; 3692 : done:
; 3693 :     Py_XDECREF(self_as_str);

$LN20@object_for:
  000e2	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000e6	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 3694 : 
; 3695 :     return result;

  000ec	48 8b c7	 mov	 rax, rdi

; 3696 : }

  000ef	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000f4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f8	5f		 pop	 rdi
  000f9	c3		 ret	 0

; 3690 :     }
; 3691 : 
; 3692 : done:
; 3693 :     Py_XDECREF(self_as_str);

$LN15@object_for:
  000fa	48 8b cb	 mov	 rcx, rbx
  000fd	e8 00 00 00 00	 call	 Px_DecRef
$LN3@object_for:

; 3694 : 
; 3695 :     return result;

  00102	48 8b c7	 mov	 rax, rdi

; 3696 : }

  00105	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0010a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0010e	5f		 pop	 rdi
  0010f	c3		 ret	 0
object_format ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT object_sizeof
_TEXT	SEGMENT
self$ = 8
args$ = 16
object_sizeof PROC					; COMDAT

; 3701 :     Py_ssize_t res, isize;
; 3702 : 
; 3703 :     res = 0;
; 3704 :     isize = self->ob_type->tp_itemsize;

  00000	48 8b 51 58	 mov	 rdx, QWORD PTR [rcx+88]
  00004	33 c0		 xor	 eax, eax
  00006	48 8b 8a 80 00
	00 00		 mov	 rcx, QWORD PTR [rdx+128]

; 3705 :     if (isize > 0)

  0000d	48 85 c9	 test	 rcx, rcx
  00010	7e 08		 jle	 SHORT $LN1@object_siz

; 3706 :         res = Py_SIZE(self->ob_type) * isize;

  00012	48 8b 42 60	 mov	 rax, QWORD PTR [rdx+96]
  00016	48 0f af c1	 imul	 rax, rcx
$LN1@object_siz:

; 3707 :     res += self->ob_type->tp_basicsize;

  0001a	48 03 42 78	 add	 rax, QWORD PTR [rdx+120]

; 3708 : 
; 3709 :     return PyLong_FromSsize_t(res);

  0001e	48 8b c8	 mov	 rcx, rax

; 3710 : }

  00021	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
object_sizeof ENDP
_TEXT	ENDS
EXTRN	PyDict_Copy:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$object_dir DD imagerel object_dir
	DD	imagerel object_dir+439
	DD	imagerel $unwind$object_dir
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$object_dir DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0c016521aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT object_dir
_TEXT	SEGMENT
self$ = 64
args$ = 72
object_dir PROC						; COMDAT

; 3717 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3718 :     PyObject *result = NULL;
; 3719 :     PyObject *dict = NULL;
; 3720 :     PyObject *itsclass = NULL;
; 3721 : 
; 3722 :     /* Get __dict__ (which may or may not be a real dict...) */
; 3723 :     dict = _PyObject_GetAttrId(self, &PyId___dict__);

  0001a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00020	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00029	48 8b e9	 mov	 rbp, rcx
  0002c	4c 8b 24 d0	 mov	 r12, QWORD PTR [rax+rdx*8]
  00030	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId___dict__
  00035	33 ff		 xor	 edi, edi
  00037	49 03 d4	 add	 rdx, r12
  0003a	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  0003f	48 8b f0	 mov	 rsi, rax

; 3724 :     if (dict == NULL) {

  00042	48 85 c0	 test	 rax, rax
  00045	75 0f		 jne	 SHORT $LN16@object_dir

; 3725 :         PyErr_Clear();

  00047	e8 00 00 00 00	 call	 PyErr_Clear

; 3726 :         dict = PyDict_New();

  0004c	e8 00 00 00 00	 call	 PyDict_New
  00051	48 8b d8	 mov	 rbx, rax
  00054	eb 32		 jmp	 SHORT $LN13@object_dir
$LN16@object_dir:

; 3727 :     }
; 3728 :     else if (!PyDict_Check(dict)) {

  00056	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]

; 3729 :         Py_DECREF(dict);

  0005a	48 8b ce	 mov	 rcx, rsi
  0005d	f7 80 00 01 00
	00 00 00 00 20	 test	 DWORD PTR [rax+256], 536870912 ; 20000000H
  00067	75 0f		 jne	 SHORT $LN14@object_dir
  00069	e8 00 00 00 00	 call	 _Py_DecRef

; 3730 :         dict = PyDict_New();

  0006e	e8 00 00 00 00	 call	 PyDict_New
  00073	48 8b d8	 mov	 rbx, rax

; 3731 :     }
; 3732 :     else {

  00076	eb 10		 jmp	 SHORT $LN13@object_dir
$LN14@object_dir:

; 3733 :         /* Copy __dict__ to avoid mutating it. */
; 3734 :         PyObject *temp = PyDict_Copy(dict);

  00078	e8 00 00 00 00	 call	 PyDict_Copy

; 3735 :         Py_DECREF(dict);

  0007d	48 8b ce	 mov	 rcx, rsi
  00080	48 8b d8	 mov	 rbx, rax
  00083	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@object_dir:

; 3736 :         dict = temp;
; 3737 :     }
; 3738 : 
; 3739 :     if (dict == NULL)

  00088	48 85 db	 test	 rbx, rbx
  0008b	0f 84 08 01 00
	00		 je	 $LN44@object_dir

; 3740 :         goto error;
; 3741 : 
; 3742 :     /* Merge in attrs reachable from its class. */
; 3743 :     itsclass = _PyObject_GetAttrId(self, &PyId___class__);

  00091	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId___class__
  00096	48 8b cd	 mov	 rcx, rbp
  00099	49 03 d4	 add	 rdx, r12
  0009c	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  000a1	48 8b f0	 mov	 rsi, rax

; 3744 :     if (itsclass == NULL)

  000a4	48 85 c0	 test	 rax, rax
  000a7	75 07		 jne	 SHORT $LN11@object_dir

; 3745 :         /* XXX(tomer): Perhaps fall back to obj->ob_type if no
; 3746 :                        __class__ exists? */
; 3747 :         PyErr_Clear();

  000a9	e8 00 00 00 00	 call	 PyErr_Clear
  000ae	eb 0f		 jmp	 SHORT $LN9@object_dir
$LN11@object_dir:

; 3748 :     else if (merge_class_dict(dict, itsclass) != 0)

  000b0	48 8b d0	 mov	 rdx, rax
  000b3	48 8b cb	 mov	 rcx, rbx
  000b6	e8 00 00 00 00	 call	 merge_class_dict
  000bb	85 c0		 test	 eax, eax
  000bd	75 0b		 jne	 SHORT $error$23397
$LN9@object_dir:

; 3749 :         goto error;
; 3750 : 
; 3751 :     result = PyDict_Keys(dict);

  000bf	48 8b cb	 mov	 rcx, rbx
  000c2	e8 00 00 00 00	 call	 PyDict_Keys
  000c7	48 8b f8	 mov	 rdi, rax
$error$23397:

; 3752 :     /* fall through */
; 3753 : error:
; 3754 :     Py_XDECREF(itsclass);

  000ca	48 85 f6	 test	 rsi, rsi
  000cd	74 65		 je	 SHORT $LN7@object_dir
  000cf	e8 00 00 00 00	 call	 _Py_PXCTX
  000d4	85 c0		 test	 eax, eax
  000d6	75 5c		 jne	 SHORT $LN7@object_dir
  000d8	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  000dc	a8 20		 test	 al, 32			; 00000020H
  000de	75 4c		 jne	 SHORT $LN23@object_dir
  000e0	84 c0		 test	 al, al
  000e2	78 48		 js	 SHORT $LN23@object_dir
  000e4	a8 02		 test	 al, 2
  000e6	75 4c		 jne	 SHORT $LN7@object_dir
  000e8	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  000ec	75 46		 jne	 SHORT $LN7@object_dir
  000ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000fc	4c 8b ce	 mov	 r9, rsi
  000ff	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00105	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0010d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00112	48 8b ce	 mov	 rcx, rsi
  00115	85 c0		 test	 eax, eax
  00117	74 07		 je	 SHORT $LN28@object_dir
  00119	e8 00 00 00 00	 call	 _Px_Dealloc
  0011e	eb 14		 jmp	 SHORT $LN7@object_dir
$LN28@object_dir:
  00120	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  00124	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0012a	eb 08		 jmp	 SHORT $LN7@object_dir
$LN23@object_dir:
  0012c	48 8b ce	 mov	 rcx, rsi
  0012f	e8 00 00 00 00	 call	 Px_DecRef
$LN7@object_dir:

; 3755 :     Py_XDECREF(dict);

  00134	e8 00 00 00 00	 call	 _Py_PXCTX
  00139	85 c0		 test	 eax, eax
  0013b	75 5c		 jne	 SHORT $LN44@object_dir
  0013d	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00141	a8 20		 test	 al, 32			; 00000020H
  00143	75 4c		 jne	 SHORT $LN34@object_dir
  00145	84 c0		 test	 al, al
  00147	78 48		 js	 SHORT $LN34@object_dir
  00149	a8 02		 test	 al, 2
  0014b	75 4c		 jne	 SHORT $LN44@object_dir
  0014d	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00151	75 46		 jne	 SHORT $LN44@object_dir
  00153	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0015a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00161	4c 8b cb	 mov	 r9, rbx
  00164	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0016a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00172	e8 00 00 00 00	 call	 _PyParallel_Guard
  00177	48 8b cb	 mov	 rcx, rbx
  0017a	85 c0		 test	 eax, eax
  0017c	74 07		 je	 SHORT $LN39@object_dir
  0017e	e8 00 00 00 00	 call	 _Px_Dealloc
  00183	eb 14		 jmp	 SHORT $LN44@object_dir
$LN39@object_dir:
  00185	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00189	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0018f	eb 08		 jmp	 SHORT $LN44@object_dir
$LN34@object_dir:
  00191	48 8b cb	 mov	 rcx, rbx
  00194	e8 00 00 00 00	 call	 Px_DecRef
$LN44@object_dir:

; 3756 :     return result;
; 3757 : }

  00199	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0019e	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  001a3	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  001a8	48 8b c7	 mov	 rax, rdi
  001ab	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  001b0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001b4	41 5c		 pop	 r12
  001b6	c3		 ret	 0
object_dir ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@HIIJJPBB@method?5cannot?5be?5both?5class?5and?5@ ; `string'
EXTRN	PyDescr_NewMethod:PROC
EXTRN	PyStaticMethod_New:PROC
EXTRN	PyCFunction_NewEx:PROC
EXTRN	PyDescr_NewClassMethod:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$add_methods DD imagerel add_methods
	DD	imagerel add_methods+372
	DD	imagerel $unwind$add_methods
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_methods DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0c016521aH
xdata	ENDS
;	COMDAT ??_C@_0CH@HIIJJPBB@method?5cannot?5be?5both?5class?5and?5@
CONST	SEGMENT
??_C@_0CH@HIIJJPBB@method?5cannot?5be?5both?5class?5and?5@ DB 'method can'
	DB	'not be both class and static', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
CONST	ENDS
;	COMDAT add_methods
_TEXT	SEGMENT
type$ = 64
meth$ = 72
add_methods PROC					; COMDAT

; 3823 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3824 :     PyObject *dict = type->tp_dict;
; 3825 : 
; 3826 :     for (; meth->ml_name != NULL; meth++) {

  0001a	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0001d	4c 8b a1 60 01
	00 00		 mov	 r12, QWORD PTR [rcx+352]
  00024	48 8b fa	 mov	 rdi, rdx
  00027	48 8b e9	 mov	 rbp, rcx
  0002a	48 85 c0	 test	 rax, rax
  0002d	0f 84 0c 01 00
	00		 je	 $LN10@add_method
$LL12@add_method:

; 3827 :         PyObject *descr;
; 3828 :         int err;
; 3829 :         if (PyDict_GetItemString(dict, meth->ml_name) &&
; 3830 :             !(meth->ml_flags & METH_COEXIST))

  00033	48 8b d0	 mov	 rdx, rax
  00036	49 8b cc	 mov	 rcx, r12
  00039	e8 00 00 00 00	 call	 PyDict_GetItemString
  0003e	48 85 c0	 test	 rax, rax
  00041	74 0a		 je	 SHORT $LN9@add_method
  00043	f6 47 10 40	 test	 BYTE PTR [rdi+16], 64	; 00000040H
  00047	0f 84 e1 00 00
	00		 je	 $LN11@add_method
$LN9@add_method:

; 3831 :                 continue;
; 3832 :         if (meth->ml_flags & METH_CLASS) {

  0004d	8b 47 10	 mov	 eax, DWORD PTR [rdi+16]
  00050	a8 10		 test	 al, 16
  00052	74 15		 je	 SHORT $LN8@add_method

; 3833 :             if (meth->ml_flags & METH_STATIC) {

  00054	a8 20		 test	 al, 32			; 00000020H
  00056	0f 85 00 01 00
	00		 jne	 $LN27@add_method

; 3837 :             }
; 3838 :             descr = PyDescr_NewClassMethod(type, meth);

  0005c	48 8b d7	 mov	 rdx, rdi
  0005f	48 8b cd	 mov	 rcx, rbp
  00062	e8 00 00 00 00	 call	 PyDescr_NewClassMethod
  00067	eb 3e		 jmp	 SHORT $LN33@add_method
$LN8@add_method:

; 3839 :         }
; 3840 :         else if (meth->ml_flags & METH_STATIC) {

  00069	a8 20		 test	 al, 32			; 00000020H
  0006b	74 2f		 je	 SHORT $LN5@add_method

; 3841 :             PyObject *cfunc = PyCFunction_New(meth, (PyObject*)type);

  0006d	45 33 c0	 xor	 r8d, r8d
  00070	48 8b d5	 mov	 rdx, rbp
  00073	48 8b cf	 mov	 rcx, rdi
  00076	e8 00 00 00 00	 call	 PyCFunction_NewEx
  0007b	48 8b f0	 mov	 rsi, rax

; 3842 :             if (cfunc == NULL)

  0007e	48 85 c0	 test	 rax, rax
  00081	0f 84 e8 00 00
	00		 je	 $LN28@add_method

; 3843 :                 return -1;
; 3844 :             descr = PyStaticMethod_New(cfunc);

  00087	48 8b c8	 mov	 rcx, rax
  0008a	e8 00 00 00 00	 call	 PyStaticMethod_New

; 3845 :             Py_DECREF(cfunc);

  0008f	48 8b ce	 mov	 rcx, rsi
  00092	48 8b d8	 mov	 rbx, rax
  00095	e8 00 00 00 00	 call	 _Py_DecRef

; 3846 :         }
; 3847 :         else {

  0009a	eb 0e		 jmp	 SHORT $LN3@add_method
$LN5@add_method:

; 3848 :             descr = PyDescr_NewMethod(type, meth);

  0009c	48 8b d7	 mov	 rdx, rdi
  0009f	48 8b cd	 mov	 rcx, rbp
  000a2	e8 00 00 00 00	 call	 PyDescr_NewMethod
$LN33@add_method:
  000a7	48 8b d8	 mov	 rbx, rax
$LN3@add_method:

; 3849 :         }
; 3850 :         if (descr == NULL)

  000aa	48 85 db	 test	 rbx, rbx
  000ad	0f 84 bc 00 00
	00		 je	 $LN28@add_method

; 3851 :             return -1;
; 3852 :         err = PyDict_SetItemString(dict, meth->ml_name, descr);

  000b3	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  000b6	4c 8b c3	 mov	 r8, rbx
  000b9	49 8b cc	 mov	 rcx, r12
  000bc	e8 00 00 00 00	 call	 PyDict_SetItemString
  000c1	8b f0		 mov	 esi, eax

; 3853 :         Py_DECREF(descr);

  000c3	e8 00 00 00 00	 call	 _Py_PXCTX
  000c8	85 c0		 test	 eax, eax
  000ca	75 5e		 jne	 SHORT $LN25@add_method
  000cc	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  000d0	f6 c1 20	 test	 cl, 32			; 00000020H
  000d3	75 4d		 jne	 SHORT $LN19@add_method
  000d5	84 c9		 test	 cl, cl
  000d7	78 49		 js	 SHORT $LN19@add_method
  000d9	f6 c1 02	 test	 cl, 2
  000dc	75 4c		 jne	 SHORT $LN25@add_method
  000de	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000e2	75 46		 jne	 SHORT $LN25@add_method
  000e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000f2	4c 8b cb	 mov	 r9, rbx
  000f5	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000fb	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00103	e8 00 00 00 00	 call	 _PyParallel_Guard
  00108	48 8b cb	 mov	 rcx, rbx
  0010b	85 c0		 test	 eax, eax
  0010d	74 07		 je	 SHORT $LN24@add_method
  0010f	e8 00 00 00 00	 call	 _Px_Dealloc
  00114	eb 14		 jmp	 SHORT $LN25@add_method
$LN24@add_method:
  00116	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0011a	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00120	eb 08		 jmp	 SHORT $LN25@add_method
$LN19@add_method:
  00122	48 8b cb	 mov	 rcx, rbx
  00125	e8 00 00 00 00	 call	 Px_DecRef
$LN25@add_method:

; 3854 :         if (err < 0)

  0012a	85 f6		 test	 esi, esi
  0012c	78 41		 js	 SHORT $LN28@add_method
$LN11@add_method:

; 3824 :     PyObject *dict = type->tp_dict;
; 3825 : 
; 3826 :     for (; meth->ml_name != NULL; meth++) {

  0012e	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00132	48 83 c7 20	 add	 rdi, 32			; 00000020H
  00136	48 85 c0	 test	 rax, rax
  00139	0f 85 f4 fe ff
	ff		 jne	 $LL12@add_method
$LN10@add_method:

; 3855 :             return -1;
; 3856 :     }
; 3857 :     return 0;

  0013f	33 c0		 xor	 eax, eax
$LN13@add_method:

; 3858 : }

  00141	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00146	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0014b	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00150	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00155	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00159	41 5c		 pop	 r12
  0015b	c3		 ret	 0
$LN27@add_method:

; 3834 :                 PyErr_SetString(PyExc_ValueError,
; 3835 :                      "method cannot be both class and static");

  0015c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00163	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@HIIJJPBB@method?5cannot?5be?5both?5class?5and?5@
  0016a	e8 00 00 00 00	 call	 PyErr_SetString
$LN28@add_method:

; 3836 :                 return -1;

  0016f	83 c8 ff	 or	 eax, -1
  00172	eb cd		 jmp	 SHORT $LN13@add_method
add_methods ENDP
_TEXT	ENDS
EXTRN	PyDescr_NewMember:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_members DD imagerel add_members
	DD	imagerel add_members+150
	DD	imagerel $unwind$add_members
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_members DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT add_members
_TEXT	SEGMENT
type$ = 48
memb$ = 56
add_members PROC					; COMDAT

; 3862 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3863 :     PyObject *dict = type->tp_dict;
; 3864 : 
; 3865 :     for (; memb->name != NULL; memb++) {

  00014	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00017	48 8b b1 60 01
	00 00		 mov	 rsi, QWORD PTR [rcx+352]
  0001e	48 8b da	 mov	 rbx, rdx
  00021	48 8b e9	 mov	 rbp, rcx
  00024	48 85 c0	 test	 rax, rax
  00027	74 51		 je	 SHORT $LN13@add_member
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL6@add_member:

; 3866 :         PyObject *descr;
; 3867 :         if (PyDict_GetItemString(dict, memb->name))

  00030	48 8b d0	 mov	 rdx, rax
  00033	48 8b ce	 mov	 rcx, rsi
  00036	e8 00 00 00 00	 call	 PyDict_GetItemString
  0003b	48 85 c0	 test	 rax, rax
  0003e	75 2d		 jne	 SHORT $LN5@add_member

; 3868 :             continue;
; 3869 :         descr = PyDescr_NewMember(type, memb);

  00040	48 8b d3	 mov	 rdx, rbx
  00043	48 8b cd	 mov	 rcx, rbp
  00046	e8 00 00 00 00	 call	 PyDescr_NewMember
  0004b	48 8b f8	 mov	 rdi, rax

; 3870 :         if (descr == NULL)

  0004e	48 85 c0	 test	 rax, rax
  00051	74 3e		 je	 SHORT $LN10@add_member

; 3872 :         if (PyDict_SetItemString(dict, memb->name, descr) < 0)

  00053	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  00056	4c 8b c0	 mov	 r8, rax
  00059	48 8b ce	 mov	 rcx, rsi
  0005c	e8 00 00 00 00	 call	 PyDict_SetItemString
  00061	85 c0		 test	 eax, eax
  00063	78 2c		 js	 SHORT $LN10@add_member

; 3873 :             return -1;
; 3874 :         Py_DECREF(descr);

  00065	48 8b cf	 mov	 rcx, rdi
  00068	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@add_member:

; 3863 :     PyObject *dict = type->tp_dict;
; 3864 : 
; 3865 :     for (; memb->name != NULL; memb++) {

  0006d	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  00071	48 83 c3 28	 add	 rbx, 40			; 00000028H
  00075	48 85 c0	 test	 rax, rax
  00078	75 b6		 jne	 SHORT $LL6@add_member
$LN13@add_member:

; 3875 :     }
; 3876 :     return 0;

  0007a	33 c0		 xor	 eax, eax
$LN7@add_member:

; 3877 : }

  0007c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00081	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00086	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0008b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008f	5f		 pop	 rdi
  00090	c3		 ret	 0
$LN10@add_member:

; 3871 :             return -1;

  00091	83 c8 ff	 or	 eax, -1
  00094	eb e6		 jmp	 SHORT $LN7@add_member
add_members ENDP
_TEXT	ENDS
EXTRN	PyDescr_NewGetSet:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_getset DD imagerel add_getset
	DD	imagerel add_getset+150
	DD	imagerel $unwind$add_getset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_getset DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT add_getset
_TEXT	SEGMENT
type$ = 48
gsp$ = 56
add_getset PROC						; COMDAT

; 3881 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3882 :     PyObject *dict = type->tp_dict;
; 3883 : 
; 3884 :     for (; gsp->name != NULL; gsp++) {

  00014	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00017	48 8b b1 60 01
	00 00		 mov	 rsi, QWORD PTR [rcx+352]
  0001e	48 8b da	 mov	 rbx, rdx
  00021	48 8b e9	 mov	 rbp, rcx
  00024	48 85 c0	 test	 rax, rax
  00027	74 51		 je	 SHORT $LN13@add_getset
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL6@add_getset:

; 3885 :         PyObject *descr;
; 3886 :         if (PyDict_GetItemString(dict, gsp->name))

  00030	48 8b d0	 mov	 rdx, rax
  00033	48 8b ce	 mov	 rcx, rsi
  00036	e8 00 00 00 00	 call	 PyDict_GetItemString
  0003b	48 85 c0	 test	 rax, rax
  0003e	75 2d		 jne	 SHORT $LN5@add_getset

; 3887 :             continue;
; 3888 :         descr = PyDescr_NewGetSet(type, gsp);

  00040	48 8b d3	 mov	 rdx, rbx
  00043	48 8b cd	 mov	 rcx, rbp
  00046	e8 00 00 00 00	 call	 PyDescr_NewGetSet
  0004b	48 8b f8	 mov	 rdi, rax

; 3889 : 
; 3890 :         if (descr == NULL)

  0004e	48 85 c0	 test	 rax, rax
  00051	74 3e		 je	 SHORT $LN10@add_getset

; 3892 :         if (PyDict_SetItemString(dict, gsp->name, descr) < 0)

  00053	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  00056	4c 8b c0	 mov	 r8, rax
  00059	48 8b ce	 mov	 rcx, rsi
  0005c	e8 00 00 00 00	 call	 PyDict_SetItemString
  00061	85 c0		 test	 eax, eax
  00063	78 2c		 js	 SHORT $LN10@add_getset

; 3893 :             return -1;
; 3894 :         Py_DECREF(descr);

  00065	48 8b cf	 mov	 rcx, rdi
  00068	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@add_getset:

; 3882 :     PyObject *dict = type->tp_dict;
; 3883 : 
; 3884 :     for (; gsp->name != NULL; gsp++) {

  0006d	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  00071	48 83 c3 28	 add	 rbx, 40			; 00000028H
  00075	48 85 c0	 test	 rax, rax
  00078	75 b6		 jne	 SHORT $LL6@add_getset
$LN13@add_getset:

; 3895 :     }
; 3896 :     return 0;

  0007a	33 c0		 xor	 eax, eax
$LN7@add_getset:

; 3897 : }

  0007c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00081	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00086	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0008b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008f	5f		 pop	 rdi
  00090	c3		 ret	 0
$LN10@add_getset:

; 3891 :             return -1;

  00091	83 c8 ff	 or	 eax, -1
  00094	eb e6		 jmp	 SHORT $LN7@add_getset
add_getset ENDP
_TEXT	ENDS
EXTRN	PyDict_Type:BYTE
EXTRN	PyList_Type:BYTE
EXTRN	PyTuple_Type:BYTE
EXTRN	PyBytes_Type:BYTE
EXTRN	PyLong_Type:BYTE
EXTRN	PyExc_BaseException:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$inherit_special DD imagerel inherit_special
	DD	imagerel inherit_special+507
	DD	imagerel $unwind$inherit_special
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inherit_special DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT inherit_special
_TEXT	SEGMENT
type$ = 48
base$ = 56
inherit_special PROC					; COMDAT

; 3901 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3902 : 
; 3903 :     /* Copying basicsize is connected to the GC flags */
; 3904 :     if (!(type->tp_flags & Py_TPFLAGS_HAVE_GC) &&
; 3905 :         (base->tp_flags & Py_TPFLAGS_HAVE_GC) &&
; 3906 :         (!type->tp_traverse && !type->tp_clear)) {

  00004	8b 81 00 01 00
	00		 mov	 eax, DWORD PTR [rcx+256]
  0000a	4c 8b da	 mov	 r11, rdx
  0000d	4c 8b d1	 mov	 r10, rcx
  00010	0f ba e0 0e	 bt	 eax, 14
  00014	72 46		 jb	 SHORT $LN23@inherit_sp
  00016	f7 82 00 01 00
	00 00 40 00 00	 test	 DWORD PTR [rdx+256], 16384 ; 00004000H
  00020	74 3a		 je	 SHORT $LN23@inherit_sp
  00022	48 83 b9 10 01
	00 00 00	 cmp	 QWORD PTR [rcx+272], 0
  0002a	75 30		 jne	 SHORT $LN23@inherit_sp
  0002c	48 83 b9 18 01
	00 00 00	 cmp	 QWORD PTR [rcx+280], 0
  00034	75 26		 jne	 SHORT $LN23@inherit_sp

; 3907 :         type->tp_flags |= Py_TPFLAGS_HAVE_GC;

  00036	0f ba e8 0e	 bts	 eax, 14
  0003a	89 81 00 01 00
	00		 mov	 DWORD PTR [rcx+256], eax

; 3908 :         if (type->tp_traverse == NULL)
; 3909 :             type->tp_traverse = base->tp_traverse;

  00040	48 8b 82 10 01
	00 00		 mov	 rax, QWORD PTR [rdx+272]
  00047	48 89 81 10 01
	00 00		 mov	 QWORD PTR [rcx+272], rax

; 3910 :         if (type->tp_clear == NULL)
; 3911 :             type->tp_clear = base->tp_clear;

  0004e	48 8b 82 18 01
	00 00		 mov	 rax, QWORD PTR [rdx+280]
  00055	48 89 81 18 01
	00 00		 mov	 QWORD PTR [rcx+280], rax
$LN23@inherit_sp:

; 3912 :     }
; 3913 :     {
; 3914 :         /* The condition below could use some explanation.
; 3915 :            It appears that tp_new is not inherited for static types
; 3916 :            whose base class is 'object'; this seems to be a precaution
; 3917 :            so that old extension types don't suddenly become
; 3918 :            callable (object.__new__ wouldn't insure the invariants
; 3919 :            that the extension type's own factory function ensures).
; 3920 :            Heap types, of course, are under our control, so they do
; 3921 :            inherit tp_new; static extension types that specify some
; 3922 :            other built-in type as the default also
; 3923 :            inherit object.__new__. */
; 3924 :         if (base != &PyBaseObject_Type ||
; 3925 :             (type->tp_flags & Py_TPFLAGS_HEAPTYPE)) {

  0005c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBaseObject_Type
  00063	48 3b d0	 cmp	 rdx, rax
  00066	75 0c		 jne	 SHORT $LN21@inherit_sp
  00068	f7 81 00 01 00
	00 00 02 00 00	 test	 DWORD PTR [rcx+256], 512 ; 00000200H
  00072	74 18		 je	 SHORT $LN20@inherit_sp
$LN21@inherit_sp:

; 3926 :             if (type->tp_new == NULL)

  00074	48 83 b9 90 01
	00 00 00	 cmp	 QWORD PTR [rcx+400], 0
  0007c	75 0e		 jne	 SHORT $LN20@inherit_sp

; 3927 :                 type->tp_new = base->tp_new;

  0007e	48 8b 82 90 01
	00 00		 mov	 rax, QWORD PTR [rdx+400]
  00085	48 89 81 90 01
	00 00		 mov	 QWORD PTR [rcx+400], rax
$LN20@inherit_sp:

; 3928 :         }
; 3929 :     }
; 3930 :     if (type->tp_basicsize == 0)

  0008c	48 83 79 78 00	 cmp	 QWORD PTR [rcx+120], 0
  00091	75 08		 jne	 SHORT $LN19@inherit_sp

; 3931 :         type->tp_basicsize = base->tp_basicsize;

  00093	48 8b 42 78	 mov	 rax, QWORD PTR [rdx+120]
  00097	48 89 41 78	 mov	 QWORD PTR [rcx+120], rax
$LN19@inherit_sp:

; 3932 : 
; 3933 :     /* Copy other non-function slots */
; 3934 : 
; 3935 : #undef COPYVAL
; 3936 : #define COPYVAL(SLOT) \
; 3937 :     if (type->SLOT == 0) type->SLOT = base->SLOT
; 3938 : 
; 3939 :     COPYVAL(tp_itemsize);

  0009b	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  000a3	75 0e		 jne	 SHORT $LN18@inherit_sp
  000a5	48 8b 82 80 00
	00 00		 mov	 rax, QWORD PTR [rdx+128]
  000ac	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax
$LN18@inherit_sp:

; 3940 :     COPYVAL(tp_weaklistoffset);

  000b3	48 83 b9 28 01
	00 00 00	 cmp	 QWORD PTR [rcx+296], 0
  000bb	75 0e		 jne	 SHORT $LN17@inherit_sp
  000bd	48 8b 82 28 01
	00 00		 mov	 rax, QWORD PTR [rdx+296]
  000c4	48 89 81 28 01
	00 00		 mov	 QWORD PTR [rcx+296], rax
$LN17@inherit_sp:

; 3941 :     COPYVAL(tp_dictoffset);

  000cb	48 83 b9 78 01
	00 00 00	 cmp	 QWORD PTR [rcx+376], 0
  000d3	75 0e		 jne	 SHORT $LN16@inherit_sp
  000d5	48 8b 82 78 01
	00 00		 mov	 rax, QWORD PTR [rdx+376]
  000dc	48 89 81 78 01
	00 00		 mov	 QWORD PTR [rcx+376], rax
$LN16@inherit_sp:

; 3942 : 
; 3943 :     /* Setup fast subclass flags */
; 3944 :     if (PyType_IsSubtype(base, (PyTypeObject*)PyExc_BaseException))

  000e3	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_BaseException
  000ea	49 8b cb	 mov	 rcx, r11
  000ed	e8 00 00 00 00	 call	 PyType_IsSubtype
  000f2	85 c0		 test	 eax, eax
  000f4	74 10		 je	 SHORT $LN15@inherit_sp

; 3945 :         type->tp_flags |= Py_TPFLAGS_BASE_EXC_SUBCLASS;

  000f6	41 81 8a 00 01
	00 00 00 00 00
	40		 or	 DWORD PTR [r10+256], 1073741824 ; 40000000H

; 3960 : }

  00101	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00105	c3		 ret	 0
$LN15@inherit_sp:

; 3946 :     else if (PyType_IsSubtype(base, &PyType_Type))

  00106	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyType_Type
  0010d	49 8b cb	 mov	 rcx, r11
  00110	e8 00 00 00 00	 call	 PyType_IsSubtype
  00115	85 c0		 test	 eax, eax
  00117	74 10		 je	 SHORT $LN13@inherit_sp

; 3947 :         type->tp_flags |= Py_TPFLAGS_TYPE_SUBCLASS;

  00119	41 81 8a 00 01
	00 00 00 00 00
	80		 or	 DWORD PTR [r10+256], -2147483648 ; ffffffff80000000H

; 3960 : }

  00124	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00128	c3		 ret	 0
$LN13@inherit_sp:

; 3948 :     else if (PyType_IsSubtype(base, &PyLong_Type))

  00129	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyLong_Type
  00130	49 8b cb	 mov	 rcx, r11
  00133	e8 00 00 00 00	 call	 PyType_IsSubtype
  00138	85 c0		 test	 eax, eax
  0013a	74 10		 je	 SHORT $LN11@inherit_sp

; 3949 :         type->tp_flags |= Py_TPFLAGS_LONG_SUBCLASS;

  0013c	41 81 8a 00 01
	00 00 00 00 00
	01		 or	 DWORD PTR [r10+256], 16777216 ; 01000000H

; 3960 : }

  00147	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0014b	c3		 ret	 0
$LN11@inherit_sp:

; 3950 :     else if (PyType_IsSubtype(base, &PyBytes_Type))

  0014c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyBytes_Type
  00153	49 8b cb	 mov	 rcx, r11
  00156	e8 00 00 00 00	 call	 PyType_IsSubtype
  0015b	85 c0		 test	 eax, eax
  0015d	74 10		 je	 SHORT $LN9@inherit_sp

; 3951 :         type->tp_flags |= Py_TPFLAGS_BYTES_SUBCLASS;

  0015f	41 81 8a 00 01
	00 00 00 00 00
	08		 or	 DWORD PTR [r10+256], 134217728 ; 08000000H

; 3960 : }

  0016a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0016e	c3		 ret	 0
$LN9@inherit_sp:

; 3952 :     else if (PyType_IsSubtype(base, &PyUnicode_Type))

  0016f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyUnicode_Type
  00176	49 8b cb	 mov	 rcx, r11
  00179	e8 00 00 00 00	 call	 PyType_IsSubtype
  0017e	85 c0		 test	 eax, eax
  00180	74 10		 je	 SHORT $LN7@inherit_sp

; 3953 :         type->tp_flags |= Py_TPFLAGS_UNICODE_SUBCLASS;

  00182	41 81 8a 00 01
	00 00 00 00 00
	10		 or	 DWORD PTR [r10+256], 268435456 ; 10000000H

; 3960 : }

  0018d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00191	c3		 ret	 0
$LN7@inherit_sp:

; 3954 :     else if (PyType_IsSubtype(base, &PyTuple_Type))

  00192	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyTuple_Type
  00199	49 8b cb	 mov	 rcx, r11
  0019c	e8 00 00 00 00	 call	 PyType_IsSubtype
  001a1	85 c0		 test	 eax, eax
  001a3	74 10		 je	 SHORT $LN5@inherit_sp

; 3955 :         type->tp_flags |= Py_TPFLAGS_TUPLE_SUBCLASS;

  001a5	41 81 8a 00 01
	00 00 00 00 00
	04		 or	 DWORD PTR [r10+256], 67108864 ; 04000000H

; 3960 : }

  001b0	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001b4	c3		 ret	 0
$LN5@inherit_sp:

; 3956 :     else if (PyType_IsSubtype(base, &PyList_Type))

  001b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyList_Type
  001bc	49 8b cb	 mov	 rcx, r11
  001bf	e8 00 00 00 00	 call	 PyType_IsSubtype
  001c4	85 c0		 test	 eax, eax
  001c6	74 10		 je	 SHORT $LN3@inherit_sp

; 3957 :         type->tp_flags |= Py_TPFLAGS_LIST_SUBCLASS;

  001c8	41 81 8a 00 01
	00 00 00 00 00
	02		 or	 DWORD PTR [r10+256], 33554432 ; 02000000H

; 3960 : }

  001d3	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001d7	c3		 ret	 0
$LN3@inherit_sp:

; 3958 :     else if (PyType_IsSubtype(base, &PyDict_Type))

  001d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDict_Type
  001df	49 8b cb	 mov	 rcx, r11
  001e2	e8 00 00 00 00	 call	 PyType_IsSubtype
  001e7	85 c0		 test	 eax, eax
  001e9	74 0b		 je	 SHORT $LN1@inherit_sp

; 3959 :         type->tp_flags |= Py_TPFLAGS_DICT_SUBCLASS;

  001eb	41 81 8a 00 01
	00 00 00 00 00
	20		 or	 DWORD PTR [r10+256], 536870912 ; 20000000H
$LN1@inherit_sp:

; 3960 : }

  001f6	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001fa	c3		 ret	 0
inherit_special ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$overrides_hash DD imagerel overrides_hash
	DD	imagerel overrides_hash+110
	DD	imagerel $unwind$overrides_hash
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$overrides_hash DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT overrides_hash
_TEXT	SEGMENT
type$ = 48
overrides_hash PROC					; COMDAT

; 3964 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3965 :     PyObject *dict = type->tp_dict;

  0000a	48 8b 99 60 01
	00 00		 mov	 rbx, QWORD PTR [rcx+352]

; 3966 :     _Py_IDENTIFIER(__eq__);
; 3967 : 
; 3968 :     assert(dict != NULL);
; 3969 :     if (_PyDict_GetItemId(dict, &PyId___eq__) != NULL)

  00011	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0001a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00020	48 8b 3c c8	 mov	 rdi, QWORD PTR [rax+rcx*8]
  00024	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___eq__@?1??overrides_hash@@9@9
  00029	48 8b cb	 mov	 rcx, rbx
  0002c	48 03 d7	 add	 rdx, rdi
  0002f	e8 00 00 00 00	 call	 _PyDict_GetItemId
  00034	48 85 c0	 test	 rax, rax
  00037	74 10		 je	 SHORT $LN2@overrides_

; 3970 :         return 1;

  00039	b8 01 00 00 00	 mov	 eax, 1

; 3972 :         return 1;
; 3973 :     return 0;
; 3974 : }

  0003e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5f		 pop	 rdi
  00048	c3		 ret	 0
$LN2@overrides_:

; 3971 :     if (_PyDict_GetItemId(dict, &PyId___hash__) != NULL)

  00049	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId___hash__
  0004e	48 8b cb	 mov	 rcx, rbx
  00051	48 03 d7	 add	 rdx, rdi
  00054	e8 00 00 00 00	 call	 _PyDict_GetItemId

; 3972 :         return 1;
; 3973 :     return 0;
; 3974 : }

  00059	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005e	33 c9		 xor	 ecx, ecx
  00060	48 85 c0	 test	 rax, rax
  00063	0f 95 c1	 setne	 cl
  00066	8b c1		 mov	 eax, ecx
  00068	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006c	5f		 pop	 rdi
  0006d	c3		 ret	 0
overrides_hash ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inherit_slots DD imagerel inherit_slots
	DD	imagerel inherit_slots+3497
	DD	imagerel $unwind$inherit_slots
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inherit_slots DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT inherit_slots
_TEXT	SEGMENT
type$ = 48
base$ = 56
inherit_slots PROC					; COMDAT

; 3978 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3979 :     PyTypeObject *basebase;
; 3980 : 
; 3981 : #undef SLOTDEFINED
; 3982 : #undef COPYSLOT
; 3983 : #undef COPYNUM
; 3984 : #undef COPYSEQ
; 3985 : #undef COPYMAP
; 3986 : #undef COPYBUF
; 3987 : 
; 3988 : #define SLOTDEFINED(SLOT) \
; 3989 :     (base->SLOT != 0 && \
; 3990 :      (basebase == NULL || base->SLOT != basebase->SLOT))
; 3991 : 
; 3992 : #define COPYSLOT(SLOT) \
; 3993 :     if (!type->SLOT && SLOTDEFINED(SLOT)) type->SLOT = base->SLOT
; 3994 : 
; 3995 : #define COPYNUM(SLOT) COPYSLOT(tp_as_number->SLOT)
; 3996 : #define COPYSEQ(SLOT) COPYSLOT(tp_as_sequence->SLOT)
; 3997 : #define COPYMAP(SLOT) COPYSLOT(tp_as_mapping->SLOT)
; 3998 : #define COPYBUF(SLOT) COPYSLOT(tp_as_buffer->SLOT)
; 3999 : 
; 4000 :     /* This won't inherit indirect slots (from tp_as_number etc.)
; 4001 :        if type doesn't provide the space. */
; 4002 : 
; 4003 :     if (type->tp_as_number != NULL && base->tp_as_number != NULL) {

  0000f	4c 8b 81 b8 00
	00 00		 mov	 r8, QWORD PTR [rcx+184]
  00016	45 33 d2	 xor	 r10d, r10d
  00019	48 8b f2	 mov	 rsi, rdx
  0001c	48 8b d9	 mov	 rbx, rcx
  0001f	4d 85 c0	 test	 r8, r8
  00022	0f 84 6f 07 00
	00		 je	 $LN66@inherit_sl
  00028	48 8b 92 b8 00
	00 00		 mov	 rdx, QWORD PTR [rdx+184]
  0002f	48 85 d2	 test	 rdx, rdx
  00032	0f 84 5f 07 00
	00		 je	 $LN66@inherit_sl

; 4004 :         basebase = base->tp_base;

  00038	48 8b 8e 58 01
	00 00		 mov	 rcx, QWORD PTR [rsi+344]

; 4005 :         if (basebase->tp_as_number == NULL)

  0003f	4c 39 91 b8 00
	00 00		 cmp	 QWORD PTR [rcx+184], r10
  00046	49 0f 44 ca	 cmove	 rcx, r10

; 4006 :             basebase = NULL;
; 4007 :         COPYNUM(nb_add);

  0004a	4d 39 10	 cmp	 QWORD PTR [r8], r10
  0004d	75 1c		 jne	 SHORT $LN130@inherit_sl
  0004f	4c 8b 0a	 mov	 r9, QWORD PTR [rdx]
  00052	4d 85 c9	 test	 r9, r9
  00055	74 14		 je	 SHORT $LN130@inherit_sl
  00057	48 85 c9	 test	 rcx, rcx
  0005a	74 0c		 je	 SHORT $LN129@inherit_sl
  0005c	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00063	4c 3b 08	 cmp	 r9, QWORD PTR [rax]
  00066	74 03		 je	 SHORT $LN130@inherit_sl
$LN129@inherit_sl:
  00068	4d 89 08	 mov	 QWORD PTR [r8], r9
$LN130@inherit_sl:

; 4008 :         COPYNUM(nb_subtract);

  0006b	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  00072	4d 39 50 08	 cmp	 QWORD PTR [r8+8], r10
  00076	75 26		 jne	 SHORT $LN128@inherit_sl
  00078	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  0007f	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00083	48 85 d2	 test	 rdx, rdx
  00086	74 16		 je	 SHORT $LN128@inherit_sl
  00088	48 85 c9	 test	 rcx, rcx
  0008b	74 0d		 je	 SHORT $LN127@inherit_sl
  0008d	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00094	48 3b 50 08	 cmp	 rdx, QWORD PTR [rax+8]
  00098	74 04		 je	 SHORT $LN128@inherit_sl
$LN127@inherit_sl:
  0009a	49 89 50 08	 mov	 QWORD PTR [r8+8], rdx
$LN128@inherit_sl:

; 4009 :         COPYNUM(nb_multiply);

  0009e	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  000a5	4d 39 50 10	 cmp	 QWORD PTR [r8+16], r10
  000a9	75 26		 jne	 SHORT $LN126@inherit_sl
  000ab	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  000b2	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  000b6	48 85 d2	 test	 rdx, rdx
  000b9	74 16		 je	 SHORT $LN126@inherit_sl
  000bb	48 85 c9	 test	 rcx, rcx
  000be	74 0d		 je	 SHORT $LN125@inherit_sl
  000c0	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  000c7	48 3b 50 10	 cmp	 rdx, QWORD PTR [rax+16]
  000cb	74 04		 je	 SHORT $LN126@inherit_sl
$LN125@inherit_sl:
  000cd	49 89 50 10	 mov	 QWORD PTR [r8+16], rdx
$LN126@inherit_sl:

; 4010 :         COPYNUM(nb_remainder);

  000d1	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  000d8	4d 39 50 18	 cmp	 QWORD PTR [r8+24], r10
  000dc	75 26		 jne	 SHORT $LN124@inherit_sl
  000de	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  000e5	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  000e9	48 85 d2	 test	 rdx, rdx
  000ec	74 16		 je	 SHORT $LN124@inherit_sl
  000ee	48 85 c9	 test	 rcx, rcx
  000f1	74 0d		 je	 SHORT $LN123@inherit_sl
  000f3	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  000fa	48 3b 50 18	 cmp	 rdx, QWORD PTR [rax+24]
  000fe	74 04		 je	 SHORT $LN124@inherit_sl
$LN123@inherit_sl:
  00100	49 89 50 18	 mov	 QWORD PTR [r8+24], rdx
$LN124@inherit_sl:

; 4011 :         COPYNUM(nb_divmod);

  00104	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  0010b	4d 39 50 20	 cmp	 QWORD PTR [r8+32], r10
  0010f	75 26		 jne	 SHORT $LN122@inherit_sl
  00111	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  00118	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  0011c	48 85 d2	 test	 rdx, rdx
  0011f	74 16		 je	 SHORT $LN122@inherit_sl
  00121	48 85 c9	 test	 rcx, rcx
  00124	74 0d		 je	 SHORT $LN121@inherit_sl
  00126	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  0012d	48 3b 50 20	 cmp	 rdx, QWORD PTR [rax+32]
  00131	74 04		 je	 SHORT $LN122@inherit_sl
$LN121@inherit_sl:
  00133	49 89 50 20	 mov	 QWORD PTR [r8+32], rdx
$LN122@inherit_sl:

; 4012 :         COPYNUM(nb_power);

  00137	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  0013e	4d 39 50 28	 cmp	 QWORD PTR [r8+40], r10
  00142	75 26		 jne	 SHORT $LN120@inherit_sl
  00144	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  0014b	48 8b 50 28	 mov	 rdx, QWORD PTR [rax+40]
  0014f	48 85 d2	 test	 rdx, rdx
  00152	74 16		 je	 SHORT $LN120@inherit_sl
  00154	48 85 c9	 test	 rcx, rcx
  00157	74 0d		 je	 SHORT $LN119@inherit_sl
  00159	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00160	48 3b 50 28	 cmp	 rdx, QWORD PTR [rax+40]
  00164	74 04		 je	 SHORT $LN120@inherit_sl
$LN119@inherit_sl:
  00166	49 89 50 28	 mov	 QWORD PTR [r8+40], rdx
$LN120@inherit_sl:

; 4013 :         COPYNUM(nb_negative);

  0016a	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  00171	4d 39 50 30	 cmp	 QWORD PTR [r8+48], r10
  00175	75 26		 jne	 SHORT $LN118@inherit_sl
  00177	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  0017e	48 8b 50 30	 mov	 rdx, QWORD PTR [rax+48]
  00182	48 85 d2	 test	 rdx, rdx
  00185	74 16		 je	 SHORT $LN118@inherit_sl
  00187	48 85 c9	 test	 rcx, rcx
  0018a	74 0d		 je	 SHORT $LN117@inherit_sl
  0018c	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00193	48 3b 50 30	 cmp	 rdx, QWORD PTR [rax+48]
  00197	74 04		 je	 SHORT $LN118@inherit_sl
$LN117@inherit_sl:
  00199	49 89 50 30	 mov	 QWORD PTR [r8+48], rdx
$LN118@inherit_sl:

; 4014 :         COPYNUM(nb_positive);

  0019d	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  001a4	4d 39 50 38	 cmp	 QWORD PTR [r8+56], r10
  001a8	75 26		 jne	 SHORT $LN116@inherit_sl
  001aa	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  001b1	48 8b 50 38	 mov	 rdx, QWORD PTR [rax+56]
  001b5	48 85 d2	 test	 rdx, rdx
  001b8	74 16		 je	 SHORT $LN116@inherit_sl
  001ba	48 85 c9	 test	 rcx, rcx
  001bd	74 0d		 je	 SHORT $LN115@inherit_sl
  001bf	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  001c6	48 3b 50 38	 cmp	 rdx, QWORD PTR [rax+56]
  001ca	74 04		 je	 SHORT $LN116@inherit_sl
$LN115@inherit_sl:
  001cc	49 89 50 38	 mov	 QWORD PTR [r8+56], rdx
$LN116@inherit_sl:

; 4015 :         COPYNUM(nb_absolute);

  001d0	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  001d7	4d 39 50 40	 cmp	 QWORD PTR [r8+64], r10
  001db	75 26		 jne	 SHORT $LN114@inherit_sl
  001dd	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  001e4	48 8b 50 40	 mov	 rdx, QWORD PTR [rax+64]
  001e8	48 85 d2	 test	 rdx, rdx
  001eb	74 16		 je	 SHORT $LN114@inherit_sl
  001ed	48 85 c9	 test	 rcx, rcx
  001f0	74 0d		 je	 SHORT $LN113@inherit_sl
  001f2	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  001f9	48 3b 50 40	 cmp	 rdx, QWORD PTR [rax+64]
  001fd	74 04		 je	 SHORT $LN114@inherit_sl
$LN113@inherit_sl:
  001ff	49 89 50 40	 mov	 QWORD PTR [r8+64], rdx
$LN114@inherit_sl:

; 4016 :         COPYNUM(nb_bool);

  00203	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  0020a	4d 39 50 48	 cmp	 QWORD PTR [r8+72], r10
  0020e	75 26		 jne	 SHORT $LN112@inherit_sl
  00210	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  00217	48 8b 50 48	 mov	 rdx, QWORD PTR [rax+72]
  0021b	48 85 d2	 test	 rdx, rdx
  0021e	74 16		 je	 SHORT $LN112@inherit_sl
  00220	48 85 c9	 test	 rcx, rcx
  00223	74 0d		 je	 SHORT $LN111@inherit_sl
  00225	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  0022c	48 3b 50 48	 cmp	 rdx, QWORD PTR [rax+72]
  00230	74 04		 je	 SHORT $LN112@inherit_sl
$LN111@inherit_sl:
  00232	49 89 50 48	 mov	 QWORD PTR [r8+72], rdx
$LN112@inherit_sl:

; 4017 :         COPYNUM(nb_invert);

  00236	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  0023d	4d 39 50 50	 cmp	 QWORD PTR [r8+80], r10
  00241	75 26		 jne	 SHORT $LN110@inherit_sl
  00243	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  0024a	48 8b 50 50	 mov	 rdx, QWORD PTR [rax+80]
  0024e	48 85 d2	 test	 rdx, rdx
  00251	74 16		 je	 SHORT $LN110@inherit_sl
  00253	48 85 c9	 test	 rcx, rcx
  00256	74 0d		 je	 SHORT $LN109@inherit_sl
  00258	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  0025f	48 3b 50 50	 cmp	 rdx, QWORD PTR [rax+80]
  00263	74 04		 je	 SHORT $LN110@inherit_sl
$LN109@inherit_sl:
  00265	49 89 50 50	 mov	 QWORD PTR [r8+80], rdx
$LN110@inherit_sl:

; 4018 :         COPYNUM(nb_lshift);

  00269	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  00270	4d 39 50 58	 cmp	 QWORD PTR [r8+88], r10
  00274	75 26		 jne	 SHORT $LN108@inherit_sl
  00276	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  0027d	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00281	48 85 d2	 test	 rdx, rdx
  00284	74 16		 je	 SHORT $LN108@inherit_sl
  00286	48 85 c9	 test	 rcx, rcx
  00289	74 0d		 je	 SHORT $LN107@inherit_sl
  0028b	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00292	48 3b 50 58	 cmp	 rdx, QWORD PTR [rax+88]
  00296	74 04		 je	 SHORT $LN108@inherit_sl
$LN107@inherit_sl:
  00298	49 89 50 58	 mov	 QWORD PTR [r8+88], rdx
$LN108@inherit_sl:

; 4019 :         COPYNUM(nb_rshift);

  0029c	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  002a3	4d 39 50 60	 cmp	 QWORD PTR [r8+96], r10
  002a7	75 26		 jne	 SHORT $LN106@inherit_sl
  002a9	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  002b0	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  002b4	48 85 d2	 test	 rdx, rdx
  002b7	74 16		 je	 SHORT $LN106@inherit_sl
  002b9	48 85 c9	 test	 rcx, rcx
  002bc	74 0d		 je	 SHORT $LN105@inherit_sl
  002be	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  002c5	48 3b 50 60	 cmp	 rdx, QWORD PTR [rax+96]
  002c9	74 04		 je	 SHORT $LN106@inherit_sl
$LN105@inherit_sl:
  002cb	49 89 50 60	 mov	 QWORD PTR [r8+96], rdx
$LN106@inherit_sl:

; 4020 :         COPYNUM(nb_and);

  002cf	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  002d6	4d 39 50 68	 cmp	 QWORD PTR [r8+104], r10
  002da	75 26		 jne	 SHORT $LN104@inherit_sl
  002dc	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  002e3	48 8b 50 68	 mov	 rdx, QWORD PTR [rax+104]
  002e7	48 85 d2	 test	 rdx, rdx
  002ea	74 16		 je	 SHORT $LN104@inherit_sl
  002ec	48 85 c9	 test	 rcx, rcx
  002ef	74 0d		 je	 SHORT $LN103@inherit_sl
  002f1	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  002f8	48 3b 50 68	 cmp	 rdx, QWORD PTR [rax+104]
  002fc	74 04		 je	 SHORT $LN104@inherit_sl
$LN103@inherit_sl:
  002fe	49 89 50 68	 mov	 QWORD PTR [r8+104], rdx
$LN104@inherit_sl:

; 4021 :         COPYNUM(nb_xor);

  00302	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  00309	4d 39 50 70	 cmp	 QWORD PTR [r8+112], r10
  0030d	75 26		 jne	 SHORT $LN102@inherit_sl
  0030f	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  00316	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  0031a	48 85 d2	 test	 rdx, rdx
  0031d	74 16		 je	 SHORT $LN102@inherit_sl
  0031f	48 85 c9	 test	 rcx, rcx
  00322	74 0d		 je	 SHORT $LN101@inherit_sl
  00324	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  0032b	48 3b 50 70	 cmp	 rdx, QWORD PTR [rax+112]
  0032f	74 04		 je	 SHORT $LN102@inherit_sl
$LN101@inherit_sl:
  00331	49 89 50 70	 mov	 QWORD PTR [r8+112], rdx
$LN102@inherit_sl:

; 4022 :         COPYNUM(nb_or);

  00335	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  0033c	4d 39 50 78	 cmp	 QWORD PTR [r8+120], r10
  00340	75 26		 jne	 SHORT $LN100@inherit_sl
  00342	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  00349	48 8b 50 78	 mov	 rdx, QWORD PTR [rax+120]
  0034d	48 85 d2	 test	 rdx, rdx
  00350	74 16		 je	 SHORT $LN100@inherit_sl
  00352	48 85 c9	 test	 rcx, rcx
  00355	74 0d		 je	 SHORT $LN99@inherit_sl
  00357	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  0035e	48 3b 50 78	 cmp	 rdx, QWORD PTR [rax+120]
  00362	74 04		 je	 SHORT $LN100@inherit_sl
$LN99@inherit_sl:
  00364	49 89 50 78	 mov	 QWORD PTR [r8+120], rdx
$LN100@inherit_sl:

; 4023 :         COPYNUM(nb_int);

  00368	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  0036f	4d 39 90 80 00
	00 00		 cmp	 QWORD PTR [r8+128], r10
  00376	75 2f		 jne	 SHORT $LN98@inherit_sl
  00378	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  0037f	48 8b 90 80 00
	00 00		 mov	 rdx, QWORD PTR [rax+128]
  00386	48 85 d2	 test	 rdx, rdx
  00389	74 1c		 je	 SHORT $LN98@inherit_sl
  0038b	48 85 c9	 test	 rcx, rcx
  0038e	74 10		 je	 SHORT $LN97@inherit_sl
  00390	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00397	48 3b 90 80 00
	00 00		 cmp	 rdx, QWORD PTR [rax+128]
  0039e	74 07		 je	 SHORT $LN98@inherit_sl
$LN97@inherit_sl:
  003a0	49 89 90 80 00
	00 00		 mov	 QWORD PTR [r8+128], rdx
$LN98@inherit_sl:

; 4024 :         COPYNUM(nb_float);

  003a7	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  003ae	4d 39 90 90 00
	00 00		 cmp	 QWORD PTR [r8+144], r10
  003b5	75 2f		 jne	 SHORT $LN96@inherit_sl
  003b7	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  003be	48 8b 90 90 00
	00 00		 mov	 rdx, QWORD PTR [rax+144]
  003c5	48 85 d2	 test	 rdx, rdx
  003c8	74 1c		 je	 SHORT $LN96@inherit_sl
  003ca	48 85 c9	 test	 rcx, rcx
  003cd	74 10		 je	 SHORT $LN95@inherit_sl
  003cf	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  003d6	48 3b 90 90 00
	00 00		 cmp	 rdx, QWORD PTR [rax+144]
  003dd	74 07		 je	 SHORT $LN96@inherit_sl
$LN95@inherit_sl:
  003df	49 89 90 90 00
	00 00		 mov	 QWORD PTR [r8+144], rdx
$LN96@inherit_sl:

; 4025 :         COPYNUM(nb_inplace_add);

  003e6	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  003ed	4d 39 90 98 00
	00 00		 cmp	 QWORD PTR [r8+152], r10
  003f4	75 2f		 jne	 SHORT $LN94@inherit_sl
  003f6	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  003fd	48 8b 90 98 00
	00 00		 mov	 rdx, QWORD PTR [rax+152]
  00404	48 85 d2	 test	 rdx, rdx
  00407	74 1c		 je	 SHORT $LN94@inherit_sl
  00409	48 85 c9	 test	 rcx, rcx
  0040c	74 10		 je	 SHORT $LN93@inherit_sl
  0040e	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00415	48 3b 90 98 00
	00 00		 cmp	 rdx, QWORD PTR [rax+152]
  0041c	74 07		 je	 SHORT $LN94@inherit_sl
$LN93@inherit_sl:
  0041e	49 89 90 98 00
	00 00		 mov	 QWORD PTR [r8+152], rdx
$LN94@inherit_sl:

; 4026 :         COPYNUM(nb_inplace_subtract);

  00425	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  0042c	4d 39 90 a0 00
	00 00		 cmp	 QWORD PTR [r8+160], r10
  00433	75 2f		 jne	 SHORT $LN92@inherit_sl
  00435	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  0043c	48 8b 90 a0 00
	00 00		 mov	 rdx, QWORD PTR [rax+160]
  00443	48 85 d2	 test	 rdx, rdx
  00446	74 1c		 je	 SHORT $LN92@inherit_sl
  00448	48 85 c9	 test	 rcx, rcx
  0044b	74 10		 je	 SHORT $LN91@inherit_sl
  0044d	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00454	48 3b 90 a0 00
	00 00		 cmp	 rdx, QWORD PTR [rax+160]
  0045b	74 07		 je	 SHORT $LN92@inherit_sl
$LN91@inherit_sl:
  0045d	49 89 90 a0 00
	00 00		 mov	 QWORD PTR [r8+160], rdx
$LN92@inherit_sl:

; 4027 :         COPYNUM(nb_inplace_multiply);

  00464	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  0046b	4d 39 90 a8 00
	00 00		 cmp	 QWORD PTR [r8+168], r10
  00472	75 2f		 jne	 SHORT $LN90@inherit_sl
  00474	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  0047b	48 8b 90 a8 00
	00 00		 mov	 rdx, QWORD PTR [rax+168]
  00482	48 85 d2	 test	 rdx, rdx
  00485	74 1c		 je	 SHORT $LN90@inherit_sl
  00487	48 85 c9	 test	 rcx, rcx
  0048a	74 10		 je	 SHORT $LN89@inherit_sl
  0048c	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00493	48 3b 90 a8 00
	00 00		 cmp	 rdx, QWORD PTR [rax+168]
  0049a	74 07		 je	 SHORT $LN90@inherit_sl
$LN89@inherit_sl:
  0049c	49 89 90 a8 00
	00 00		 mov	 QWORD PTR [r8+168], rdx
$LN90@inherit_sl:

; 4028 :         COPYNUM(nb_inplace_remainder);

  004a3	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  004aa	4d 39 90 b0 00
	00 00		 cmp	 QWORD PTR [r8+176], r10
  004b1	75 2f		 jne	 SHORT $LN88@inherit_sl
  004b3	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  004ba	48 8b 90 b0 00
	00 00		 mov	 rdx, QWORD PTR [rax+176]
  004c1	48 85 d2	 test	 rdx, rdx
  004c4	74 1c		 je	 SHORT $LN88@inherit_sl
  004c6	48 85 c9	 test	 rcx, rcx
  004c9	74 10		 je	 SHORT $LN87@inherit_sl
  004cb	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  004d2	48 3b 90 b0 00
	00 00		 cmp	 rdx, QWORD PTR [rax+176]
  004d9	74 07		 je	 SHORT $LN88@inherit_sl
$LN87@inherit_sl:
  004db	49 89 90 b0 00
	00 00		 mov	 QWORD PTR [r8+176], rdx
$LN88@inherit_sl:

; 4029 :         COPYNUM(nb_inplace_power);

  004e2	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  004e9	4d 39 90 b8 00
	00 00		 cmp	 QWORD PTR [r8+184], r10
  004f0	75 2f		 jne	 SHORT $LN86@inherit_sl
  004f2	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  004f9	48 8b 90 b8 00
	00 00		 mov	 rdx, QWORD PTR [rax+184]
  00500	48 85 d2	 test	 rdx, rdx
  00503	74 1c		 je	 SHORT $LN86@inherit_sl
  00505	48 85 c9	 test	 rcx, rcx
  00508	74 10		 je	 SHORT $LN85@inherit_sl
  0050a	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00511	48 3b 90 b8 00
	00 00		 cmp	 rdx, QWORD PTR [rax+184]
  00518	74 07		 je	 SHORT $LN86@inherit_sl
$LN85@inherit_sl:
  0051a	49 89 90 b8 00
	00 00		 mov	 QWORD PTR [r8+184], rdx
$LN86@inherit_sl:

; 4030 :         COPYNUM(nb_inplace_lshift);

  00521	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  00528	4d 39 90 c0 00
	00 00		 cmp	 QWORD PTR [r8+192], r10
  0052f	75 2f		 jne	 SHORT $LN84@inherit_sl
  00531	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  00538	48 8b 90 c0 00
	00 00		 mov	 rdx, QWORD PTR [rax+192]
  0053f	48 85 d2	 test	 rdx, rdx
  00542	74 1c		 je	 SHORT $LN84@inherit_sl
  00544	48 85 c9	 test	 rcx, rcx
  00547	74 10		 je	 SHORT $LN83@inherit_sl
  00549	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00550	48 3b 90 c0 00
	00 00		 cmp	 rdx, QWORD PTR [rax+192]
  00557	74 07		 je	 SHORT $LN84@inherit_sl
$LN83@inherit_sl:
  00559	49 89 90 c0 00
	00 00		 mov	 QWORD PTR [r8+192], rdx
$LN84@inherit_sl:

; 4031 :         COPYNUM(nb_inplace_rshift);

  00560	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  00567	4d 39 90 c8 00
	00 00		 cmp	 QWORD PTR [r8+200], r10
  0056e	75 2f		 jne	 SHORT $LN82@inherit_sl
  00570	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  00577	48 8b 90 c8 00
	00 00		 mov	 rdx, QWORD PTR [rax+200]
  0057e	48 85 d2	 test	 rdx, rdx
  00581	74 1c		 je	 SHORT $LN82@inherit_sl
  00583	48 85 c9	 test	 rcx, rcx
  00586	74 10		 je	 SHORT $LN81@inherit_sl
  00588	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  0058f	48 3b 90 c8 00
	00 00		 cmp	 rdx, QWORD PTR [rax+200]
  00596	74 07		 je	 SHORT $LN82@inherit_sl
$LN81@inherit_sl:
  00598	49 89 90 c8 00
	00 00		 mov	 QWORD PTR [r8+200], rdx
$LN82@inherit_sl:

; 4032 :         COPYNUM(nb_inplace_and);

  0059f	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  005a6	4d 39 90 d0 00
	00 00		 cmp	 QWORD PTR [r8+208], r10
  005ad	75 2f		 jne	 SHORT $LN80@inherit_sl
  005af	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  005b6	48 8b 90 d0 00
	00 00		 mov	 rdx, QWORD PTR [rax+208]
  005bd	48 85 d2	 test	 rdx, rdx
  005c0	74 1c		 je	 SHORT $LN80@inherit_sl
  005c2	48 85 c9	 test	 rcx, rcx
  005c5	74 10		 je	 SHORT $LN79@inherit_sl
  005c7	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  005ce	48 3b 90 d0 00
	00 00		 cmp	 rdx, QWORD PTR [rax+208]
  005d5	74 07		 je	 SHORT $LN80@inherit_sl
$LN79@inherit_sl:
  005d7	49 89 90 d0 00
	00 00		 mov	 QWORD PTR [r8+208], rdx
$LN80@inherit_sl:

; 4033 :         COPYNUM(nb_inplace_xor);

  005de	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  005e5	4d 39 90 d8 00
	00 00		 cmp	 QWORD PTR [r8+216], r10
  005ec	75 2f		 jne	 SHORT $LN78@inherit_sl
  005ee	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  005f5	48 8b 90 d8 00
	00 00		 mov	 rdx, QWORD PTR [rax+216]
  005fc	48 85 d2	 test	 rdx, rdx
  005ff	74 1c		 je	 SHORT $LN78@inherit_sl
  00601	48 85 c9	 test	 rcx, rcx
  00604	74 10		 je	 SHORT $LN77@inherit_sl
  00606	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  0060d	48 3b 90 d8 00
	00 00		 cmp	 rdx, QWORD PTR [rax+216]
  00614	74 07		 je	 SHORT $LN78@inherit_sl
$LN77@inherit_sl:
  00616	49 89 90 d8 00
	00 00		 mov	 QWORD PTR [r8+216], rdx
$LN78@inherit_sl:

; 4034 :         COPYNUM(nb_inplace_or);

  0061d	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  00624	4d 39 90 e0 00
	00 00		 cmp	 QWORD PTR [r8+224], r10
  0062b	75 2f		 jne	 SHORT $LN76@inherit_sl
  0062d	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  00634	48 8b 90 e0 00
	00 00		 mov	 rdx, QWORD PTR [rax+224]
  0063b	48 85 d2	 test	 rdx, rdx
  0063e	74 1c		 je	 SHORT $LN76@inherit_sl
  00640	48 85 c9	 test	 rcx, rcx
  00643	74 10		 je	 SHORT $LN75@inherit_sl
  00645	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  0064c	48 3b 90 e0 00
	00 00		 cmp	 rdx, QWORD PTR [rax+224]
  00653	74 07		 je	 SHORT $LN76@inherit_sl
$LN75@inherit_sl:
  00655	49 89 90 e0 00
	00 00		 mov	 QWORD PTR [r8+224], rdx
$LN76@inherit_sl:

; 4035 :         COPYNUM(nb_true_divide);

  0065c	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  00663	4d 39 90 f0 00
	00 00		 cmp	 QWORD PTR [r8+240], r10
  0066a	75 2f		 jne	 SHORT $LN74@inherit_sl
  0066c	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  00673	48 8b 90 f0 00
	00 00		 mov	 rdx, QWORD PTR [rax+240]
  0067a	48 85 d2	 test	 rdx, rdx
  0067d	74 1c		 je	 SHORT $LN74@inherit_sl
  0067f	48 85 c9	 test	 rcx, rcx
  00682	74 10		 je	 SHORT $LN73@inherit_sl
  00684	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  0068b	48 3b 90 f0 00
	00 00		 cmp	 rdx, QWORD PTR [rax+240]
  00692	74 07		 je	 SHORT $LN74@inherit_sl
$LN73@inherit_sl:
  00694	49 89 90 f0 00
	00 00		 mov	 QWORD PTR [r8+240], rdx
$LN74@inherit_sl:

; 4036 :         COPYNUM(nb_floor_divide);

  0069b	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  006a2	4d 39 90 e8 00
	00 00		 cmp	 QWORD PTR [r8+232], r10
  006a9	75 2f		 jne	 SHORT $LN72@inherit_sl
  006ab	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  006b2	48 8b 90 e8 00
	00 00		 mov	 rdx, QWORD PTR [rax+232]
  006b9	48 85 d2	 test	 rdx, rdx
  006bc	74 1c		 je	 SHORT $LN72@inherit_sl
  006be	48 85 c9	 test	 rcx, rcx
  006c1	74 10		 je	 SHORT $LN71@inherit_sl
  006c3	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  006ca	48 3b 90 e8 00
	00 00		 cmp	 rdx, QWORD PTR [rax+232]
  006d1	74 07		 je	 SHORT $LN72@inherit_sl
$LN71@inherit_sl:
  006d3	49 89 90 e8 00
	00 00		 mov	 QWORD PTR [r8+232], rdx
$LN72@inherit_sl:

; 4037 :         COPYNUM(nb_inplace_true_divide);

  006da	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  006e1	4d 39 90 00 01
	00 00		 cmp	 QWORD PTR [r8+256], r10
  006e8	75 2f		 jne	 SHORT $LN70@inherit_sl
  006ea	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  006f1	48 8b 90 00 01
	00 00		 mov	 rdx, QWORD PTR [rax+256]
  006f8	48 85 d2	 test	 rdx, rdx
  006fb	74 1c		 je	 SHORT $LN70@inherit_sl
  006fd	48 85 c9	 test	 rcx, rcx
  00700	74 10		 je	 SHORT $LN69@inherit_sl
  00702	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00709	48 3b 90 00 01
	00 00		 cmp	 rdx, QWORD PTR [rax+256]
  00710	74 07		 je	 SHORT $LN70@inherit_sl
$LN69@inherit_sl:
  00712	49 89 90 00 01
	00 00		 mov	 QWORD PTR [r8+256], rdx
$LN70@inherit_sl:

; 4038 :         COPYNUM(nb_inplace_floor_divide);

  00719	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  00720	4d 39 90 f8 00
	00 00		 cmp	 QWORD PTR [r8+248], r10
  00727	75 2f		 jne	 SHORT $LN68@inherit_sl
  00729	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  00730	48 8b 90 f8 00
	00 00		 mov	 rdx, QWORD PTR [rax+248]
  00737	48 85 d2	 test	 rdx, rdx
  0073a	74 1c		 je	 SHORT $LN68@inherit_sl
  0073c	48 85 c9	 test	 rcx, rcx
  0073f	74 10		 je	 SHORT $LN67@inherit_sl
  00741	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00748	48 3b 90 f8 00
	00 00		 cmp	 rdx, QWORD PTR [rax+248]
  0074f	74 07		 je	 SHORT $LN68@inherit_sl
$LN67@inherit_sl:
  00751	49 89 90 f8 00
	00 00		 mov	 QWORD PTR [r8+248], rdx
$LN68@inherit_sl:

; 4039 :         COPYNUM(nb_index);

  00758	4c 8b 83 b8 00
	00 00		 mov	 r8, QWORD PTR [rbx+184]
  0075f	4d 39 90 08 01
	00 00		 cmp	 QWORD PTR [r8+264], r10
  00766	75 2f		 jne	 SHORT $LN66@inherit_sl
  00768	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  0076f	48 8b 90 08 01
	00 00		 mov	 rdx, QWORD PTR [rax+264]
  00776	48 85 d2	 test	 rdx, rdx
  00779	74 1c		 je	 SHORT $LN66@inherit_sl
  0077b	48 85 c9	 test	 rcx, rcx
  0077e	74 10		 je	 SHORT $LN65@inherit_sl
  00780	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00787	48 3b 90 08 01
	00 00		 cmp	 rdx, QWORD PTR [rax+264]
  0078e	74 07		 je	 SHORT $LN66@inherit_sl
$LN65@inherit_sl:
  00790	49 89 90 08 01
	00 00		 mov	 QWORD PTR [r8+264], rdx
$LN66@inherit_sl:

; 4040 :     }
; 4041 : 
; 4042 :     if (type->tp_as_sequence != NULL && base->tp_as_sequence != NULL) {

  00797	48 8b 93 c0 00
	00 00		 mov	 rdx, QWORD PTR [rbx+192]
  0079e	48 85 d2	 test	 rdx, rdx
  007a1	0f 84 a8 01 00
	00		 je	 $LN48@inherit_sl
  007a7	4c 8b 86 c0 00
	00 00		 mov	 r8, QWORD PTR [rsi+192]
  007ae	4d 85 c0	 test	 r8, r8
  007b1	0f 84 98 01 00
	00		 je	 $LN48@inherit_sl

; 4043 :         basebase = base->tp_base;

  007b7	48 8b 8e 58 01
	00 00		 mov	 rcx, QWORD PTR [rsi+344]

; 4044 :         if (basebase->tp_as_sequence == NULL)

  007be	4c 39 91 c0 00
	00 00		 cmp	 QWORD PTR [rcx+192], r10
  007c5	49 0f 44 ca	 cmove	 rcx, r10

; 4045 :             basebase = NULL;
; 4046 :         COPYSEQ(sq_length);

  007c9	4c 39 12	 cmp	 QWORD PTR [rdx], r10
  007cc	75 1c		 jne	 SHORT $LN62@inherit_sl
  007ce	4d 8b 08	 mov	 r9, QWORD PTR [r8]
  007d1	4d 85 c9	 test	 r9, r9
  007d4	74 14		 je	 SHORT $LN62@inherit_sl
  007d6	48 85 c9	 test	 rcx, rcx
  007d9	74 0c		 je	 SHORT $LN61@inherit_sl
  007db	48 8b 81 c0 00
	00 00		 mov	 rax, QWORD PTR [rcx+192]
  007e2	4c 3b 08	 cmp	 r9, QWORD PTR [rax]
  007e5	74 03		 je	 SHORT $LN62@inherit_sl
$LN61@inherit_sl:
  007e7	4c 89 0a	 mov	 QWORD PTR [rdx], r9
$LN62@inherit_sl:

; 4047 :         COPYSEQ(sq_concat);

  007ea	4c 8b 83 c0 00
	00 00		 mov	 r8, QWORD PTR [rbx+192]
  007f1	4d 39 50 08	 cmp	 QWORD PTR [r8+8], r10
  007f5	75 26		 jne	 SHORT $LN60@inherit_sl
  007f7	48 8b 86 c0 00
	00 00		 mov	 rax, QWORD PTR [rsi+192]
  007fe	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00802	48 85 d2	 test	 rdx, rdx
  00805	74 16		 je	 SHORT $LN60@inherit_sl
  00807	48 85 c9	 test	 rcx, rcx
  0080a	74 0d		 je	 SHORT $LN59@inherit_sl
  0080c	48 8b 81 c0 00
	00 00		 mov	 rax, QWORD PTR [rcx+192]
  00813	48 3b 50 08	 cmp	 rdx, QWORD PTR [rax+8]
  00817	74 04		 je	 SHORT $LN60@inherit_sl
$LN59@inherit_sl:
  00819	49 89 50 08	 mov	 QWORD PTR [r8+8], rdx
$LN60@inherit_sl:

; 4048 :         COPYSEQ(sq_repeat);

  0081d	4c 8b 83 c0 00
	00 00		 mov	 r8, QWORD PTR [rbx+192]
  00824	4d 39 50 10	 cmp	 QWORD PTR [r8+16], r10
  00828	75 26		 jne	 SHORT $LN58@inherit_sl
  0082a	48 8b 86 c0 00
	00 00		 mov	 rax, QWORD PTR [rsi+192]
  00831	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00835	48 85 d2	 test	 rdx, rdx
  00838	74 16		 je	 SHORT $LN58@inherit_sl
  0083a	48 85 c9	 test	 rcx, rcx
  0083d	74 0d		 je	 SHORT $LN57@inherit_sl
  0083f	48 8b 81 c0 00
	00 00		 mov	 rax, QWORD PTR [rcx+192]
  00846	48 3b 50 10	 cmp	 rdx, QWORD PTR [rax+16]
  0084a	74 04		 je	 SHORT $LN58@inherit_sl
$LN57@inherit_sl:
  0084c	49 89 50 10	 mov	 QWORD PTR [r8+16], rdx
$LN58@inherit_sl:

; 4049 :         COPYSEQ(sq_item);

  00850	4c 8b 83 c0 00
	00 00		 mov	 r8, QWORD PTR [rbx+192]
  00857	4d 39 50 18	 cmp	 QWORD PTR [r8+24], r10
  0085b	75 26		 jne	 SHORT $LN56@inherit_sl
  0085d	48 8b 86 c0 00
	00 00		 mov	 rax, QWORD PTR [rsi+192]
  00864	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  00868	48 85 d2	 test	 rdx, rdx
  0086b	74 16		 je	 SHORT $LN56@inherit_sl
  0086d	48 85 c9	 test	 rcx, rcx
  00870	74 0d		 je	 SHORT $LN55@inherit_sl
  00872	48 8b 81 c0 00
	00 00		 mov	 rax, QWORD PTR [rcx+192]
  00879	48 3b 50 18	 cmp	 rdx, QWORD PTR [rax+24]
  0087d	74 04		 je	 SHORT $LN56@inherit_sl
$LN55@inherit_sl:
  0087f	49 89 50 18	 mov	 QWORD PTR [r8+24], rdx
$LN56@inherit_sl:

; 4050 :         COPYSEQ(sq_ass_item);

  00883	4c 8b 83 c0 00
	00 00		 mov	 r8, QWORD PTR [rbx+192]
  0088a	4d 39 50 28	 cmp	 QWORD PTR [r8+40], r10
  0088e	75 26		 jne	 SHORT $LN54@inherit_sl
  00890	48 8b 86 c0 00
	00 00		 mov	 rax, QWORD PTR [rsi+192]
  00897	48 8b 50 28	 mov	 rdx, QWORD PTR [rax+40]
  0089b	48 85 d2	 test	 rdx, rdx
  0089e	74 16		 je	 SHORT $LN54@inherit_sl
  008a0	48 85 c9	 test	 rcx, rcx
  008a3	74 0d		 je	 SHORT $LN53@inherit_sl
  008a5	48 8b 81 c0 00
	00 00		 mov	 rax, QWORD PTR [rcx+192]
  008ac	48 3b 50 28	 cmp	 rdx, QWORD PTR [rax+40]
  008b0	74 04		 je	 SHORT $LN54@inherit_sl
$LN53@inherit_sl:
  008b2	49 89 50 28	 mov	 QWORD PTR [r8+40], rdx
$LN54@inherit_sl:

; 4051 :         COPYSEQ(sq_contains);

  008b6	4c 8b 83 c0 00
	00 00		 mov	 r8, QWORD PTR [rbx+192]
  008bd	4d 39 50 38	 cmp	 QWORD PTR [r8+56], r10
  008c1	75 26		 jne	 SHORT $LN52@inherit_sl
  008c3	48 8b 86 c0 00
	00 00		 mov	 rax, QWORD PTR [rsi+192]
  008ca	48 8b 50 38	 mov	 rdx, QWORD PTR [rax+56]
  008ce	48 85 d2	 test	 rdx, rdx
  008d1	74 16		 je	 SHORT $LN52@inherit_sl
  008d3	48 85 c9	 test	 rcx, rcx
  008d6	74 0d		 je	 SHORT $LN51@inherit_sl
  008d8	48 8b 81 c0 00
	00 00		 mov	 rax, QWORD PTR [rcx+192]
  008df	48 3b 50 38	 cmp	 rdx, QWORD PTR [rax+56]
  008e3	74 04		 je	 SHORT $LN52@inherit_sl
$LN51@inherit_sl:
  008e5	49 89 50 38	 mov	 QWORD PTR [r8+56], rdx
$LN52@inherit_sl:

; 4052 :         COPYSEQ(sq_inplace_concat);

  008e9	4c 8b 83 c0 00
	00 00		 mov	 r8, QWORD PTR [rbx+192]
  008f0	4d 39 50 40	 cmp	 QWORD PTR [r8+64], r10
  008f4	75 26		 jne	 SHORT $LN50@inherit_sl
  008f6	48 8b 86 c0 00
	00 00		 mov	 rax, QWORD PTR [rsi+192]
  008fd	48 8b 50 40	 mov	 rdx, QWORD PTR [rax+64]
  00901	48 85 d2	 test	 rdx, rdx
  00904	74 16		 je	 SHORT $LN50@inherit_sl
  00906	48 85 c9	 test	 rcx, rcx
  00909	74 0d		 je	 SHORT $LN49@inherit_sl
  0090b	48 8b 81 c0 00
	00 00		 mov	 rax, QWORD PTR [rcx+192]
  00912	48 3b 50 40	 cmp	 rdx, QWORD PTR [rax+64]
  00916	74 04		 je	 SHORT $LN50@inherit_sl
$LN49@inherit_sl:
  00918	49 89 50 40	 mov	 QWORD PTR [r8+64], rdx
$LN50@inherit_sl:

; 4053 :         COPYSEQ(sq_inplace_repeat);

  0091c	4c 8b 83 c0 00
	00 00		 mov	 r8, QWORD PTR [rbx+192]
  00923	4d 39 50 48	 cmp	 QWORD PTR [r8+72], r10
  00927	75 26		 jne	 SHORT $LN48@inherit_sl
  00929	48 8b 86 c0 00
	00 00		 mov	 rax, QWORD PTR [rsi+192]
  00930	48 8b 50 48	 mov	 rdx, QWORD PTR [rax+72]
  00934	48 85 d2	 test	 rdx, rdx
  00937	74 16		 je	 SHORT $LN48@inherit_sl
  00939	48 85 c9	 test	 rcx, rcx
  0093c	74 0d		 je	 SHORT $LN47@inherit_sl
  0093e	48 8b 81 c0 00
	00 00		 mov	 rax, QWORD PTR [rcx+192]
  00945	48 3b 50 48	 cmp	 rdx, QWORD PTR [rax+72]
  00949	74 04		 je	 SHORT $LN48@inherit_sl
$LN47@inherit_sl:
  0094b	49 89 50 48	 mov	 QWORD PTR [r8+72], rdx
$LN48@inherit_sl:

; 4054 :     }
; 4055 : 
; 4056 :     if (type->tp_as_mapping != NULL && base->tp_as_mapping != NULL) {

  0094f	48 8b 93 c8 00
	00 00		 mov	 rdx, QWORD PTR [rbx+200]
  00956	48 85 d2	 test	 rdx, rdx
  00959	0f 84 a9 00 00
	00		 je	 $LN40@inherit_sl
  0095f	4c 8b 86 c8 00
	00 00		 mov	 r8, QWORD PTR [rsi+200]
  00966	4d 85 c0	 test	 r8, r8
  00969	0f 84 99 00 00
	00		 je	 $LN40@inherit_sl

; 4057 :         basebase = base->tp_base;

  0096f	48 8b 8e 58 01
	00 00		 mov	 rcx, QWORD PTR [rsi+344]

; 4058 :         if (basebase->tp_as_mapping == NULL)

  00976	4c 39 91 c8 00
	00 00		 cmp	 QWORD PTR [rcx+200], r10
  0097d	49 0f 44 ca	 cmove	 rcx, r10

; 4059 :             basebase = NULL;
; 4060 :         COPYMAP(mp_length);

  00981	4c 39 12	 cmp	 QWORD PTR [rdx], r10
  00984	75 1c		 jne	 SHORT $LN44@inherit_sl
  00986	4d 8b 08	 mov	 r9, QWORD PTR [r8]
  00989	4d 85 c9	 test	 r9, r9
  0098c	74 14		 je	 SHORT $LN44@inherit_sl
  0098e	48 85 c9	 test	 rcx, rcx
  00991	74 0c		 je	 SHORT $LN43@inherit_sl
  00993	48 8b 81 c8 00
	00 00		 mov	 rax, QWORD PTR [rcx+200]
  0099a	4c 3b 08	 cmp	 r9, QWORD PTR [rax]
  0099d	74 03		 je	 SHORT $LN44@inherit_sl
$LN43@inherit_sl:
  0099f	4c 89 0a	 mov	 QWORD PTR [rdx], r9
$LN44@inherit_sl:

; 4061 :         COPYMAP(mp_subscript);

  009a2	4c 8b 83 c8 00
	00 00		 mov	 r8, QWORD PTR [rbx+200]
  009a9	4d 39 50 08	 cmp	 QWORD PTR [r8+8], r10
  009ad	75 26		 jne	 SHORT $LN42@inherit_sl
  009af	48 8b 86 c8 00
	00 00		 mov	 rax, QWORD PTR [rsi+200]
  009b6	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  009ba	48 85 d2	 test	 rdx, rdx
  009bd	74 16		 je	 SHORT $LN42@inherit_sl
  009bf	48 85 c9	 test	 rcx, rcx
  009c2	74 0d		 je	 SHORT $LN41@inherit_sl
  009c4	48 8b 81 c8 00
	00 00		 mov	 rax, QWORD PTR [rcx+200]
  009cb	48 3b 50 08	 cmp	 rdx, QWORD PTR [rax+8]
  009cf	74 04		 je	 SHORT $LN42@inherit_sl
$LN41@inherit_sl:
  009d1	49 89 50 08	 mov	 QWORD PTR [r8+8], rdx
$LN42@inherit_sl:

; 4062 :         COPYMAP(mp_ass_subscript);

  009d5	4c 8b 83 c8 00
	00 00		 mov	 r8, QWORD PTR [rbx+200]
  009dc	4d 39 50 10	 cmp	 QWORD PTR [r8+16], r10
  009e0	75 26		 jne	 SHORT $LN40@inherit_sl
  009e2	48 8b 86 c8 00
	00 00		 mov	 rax, QWORD PTR [rsi+200]
  009e9	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  009ed	48 85 d2	 test	 rdx, rdx
  009f0	74 16		 je	 SHORT $LN40@inherit_sl
  009f2	48 85 c9	 test	 rcx, rcx
  009f5	74 0d		 je	 SHORT $LN39@inherit_sl
  009f7	48 8b 81 c8 00
	00 00		 mov	 rax, QWORD PTR [rcx+200]
  009fe	48 3b 50 10	 cmp	 rdx, QWORD PTR [rax+16]
  00a02	74 04		 je	 SHORT $LN40@inherit_sl
$LN39@inherit_sl:
  00a04	49 89 50 10	 mov	 QWORD PTR [r8+16], rdx
$LN40@inherit_sl:

; 4063 :     }
; 4064 : 
; 4065 :     if (type->tp_as_buffer != NULL && base->tp_as_buffer != NULL) {

  00a08	48 8b 8b f8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+248]
  00a0f	48 85 c9	 test	 rcx, rcx
  00a12	74 72		 je	 SHORT $LN34@inherit_sl
  00a14	4c 8b 86 f8 00
	00 00		 mov	 r8, QWORD PTR [rsi+248]
  00a1b	4d 85 c0	 test	 r8, r8
  00a1e	74 66		 je	 SHORT $LN34@inherit_sl

; 4066 :         basebase = base->tp_base;

  00a20	48 8b 96 58 01
	00 00		 mov	 rdx, QWORD PTR [rsi+344]

; 4067 :         if (basebase->tp_as_buffer == NULL)

  00a27	4c 39 92 f8 00
	00 00		 cmp	 QWORD PTR [rdx+248], r10
  00a2e	49 0f 44 d2	 cmove	 rdx, r10

; 4068 :             basebase = NULL;
; 4069 :         COPYBUF(bf_getbuffer);

  00a32	4c 39 11	 cmp	 QWORD PTR [rcx], r10
  00a35	75 1c		 jne	 SHORT $LN36@inherit_sl
  00a37	4d 8b 08	 mov	 r9, QWORD PTR [r8]
  00a3a	4d 85 c9	 test	 r9, r9
  00a3d	74 14		 je	 SHORT $LN36@inherit_sl
  00a3f	48 85 d2	 test	 rdx, rdx
  00a42	74 0c		 je	 SHORT $LN35@inherit_sl
  00a44	48 8b 82 f8 00
	00 00		 mov	 rax, QWORD PTR [rdx+248]
  00a4b	4c 3b 08	 cmp	 r9, QWORD PTR [rax]
  00a4e	74 03		 je	 SHORT $LN36@inherit_sl
$LN35@inherit_sl:
  00a50	4c 89 09	 mov	 QWORD PTR [rcx], r9
$LN36@inherit_sl:

; 4070 :         COPYBUF(bf_releasebuffer);

  00a53	4c 8b 83 f8 00
	00 00		 mov	 r8, QWORD PTR [rbx+248]
  00a5a	4d 39 50 08	 cmp	 QWORD PTR [r8+8], r10
  00a5e	75 26		 jne	 SHORT $LN34@inherit_sl
  00a60	48 8b 86 f8 00
	00 00		 mov	 rax, QWORD PTR [rsi+248]
  00a67	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00a6b	48 85 c9	 test	 rcx, rcx
  00a6e	74 16		 je	 SHORT $LN34@inherit_sl
  00a70	48 85 d2	 test	 rdx, rdx
  00a73	74 0d		 je	 SHORT $LN33@inherit_sl
  00a75	48 8b 82 f8 00
	00 00		 mov	 rax, QWORD PTR [rdx+248]
  00a7c	48 3b 48 08	 cmp	 rcx, QWORD PTR [rax+8]
  00a80	74 04		 je	 SHORT $LN34@inherit_sl
$LN33@inherit_sl:
  00a82	49 89 48 08	 mov	 QWORD PTR [r8+8], rcx
$LN34@inherit_sl:

; 4071 :     }
; 4072 : 
; 4073 :     basebase = base->tp_base;

  00a86	48 8b be 58 01
	00 00		 mov	 rdi, QWORD PTR [rsi+344]

; 4074 : 
; 4075 :     COPYSLOT(tp_dealloc);

  00a8d	4c 39 93 88 00
	00 00		 cmp	 QWORD PTR [rbx+136], r10
  00a94	75 21		 jne	 SHORT $LN32@inherit_sl
  00a96	48 8b 86 88 00
	00 00		 mov	 rax, QWORD PTR [rsi+136]
  00a9d	48 85 c0	 test	 rax, rax
  00aa0	74 15		 je	 SHORT $LN32@inherit_sl
  00aa2	48 85 ff	 test	 rdi, rdi
  00aa5	74 09		 je	 SHORT $LN31@inherit_sl
  00aa7	48 3b 87 88 00
	00 00		 cmp	 rax, QWORD PTR [rdi+136]
  00aae	74 07		 je	 SHORT $LN32@inherit_sl
$LN31@inherit_sl:
  00ab0	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax
$LN32@inherit_sl:

; 4076 :     if (type->tp_getattr == NULL && type->tp_getattro == NULL) {

  00ab7	4c 39 93 98 00
	00 00		 cmp	 QWORD PTR [rbx+152], r10
  00abe	75 25		 jne	 SHORT $LN30@inherit_sl
  00ac0	4c 39 93 e8 00
	00 00		 cmp	 QWORD PTR [rbx+232], r10
  00ac7	75 1c		 jne	 SHORT $LN30@inherit_sl

; 4077 :         type->tp_getattr = base->tp_getattr;

  00ac9	48 8b 86 98 00
	00 00		 mov	 rax, QWORD PTR [rsi+152]
  00ad0	48 89 83 98 00
	00 00		 mov	 QWORD PTR [rbx+152], rax

; 4078 :         type->tp_getattro = base->tp_getattro;

  00ad7	48 8b 86 e8 00
	00 00		 mov	 rax, QWORD PTR [rsi+232]
  00ade	48 89 83 e8 00
	00 00		 mov	 QWORD PTR [rbx+232], rax
$LN30@inherit_sl:

; 4079 :     }
; 4080 :     if (type->tp_setattr == NULL && type->tp_setattro == NULL) {

  00ae5	4c 39 93 a0 00
	00 00		 cmp	 QWORD PTR [rbx+160], r10
  00aec	75 25		 jne	 SHORT $LN29@inherit_sl
  00aee	4c 39 93 f0 00
	00 00		 cmp	 QWORD PTR [rbx+240], r10
  00af5	75 1c		 jne	 SHORT $LN29@inherit_sl

; 4081 :         type->tp_setattr = base->tp_setattr;

  00af7	48 8b 86 a0 00
	00 00		 mov	 rax, QWORD PTR [rsi+160]
  00afe	48 89 83 a0 00
	00 00		 mov	 QWORD PTR [rbx+160], rax

; 4082 :         type->tp_setattro = base->tp_setattro;

  00b05	48 8b 86 f0 00
	00 00		 mov	 rax, QWORD PTR [rsi+240]
  00b0c	48 89 83 f0 00
	00 00		 mov	 QWORD PTR [rbx+240], rax
$LN29@inherit_sl:

; 4083 :     }
; 4084 :     /* tp_reserved is ignored */
; 4085 :     COPYSLOT(tp_repr);

  00b13	4c 39 93 b0 00
	00 00		 cmp	 QWORD PTR [rbx+176], r10
  00b1a	75 21		 jne	 SHORT $LN28@inherit_sl
  00b1c	48 8b 86 b0 00
	00 00		 mov	 rax, QWORD PTR [rsi+176]
  00b23	48 85 c0	 test	 rax, rax
  00b26	74 15		 je	 SHORT $LN28@inherit_sl
  00b28	48 85 ff	 test	 rdi, rdi
  00b2b	74 09		 je	 SHORT $LN27@inherit_sl
  00b2d	48 3b 87 b0 00
	00 00		 cmp	 rax, QWORD PTR [rdi+176]
  00b34	74 07		 je	 SHORT $LN28@inherit_sl
$LN27@inherit_sl:
  00b36	48 89 83 b0 00
	00 00		 mov	 QWORD PTR [rbx+176], rax
$LN28@inherit_sl:

; 4086 :     /* tp_hash see tp_richcompare */
; 4087 :     COPYSLOT(tp_call);

  00b3d	4c 39 93 d8 00
	00 00		 cmp	 QWORD PTR [rbx+216], r10
  00b44	75 21		 jne	 SHORT $LN26@inherit_sl
  00b46	48 8b 86 d8 00
	00 00		 mov	 rax, QWORD PTR [rsi+216]
  00b4d	48 85 c0	 test	 rax, rax
  00b50	74 15		 je	 SHORT $LN26@inherit_sl
  00b52	48 85 ff	 test	 rdi, rdi
  00b55	74 09		 je	 SHORT $LN25@inherit_sl
  00b57	48 3b 87 d8 00
	00 00		 cmp	 rax, QWORD PTR [rdi+216]
  00b5e	74 07		 je	 SHORT $LN26@inherit_sl
$LN25@inherit_sl:
  00b60	48 89 83 d8 00
	00 00		 mov	 QWORD PTR [rbx+216], rax
$LN26@inherit_sl:

; 4088 :     COPYSLOT(tp_str);

  00b67	4c 39 93 e0 00
	00 00		 cmp	 QWORD PTR [rbx+224], r10
  00b6e	75 21		 jne	 SHORT $LN24@inherit_sl
  00b70	48 8b 86 e0 00
	00 00		 mov	 rax, QWORD PTR [rsi+224]
  00b77	48 85 c0	 test	 rax, rax
  00b7a	74 15		 je	 SHORT $LN24@inherit_sl
  00b7c	48 85 ff	 test	 rdi, rdi
  00b7f	74 09		 je	 SHORT $LN23@inherit_sl
  00b81	48 3b 87 e0 00
	00 00		 cmp	 rax, QWORD PTR [rdi+224]
  00b88	74 07		 je	 SHORT $LN24@inherit_sl
$LN23@inherit_sl:
  00b8a	48 89 83 e0 00
	00 00		 mov	 QWORD PTR [rbx+224], rax
$LN24@inherit_sl:

; 4089 :     {
; 4090 :         /* Copy comparison-related slots only when
; 4091 :            not overriding them anywhere */
; 4092 :         if (type->tp_richcompare == NULL &&
; 4093 :             type->tp_hash == NULL &&
; 4094 :             !overrides_hash(type))

  00b91	4c 39 93 20 01
	00 00		 cmp	 QWORD PTR [rbx+288], r10
  00b98	75 31		 jne	 SHORT $LN22@inherit_sl
  00b9a	4c 39 93 d0 00
	00 00		 cmp	 QWORD PTR [rbx+208], r10
  00ba1	75 28		 jne	 SHORT $LN22@inherit_sl
  00ba3	48 8b cb	 mov	 rcx, rbx
  00ba6	e8 00 00 00 00	 call	 overrides_hash
  00bab	85 c0		 test	 eax, eax
  00bad	75 1c		 jne	 SHORT $LN22@inherit_sl

; 4095 :         {
; 4096 :             type->tp_richcompare = base->tp_richcompare;

  00baf	48 8b 86 20 01
	00 00		 mov	 rax, QWORD PTR [rsi+288]
  00bb6	48 89 83 20 01
	00 00		 mov	 QWORD PTR [rbx+288], rax

; 4097 :             type->tp_hash = base->tp_hash;

  00bbd	48 8b 86 d0 00
	00 00		 mov	 rax, QWORD PTR [rsi+208]
  00bc4	48 89 83 d0 00
	00 00		 mov	 QWORD PTR [rbx+208], rax
$LN22@inherit_sl:

; 4098 :         }
; 4099 :     }
; 4100 :     {
; 4101 :         COPYSLOT(tp_iter);

  00bcb	48 83 bb 30 01
	00 00 00	 cmp	 QWORD PTR [rbx+304], 0
  00bd3	75 21		 jne	 SHORT $LN21@inherit_sl
  00bd5	48 8b 86 30 01
	00 00		 mov	 rax, QWORD PTR [rsi+304]
  00bdc	48 85 c0	 test	 rax, rax
  00bdf	74 15		 je	 SHORT $LN21@inherit_sl
  00be1	48 85 ff	 test	 rdi, rdi
  00be4	74 09		 je	 SHORT $LN20@inherit_sl
  00be6	48 3b 87 30 01
	00 00		 cmp	 rax, QWORD PTR [rdi+304]
  00bed	74 07		 je	 SHORT $LN21@inherit_sl
$LN20@inherit_sl:
  00bef	48 89 83 30 01
	00 00		 mov	 QWORD PTR [rbx+304], rax
$LN21@inherit_sl:

; 4102 :         COPYSLOT(tp_iternext);

  00bf6	48 83 bb 38 01
	00 00 00	 cmp	 QWORD PTR [rbx+312], 0
  00bfe	75 21		 jne	 SHORT $LN19@inherit_sl
  00c00	48 8b 86 38 01
	00 00		 mov	 rax, QWORD PTR [rsi+312]
  00c07	48 85 c0	 test	 rax, rax
  00c0a	74 15		 je	 SHORT $LN19@inherit_sl
  00c0c	48 85 ff	 test	 rdi, rdi
  00c0f	74 09		 je	 SHORT $LN18@inherit_sl
  00c11	48 3b 87 38 01
	00 00		 cmp	 rax, QWORD PTR [rdi+312]
  00c18	74 07		 je	 SHORT $LN19@inherit_sl
$LN18@inherit_sl:
  00c1a	48 89 83 38 01
	00 00		 mov	 QWORD PTR [rbx+312], rax
$LN19@inherit_sl:

; 4103 :     }
; 4104 :     {
; 4105 :         COPYSLOT(tp_descr_get);

  00c21	48 83 bb 68 01
	00 00 00	 cmp	 QWORD PTR [rbx+360], 0
  00c29	75 21		 jne	 SHORT $LN17@inherit_sl
  00c2b	48 8b 86 68 01
	00 00		 mov	 rax, QWORD PTR [rsi+360]
  00c32	48 85 c0	 test	 rax, rax
  00c35	74 15		 je	 SHORT $LN17@inherit_sl
  00c37	48 85 ff	 test	 rdi, rdi
  00c3a	74 09		 je	 SHORT $LN16@inherit_sl
  00c3c	48 3b 87 68 01
	00 00		 cmp	 rax, QWORD PTR [rdi+360]
  00c43	74 07		 je	 SHORT $LN17@inherit_sl
$LN16@inherit_sl:
  00c45	48 89 83 68 01
	00 00		 mov	 QWORD PTR [rbx+360], rax
$LN17@inherit_sl:

; 4106 :         COPYSLOT(tp_descr_set);

  00c4c	48 83 bb 70 01
	00 00 00	 cmp	 QWORD PTR [rbx+368], 0
  00c54	75 21		 jne	 SHORT $LN15@inherit_sl
  00c56	48 8b 86 70 01
	00 00		 mov	 rax, QWORD PTR [rsi+368]
  00c5d	48 85 c0	 test	 rax, rax
  00c60	74 15		 je	 SHORT $LN15@inherit_sl
  00c62	48 85 ff	 test	 rdi, rdi
  00c65	74 09		 je	 SHORT $LN14@inherit_sl
  00c67	48 3b 87 70 01
	00 00		 cmp	 rax, QWORD PTR [rdi+368]
  00c6e	74 07		 je	 SHORT $LN15@inherit_sl
$LN14@inherit_sl:
  00c70	48 89 83 70 01
	00 00		 mov	 QWORD PTR [rbx+368], rax
$LN15@inherit_sl:

; 4107 :         COPYSLOT(tp_dictoffset);

  00c77	48 83 bb 78 01
	00 00 00	 cmp	 QWORD PTR [rbx+376], 0
  00c7f	75 21		 jne	 SHORT $LN13@inherit_sl
  00c81	48 8b 86 78 01
	00 00		 mov	 rax, QWORD PTR [rsi+376]
  00c88	48 85 c0	 test	 rax, rax
  00c8b	74 15		 je	 SHORT $LN13@inherit_sl
  00c8d	48 85 ff	 test	 rdi, rdi
  00c90	74 09		 je	 SHORT $LN12@inherit_sl
  00c92	48 3b 87 78 01
	00 00		 cmp	 rax, QWORD PTR [rdi+376]
  00c99	74 07		 je	 SHORT $LN13@inherit_sl
$LN12@inherit_sl:
  00c9b	48 89 83 78 01
	00 00		 mov	 QWORD PTR [rbx+376], rax
$LN13@inherit_sl:

; 4108 :         COPYSLOT(tp_init);

  00ca2	48 83 bb 80 01
	00 00 00	 cmp	 QWORD PTR [rbx+384], 0
  00caa	75 21		 jne	 SHORT $LN11@inherit_sl
  00cac	48 8b 86 80 01
	00 00		 mov	 rax, QWORD PTR [rsi+384]
  00cb3	48 85 c0	 test	 rax, rax
  00cb6	74 15		 je	 SHORT $LN11@inherit_sl
  00cb8	48 85 ff	 test	 rdi, rdi
  00cbb	74 09		 je	 SHORT $LN10@inherit_sl
  00cbd	48 3b 87 80 01
	00 00		 cmp	 rax, QWORD PTR [rdi+384]
  00cc4	74 07		 je	 SHORT $LN11@inherit_sl
$LN10@inherit_sl:
  00cc6	48 89 83 80 01
	00 00		 mov	 QWORD PTR [rbx+384], rax
$LN11@inherit_sl:

; 4109 :         COPYSLOT(tp_alloc);

  00ccd	48 83 bb 88 01
	00 00 00	 cmp	 QWORD PTR [rbx+392], 0
  00cd5	75 21		 jne	 SHORT $LN9@inherit_sl
  00cd7	48 8b 86 88 01
	00 00		 mov	 rax, QWORD PTR [rsi+392]
  00cde	48 85 c0	 test	 rax, rax
  00ce1	74 15		 je	 SHORT $LN9@inherit_sl
  00ce3	48 85 ff	 test	 rdi, rdi
  00ce6	74 09		 je	 SHORT $LN8@inherit_sl
  00ce8	48 3b 87 88 01
	00 00		 cmp	 rax, QWORD PTR [rdi+392]
  00cef	74 07		 je	 SHORT $LN9@inherit_sl
$LN8@inherit_sl:
  00cf1	48 89 83 88 01
	00 00		 mov	 QWORD PTR [rbx+392], rax
$LN9@inherit_sl:

; 4110 :         COPYSLOT(tp_is_gc);

  00cf8	48 83 bb a0 01
	00 00 00	 cmp	 QWORD PTR [rbx+416], 0
  00d00	75 21		 jne	 SHORT $LN7@inherit_sl
  00d02	48 8b 86 a0 01
	00 00		 mov	 rax, QWORD PTR [rsi+416]
  00d09	48 85 c0	 test	 rax, rax
  00d0c	74 15		 je	 SHORT $LN7@inherit_sl
  00d0e	48 85 ff	 test	 rdi, rdi
  00d11	74 09		 je	 SHORT $LN6@inherit_sl
  00d13	48 3b 87 a0 01
	00 00		 cmp	 rax, QWORD PTR [rdi+416]
  00d1a	74 07		 je	 SHORT $LN7@inherit_sl
$LN6@inherit_sl:
  00d1c	48 89 83 a0 01
	00 00		 mov	 QWORD PTR [rbx+416], rax
$LN7@inherit_sl:

; 4111 :         if ((type->tp_flags & Py_TPFLAGS_HAVE_GC) ==
; 4112 :             (base->tp_flags & Py_TPFLAGS_HAVE_GC)) {

  00d23	8b 8b 00 01 00
	00		 mov	 ecx, DWORD PTR [rbx+256]
  00d29	8b 86 00 01 00
	00		 mov	 eax, DWORD PTR [rsi+256]
  00d2f	81 e1 00 40 00
	00		 and	 ecx, 16384		; 00004000H
  00d35	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  00d3a	3b c8		 cmp	 ecx, eax
  00d3c	75 26		 jne	 SHORT $LN5@inherit_sl

; 4113 :             /* They agree about gc. */
; 4114 :             COPYSLOT(tp_free);

  00d3e	48 83 bb 98 01
	00 00 00	 cmp	 QWORD PTR [rbx+408], 0
  00d46	75 51		 jne	 SHORT $LN1@inherit_sl
  00d48	48 8b 86 98 01
	00 00		 mov	 rax, QWORD PTR [rsi+408]
  00d4f	48 85 c0	 test	 rax, rax
  00d52	74 45		 je	 SHORT $LN1@inherit_sl
  00d54	48 85 ff	 test	 rdi, rdi
  00d57	74 39		 je	 SHORT $LN3@inherit_sl
  00d59	48 3b 87 98 01
	00 00		 cmp	 rax, QWORD PTR [rdi+408]
  00d60	74 37		 je	 SHORT $LN1@inherit_sl

; 4115 :         }
; 4116 :         else if ((type->tp_flags & Py_TPFLAGS_HAVE_GC) &&

  00d62	eb 2e		 jmp	 SHORT $LN3@inherit_sl
$LN5@inherit_sl:

; 4117 :                  type->tp_free == NULL &&
; 4118 :                  base->tp_free == PyObject_Free) {

  00d64	85 c9		 test	 ecx, ecx
  00d66	74 31		 je	 SHORT $LN1@inherit_sl
  00d68	48 83 bb 98 01
	00 00 00	 cmp	 QWORD PTR [rbx+408], 0
  00d70	75 27		 jne	 SHORT $LN1@inherit_sl
  00d72	48 8b 83 98 01
	00 00		 mov	 rax, QWORD PTR [rbx+408]
  00d79	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyObject_Free
  00d80	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyObject_GC_Del
  00d87	48 39 8e 98 01
	00 00		 cmp	 QWORD PTR [rsi+408], rcx
  00d8e	48 0f 44 c2	 cmove	 rax, rdx
$LN3@inherit_sl:
  00d92	48 89 83 98 01
	00 00		 mov	 QWORD PTR [rbx+408], rax
$LN1@inherit_sl:

; 4119 :             /* A bit of magic to plug in the correct default
; 4120 :              * tp_free function when a derived class adds gc,
; 4121 :              * didn't define tp_free, and the base uses the
; 4122 :              * default non-gc tp_free.
; 4123 :              */
; 4124 :             type->tp_free = PyObject_GC_Del;
; 4125 :         }
; 4126 :         /* else they didn't agree about gc, and there isn't something
; 4127 :          * obvious to be done -- the type is on its own.
; 4128 :          */
; 4129 :     }
; 4130 : }

  00d99	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00d9e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00da3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00da7	5f		 pop	 rdi
  00da8	c3		 ret	 0
inherit_slots ENDP
_TEXT	ENDS
EXTRN	PyList_SetItem:PROC
EXTRN	PyWeakref_NewRef:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_subclass DD imagerel add_subclass
	DD	imagerel add_subclass+205
	DD	imagerel $unwind$add_subclass
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_subclass DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT add_subclass
_TEXT	SEGMENT
base$ = 48
type$ = 56
add_subclass PROC					; COMDAT

; 4333 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4334 :     Py_ssize_t i;
; 4335 :     int result;
; 4336 :     PyObject *list, *ref, *newobj;
; 4337 : 
; 4338 :     list = base->tp_subclasses;

  0000f	48 8b 99 c0 01
	00 00		 mov	 rbx, QWORD PTR [rcx+448]
  00016	48 8b f2	 mov	 rsi, rdx
  00019	48 8b f9	 mov	 rdi, rcx

; 4339 :     if (list == NULL) {

  0001c	48 85 db	 test	 rbx, rbx
  0001f	75 29		 jne	 SHORT $LN4@add_subcla

; 4340 :         base->tp_subclasses = list = PyList_New(0);

  00021	33 c9		 xor	 ecx, ecx
  00023	e8 00 00 00 00	 call	 PyList_New
  00028	48 8b d8	 mov	 rbx, rax
  0002b	48 89 87 c0 01
	00 00		 mov	 QWORD PTR [rdi+448], rax

; 4341 :         if (list == NULL)

  00032	48 85 c0	 test	 rax, rax
  00035	75 13		 jne	 SHORT $LN4@add_subcla

; 4342 :             return -1;

  00037	83 c8 ff	 or	 eax, -1

; 4356 : }

  0003a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003f	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00044	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00048	5f		 pop	 rdi
  00049	c3		 ret	 0
$LN4@add_subcla:

; 4343 :     }
; 4344 :     assert(PyList_Check(list));
; 4345 :     newobj = PyWeakref_NewRef((PyObject *)type, NULL);

  0004a	33 d2		 xor	 edx, edx
  0004c	48 8b ce	 mov	 rcx, rsi
  0004f	e8 00 00 00 00	 call	 PyWeakref_NewRef

; 4346 :     i = PyList_GET_SIZE(list);
; 4347 :     while (--i >= 0) {

  00054	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  00058	48 ff ca	 dec	 rdx
  0005b	48 8b f8	 mov	 rdi, rax
  0005e	78 2c		 js	 SHORT $LN2@add_subcla

; 4343 :     }
; 4344 :     assert(PyList_Check(list));
; 4345 :     newobj = PyWeakref_NewRef((PyObject *)type, NULL);

  00060	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  00064	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0006b	4c 8d 04 d1	 lea	 r8, QWORD PTR [rcx+rdx*8]
  0006f	90		 npad	 1
$LL3@add_subcla:

; 4348 :         ref = PyList_GET_ITEM(list, i);

  00070	49 8b 08	 mov	 rcx, QWORD PTR [r8]

; 4349 :         assert(PyWeakref_CheckRef(ref));
; 4350 :         if (PyWeakref_GET_OBJECT(ref) == Py_None)

  00073	4c 8b 49 60	 mov	 r9, QWORD PTR [rcx+96]
  00077	49 83 79 50 00	 cmp	 QWORD PTR [r9+80], 0
  0007c	7e 35		 jle	 SHORT $LN11@add_subcla
  0007e	4c 3b c8	 cmp	 r9, rax
  00081	74 30		 je	 SHORT $LN11@add_subcla

; 4346 :     i = PyList_GET_SIZE(list);
; 4347 :     while (--i >= 0) {

  00083	49 83 e8 08	 sub	 r8, 8
  00087	48 ff ca	 dec	 rdx
  0008a	79 e4		 jns	 SHORT $LL3@add_subcla
$LN2@add_subcla:

; 4352 :     }
; 4353 :     result = PyList_Append(list, newobj);

  0008c	48 8b d7	 mov	 rdx, rdi
  0008f	48 8b cb	 mov	 rcx, rbx
  00092	e8 00 00 00 00	 call	 PyList_Append

; 4354 :     Py_DECREF(newobj);

  00097	48 8b cf	 mov	 rcx, rdi
  0009a	8b d8		 mov	 ebx, eax
  0009c	e8 00 00 00 00	 call	 _Py_DecRef

; 4355 :     return result;

  000a1	8b c3		 mov	 eax, ebx

; 4356 : }

  000a3	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a8	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000ad	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b1	5f		 pop	 rdi
  000b2	c3		 ret	 0
$LN11@add_subcla:

; 4351 :             return PyList_SetItem(list, i, newobj);

  000b3	4c 8b c7	 mov	 r8, rdi
  000b6	48 8b cb	 mov	 rcx, rbx

; 4356 : }

  000b9	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000be	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000c3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c7	5f		 pop	 rdi
  000c8	e9 00 00 00 00	 jmp	 PyList_SetItem
add_subclass ENDP
_TEXT	ENDS
EXTRN	PySequence_DelItem:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$remove_subclass DD imagerel remove_subclass
	DD	imagerel remove_subclass+99
	DD	imagerel $unwind$remove_subclass
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$remove_subclass DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT remove_subclass
_TEXT	SEGMENT
base$ = 48
type$ = 56
remove_subclass PROC					; COMDAT

; 4360 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4361 :     Py_ssize_t i;
; 4362 :     PyObject *list, *ref;
; 4363 : 
; 4364 :     list = base->tp_subclasses;

  00004	4c 8b 89 c0 01
	00 00		 mov	 r9, QWORD PTR [rcx+448]
  0000b	4c 8b d2	 mov	 r10, rdx

; 4365 :     if (list == NULL) {

  0000e	4d 85 c9	 test	 r9, r9
  00011	74 4b		 je	 SHORT $LN2@remove_sub

; 4370 :     while (--i >= 0) {

  00013	49 8b 51 60	 mov	 rdx, QWORD PTR [r9+96]
  00017	48 ff ca	 dec	 rdx
  0001a	78 42		 js	 SHORT $LN2@remove_sub

; 4366 :         return;
; 4367 :     }
; 4368 :     assert(PyList_Check(list));
; 4369 :     i = PyList_GET_SIZE(list);

  0001c	49 8b 41 70	 mov	 rax, QWORD PTR [r9+112]
  00020	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_NoneStruct
  00027	4c 8d 04 d0	 lea	 r8, QWORD PTR [rax+rdx*8]
  0002b	0f 1f 44 00 00	 npad	 5
$LL3@remove_sub:

; 4371 :         ref = PyList_GET_ITEM(list, i);

  00030	49 8b 00	 mov	 rax, QWORD PTR [r8]

; 4372 :         assert(PyWeakref_CheckRef(ref));
; 4373 :         if (PyWeakref_GET_OBJECT(ref) == (PyObject*)type) {

  00033	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00037	49 8b c3	 mov	 rax, r11
  0003a	48 83 79 50 00	 cmp	 QWORD PTR [rcx+80], 0
  0003f	48 0f 4f c1	 cmovg	 rax, rcx
  00043	49 3b c2	 cmp	 rax, r10
  00046	74 0e		 je	 SHORT $LN10@remove_sub

; 4370 :     while (--i >= 0) {

  00048	49 83 e8 08	 sub	 r8, 8
  0004c	48 ff ca	 dec	 rdx
  0004f	79 df		 jns	 SHORT $LL3@remove_sub

; 4376 :             return;
; 4377 :         }
; 4378 :     }
; 4379 : }

  00051	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00055	c3		 ret	 0
$LN10@remove_sub:

; 4374 :             /* this can't fail, right? */
; 4375 :             PySequence_DelItem(list, i);

  00056	49 8b c9	 mov	 rcx, r9
  00059	e8 00 00 00 00	 call	 PySequence_DelItem
$LN2@remove_sub:

; 4376 :             return;
; 4377 :         }
; 4378 :     }
; 4379 : }

  0005e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00062	c3		 ret	 0
remove_subclass ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@CCDHHOFN@expected?5?$CFd?5arguments?0?5got?5?$CFzd?$AA@ ; `string'
PUBLIC	??_C@_0DB@DAGMFCDN@PyArg_UnpackTuple?$CI?$CJ?5argument?5lis@ ; `string'
EXTRN	PyExc_SystemError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_num_args DD imagerel check_num_args
	DD	imagerel check_num_args+94
	DD	imagerel $unwind$check_num_args
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_num_args DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BP@CCDHHOFN@expected?5?$CFd?5arguments?0?5got?5?$CFzd?$AA@
CONST	SEGMENT
??_C@_0BP@CCDHHOFN@expected?5?$CFd?5arguments?0?5got?5?$CFzd?$AA@ DB 'exp'
	DB	'ected %d arguments, got %zd', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@DAGMFCDN@PyArg_UnpackTuple?$CI?$CJ?5argument?5lis@
CONST	SEGMENT
??_C@_0DB@DAGMFCDN@PyArg_UnpackTuple?$CI?$CJ?5argument?5lis@ DB 'PyArg_Un'
	DB	'packTuple() argument list is not a tuple', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT check_num_args
_TEXT	SEGMENT
ob$ = 48
n$ = 56
check_num_args PROC					; COMDAT

; 4383 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4384 :     if (!PyTuple_CheckExact(ob)) {

  00004	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyTuple_Type
  0000b	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0000f	74 1a		 je	 SHORT $LN2@check_num_

; 4385 :         PyErr_SetString(PyExc_SystemError,
; 4386 :             "PyArg_UnpackTuple() argument list is not a tuple");

  00011	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@DAGMFCDN@PyArg_UnpackTuple?$CI?$CJ?5argument?5lis@
  0001f	e8 00 00 00 00	 call	 PyErr_SetString

; 4394 :     return 0;

  00024	33 c0		 xor	 eax, eax

; 4395 : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
$LN2@check_num_:

; 4387 :         return 0;
; 4388 :     }
; 4389 :     if (n == PyTuple_GET_SIZE(ob))

  0002b	4c 8b 49 60	 mov	 r9, QWORD PTR [rcx+96]
  0002f	48 63 c2	 movsxd	 rax, edx
  00032	49 3b c1	 cmp	 rax, r9
  00035	75 0a		 jne	 SHORT $LN1@check_num_

; 4390 :         return 1;

  00037	b8 01 00 00 00	 mov	 eax, 1

; 4395 : }

  0003c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00040	c3		 ret	 0
$LN1@check_num_:

; 4391 :     PyErr_Format(
; 4392 :         PyExc_TypeError,
; 4393 :         "expected %d arguments, got %zd", n, PyTuple_GET_SIZE(ob));

  00041	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00048	44 8b c2	 mov	 r8d, edx
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@CCDHHOFN@expected?5?$CFd?5arguments?0?5got?5?$CFzd?$AA@
  00052	e8 00 00 00 00	 call	 PyErr_Format

; 4394 :     return 0;

  00057	33 c0		 xor	 eax, eax

; 4395 : }

  00059	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005d	c3		 ret	 0
check_num_args ENDP
_TEXT	ENDS
EXTRN	PyLong_FromLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$wrap_lenfunc DD imagerel wrap_lenfunc
	DD	imagerel wrap_lenfunc+87
	DD	imagerel $unwind$wrap_lenfunc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wrap_lenfunc DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT wrap_lenfunc
_TEXT	SEGMENT
self$ = 48
args$ = 56
wrapped$ = 64
wrap_lenfunc PROC					; COMDAT

; 4407 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b c2	 mov	 rax, rdx
  0000d	48 8b f9	 mov	 rdi, rcx

; 4408 :     lenfunc func = (lenfunc)wrapped;
; 4409 :     Py_ssize_t res;
; 4410 : 
; 4411 :     if (!check_num_args(args, 0))

  00010	33 d2		 xor	 edx, edx
  00012	48 8b c8	 mov	 rcx, rax
  00015	49 8b d8	 mov	 rbx, r8
  00018	e8 00 00 00 00	 call	 check_num_args
  0001d	85 c0		 test	 eax, eax
  0001f	75 0d		 jne	 SHORT $LN2@wrap_lenfu
$LN5@wrap_lenfu:

; 4412 :         return NULL;

  00021	33 c0		 xor	 eax, eax

; 4417 : }

  00023	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5f		 pop	 rdi
  0002d	c3		 ret	 0
$LN2@wrap_lenfu:

; 4413 :     res = (*func)(self);

  0002e	48 8b cf	 mov	 rcx, rdi
  00031	ff d3		 call	 rbx
  00033	48 8b d8	 mov	 rbx, rax

; 4414 :     if (res == -1 && PyErr_Occurred())

  00036	48 83 f8 ff	 cmp	 rax, -1
  0003a	75 0a		 jne	 SHORT $LN1@wrap_lenfu
  0003c	e8 00 00 00 00	 call	 PyErr_Occurred
  00041	48 85 c0	 test	 rax, rax

; 4415 :         return NULL;

  00044	75 db		 jne	 SHORT $LN5@wrap_lenfu
$LN1@wrap_lenfu:

; 4416 :     return PyLong_FromLong((long)res);

  00046	8b cb		 mov	 ecx, ebx

; 4417 : }

  00048	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00051	5f		 pop	 rdi
  00052	e9 00 00 00 00	 jmp	 PyLong_FromLong
wrap_lenfunc ENDP
_TEXT	ENDS
EXTRN	PyBool_FromLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$wrap_inquirypred DD imagerel wrap_inquirypred
	DD	imagerel wrap_inquirypred+85
	DD	imagerel $unwind$wrap_inquirypred
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wrap_inquirypred DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT wrap_inquirypred
_TEXT	SEGMENT
self$ = 48
args$ = 56
wrapped$ = 64
wrap_inquirypred PROC					; COMDAT

; 4421 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b c2	 mov	 rax, rdx
  0000d	48 8b f9	 mov	 rdi, rcx

; 4422 :     inquiry func = (inquiry)wrapped;
; 4423 :     int res;
; 4424 : 
; 4425 :     if (!check_num_args(args, 0))

  00010	33 d2		 xor	 edx, edx
  00012	48 8b c8	 mov	 rcx, rax
  00015	49 8b d8	 mov	 rbx, r8
  00018	e8 00 00 00 00	 call	 check_num_args
  0001d	85 c0		 test	 eax, eax
  0001f	75 0d		 jne	 SHORT $LN2@wrap_inqui
$LN5@wrap_inqui:

; 4426 :         return NULL;

  00021	33 c0		 xor	 eax, eax

; 4431 : }

  00023	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5f		 pop	 rdi
  0002d	c3		 ret	 0
$LN2@wrap_inqui:

; 4427 :     res = (*func)(self);

  0002e	48 8b cf	 mov	 rcx, rdi
  00031	ff d3		 call	 rbx
  00033	8b d8		 mov	 ebx, eax

; 4428 :     if (res == -1 && PyErr_Occurred())

  00035	83 f8 ff	 cmp	 eax, -1
  00038	75 0a		 jne	 SHORT $LN1@wrap_inqui
  0003a	e8 00 00 00 00	 call	 PyErr_Occurred
  0003f	48 85 c0	 test	 rax, rax

; 4429 :         return NULL;

  00042	75 dd		 jne	 SHORT $LN5@wrap_inqui
$LN1@wrap_inqui:

; 4430 :     return PyBool_FromLong((long)res);

  00044	8b cb		 mov	 ecx, ebx

; 4431 : }

  00046	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004f	5f		 pop	 rdi
  00050	e9 00 00 00 00	 jmp	 PyBool_FromLong
wrap_inquirypred ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$wrap_binaryfunc DD imagerel wrap_binaryfunc
	DD	imagerel wrap_binaryfunc+87
	DD	imagerel $unwind$wrap_binaryfunc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wrap_binaryfunc DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT wrap_binaryfunc
_TEXT	SEGMENT
self$ = 48
args$ = 56
wrapped$ = 64
wrap_binaryfunc PROC					; COMDAT

; 4435 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b da	 mov	 rbx, rdx
  00012	48 8b f1	 mov	 rsi, rcx

; 4436 :     binaryfunc func = (binaryfunc)wrapped;
; 4437 :     PyObject *other;
; 4438 : 
; 4439 :     if (!check_num_args(args, 1))

  00015	ba 01 00 00 00	 mov	 edx, 1
  0001a	48 8b cb	 mov	 rcx, rbx
  0001d	49 8b f8	 mov	 rdi, r8
  00020	e8 00 00 00 00	 call	 check_num_args
  00025	85 c0		 test	 eax, eax
  00027	75 12		 jne	 SHORT $LN1@wrap_binar

; 4440 :         return NULL;

  00029	33 c0		 xor	 eax, eax

; 4443 : }

  0002b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00030	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5f		 pop	 rdi
  0003a	c3		 ret	 0
$LN1@wrap_binar:

; 4441 :     other = PyTuple_GET_ITEM(args, 0);
; 4442 :     return (*func)(self, other);

  0003b	48 8b 53 70	 mov	 rdx, QWORD PTR [rbx+112]
  0003f	48 8b ce	 mov	 rcx, rsi
  00042	48 8b c7	 mov	 rax, rdi

; 4443 : }

  00045	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0004f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00053	5f		 pop	 rdi
  00054	48 ff e0	 rex_jmp rax
wrap_binaryfunc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$wrap_binaryfunc_l DD imagerel wrap_binaryfunc_l
	DD	imagerel wrap_binaryfunc_l+87
	DD	imagerel $unwind$wrap_binaryfunc_l
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wrap_binaryfunc_l DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT wrap_binaryfunc_l
_TEXT	SEGMENT
self$ = 48
args$ = 56
wrapped$ = 64
wrap_binaryfunc_l PROC					; COMDAT

; 4447 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b da	 mov	 rbx, rdx
  00012	48 8b f1	 mov	 rsi, rcx

; 4448 :     binaryfunc func = (binaryfunc)wrapped;
; 4449 :     PyObject *other;
; 4450 : 
; 4451 :     if (!check_num_args(args, 1))

  00015	ba 01 00 00 00	 mov	 edx, 1
  0001a	48 8b cb	 mov	 rcx, rbx
  0001d	49 8b f8	 mov	 rdi, r8
  00020	e8 00 00 00 00	 call	 check_num_args
  00025	85 c0		 test	 eax, eax
  00027	75 12		 jne	 SHORT $LN1@wrap_binar@2

; 4452 :         return NULL;

  00029	33 c0		 xor	 eax, eax

; 4455 : }

  0002b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00030	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5f		 pop	 rdi
  0003a	c3		 ret	 0
$LN1@wrap_binar@2:

; 4453 :     other = PyTuple_GET_ITEM(args, 0);
; 4454 :     return (*func)(self, other);

  0003b	48 8b 53 70	 mov	 rdx, QWORD PTR [rbx+112]
  0003f	48 8b ce	 mov	 rcx, rsi
  00042	48 8b c7	 mov	 rax, rdi

; 4455 : }

  00045	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0004f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00053	5f		 pop	 rdi
  00054	48 ff e0	 rex_jmp rax
wrap_binaryfunc_l ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$wrap_binaryfunc_r DD imagerel wrap_binaryfunc_r
	DD	imagerel wrap_binaryfunc_r+87
	DD	imagerel $unwind$wrap_binaryfunc_r
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wrap_binaryfunc_r DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT wrap_binaryfunc_r
_TEXT	SEGMENT
self$ = 48
args$ = 56
wrapped$ = 64
wrap_binaryfunc_r PROC					; COMDAT

; 4459 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b da	 mov	 rbx, rdx
  00012	48 8b f1	 mov	 rsi, rcx

; 4460 :     binaryfunc func = (binaryfunc)wrapped;
; 4461 :     PyObject *other;
; 4462 : 
; 4463 :     if (!check_num_args(args, 1))

  00015	ba 01 00 00 00	 mov	 edx, 1
  0001a	48 8b cb	 mov	 rcx, rbx
  0001d	49 8b f8	 mov	 rdi, r8
  00020	e8 00 00 00 00	 call	 check_num_args
  00025	85 c0		 test	 eax, eax
  00027	75 12		 jne	 SHORT $LN1@wrap_binar@3

; 4464 :         return NULL;

  00029	33 c0		 xor	 eax, eax

; 4467 : }

  0002b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00030	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5f		 pop	 rdi
  0003a	c3		 ret	 0
$LN1@wrap_binar@3:

; 4465 :     other = PyTuple_GET_ITEM(args, 0);
; 4466 :     return (*func)(other, self);

  0003b	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  0003f	48 8b d6	 mov	 rdx, rsi
  00042	48 8b c7	 mov	 rax, rdi

; 4467 : }

  00045	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0004f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00053	5f		 pop	 rdi
  00054	48 ff e0	 rex_jmp rax
wrap_binaryfunc_r ENDP
_TEXT	ENDS
EXTRN	PyArg_UnpackTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$wrap_ternaryfunc DD imagerel wrap_ternaryfunc
	DD	imagerel wrap_ternaryfunc+119
	DD	imagerel $unwind$wrap_ternaryfunc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wrap_ternaryfunc DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT wrap_ternaryfunc
_TEXT	SEGMENT
self$ = 64
args$ = 72
third$ = 80
wrapped$ = 80
other$ = 88
wrap_ternaryfunc PROC					; COMDAT

; 4471 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	48 8b c2	 mov	 rax, rdx

; 4472 :     ternaryfunc func = (ternaryfunc)wrapped;
; 4473 :     PyObject *other;
; 4474 :     PyObject *third = Py_None;

  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00017	48 89 4c 24 50	 mov	 QWORD PTR third$[rsp], rcx

; 4475 : 
; 4476 :     /* Note: This wrapper only works for __pow__() */
; 4477 : 
; 4478 :     if (!PyArg_UnpackTuple(args, "", 1, 2, &other, &third))

  0001c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR third$[rsp]
  00021	41 b9 02 00 00
	00		 mov	 r9d, 2
  00027	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002c	48 8d 4c 24 58	 lea	 rcx, QWORD PTR other$[rsp]
  00031	49 8b d8	 mov	 rbx, r8
  00034	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00039	45 8d 41 ff	 lea	 r8d, QWORD PTR [r9-1]
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00044	48 8b c8	 mov	 rcx, rax
  00047	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0004c	85 c0		 test	 eax, eax
  0004e	75 0d		 jne	 SHORT $LN1@wrap_terna

; 4479 :         return NULL;

  00050	33 c0		 xor	 eax, eax

; 4481 : }

  00052	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00057	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005b	5f		 pop	 rdi
  0005c	c3		 ret	 0
$LN1@wrap_terna:

; 4480 :     return (*func)(self, other, third);

  0005d	4c 8b 44 24 50	 mov	 r8, QWORD PTR third$[rsp]
  00062	48 8b 54 24 58	 mov	 rdx, QWORD PTR other$[rsp]
  00067	48 8b cf	 mov	 rcx, rdi
  0006a	ff d3		 call	 rbx

; 4481 : }

  0006c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00071	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00075	5f		 pop	 rdi
  00076	c3		 ret	 0
wrap_ternaryfunc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$wrap_ternaryfunc_r DD imagerel wrap_ternaryfunc_r
	DD	imagerel wrap_ternaryfunc_r+119
	DD	imagerel $unwind$wrap_ternaryfunc_r
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wrap_ternaryfunc_r DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT wrap_ternaryfunc_r
_TEXT	SEGMENT
self$ = 64
args$ = 72
third$ = 80
wrapped$ = 80
other$ = 88
wrap_ternaryfunc_r PROC					; COMDAT

; 4485 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	48 8b c2	 mov	 rax, rdx

; 4486 :     ternaryfunc func = (ternaryfunc)wrapped;
; 4487 :     PyObject *other;
; 4488 :     PyObject *third = Py_None;

  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00017	48 89 4c 24 50	 mov	 QWORD PTR third$[rsp], rcx

; 4489 : 
; 4490 :     /* Note: This wrapper only works for __pow__() */
; 4491 : 
; 4492 :     if (!PyArg_UnpackTuple(args, "", 1, 2, &other, &third))

  0001c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR third$[rsp]
  00021	41 b9 02 00 00
	00		 mov	 r9d, 2
  00027	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002c	48 8d 4c 24 58	 lea	 rcx, QWORD PTR other$[rsp]
  00031	49 8b d8	 mov	 rbx, r8
  00034	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00039	45 8d 41 ff	 lea	 r8d, QWORD PTR [r9-1]
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00044	48 8b c8	 mov	 rcx, rax
  00047	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0004c	85 c0		 test	 eax, eax
  0004e	75 0d		 jne	 SHORT $LN1@wrap_terna@2

; 4493 :         return NULL;

  00050	33 c0		 xor	 eax, eax

; 4495 : }

  00052	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00057	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005b	5f		 pop	 rdi
  0005c	c3		 ret	 0
$LN1@wrap_terna@2:

; 4494 :     return (*func)(other, self, third);

  0005d	4c 8b 44 24 50	 mov	 r8, QWORD PTR third$[rsp]
  00062	48 8b 4c 24 58	 mov	 rcx, QWORD PTR other$[rsp]
  00067	48 8b d7	 mov	 rdx, rdi
  0006a	ff d3		 call	 rbx

; 4495 : }

  0006c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00071	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00075	5f		 pop	 rdi
  00076	c3		 ret	 0
wrap_ternaryfunc_r ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$wrap_unaryfunc DD imagerel wrap_unaryfunc
	DD	imagerel wrap_unaryfunc+65
	DD	imagerel $unwind$wrap_unaryfunc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wrap_unaryfunc DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT wrap_unaryfunc
_TEXT	SEGMENT
self$ = 48
args$ = 56
wrapped$ = 64
wrap_unaryfunc PROC					; COMDAT

; 4499 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b c2	 mov	 rax, rdx
  0000d	48 8b f9	 mov	 rdi, rcx

; 4500 :     unaryfunc func = (unaryfunc)wrapped;
; 4501 : 
; 4502 :     if (!check_num_args(args, 0))

  00010	33 d2		 xor	 edx, edx
  00012	48 8b c8	 mov	 rcx, rax
  00015	49 8b d8	 mov	 rbx, r8
  00018	e8 00 00 00 00	 call	 check_num_args
  0001d	85 c0		 test	 eax, eax
  0001f	75 0d		 jne	 SHORT $LN1@wrap_unary

; 4503 :         return NULL;

  00021	33 c0		 xor	 eax, eax

; 4505 : }

  00023	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5f		 pop	 rdi
  0002d	c3		 ret	 0
$LN1@wrap_unary:

; 4504 :     return (*func)(self);

  0002e	48 8b cf	 mov	 rcx, rdi
  00031	48 8b c3	 mov	 rax, rbx

; 4505 : }

  00034	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5f		 pop	 rdi
  0003e	48 ff e0	 rex_jmp rax
wrap_unaryfunc ENDP
_TEXT	ENDS
EXTRN	PyNumber_AsSsize_t:PROC
EXTRN	PyExc_OverflowError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$wrap_indexargfunc DD imagerel wrap_indexargfunc
	DD	imagerel wrap_indexargfunc+82
	DD	imagerel $unwind$wrap_indexargfunc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$wrap_indexargfunc DD imagerel wrap_indexargfunc+82
	DD	imagerel wrap_indexargfunc+129
	DD	imagerel $chain$0$wrap_indexargfunc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$wrap_indexargfunc DD imagerel wrap_indexargfunc+129
	DD	imagerel wrap_indexargfunc+153
	DD	imagerel $chain$2$wrap_indexargfunc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$wrap_indexargfunc DD 020021H
	DD	083400H
	DD	imagerel wrap_indexargfunc
	DD	imagerel wrap_indexargfunc+82
	DD	imagerel $unwind$wrap_indexargfunc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$wrap_indexargfunc DD 020521H
	DD	083405H
	DD	imagerel wrap_indexargfunc
	DD	imagerel wrap_indexargfunc+82
	DD	imagerel $unwind$wrap_indexargfunc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wrap_indexargfunc DD 040a01H
	DD	09640aH
	DD	07006520aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT wrap_indexargfunc
_TEXT	SEGMENT
self$ = 64
args$ = 72
o$ = 80
wrapped$ = 80
wrap_indexargfunc PROC					; COMDAT

; 4509 : {

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f1	 mov	 rsi, rcx
  0000d	48 8b c2	 mov	 rax, rdx

; 4510 :     ssizeargfunc func = (ssizeargfunc)wrapped;
; 4511 :     PyObject* o;
; 4512 :     Py_ssize_t i;
; 4513 : 
; 4514 :     if (!PyArg_UnpackTuple(args, "", 1, 1, &o))

  00010	48 8d 4c 24 50	 lea	 rcx, QWORD PTR o$[rsp]
  00015	41 b9 01 00 00
	00		 mov	 r9d, 1
  0001b	49 8b f8	 mov	 rdi, r8
  0001e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0002a	48 8b c8	 mov	 rcx, rax
  0002d	45 8b c1	 mov	 r8d, r9d
  00030	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  00035	85 c0		 test	 eax, eax
  00037	75 0d		 jne	 SHORT $LN2@wrap_index

; 4515 :         return NULL;

  00039	33 c0		 xor	 eax, eax

; 4520 : }

  0003b	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00040	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00044	5f		 pop	 rdi
  00045	c3		 ret	 0
$LN2@wrap_index:

; 4516 :     i = PyNumber_AsSsize_t(o, PyExc_OverflowError);

  00046	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_OverflowError
  0004d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR o$[rsp]
  00052	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00057	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  0005c	48 8b d8	 mov	 rbx, rax

; 4517 :     if (i == -1 && PyErr_Occurred())

  0005f	48 83 f8 ff	 cmp	 rax, -1
  00063	75 1c		 jne	 SHORT $LN1@wrap_index
  00065	e8 00 00 00 00	 call	 PyErr_Occurred
  0006a	48 85 c0	 test	 rax, rax
  0006d	74 12		 je	 SHORT $LN1@wrap_index

; 4518 :         return NULL;

  0006f	33 c0		 xor	 eax, eax
  00071	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 4520 : }

  00076	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0007b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007f	5f		 pop	 rdi
  00080	c3		 ret	 0
$LN1@wrap_index:

; 4519 :     return (*func)(self, i);

  00081	48 8b d3	 mov	 rdx, rbx
  00084	48 8b ce	 mov	 rcx, rsi
  00087	ff d7		 call	 rdi
  00089	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 4520 : }

  0008e	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00093	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00097	5f		 pop	 rdi
  00098	c3		 ret	 0
wrap_indexargfunc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getindex DD imagerel getindex
	DD	imagerel getindex+121
	DD	imagerel $unwind$getindex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getindex DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT getindex
_TEXT	SEGMENT
self$ = 48
arg$ = 56
getindex PROC						; COMDAT

; 4524 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b c2	 mov	 rax, rdx

; 4525 :     Py_ssize_t i;
; 4526 : 
; 4527 :     i = PyNumber_AsSsize_t(arg, PyExc_OverflowError);

  0000d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_OverflowError
  00014	48 8b f9	 mov	 rdi, rcx
  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  0001f	48 8b d8	 mov	 rbx, rax

; 4528 :     if (i == -1 && PyErr_Occurred())

  00022	48 83 f8 ff	 cmp	 rax, -1
  00026	75 19		 jne	 SHORT $LN4@getindex
  00028	e8 00 00 00 00	 call	 PyErr_Occurred
  0002d	48 85 c0	 test	 rax, rax
  00030	74 14		 je	 SHORT $LN7@getindex
$LN8@getindex:

; 4529 :         return -1;

  00032	48 83 c8 ff	 or	 rax, -1

; 4540 : }

  00036	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5f		 pop	 rdi
  00040	c3		 ret	 0
$LN4@getindex:

; 4530 :     if (i < 0) {

  00041	48 85 c0	 test	 rax, rax
  00044	79 25		 jns	 SHORT $LN2@getindex
$LN7@getindex:

; 4531 :         PySequenceMethods *sq = Py_TYPE(self)->tp_as_sequence;

  00046	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0004a	48 8b 88 c0 00
	00 00		 mov	 rcx, QWORD PTR [rax+192]

; 4532 :         if (sq && sq->sq_length) {

  00051	48 85 c9	 test	 rcx, rcx
  00054	74 15		 je	 SHORT $LN2@getindex
  00056	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00059	48 85 c0	 test	 rax, rax
  0005c	74 0d		 je	 SHORT $LN2@getindex

; 4533 :             Py_ssize_t n = (*sq->sq_length)(self);

  0005e	48 8b cf	 mov	 rcx, rdi
  00061	ff d0		 call	 rax

; 4534 :             if (n < 0)

  00063	48 85 c0	 test	 rax, rax

; 4535 :                 return -1;

  00066	78 ca		 js	 SHORT $LN8@getindex

; 4536 :             i += n;

  00068	48 03 d8	 add	 rbx, rax
$LN2@getindex:

; 4537 :         }
; 4538 :     }
; 4539 :     return i;

  0006b	48 8b c3	 mov	 rax, rbx

; 4540 : }

  0006e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00073	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00077	5f		 pop	 rdi
  00078	c3		 ret	 0
getindex ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$wrap_sq_item DD imagerel wrap_sq_item
	DD	imagerel wrap_sq_item+30
	DD	imagerel $unwind$wrap_sq_item
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$wrap_sq_item DD imagerel wrap_sq_item+30
	DD	imagerel wrap_sq_item+77
	DD	imagerel $chain$0$wrap_sq_item
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$wrap_sq_item DD imagerel wrap_sq_item+77
	DD	imagerel wrap_sq_item+104
	DD	imagerel $chain$2$wrap_sq_item
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$wrap_sq_item DD imagerel wrap_sq_item+104
	DD	imagerel wrap_sq_item+130
	DD	imagerel $chain$3$wrap_sq_item
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$wrap_sq_item DD 021H
	DD	imagerel wrap_sq_item
	DD	imagerel wrap_sq_item+30
	DD	imagerel $unwind$wrap_sq_item
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$wrap_sq_item DD 020021H
	DD	066400H
	DD	imagerel wrap_sq_item
	DD	imagerel wrap_sq_item+30
	DD	imagerel $unwind$wrap_sq_item
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$wrap_sq_item DD 020521H
	DD	066405H
	DD	imagerel wrap_sq_item
	DD	imagerel wrap_sq_item+30
	DD	imagerel $unwind$wrap_sq_item
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wrap_sq_item DD 040a01H
	DD	07340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT wrap_sq_item
_TEXT	SEGMENT
self$ = 48
args$ = 56
wrapped$ = 64
wrap_sq_item PROC					; COMDAT

; 4544 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4545 :     ssizeargfunc func = (ssizeargfunc)wrapped;
; 4546 :     PyObject *arg;
; 4547 :     Py_ssize_t i;
; 4548 : 
; 4549 :     if (PyTuple_GET_SIZE(args) == 1) {

  0000a	48 83 7a 60 01	 cmp	 QWORD PTR [rdx+96], 1
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b c2	 mov	 rax, rdx
  00015	48 8b d9	 mov	 rbx, rcx
  00018	75 4e		 jne	 SHORT $LN2@wrap_sq_it

; 4550 :         arg = PyTuple_GET_ITEM(args, 0);
; 4551 :         i = getindex(self, arg);

  0001a	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  0001e	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00023	e8 00 00 00 00	 call	 getindex
  00028	48 8b f0	 mov	 rsi, rax

; 4552 :         if (i == -1 && PyErr_Occurred())

  0002b	48 83 f8 ff	 cmp	 rax, -1
  0002f	75 1c		 jne	 SHORT $LN1@wrap_sq_it
  00031	e8 00 00 00 00	 call	 PyErr_Occurred
  00036	48 85 c0	 test	 rax, rax
  00039	74 12		 je	 SHORT $LN1@wrap_sq_it

; 4553 :             return NULL;

  0003b	33 c0		 xor	 eax, eax
  0003d	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 4557 :     assert(PyErr_Occurred());
; 4558 :     return NULL;
; 4559 : }

  00042	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5f		 pop	 rdi
  0004c	c3		 ret	 0
$LN1@wrap_sq_it:

; 4554 :         return (*func)(self, i);

  0004d	48 8b d6	 mov	 rdx, rsi
  00050	48 8b cb	 mov	 rcx, rbx
  00053	48 8b c7	 mov	 rax, rdi
  00056	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 4557 :     assert(PyErr_Occurred());
; 4558 :     return NULL;
; 4559 : }

  0005b	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00060	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00064	5f		 pop	 rdi
  00065	48 ff e0	 rex_jmp rax
$LN2@wrap_sq_it:

; 4555 :     }
; 4556 :     check_num_args(args, 1);

  00068	ba 01 00 00 00	 mov	 edx, 1
  0006d	48 8b c8	 mov	 rcx, rax
  00070	e8 00 00 00 00	 call	 check_num_args

; 4557 :     assert(PyErr_Occurred());
; 4558 :     return NULL;
; 4559 : }

  00075	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0007a	33 c0		 xor	 eax, eax
  0007c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00080	5f		 pop	 rdi
  00081	c3		 ret	 0
wrap_sq_item ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$wrap_sq_setitem DD imagerel wrap_sq_setitem
	DD	imagerel wrap_sq_setitem+88
	DD	imagerel $unwind$wrap_sq_setitem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$wrap_sq_setitem DD imagerel wrap_sq_setitem+88
	DD	imagerel wrap_sq_setitem+163
	DD	imagerel $chain$0$wrap_sq_setitem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$wrap_sq_setitem DD imagerel wrap_sq_setitem+163
	DD	imagerel wrap_sq_setitem+255
	DD	imagerel $chain$2$wrap_sq_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$wrap_sq_setitem DD 020021H
	DD	083400H
	DD	imagerel wrap_sq_setitem
	DD	imagerel wrap_sq_setitem+88
	DD	imagerel $unwind$wrap_sq_setitem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$wrap_sq_setitem DD 020521H
	DD	083405H
	DD	imagerel wrap_sq_setitem
	DD	imagerel wrap_sq_setitem+88
	DD	imagerel $unwind$wrap_sq_setitem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wrap_sq_setitem DD 040a01H
	DD	09640aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT wrap_sq_setitem
_TEXT	SEGMENT
self$ = 64
args$ = 72
arg$ = 80
wrapped$ = 80
value$ = 88
wrap_sq_setitem PROC					; COMDAT

; 4563 : {

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	48 8b c2	 mov	 rax, rdx

; 4564 :     ssizeobjargproc func = (ssizeobjargproc)wrapped;
; 4565 :     Py_ssize_t i;
; 4566 :     int res;
; 4567 :     PyObject *arg, *value;
; 4568 : 
; 4569 :     if (!PyArg_UnpackTuple(args, "", 2, 2, &arg, &value))

  00010	48 8d 4c 24 58	 lea	 rcx, QWORD PTR value$[rsp]
  00015	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0001a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR arg$[rsp]
  0001f	41 b9 02 00 00
	00		 mov	 r9d, 2
  00025	49 8b f0	 mov	 rsi, r8
  00028	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00034	48 8b c8	 mov	 rcx, rax
  00037	45 8b c1	 mov	 r8d, r9d
  0003a	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0003f	85 c0		 test	 eax, eax
  00041	75 0d		 jne	 SHORT $LN3@wrap_sq_se

; 4570 :         return NULL;

  00043	33 c0		 xor	 eax, eax

; 4578 :     return Py_None;
; 4579 : }

  00045	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0004a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004e	5f		 pop	 rdi
  0004f	c3		 ret	 0
$LN3@wrap_sq_se:

; 4571 :     i = getindex(self, arg);

  00050	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00055	48 8b cf	 mov	 rcx, rdi
  00058	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0005d	e8 00 00 00 00	 call	 getindex
  00062	48 8b d8	 mov	 rbx, rax

; 4572 :     if (i == -1 && PyErr_Occurred())

  00065	48 83 f8 ff	 cmp	 rax, -1
  00069	75 0a		 jne	 SHORT $LN2@wrap_sq_se
  0006b	e8 00 00 00 00	 call	 PyErr_Occurred
  00070	48 85 c0	 test	 rax, rax

; 4573 :         return NULL;

  00073	75 1c		 jne	 SHORT $LN11@wrap_sq_se
$LN2@wrap_sq_se:

; 4574 :     res = (*func)(self, i, value);

  00075	4c 8b 44 24 58	 mov	 r8, QWORD PTR value$[rsp]
  0007a	48 8b d3	 mov	 rdx, rbx
  0007d	48 8b cf	 mov	 rcx, rdi
  00080	ff d6		 call	 rsi

; 4575 :     if (res == -1 && PyErr_Occurred())

  00082	83 f8 ff	 cmp	 eax, -1
  00085	75 1c		 jne	 SHORT $LN1@wrap_sq_se
  00087	e8 00 00 00 00	 call	 PyErr_Occurred
  0008c	48 85 c0	 test	 rax, rax
  0008f	74 12		 je	 SHORT $LN1@wrap_sq_se
$LN11@wrap_sq_se:

; 4576 :         return NULL;

  00091	33 c0		 xor	 eax, eax
  00093	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 4578 :     return Py_None;
; 4579 : }

  00098	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0009d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a1	5f		 pop	 rdi
  000a2	c3		 ret	 0
$LN1@wrap_sq_se:

; 4577 :     Py_INCREF(Py_None);

  000a3	e8 00 00 00 00	 call	 _Py_PXCTX
  000a8	85 c0		 test	 eax, eax
  000aa	75 3c		 jne	 SHORT $LN7@wrap_sq_se
  000ac	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  000b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000c1	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000c7	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000cf	e8 00 00 00 00	 call	 _PyParallel_Guard
  000d4	85 c0		 test	 eax, eax
  000d6	75 09		 jne	 SHORT $LN6@wrap_sq_se
  000d8	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000df	74 07		 je	 SHORT $LN7@wrap_sq_se
$LN6@wrap_sq_se:
  000e1	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN7@wrap_sq_se:

; 4578 :     return Py_None;
; 4579 : }

  000e8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ed	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000f2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000f9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000fd	5f		 pop	 rdi
  000fe	c3		 ret	 0
wrap_sq_setitem ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$wrap_sq_delitem DD imagerel wrap_sq_delitem
	DD	imagerel wrap_sq_delitem+208
	DD	imagerel $unwind$wrap_sq_delitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wrap_sq_delitem DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT wrap_sq_delitem
_TEXT	SEGMENT
self$ = 64
args$ = 72
wrapped$ = 80
wrap_sq_delitem PROC					; COMDAT

; 4583 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b da	 mov	 rbx, rdx
  00012	48 8b f9	 mov	 rdi, rcx

; 4584 :     ssizeobjargproc func = (ssizeobjargproc)wrapped;
; 4585 :     Py_ssize_t i;
; 4586 :     int res;
; 4587 :     PyObject *arg;
; 4588 : 
; 4589 :     if (!check_num_args(args, 1))

  00015	ba 01 00 00 00	 mov	 edx, 1
  0001a	48 8b cb	 mov	 rcx, rbx
  0001d	49 8b f0	 mov	 rsi, r8
  00020	e8 00 00 00 00	 call	 check_num_args
  00025	85 c0		 test	 eax, eax
  00027	75 12		 jne	 SHORT $LN3@wrap_sq_de
$LN10@wrap_sq_de:

; 4590 :         return NULL;

  00029	33 c0		 xor	 eax, eax

; 4599 :     return Py_None;
; 4600 : }

  0002b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00030	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00035	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00039	5f		 pop	 rdi
  0003a	c3		 ret	 0
$LN3@wrap_sq_de:

; 4591 :     arg = PyTuple_GET_ITEM(args, 0);
; 4592 :     i = getindex(self, arg);

  0003b	48 8b 53 70	 mov	 rdx, QWORD PTR [rbx+112]
  0003f	48 8b cf	 mov	 rcx, rdi
  00042	e8 00 00 00 00	 call	 getindex
  00047	48 8b d8	 mov	 rbx, rax

; 4593 :     if (i == -1 && PyErr_Occurred())

  0004a	48 83 f8 ff	 cmp	 rax, -1
  0004e	75 0a		 jne	 SHORT $LN2@wrap_sq_de
  00050	e8 00 00 00 00	 call	 PyErr_Occurred
  00055	48 85 c0	 test	 rax, rax

; 4594 :         return NULL;

  00058	75 cf		 jne	 SHORT $LN10@wrap_sq_de
$LN2@wrap_sq_de:

; 4595 :     res = (*func)(self, i, NULL);

  0005a	45 33 c0	 xor	 r8d, r8d
  0005d	48 8b d3	 mov	 rdx, rbx
  00060	48 8b cf	 mov	 rcx, rdi
  00063	ff d6		 call	 rsi

; 4596 :     if (res == -1 && PyErr_Occurred())

  00065	83 f8 ff	 cmp	 eax, -1
  00068	75 0a		 jne	 SHORT $LN1@wrap_sq_de
  0006a	e8 00 00 00 00	 call	 PyErr_Occurred
  0006f	48 85 c0	 test	 rax, rax

; 4597 :         return NULL;

  00072	75 b5		 jne	 SHORT $LN10@wrap_sq_de
$LN1@wrap_sq_de:

; 4598 :     Py_INCREF(Py_None);

  00074	e8 00 00 00 00	 call	 _Py_PXCTX
  00079	85 c0		 test	 eax, eax
  0007b	75 3c		 jne	 SHORT $LN7@wrap_sq_de
  0007d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00084	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0008b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00092	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00098	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000a0	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a5	85 c0		 test	 eax, eax
  000a7	75 09		 jne	 SHORT $LN6@wrap_sq_de
  000a9	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000b0	74 07		 je	 SHORT $LN7@wrap_sq_de
$LN6@wrap_sq_de:
  000b2	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN7@wrap_sq_de:

; 4599 :     return Py_None;
; 4600 : }

  000b9	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000be	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000c3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000ca	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ce	5f		 pop	 rdi
  000cf	c3		 ret	 0
wrap_sq_delitem ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$wrap_objobjproc DD imagerel wrap_objobjproc
	DD	imagerel wrap_objobjproc+107
	DD	imagerel $unwind$wrap_objobjproc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wrap_objobjproc DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT wrap_objobjproc
_TEXT	SEGMENT
self$ = 48
args$ = 56
wrapped$ = 64
wrap_objobjproc PROC					; COMDAT

; 4605 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b da	 mov	 rbx, rdx
  00012	48 8b f1	 mov	 rsi, rcx

; 4606 :     objobjproc func = (objobjproc)wrapped;
; 4607 :     int res;
; 4608 :     PyObject *value;
; 4609 : 
; 4610 :     if (!check_num_args(args, 1))

  00015	ba 01 00 00 00	 mov	 edx, 1
  0001a	48 8b cb	 mov	 rcx, rbx
  0001d	49 8b f8	 mov	 rdi, r8
  00020	e8 00 00 00 00	 call	 check_num_args
  00025	85 c0		 test	 eax, eax
  00027	75 12		 jne	 SHORT $LN3@wrap_objob
$LN6@wrap_objob:

; 4611 :         return NULL;

  00029	33 c0		 xor	 eax, eax

; 4618 : }

  0002b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00030	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5f		 pop	 rdi
  0003a	c3		 ret	 0
$LN3@wrap_objob:

; 4612 :     value = PyTuple_GET_ITEM(args, 0);
; 4613 :     res = (*func)(self, value);

  0003b	48 8b 53 70	 mov	 rdx, QWORD PTR [rbx+112]
  0003f	48 8b ce	 mov	 rcx, rsi
  00042	ff d7		 call	 rdi
  00044	8b d8		 mov	 ebx, eax

; 4614 :     if (res == -1 && PyErr_Occurred())

  00046	83 f8 ff	 cmp	 eax, -1
  00049	75 0a		 jne	 SHORT $LN2@wrap_objob
  0004b	e8 00 00 00 00	 call	 PyErr_Occurred
  00050	48 85 c0	 test	 rax, rax

; 4615 :         return NULL;

  00053	75 d4		 jne	 SHORT $LN6@wrap_objob
$LN2@wrap_objob:

; 4616 :     else
; 4617 :         return PyBool_FromLong(res);

  00055	8b cb		 mov	 ecx, ebx

; 4618 : }

  00057	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005c	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00061	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00065	5f		 pop	 rdi
  00066	e9 00 00 00 00	 jmp	 PyBool_FromLong
wrap_objobjproc ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$wrap_objobjargproc DD imagerel wrap_objobjargproc
	DD	imagerel wrap_objobjargproc+197
	DD	imagerel $unwind$wrap_objobjargproc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wrap_objobjargproc DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT wrap_objobjargproc
_TEXT	SEGMENT
self$ = 64
args$ = 72
value$ = 80
wrapped$ = 80
key$ = 88
wrap_objobjargproc PROC					; COMDAT

; 4622 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	48 8b c2	 mov	 rax, rdx

; 4623 :     objobjargproc func = (objobjargproc)wrapped;
; 4624 :     int res;
; 4625 :     PyObject *key, *value;
; 4626 : 
; 4627 :     if (!PyArg_UnpackTuple(args, "", 2, 2, &key, &value))

  00010	48 8d 4c 24 50	 lea	 rcx, QWORD PTR value$[rsp]
  00015	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0001a	48 8d 4c 24 58	 lea	 rcx, QWORD PTR key$[rsp]
  0001f	41 b9 02 00 00
	00		 mov	 r9d, 2
  00025	49 8b d8	 mov	 rbx, r8
  00028	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00034	48 8b c8	 mov	 rcx, rax
  00037	45 8b c1	 mov	 r8d, r9d
  0003a	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0003f	85 c0		 test	 eax, eax
  00041	75 0d		 jne	 SHORT $LN2@wrap_objob@2
$LN9@wrap_objob@2:

; 4628 :         return NULL;

  00043	33 c0		 xor	 eax, eax

; 4634 : }

  00045	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0004a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004e	5f		 pop	 rdi
  0004f	c3		 ret	 0
$LN2@wrap_objob@2:

; 4629 :     res = (*func)(self, key, value);

  00050	4c 8b 44 24 50	 mov	 r8, QWORD PTR value$[rsp]
  00055	48 8b 54 24 58	 mov	 rdx, QWORD PTR key$[rsp]
  0005a	48 8b cf	 mov	 rcx, rdi
  0005d	ff d3		 call	 rbx

; 4630 :     if (res == -1 && PyErr_Occurred())

  0005f	83 f8 ff	 cmp	 eax, -1
  00062	75 0a		 jne	 SHORT $LN1@wrap_objob@2
  00064	e8 00 00 00 00	 call	 PyErr_Occurred
  00069	48 85 c0	 test	 rax, rax

; 4631 :         return NULL;

  0006c	75 d5		 jne	 SHORT $LN9@wrap_objob@2
$LN1@wrap_objob@2:

; 4632 :     Py_INCREF(Py_None);

  0006e	e8 00 00 00 00	 call	 _Py_PXCTX
  00073	85 c0		 test	 eax, eax
  00075	75 3c		 jne	 SHORT $LN6@wrap_objob@2
  00077	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  0007e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0008c	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00092	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0009a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0009f	85 c0		 test	 eax, eax
  000a1	75 09		 jne	 SHORT $LN5@wrap_objob@2
  000a3	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000aa	74 07		 je	 SHORT $LN6@wrap_objob@2
$LN5@wrap_objob@2:
  000ac	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN6@wrap_objob@2:

; 4633 :     return Py_None;

  000b3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 4634 : }

  000ba	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000bf	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c3	5f		 pop	 rdi
  000c4	c3		 ret	 0
wrap_objobjargproc ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$wrap_delitem DD imagerel wrap_delitem
	DD	imagerel wrap_delitem+178
	DD	imagerel $unwind$wrap_delitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wrap_delitem DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT wrap_delitem
_TEXT	SEGMENT
self$ = 64
args$ = 72
wrapped$ = 80
wrap_delitem PROC					; COMDAT

; 4638 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b da	 mov	 rbx, rdx
  00012	48 8b f1	 mov	 rsi, rcx

; 4639 :     objobjargproc func = (objobjargproc)wrapped;
; 4640 :     int res;
; 4641 :     PyObject *key;
; 4642 : 
; 4643 :     if (!check_num_args(args, 1))

  00015	ba 01 00 00 00	 mov	 edx, 1
  0001a	48 8b cb	 mov	 rcx, rbx
  0001d	49 8b f8	 mov	 rdi, r8
  00020	e8 00 00 00 00	 call	 check_num_args
  00025	85 c0		 test	 eax, eax
  00027	75 12		 jne	 SHORT $LN2@wrap_delit
$LN9@wrap_delit:

; 4644 :         return NULL;

  00029	33 c0		 xor	 eax, eax

; 4650 :     return Py_None;
; 4651 : }

  0002b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00030	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00035	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00039	5f		 pop	 rdi
  0003a	c3		 ret	 0
$LN2@wrap_delit:

; 4645 :     key = PyTuple_GET_ITEM(args, 0);
; 4646 :     res = (*func)(self, key, NULL);

  0003b	48 8b 53 70	 mov	 rdx, QWORD PTR [rbx+112]
  0003f	45 33 c0	 xor	 r8d, r8d
  00042	48 8b ce	 mov	 rcx, rsi
  00045	ff d7		 call	 rdi

; 4647 :     if (res == -1 && PyErr_Occurred())

  00047	83 f8 ff	 cmp	 eax, -1
  0004a	75 0a		 jne	 SHORT $LN1@wrap_delit
  0004c	e8 00 00 00 00	 call	 PyErr_Occurred
  00051	48 85 c0	 test	 rax, rax

; 4648 :         return NULL;

  00054	75 d3		 jne	 SHORT $LN9@wrap_delit
$LN1@wrap_delit:

; 4649 :     Py_INCREF(Py_None);

  00056	e8 00 00 00 00	 call	 _Py_PXCTX
  0005b	85 c0		 test	 eax, eax
  0005d	75 3c		 jne	 SHORT $LN6@wrap_delit
  0005f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00074	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0007a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00082	e8 00 00 00 00	 call	 _PyParallel_Guard
  00087	85 c0		 test	 eax, eax
  00089	75 09		 jne	 SHORT $LN5@wrap_delit
  0008b	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00092	74 07		 je	 SHORT $LN6@wrap_delit
$LN5@wrap_delit:
  00094	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN6@wrap_delit:

; 4650 :     return Py_None;
; 4651 : }

  0009b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a0	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000a5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000ac	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b0	5f		 pop	 rdi
  000b1	c3		 ret	 0
wrap_delitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@HJHEGLIK@can?8t?5apply?5this?5?$CFs?5to?5?$CFs?5object@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$hackcheck DD imagerel hackcheck
	DD	imagerel hackcheck+90
	DD	imagerel $unwind$hackcheck
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$hackcheck DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CB@HJHEGLIK@can?8t?5apply?5this?5?$CFs?5to?5?$CFs?5object@
CONST	SEGMENT
??_C@_0CB@HJHEGLIK@can?8t?5apply?5this?5?$CFs?5to?5?$CFs?5object@ DB 'can'
	DB	'''t apply this %s to %s object', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT hackcheck
_TEXT	SEGMENT
self$ = 48
func$ = 56
what$ = 64
hackcheck PROC						; COMDAT

; 4657 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4658 :     PyTypeObject *type = Py_TYPE(self);

  00004	4c 8b 49 58	 mov	 r9, QWORD PTR [rcx+88]

; 4659 :     while (type && type->tp_flags & Py_TPFLAGS_HEAPTYPE)

  00008	4d 85 c9	 test	 r9, r9
  0000b	74 1c		 je	 SHORT $LN1@hackcheck
  0000d	0f 1f 00	 npad	 3
$LL3@hackcheck:
  00010	41 f7 81 00 01
	00 00 00 02 00
	00		 test	 DWORD PTR [r9+256], 512	; 00000200H
  0001b	74 16		 je	 SHORT $LN2@hackcheck

; 4660 :         type = type->tp_base;

  0001d	4d 8b 89 58 01
	00 00		 mov	 r9, QWORD PTR [r9+344]
  00024	4d 85 c9	 test	 r9, r9
  00027	75 e7		 jne	 SHORT $LL3@hackcheck
$LN1@hackcheck:

; 4669 :     }
; 4670 :     return 1;

  00029	b8 01 00 00 00	 mov	 eax, 1

; 4671 : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
$LN2@hackcheck:

; 4661 :     /* If type is NULL now, this is a really weird type.
; 4662 :        In the spirit of backwards compatibility (?), just shut up. */
; 4663 :     if (type && type->tp_setattro != func) {

  00033	49 39 91 f0 00
	00 00		 cmp	 QWORD PTR [r9+240], rdx
  0003a	74 ed		 je	 SHORT $LN1@hackcheck

; 4664 :         PyErr_Format(PyExc_TypeError,
; 4665 :                      "can't apply this %s to %s object",
; 4666 :                      what,
; 4667 :                      type->tp_name);

  0003c	4d 8b 49 70	 mov	 r9, QWORD PTR [r9+112]
  00040	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@HJHEGLIK@can?8t?5apply?5this?5?$CFs?5to?5?$CFs?5object@
  0004e	e8 00 00 00 00	 call	 PyErr_Format

; 4668 :         return 0;

  00053	33 c0		 xor	 eax, eax

; 4671 : }

  00055	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00059	c3		 ret	 0
hackcheck ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$wrap_setattr DD imagerel wrap_setattr
	DD	imagerel wrap_setattr+208
	DD	imagerel $unwind$wrap_setattr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wrap_setattr DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT wrap_setattr
_TEXT	SEGMENT
self$ = 64
args$ = 72
value$ = 80
wrapped$ = 80
name$ = 88
wrap_setattr PROC					; COMDAT

; 4675 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	48 8b c2	 mov	 rax, rdx

; 4676 :     setattrofunc func = (setattrofunc)wrapped;
; 4677 :     int res;
; 4678 :     PyObject *name, *value;
; 4679 : 
; 4680 :     if (!PyArg_UnpackTuple(args, "", 2, 2, &name, &value))

  00010	48 8d 4c 24 50	 lea	 rcx, QWORD PTR value$[rsp]
  00015	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0001a	48 8d 4c 24 58	 lea	 rcx, QWORD PTR name$[rsp]
  0001f	41 b9 02 00 00
	00		 mov	 r9d, 2
  00025	49 8b d8	 mov	 rbx, r8
  00028	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00034	48 8b c8	 mov	 rcx, rax
  00037	45 8b c1	 mov	 r8d, r9d
  0003a	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0003f	85 c0		 test	 eax, eax
  00041	75 0d		 jne	 SHORT $LN3@wrap_setat
$LN10@wrap_setat:

; 4681 :         return NULL;

  00043	33 c0		 xor	 eax, eax

; 4689 : }

  00045	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0004a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004e	5f		 pop	 rdi
  0004f	c3		 ret	 0
$LN3@wrap_setat:

; 4682 :     if (!hackcheck(self, func, "__setattr__"))

  00050	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0M@CIMGLOJN@__setattr__?$AA@
  00057	48 8b d3	 mov	 rdx, rbx
  0005a	48 8b cf	 mov	 rcx, rdi
  0005d	e8 00 00 00 00	 call	 hackcheck
  00062	85 c0		 test	 eax, eax

; 4683 :         return NULL;

  00064	74 dd		 je	 SHORT $LN10@wrap_setat

; 4684 :     res = (*func)(self, name, value);

  00066	4c 8b 44 24 50	 mov	 r8, QWORD PTR value$[rsp]
  0006b	48 8b 54 24 58	 mov	 rdx, QWORD PTR name$[rsp]
  00070	48 8b cf	 mov	 rcx, rdi
  00073	ff d3		 call	 rbx

; 4685 :     if (res < 0)

  00075	85 c0		 test	 eax, eax

; 4686 :         return NULL;

  00077	78 ca		 js	 SHORT $LN10@wrap_setat

; 4687 :     Py_INCREF(Py_None);

  00079	e8 00 00 00 00	 call	 _Py_PXCTX
  0007e	85 c0		 test	 eax, eax
  00080	75 3c		 jne	 SHORT $LN7@wrap_setat
  00082	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00089	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00090	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00097	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0009d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000a5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000aa	85 c0		 test	 eax, eax
  000ac	75 09		 jne	 SHORT $LN6@wrap_setat
  000ae	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000b5	74 07		 je	 SHORT $LN7@wrap_setat
$LN6@wrap_setat:
  000b7	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN7@wrap_setat:

; 4688 :     return Py_None;

  000be	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 4689 : }

  000c5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ca	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ce	5f		 pop	 rdi
  000cf	c3		 ret	 0
wrap_setattr ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$wrap_delattr DD imagerel wrap_delattr
	DD	imagerel wrap_delattr+192
	DD	imagerel $unwind$wrap_delattr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wrap_delattr DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT wrap_delattr
_TEXT	SEGMENT
self$ = 64
args$ = 72
wrapped$ = 80
wrap_delattr PROC					; COMDAT

; 4693 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b f2	 mov	 rsi, rdx
  00012	48 8b f9	 mov	 rdi, rcx

; 4694 :     setattrofunc func = (setattrofunc)wrapped;
; 4695 :     int res;
; 4696 :     PyObject *name;
; 4697 : 
; 4698 :     if (!check_num_args(args, 1))

  00015	ba 01 00 00 00	 mov	 edx, 1
  0001a	48 8b ce	 mov	 rcx, rsi
  0001d	49 8b d8	 mov	 rbx, r8
  00020	e8 00 00 00 00	 call	 check_num_args
  00025	85 c0		 test	 eax, eax
  00027	75 12		 jne	 SHORT $LN3@wrap_delat
$LN10@wrap_delat:

; 4699 :         return NULL;

  00029	33 c0		 xor	 eax, eax

; 4707 :     return Py_None;
; 4708 : }

  0002b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00030	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00035	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00039	5f		 pop	 rdi
  0003a	c3		 ret	 0
$LN3@wrap_delat:

; 4700 :     name = PyTuple_GET_ITEM(args, 0);

  0003b	48 8b 76 70	 mov	 rsi, QWORD PTR [rsi+112]

; 4701 :     if (!hackcheck(self, func, "__delattr__"))

  0003f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0M@ECOKAOJC@__delattr__?$AA@
  00046	48 8b d3	 mov	 rdx, rbx
  00049	48 8b cf	 mov	 rcx, rdi
  0004c	e8 00 00 00 00	 call	 hackcheck
  00051	85 c0		 test	 eax, eax

; 4702 :         return NULL;

  00053	74 d4		 je	 SHORT $LN10@wrap_delat

; 4703 :     res = (*func)(self, name, NULL);

  00055	45 33 c0	 xor	 r8d, r8d
  00058	48 8b d6	 mov	 rdx, rsi
  0005b	48 8b cf	 mov	 rcx, rdi
  0005e	ff d3		 call	 rbx

; 4704 :     if (res < 0)

  00060	85 c0		 test	 eax, eax

; 4705 :         return NULL;

  00062	78 c5		 js	 SHORT $LN10@wrap_delat

; 4706 :     Py_INCREF(Py_None);

  00064	e8 00 00 00 00	 call	 _Py_PXCTX
  00069	85 c0		 test	 eax, eax
  0006b	75 3c		 jne	 SHORT $LN7@wrap_delat
  0006d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00082	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00088	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00090	e8 00 00 00 00	 call	 _PyParallel_Guard
  00095	85 c0		 test	 eax, eax
  00097	75 09		 jne	 SHORT $LN6@wrap_delat
  00099	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000a0	74 07		 je	 SHORT $LN7@wrap_delat
$LN6@wrap_delat:
  000a2	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN7@wrap_delat:

; 4707 :     return Py_None;
; 4708 : }

  000a9	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ae	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000b3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000ba	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000be	5f		 pop	 rdi
  000bf	c3		 ret	 0
wrap_delattr ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$wrap_hashfunc DD imagerel wrap_hashfunc
	DD	imagerel wrap_hashfunc+88
	DD	imagerel $unwind$wrap_hashfunc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wrap_hashfunc DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT wrap_hashfunc
_TEXT	SEGMENT
self$ = 48
args$ = 56
wrapped$ = 64
wrap_hashfunc PROC					; COMDAT

; 4712 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b c2	 mov	 rax, rdx
  0000d	48 8b f9	 mov	 rdi, rcx

; 4713 :     hashfunc func = (hashfunc)wrapped;
; 4714 :     Py_hash_t res;
; 4715 : 
; 4716 :     if (!check_num_args(args, 0))

  00010	33 d2		 xor	 edx, edx
  00012	48 8b c8	 mov	 rcx, rax
  00015	49 8b d8	 mov	 rbx, r8
  00018	e8 00 00 00 00	 call	 check_num_args
  0001d	85 c0		 test	 eax, eax
  0001f	75 0d		 jne	 SHORT $LN2@wrap_hashf
$LN5@wrap_hashf:

; 4717 :         return NULL;

  00021	33 c0		 xor	 eax, eax

; 4722 : }

  00023	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5f		 pop	 rdi
  0002d	c3		 ret	 0
$LN2@wrap_hashf:

; 4718 :     res = (*func)(self);

  0002e	48 8b cf	 mov	 rcx, rdi
  00031	ff d3		 call	 rbx
  00033	48 8b d8	 mov	 rbx, rax

; 4719 :     if (res == -1 && PyErr_Occurred())

  00036	48 83 f8 ff	 cmp	 rax, -1
  0003a	75 0a		 jne	 SHORT $LN1@wrap_hashf
  0003c	e8 00 00 00 00	 call	 PyErr_Occurred
  00041	48 85 c0	 test	 rax, rax

; 4720 :         return NULL;

  00044	75 db		 jne	 SHORT $LN5@wrap_hashf
$LN1@wrap_hashf:

; 4721 :     return PyLong_FromSsize_t(res);

  00046	48 8b cb	 mov	 rcx, rbx

; 4722 : }

  00049	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00052	5f		 pop	 rdi
  00053	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
wrap_hashfunc ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT wrap_call
_TEXT	SEGMENT
self$ = 8
args$ = 16
wrapped$ = 24
kwds$ = 32
wrap_call PROC						; COMDAT

; 4726 : {

  00000	49 8b c0	 mov	 rax, r8

; 4727 :     ternaryfunc func = (ternaryfunc)wrapped;
; 4728 : 
; 4729 :     return (*func)(self, args, kwds);

  00003	4d 8b c1	 mov	 r8, r9

; 4730 : }

  00006	48 ff e0	 rex_jmp rax
wrap_call ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$wrap_richcmpfunc DD imagerel wrap_richcmpfunc
	DD	imagerel wrap_richcmpfunc+86
	DD	imagerel $unwind$wrap_richcmpfunc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wrap_richcmpfunc DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT wrap_richcmpfunc
_TEXT	SEGMENT
self$ = 48
args$ = 56
wrapped$ = 64
op$ = 72
wrap_richcmpfunc PROC					; COMDAT

; 4734 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b da	 mov	 rbx, rdx
  00017	48 8b e9	 mov	 rbp, rcx

; 4735 :     richcmpfunc func = (richcmpfunc)wrapped;
; 4736 :     PyObject *other;
; 4737 : 
; 4738 :     if (!check_num_args(args, 1))

  0001a	ba 01 00 00 00	 mov	 edx, 1
  0001f	48 8b cb	 mov	 rcx, rbx
  00022	41 8b f9	 mov	 edi, r9d
  00025	49 8b f0	 mov	 rsi, r8
  00028	e8 00 00 00 00	 call	 check_num_args
  0002d	85 c0		 test	 eax, eax
  0002f	75 04		 jne	 SHORT $LN1@wrap_richc

; 4739 :         return NULL;

  00031	33 c0		 xor	 eax, eax
  00033	eb 0c		 jmp	 SHORT $LN2@wrap_richc
$LN1@wrap_richc:

; 4740 :     other = PyTuple_GET_ITEM(args, 0);
; 4741 :     return (*func)(self, other, op);

  00035	48 8b 53 70	 mov	 rdx, QWORD PTR [rbx+112]
  00039	44 8b c7	 mov	 r8d, edi
  0003c	48 8b cd	 mov	 rcx, rbp
  0003f	ff d6		 call	 rsi
$LN2@wrap_richc:

; 4742 : }

  00041	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00046	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0004b	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00050	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00054	5f		 pop	 rdi
  00055	c3		 ret	 0
wrap_richcmpfunc ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT richcmp_lt
_TEXT	SEGMENT
self$ = 8
args$ = 16
wrapped$ = 24
richcmp_lt PROC						; COMDAT

; 4752 : RICHCMP_WRAPPER(lt, Py_LT)

  00000	45 33 c9	 xor	 r9d, r9d
  00003	e9 00 00 00 00	 jmp	 wrap_richcmpfunc
richcmp_lt ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT richcmp_le
_TEXT	SEGMENT
self$ = 8
args$ = 16
wrapped$ = 24
richcmp_le PROC						; COMDAT

; 4753 : RICHCMP_WRAPPER(le, Py_LE)

  00000	41 b9 01 00 00
	00		 mov	 r9d, 1
  00006	e9 00 00 00 00	 jmp	 wrap_richcmpfunc
richcmp_le ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT richcmp_eq
_TEXT	SEGMENT
self$ = 8
args$ = 16
wrapped$ = 24
richcmp_eq PROC						; COMDAT

; 4754 : RICHCMP_WRAPPER(eq, Py_EQ)

  00000	41 b9 02 00 00
	00		 mov	 r9d, 2
  00006	e9 00 00 00 00	 jmp	 wrap_richcmpfunc
richcmp_eq ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT richcmp_ne
_TEXT	SEGMENT
self$ = 8
args$ = 16
wrapped$ = 24
richcmp_ne PROC						; COMDAT

; 4755 : RICHCMP_WRAPPER(ne, Py_NE)

  00000	41 b9 03 00 00
	00		 mov	 r9d, 3
  00006	e9 00 00 00 00	 jmp	 wrap_richcmpfunc
richcmp_ne ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT richcmp_gt
_TEXT	SEGMENT
self$ = 8
args$ = 16
wrapped$ = 24
richcmp_gt PROC						; COMDAT

; 4756 : RICHCMP_WRAPPER(gt, Py_GT)

  00000	41 b9 04 00 00
	00		 mov	 r9d, 4
  00006	e9 00 00 00 00	 jmp	 wrap_richcmpfunc
richcmp_gt ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT richcmp_ge
_TEXT	SEGMENT
self$ = 8
args$ = 16
wrapped$ = 24
richcmp_ge PROC						; COMDAT

; 4757 : RICHCMP_WRAPPER(ge, Py_GE)

  00000	41 b9 05 00 00
	00		 mov	 r9d, 5
  00006	e9 00 00 00 00	 jmp	 wrap_richcmpfunc
richcmp_ge ENDP
_TEXT	ENDS
EXTRN	PyErr_SetNone:PROC
EXTRN	PyExc_StopIteration:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$wrap_next DD imagerel wrap_next
	DD	imagerel wrap_next+95
	DD	imagerel $unwind$wrap_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wrap_next DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT wrap_next
_TEXT	SEGMENT
self$ = 48
args$ = 56
wrapped$ = 64
wrap_next PROC						; COMDAT

; 4761 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b c2	 mov	 rax, rdx
  0000d	48 8b f9	 mov	 rdi, rcx

; 4762 :     unaryfunc func = (unaryfunc)wrapped;
; 4763 :     PyObject *res;
; 4764 : 
; 4765 :     if (!check_num_args(args, 0))

  00010	33 d2		 xor	 edx, edx
  00012	48 8b c8	 mov	 rcx, rax
  00015	49 8b d8	 mov	 rbx, r8
  00018	e8 00 00 00 00	 call	 check_num_args
  0001d	85 c0		 test	 eax, eax
  0001f	75 0d		 jne	 SHORT $LN2@wrap_next

; 4766 :         return NULL;

  00021	33 c0		 xor	 eax, eax

; 4771 : }

  00023	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5f		 pop	 rdi
  0002d	c3		 ret	 0
$LN2@wrap_next:

; 4767 :     res = (*func)(self);

  0002e	48 8b cf	 mov	 rcx, rdi
  00031	ff d3		 call	 rbx
  00033	48 8b d8	 mov	 rbx, rax

; 4768 :     if (res == NULL && !PyErr_Occurred())

  00036	48 85 c0	 test	 rax, rax
  00039	75 16		 jne	 SHORT $LN1@wrap_next
  0003b	e8 00 00 00 00	 call	 PyErr_Occurred
  00040	48 85 c0	 test	 rax, rax
  00043	75 0c		 jne	 SHORT $LN1@wrap_next

; 4769 :         PyErr_SetNone(PyExc_StopIteration);

  00045	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_StopIteration
  0004c	e8 00 00 00 00	 call	 PyErr_SetNone
$LN1@wrap_next:

; 4770 :     return res;

  00051	48 8b c3	 mov	 rax, rbx

; 4771 : }

  00054	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00059	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005d	5f		 pop	 rdi
  0005e	c3		 ret	 0
wrap_next ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@LLJHLDPJ@__get__?$CINone?0?5None?$CJ?5is?5invalid?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$wrap_descr_get DD imagerel wrap_descr_get
	DD	imagerel wrap_descr_get+186
	DD	imagerel $unwind$wrap_descr_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wrap_descr_get DD 061001H
	DD	096410H
	DD	083410H
	DD	0700c5210H
xdata	ENDS
;	COMDAT ??_C@_0BP@LLJHLDPJ@__get__?$CINone?0?5None?$CJ?5is?5invalid?$AA@
CONST	SEGMENT
??_C@_0BP@LLJHLDPJ@__get__?$CINone?0?5None?$CJ?5is?5invalid?$AA@ DB '__ge'
	DB	't__(None, None) is invalid', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT wrap_descr_get
_TEXT	SEGMENT
self$ = 64
args$ = 72
type$ = 80
wrapped$ = 80
obj$ = 88
wrap_descr_get PROC					; COMDAT

; 4775 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 08	 mov	 QWORD PTR [r11+8], rbx
  00007	49 89 73 10	 mov	 QWORD PTR [r11+16], rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00010	48 8b f9	 mov	 rdi, rcx

; 4776 :     descrgetfunc func = (descrgetfunc)wrapped;
; 4777 :     PyObject *obj;
; 4778 :     PyObject *type = NULL;
; 4779 : 
; 4780 :     if (!PyArg_UnpackTuple(args, "", 1, 2, &obj, &type))

  00013	49 8d 4b 18	 lea	 rcx, QWORD PTR [r11+24]
  00017	33 f6		 xor	 esi, esi
  00019	49 89 4b f0	 mov	 QWORD PTR [r11-16], rcx
  0001d	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  00021	48 8b c2	 mov	 rax, rdx
  00024	49 8b d8	 mov	 rbx, r8
  00027	49 89 4b e8	 mov	 QWORD PTR [r11-24], rcx
  0002b	44 8d 4e 02	 lea	 r9d, QWORD PTR [rsi+2]
  0002f	44 8d 46 01	 lea	 r8d, QWORD PTR [rsi+1]
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	49 89 73 18	 mov	 QWORD PTR [r11+24], rsi
  00041	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  00046	85 c0		 test	 eax, eax

; 4781 :         return NULL;

  00048	74 49		 je	 SHORT $LN8@wrap_descr

; 4782 :     if (obj == Py_None)

  0004a	48 8b 54 24 58	 mov	 rdx, QWORD PTR obj$[rsp]

; 4783 :         obj = NULL;
; 4784 :     if (type == Py_None)

  0004f	4c 8b 44 24 50	 mov	 r8, QWORD PTR type$[rsp]
  00054	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0005b	48 3b d0	 cmp	 rdx, rax
  0005e	48 0f 44 d6	 cmove	 rdx, rsi
  00062	48 89 54 24 58	 mov	 QWORD PTR obj$[rsp], rdx
  00067	4c 3b c0	 cmp	 r8, rax
  0006a	75 0a		 jne	 SHORT $LN2@wrap_descr

; 4785 :         type = NULL;

  0006c	44 8b c6	 mov	 r8d, esi
  0006f	48 89 74 24 50	 mov	 QWORD PTR type$[rsp], rsi

; 4786 :     if (type == NULL &&obj == NULL) {

  00074	eb 05		 jmp	 SHORT $LN7@wrap_descr
$LN2@wrap_descr:
  00076	4d 85 c0	 test	 r8, r8
  00079	75 2a		 jne	 SHORT $LN1@wrap_descr
$LN7@wrap_descr:
  0007b	48 85 d2	 test	 rdx, rdx
  0007e	75 25		 jne	 SHORT $LN1@wrap_descr

; 4787 :         PyErr_SetString(PyExc_TypeError,
; 4788 :                         "__get__(None, None) is invalid");

  00080	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00087	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@LLJHLDPJ@__get__?$CINone?0?5None?$CJ?5is?5invalid?$AA@
  0008e	e8 00 00 00 00	 call	 PyErr_SetString
$LN8@wrap_descr:

; 4789 :         return NULL;

  00093	33 c0		 xor	 eax, eax

; 4792 : }

  00095	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0009a	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0009f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a3	5f		 pop	 rdi
  000a4	c3		 ret	 0
$LN1@wrap_descr:

; 4790 :     }
; 4791 :     return (*func)(self, obj, type);

  000a5	48 8b cf	 mov	 rcx, rdi
  000a8	ff d3		 call	 rbx

; 4792 : }

  000aa	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000af	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000b4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b8	5f		 pop	 rdi
  000b9	c3		 ret	 0
wrap_descr_get ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$wrap_descr_set DD imagerel wrap_descr_set
	DD	imagerel wrap_descr_set+186
	DD	imagerel $unwind$wrap_descr_set
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wrap_descr_set DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT wrap_descr_set
_TEXT	SEGMENT
self$ = 64
args$ = 72
value$ = 80
wrapped$ = 80
obj$ = 88
wrap_descr_set PROC					; COMDAT

; 4796 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	48 8b c2	 mov	 rax, rdx

; 4797 :     descrsetfunc func = (descrsetfunc)wrapped;
; 4798 :     PyObject *obj, *value;
; 4799 :     int ret;
; 4800 : 
; 4801 :     if (!PyArg_UnpackTuple(args, "", 2, 2, &obj, &value))

  00010	48 8d 4c 24 50	 lea	 rcx, QWORD PTR value$[rsp]
  00015	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0001a	48 8d 4c 24 58	 lea	 rcx, QWORD PTR obj$[rsp]
  0001f	41 b9 02 00 00
	00		 mov	 r9d, 2
  00025	49 8b d8	 mov	 rbx, r8
  00028	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00034	48 8b c8	 mov	 rcx, rax
  00037	45 8b c1	 mov	 r8d, r9d
  0003a	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0003f	85 c0		 test	 eax, eax
  00041	75 0d		 jne	 SHORT $LN2@wrap_descr@2
$LN9@wrap_descr@2:

; 4802 :         return NULL;

  00043	33 c0		 xor	 eax, eax

; 4808 : }

  00045	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0004a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004e	5f		 pop	 rdi
  0004f	c3		 ret	 0
$LN2@wrap_descr@2:

; 4803 :     ret = (*func)(self, obj, value);

  00050	4c 8b 44 24 50	 mov	 r8, QWORD PTR value$[rsp]
  00055	48 8b 54 24 58	 mov	 rdx, QWORD PTR obj$[rsp]
  0005a	48 8b cf	 mov	 rcx, rdi
  0005d	ff d3		 call	 rbx

; 4804 :     if (ret < 0)

  0005f	85 c0		 test	 eax, eax

; 4805 :         return NULL;

  00061	78 e0		 js	 SHORT $LN9@wrap_descr@2

; 4806 :     Py_INCREF(Py_None);

  00063	e8 00 00 00 00	 call	 _Py_PXCTX
  00068	85 c0		 test	 eax, eax
  0006a	75 3c		 jne	 SHORT $LN6@wrap_descr@2
  0006c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00081	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00087	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00094	85 c0		 test	 eax, eax
  00096	75 09		 jne	 SHORT $LN5@wrap_descr@2
  00098	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0009f	74 07		 je	 SHORT $LN6@wrap_descr@2
$LN5@wrap_descr@2:
  000a1	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN6@wrap_descr@2:

; 4807 :     return Py_None;

  000a8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 4808 : }

  000af	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b8	5f		 pop	 rdi
  000b9	c3		 ret	 0
wrap_descr_set ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$wrap_descr_delete DD imagerel wrap_descr_delete
	DD	imagerel wrap_descr_delete+167
	DD	imagerel $unwind$wrap_descr_delete
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wrap_descr_delete DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT wrap_descr_delete
_TEXT	SEGMENT
self$ = 64
args$ = 72
wrapped$ = 80
wrap_descr_delete PROC					; COMDAT

; 4812 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b da	 mov	 rbx, rdx
  00012	48 8b f1	 mov	 rsi, rcx

; 4813 :     descrsetfunc func = (descrsetfunc)wrapped;
; 4814 :     PyObject *obj;
; 4815 :     int ret;
; 4816 : 
; 4817 :     if (!check_num_args(args, 1))

  00015	ba 01 00 00 00	 mov	 edx, 1
  0001a	48 8b cb	 mov	 rcx, rbx
  0001d	49 8b f8	 mov	 rdi, r8
  00020	e8 00 00 00 00	 call	 check_num_args
  00025	85 c0		 test	 eax, eax
  00027	75 12		 jne	 SHORT $LN2@wrap_descr@3
$LN9@wrap_descr@3:

; 4818 :         return NULL;

  00029	33 c0		 xor	 eax, eax

; 4824 :     return Py_None;
; 4825 : }

  0002b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00030	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00035	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00039	5f		 pop	 rdi
  0003a	c3		 ret	 0
$LN2@wrap_descr@3:

; 4819 :     obj = PyTuple_GET_ITEM(args, 0);
; 4820 :     ret = (*func)(self, obj, NULL);

  0003b	48 8b 53 70	 mov	 rdx, QWORD PTR [rbx+112]
  0003f	45 33 c0	 xor	 r8d, r8d
  00042	48 8b ce	 mov	 rcx, rsi
  00045	ff d7		 call	 rdi

; 4821 :     if (ret < 0)

  00047	85 c0		 test	 eax, eax

; 4822 :         return NULL;

  00049	78 de		 js	 SHORT $LN9@wrap_descr@3

; 4823 :     Py_INCREF(Py_None);

  0004b	e8 00 00 00 00	 call	 _Py_PXCTX
  00050	85 c0		 test	 eax, eax
  00052	75 3c		 jne	 SHORT $LN6@wrap_descr@3
  00054	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00069	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0006f	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00077	e8 00 00 00 00	 call	 _PyParallel_Guard
  0007c	85 c0		 test	 eax, eax
  0007e	75 09		 jne	 SHORT $LN5@wrap_descr@3
  00080	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00087	74 07		 je	 SHORT $LN6@wrap_descr@3
$LN5@wrap_descr@3:
  00089	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN6@wrap_descr@3:

; 4824 :     return Py_None;
; 4825 : }

  00090	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00095	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0009a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000a1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a5	5f		 pop	 rdi
  000a6	c3		 ret	 0
wrap_descr_delete ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$wrap_init DD imagerel wrap_init
	DD	imagerel wrap_init+104
	DD	imagerel $unwind$wrap_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wrap_init DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT wrap_init
_TEXT	SEGMENT
self$ = 64
args$ = 72
wrapped$ = 80
kwds$ = 88
wrap_init PROC						; COMDAT

; 4829 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	49 8b c0	 mov	 rax, r8

; 4830 :     initproc func = (initproc)wrapped;
; 4831 : 
; 4832 :     if (func(self, args, kwds) < 0)

  00007	4d 8b c1	 mov	 r8, r9
  0000a	ff d0		 call	 rax
  0000c	85 c0		 test	 eax, eax
  0000e	79 07		 jns	 SHORT $LN1@wrap_init

; 4833 :         return NULL;

  00010	33 c0		 xor	 eax, eax

; 4836 : }

  00012	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00016	c3		 ret	 0
$LN1@wrap_init:

; 4834 :     Py_INCREF(Py_None);

  00017	e8 00 00 00 00	 call	 _Py_PXCTX
  0001c	85 c0		 test	 eax, eax
  0001e	75 3c		 jne	 SHORT $LN5@wrap_init
  00020	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00035	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0003b	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00043	e8 00 00 00 00	 call	 _PyParallel_Guard
  00048	85 c0		 test	 eax, eax
  0004a	75 09		 jne	 SHORT $LN4@wrap_init
  0004c	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00053	74 07		 je	 SHORT $LN5@wrap_init
$LN4@wrap_init:
  00055	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN5@wrap_init:

; 4835 :     return Py_None;

  0005c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 4836 : }

  00063	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00067	c3		 ret	 0
wrap_init ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_tp_new_wrapper DD imagerel add_tp_new_wrapper
	DD	imagerel add_tp_new_wrapper+86
	DD	imagerel $unwind$add_tp_new_wrapper
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$add_tp_new_wrapper DD imagerel add_tp_new_wrapper+86
	DD	imagerel add_tp_new_wrapper+153
	DD	imagerel $chain$0$add_tp_new_wrapper
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$add_tp_new_wrapper DD imagerel add_tp_new_wrapper+153
	DD	imagerel add_tp_new_wrapper+176
	DD	imagerel $chain$2$add_tp_new_wrapper
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$add_tp_new_wrapper DD 020021H
	DD	063400H
	DD	imagerel add_tp_new_wrapper
	DD	imagerel add_tp_new_wrapper+86
	DD	imagerel $unwind$add_tp_new_wrapper
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$add_tp_new_wrapper DD 020521H
	DD	063405H
	DD	imagerel add_tp_new_wrapper
	DD	imagerel add_tp_new_wrapper+86
	DD	imagerel $unwind$add_tp_new_wrapper
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_tp_new_wrapper DD 040a01H
	DD	07640aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT add_tp_new_wrapper
_TEXT	SEGMENT
type$ = 48
add_tp_new_wrapper PROC					; COMDAT

; 4906 : {

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4907 :     PyObject *func;
; 4908 : 
; 4909 :     if (_PyDict_GetItemId(type->tp_dict, &PyId___new__) != NULL)

  0000a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00010	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00019	48 8b f9	 mov	 rdi, rcx
  0001c	48 8b 34 d0	 mov	 rsi, QWORD PTR [rax+rdx*8]
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:PyId___new__
  00025	48 03 f1	 add	 rsi, rcx
  00028	48 8b 8f 60 01
	00 00		 mov	 rcx, QWORD PTR [rdi+352]
  0002f	48 8b d6	 mov	 rdx, rsi
  00032	e8 00 00 00 00	 call	 _PyDict_GetItemId
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0d		 je	 SHORT $LN3@add_tp_new

; 4910 :         return 0;

  0003c	33 c0		 xor	 eax, eax

; 4919 :     return 0;
; 4920 : }

  0003e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5f		 pop	 rdi
  00048	c3		 ret	 0
$LN3@add_tp_new:

; 4911 :     func = PyCFunction_New(tp_new_methoddef, (PyObject *)type);

  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tp_new_methoddef
  00050	45 33 c0	 xor	 r8d, r8d
  00053	48 8b d7	 mov	 rdx, rdi
  00056	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0005b	e8 00 00 00 00	 call	 PyCFunction_NewEx
  00060	48 8b d8	 mov	 rbx, rax

; 4912 :     if (func == NULL)

  00063	48 85 c0	 test	 rax, rax

; 4913 :         return -1;

  00066	74 1e		 je	 SHORT $LN7@add_tp_new

; 4914 :     if (_PyDict_SetItemId(type->tp_dict, &PyId___new__, func)) {

  00068	48 8b 8f 60 01
	00 00		 mov	 rcx, QWORD PTR [rdi+352]
  0006f	4c 8b c0	 mov	 r8, rax
  00072	48 8b d6	 mov	 rdx, rsi
  00075	e8 00 00 00 00	 call	 _PyDict_SetItemId

; 4915 :         Py_DECREF(func);

  0007a	48 8b cb	 mov	 rcx, rbx
  0007d	85 c0		 test	 eax, eax
  0007f	74 18		 je	 SHORT $LN1@add_tp_new
  00081	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@add_tp_new:

; 4916 :         return -1;

  00086	83 c8 ff	 or	 eax, -1
  00089	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 4919 :     return 0;
; 4920 : }

  0008e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00093	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00097	5f		 pop	 rdi
  00098	c3		 ret	 0
$LN1@add_tp_new:

; 4917 :     }
; 4918 :     Py_DECREF(func);

  00099	e8 00 00 00 00	 call	 _Py_DecRef
  0009e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 4919 :     return 0;
; 4920 : }

  000a3	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000a8	33 c0		 xor	 eax, eax
  000aa	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ae	5f		 pop	 rdi
  000af	c3		 ret	 0
add_tp_new_wrapper ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$method_is_overloaded DD imagerel method_is_overloaded
	DD	imagerel method_is_overloaded+176
	DD	imagerel $unwind$method_is_overloaded
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$method_is_overloaded DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT method_is_overloaded
_TEXT	SEGMENT
left$ = 48
right$ = 56
name$ = 64
method_is_overloaded PROC				; COMDAT

; 4945 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b c2	 mov	 rax, rdx
  00012	48 8b f1	 mov	 rsi, rcx

; 4946 :     PyObject *a, *b;
; 4947 :     int ok;
; 4948 : 
; 4949 :     b = _PyObject_GetAttrId((PyObject *)(Py_TYPE(right)), name);

  00015	49 8b d0	 mov	 rdx, r8
  00018	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0001c	49 8b f8	 mov	 rdi, r8
  0001f	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00024	48 8b d8	 mov	 rbx, rax

; 4950 :     if (b == NULL) {

  00027	48 85 c0	 test	 rax, rax
  0002a	75 17		 jne	 SHORT $LN3@method_is_
$LN6@method_is_:

; 4951 :         PyErr_Clear();

  0002c	e8 00 00 00 00	 call	 PyErr_Clear

; 4952 :         /* If right doesn't have it, it's not overloaded */
; 4953 :         return 0;

  00031	33 c0		 xor	 eax, eax

; 4970 :     }
; 4971 : 
; 4972 :     return ok;
; 4973 : }

  00033	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00038	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
$LN3@method_is_:

; 4954 :     }
; 4955 : 
; 4956 :     a = _PyObject_GetAttrId((PyObject *)(Py_TYPE(left)), name);

  00043	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  00047	48 8b d7	 mov	 rdx, rdi
  0004a	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  0004f	48 8b f0	 mov	 rsi, rax

; 4957 :     if (a == NULL) {

  00052	48 85 c0	 test	 rax, rax
  00055	75 20		 jne	 SHORT $LN2@method_is_

; 4958 :         PyErr_Clear();

  00057	e8 00 00 00 00	 call	 PyErr_Clear

; 4959 :         Py_DECREF(b);

  0005c	48 8b cb	 mov	 rcx, rbx
  0005f	e8 00 00 00 00	 call	 _Py_DecRef

; 4960 :         /* If right has it but left doesn't, it's overloaded */
; 4961 :         return 1;

  00064	8d 46 01	 lea	 eax, QWORD PTR [rsi+1]

; 4970 :     }
; 4971 : 
; 4972 :     return ok;
; 4973 : }

  00067	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006c	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00071	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00075	5f		 pop	 rdi
  00076	c3		 ret	 0
$LN2@method_is_:

; 4962 :     }
; 4963 : 
; 4964 :     ok = PyObject_RichCompareBool(a, b, Py_NE);

  00077	41 b8 03 00 00
	00		 mov	 r8d, 3
  0007d	48 8b d3	 mov	 rdx, rbx
  00080	48 8b c8	 mov	 rcx, rax
  00083	e8 00 00 00 00	 call	 PyObject_RichCompareBool

; 4965 :     Py_DECREF(a);

  00088	48 8b ce	 mov	 rcx, rsi
  0008b	8b f8		 mov	 edi, eax
  0008d	e8 00 00 00 00	 call	 _Py_DecRef

; 4966 :     Py_DECREF(b);

  00092	48 8b cb	 mov	 rcx, rbx
  00095	e8 00 00 00 00	 call	 _Py_DecRef

; 4967 :     if (ok < 0) {

  0009a	85 ff		 test	 edi, edi

; 4968 :         PyErr_Clear();
; 4969 :         return 0;

  0009c	78 8e		 js	 SHORT $LN6@method_is_

; 4970 :     }
; 4971 : 
; 4972 :     return ok;
; 4973 : }

  0009e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a3	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000a8	8b c7		 mov	 eax, edi
  000aa	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ae	5f		 pop	 rdi
  000af	c3		 ret	 0
method_is_overloaded ENDP
_TEXT	ENDS
EXTRN	PyErr_SetObject:PROC
EXTRN	PyObject_Call:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$slot_sq_item DD imagerel slot_sq_item
	DD	imagerel slot_sq_item+522
	DD	imagerel $unwind$slot_sq_item
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_sq_item DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT slot_sq_item
_TEXT	SEGMENT
self$ = 64
i$ = 72
slot_sq_item PROC					; COMDAT

; 5044 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 5045 :     PyObject *func, *args = NULL, *ival = NULL, *retval = NULL;
; 5046 :     descrgetfunc f;
; 5047 : 
; 5048 :     func = _PyType_LookupId(Py_TYPE(self), &PyId___getitem__);

  00014	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0001b	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00024	48 8b f1	 mov	 rsi, rcx
  00027	4a 8b 3c c0	 mov	 rdi, QWORD PTR [rax+r8*8]
  0002b	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:PyId___getitem__
  00030	48 8b ea	 mov	 rbp, rdx
  00033	48 03 f9	 add	 rdi, rcx
  00036	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  0003a	48 8b d7	 mov	 rdx, rdi
  0003d	e8 00 00 00 00	 call	 _PyType_LookupId
  00042	48 8b d8	 mov	 rbx, rax

; 5049 :     if (func != NULL) {

  00045	48 85 c0	 test	 rax, rax
  00048	0f 84 8e 01 00
	00		 je	 $LN27@slot_sq_it

; 5050 :         if ((f = Py_TYPE(func)->tp_descr_get) == NULL)

  0004e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00052	48 8b 81 68 01
	00 00		 mov	 rax, QWORD PTR [rcx+360]
  00059	48 85 c0	 test	 rax, rax
  0005c	75 3d		 jne	 SHORT $LN26@slot_sq_it

; 5051 :             Py_INCREF(func);

  0005e	e8 00 00 00 00	 call	 _Py_PXCTX
  00063	85 c0		 test	 eax, eax
  00065	75 4c		 jne	 SHORT $LN24@slot_sq_it
  00067	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0006e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00075	4c 8b cb	 mov	 r9, rbx
  00078	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0007e	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00086	e8 00 00 00 00	 call	 _PyParallel_Guard
  0008b	85 c0		 test	 eax, eax
  0008d	75 06		 jne	 SHORT $LN30@slot_sq_it
  0008f	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00093	74 1e		 je	 SHORT $LN24@slot_sq_it
$LN30@slot_sq_it:
  00095	48 ff 43 50	 inc	 QWORD PTR [rbx+80]

; 5052 :         else {

  00099	eb 18		 jmp	 SHORT $LN24@slot_sq_it
$LN26@slot_sq_it:

; 5053 :             func = f(func, self, (PyObject *)(Py_TYPE(self)));

  0009b	4c 8b 46 58	 mov	 r8, QWORD PTR [rsi+88]
  0009f	48 8b d6	 mov	 rdx, rsi
  000a2	48 8b cb	 mov	 rcx, rbx
  000a5	ff d0		 call	 rax
  000a7	48 8b d8	 mov	 rbx, rax

; 5054 :             if (func == NULL) {

  000aa	48 85 c0	 test	 rax, rax

; 5055 :                 return NULL;

  000ad	0f 84 40 01 00
	00		 je	 $LN3@slot_sq_it
$LN24@slot_sq_it:

; 5056 :             }
; 5057 :         }
; 5058 :         ival = PyLong_FromSsize_t(i);

  000b3	48 8b cd	 mov	 rcx, rbp
  000b6	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  000bb	48 8b f8	 mov	 rdi, rax

; 5059 :         if (ival != NULL) {

  000be	48 85 c0	 test	 rax, rax
  000c1	0f 84 a9 00 00
	00		 je	 $LN7@slot_sq_it

; 5060 :             args = PyTuple_New(1);

  000c7	b9 01 00 00 00	 mov	 ecx, 1
  000cc	e8 00 00 00 00	 call	 PyTuple_New
  000d1	48 8b f0	 mov	 rsi, rax

; 5061 :             if (args != NULL) {

  000d4	48 85 c0	 test	 rax, rax
  000d7	74 32		 je	 SHORT $LN11@slot_sq_it

; 5062 :                 PyTuple_SET_ITEM(args, 0, ival);
; 5063 :                 retval = PyObject_Call(func, args, NULL);

  000d9	45 33 c0	 xor	 r8d, r8d
  000dc	48 8b d0	 mov	 rdx, rax
  000df	48 8b cb	 mov	 rcx, rbx
  000e2	48 89 78 70	 mov	 QWORD PTR [rax+112], rdi
  000e6	e8 00 00 00 00	 call	 PyObject_Call

; 5064 :                 Py_XDECREF(args);

  000eb	48 8b ce	 mov	 rcx, rsi
  000ee	48 8b f8	 mov	 rdi, rax
  000f1	e8 00 00 00 00	 call	 _Py_DecRef

; 5065 :                 Py_XDECREF(func);

  000f6	48 85 db	 test	 rbx, rbx
  000f9	74 08		 je	 SHORT $LN16@slot_sq_it
  000fb	48 8b cb	 mov	 rcx, rbx
  000fe	e8 00 00 00 00	 call	 _Py_DecRef
$LN16@slot_sq_it:

; 5066 :                 return retval;

  00103	48 8b c7	 mov	 rax, rdi
  00106	e9 ea 00 00 00	 jmp	 $LN28@slot_sq_it
$LN11@slot_sq_it:

; 5073 :     }
; 5074 :     Py_XDECREF(args);
; 5075 :     Py_XDECREF(ival);

  0010b	e8 00 00 00 00	 call	 _Py_PXCTX
  00110	85 c0		 test	 eax, eax
  00112	75 5c		 jne	 SHORT $LN7@slot_sq_it
  00114	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00118	a8 20		 test	 al, 32			; 00000020H
  0011a	75 4c		 jne	 SHORT $LN49@slot_sq_it
  0011c	84 c0		 test	 al, al
  0011e	78 48		 js	 SHORT $LN49@slot_sq_it
  00120	a8 02		 test	 al, 2
  00122	75 4c		 jne	 SHORT $LN7@slot_sq_it
  00124	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00128	75 46		 jne	 SHORT $LN7@slot_sq_it
  0012a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00131	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00138	4c 8b cf	 mov	 r9, rdi
  0013b	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00141	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00149	e8 00 00 00 00	 call	 _PyParallel_Guard
  0014e	48 8b cf	 mov	 rcx, rdi
  00151	85 c0		 test	 eax, eax
  00153	74 07		 je	 SHORT $LN54@slot_sq_it
  00155	e8 00 00 00 00	 call	 _Px_Dealloc
  0015a	eb 14		 jmp	 SHORT $LN7@slot_sq_it
$LN54@slot_sq_it:
  0015c	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00160	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00166	eb 08		 jmp	 SHORT $LN7@slot_sq_it
$LN49@slot_sq_it:
  00168	48 8b cf	 mov	 rcx, rdi
  0016b	e8 00 00 00 00	 call	 Px_DecRef
$LN7@slot_sq_it:

; 5076 :     Py_XDECREF(func);

  00170	48 85 db	 test	 rbx, rbx
  00173	74 7e		 je	 SHORT $LN3@slot_sq_it
  00175	e8 00 00 00 00	 call	 _Py_PXCTX
  0017a	85 c0		 test	 eax, eax
  0017c	75 75		 jne	 SHORT $LN3@slot_sq_it
  0017e	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00182	a8 20		 test	 al, 32			; 00000020H
  00184	75 4c		 jne	 SHORT $LN60@slot_sq_it
  00186	84 c0		 test	 al, al
  00188	78 48		 js	 SHORT $LN60@slot_sq_it
  0018a	a8 02		 test	 al, 2
  0018c	75 65		 jne	 SHORT $LN3@slot_sq_it
  0018e	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00192	75 5f		 jne	 SHORT $LN3@slot_sq_it
  00194	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0019b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001a2	4c 8b cb	 mov	 r9, rbx
  001a5	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001ab	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001b3	e8 00 00 00 00	 call	 _PyParallel_Guard
  001b8	48 8b cb	 mov	 rcx, rbx
  001bb	85 c0		 test	 eax, eax
  001bd	74 07		 je	 SHORT $LN65@slot_sq_it
  001bf	e8 00 00 00 00	 call	 _Px_Dealloc
  001c4	eb 2d		 jmp	 SHORT $LN3@slot_sq_it
$LN65@slot_sq_it:
  001c6	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  001ca	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001d0	eb 21		 jmp	 SHORT $LN3@slot_sq_it
$LN60@slot_sq_it:
  001d2	48 8b cb	 mov	 rcx, rbx
  001d5	e8 00 00 00 00	 call	 Px_DecRef
  001da	eb 17		 jmp	 SHORT $LN3@slot_sq_it
$LN27@slot_sq_it:

; 5067 :             }
; 5068 :         }
; 5069 :     }
; 5070 :     else {
; 5071 :         PyObject *getitem_str = _PyUnicode_FromId(&PyId___getitem__);

  001dc	48 8b cf	 mov	 rcx, rdi
  001df	e8 00 00 00 00	 call	 _PyUnicode_FromId

; 5072 :         PyErr_SetObject(PyExc_AttributeError, getitem_str);

  001e4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  001eb	48 8b d0	 mov	 rdx, rax
  001ee	e8 00 00 00 00	 call	 PyErr_SetObject
$LN3@slot_sq_it:

; 5077 :     return NULL;

  001f3	33 c0		 xor	 eax, eax
$LN28@slot_sq_it:

; 5078 : }

  001f5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001fa	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  001ff	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00204	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00208	5f		 pop	 rdi
  00209	c3		 ret	 0
slot_sq_item ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$call_attribute DD imagerel call_attribute
	DD	imagerel call_attribute+232
	DD	imagerel $unwind$call_attribute
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$call_attribute DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT call_attribute
_TEXT	SEGMENT
self$ = 64
attr$ = 72
name$ = 80
call_attribute PROC					; COMDAT

; 5395 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 5396 :     PyObject *res, *descr = NULL;
; 5397 :     descrgetfunc f = Py_TYPE(attr)->tp_descr_get;

  0000a	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  0000e	33 db		 xor	 ebx, ebx
  00010	49 8b f8	 mov	 rdi, r8
  00013	4c 8b 90 68 01
	00 00		 mov	 r10, QWORD PTR [rax+360]
  0001a	4c 8b ca	 mov	 r9, rdx

; 5398 : 
; 5399 :     if (f != NULL) {

  0001d	4d 85 d2	 test	 r10, r10
  00020	74 23		 je	 SHORT $LN5@call_attri

; 5400 :         descr = f(attr, self, (PyObject *)(Py_TYPE(self)));

  00022	4c 8b 41 58	 mov	 r8, QWORD PTR [rcx+88]
  00026	48 8b d1	 mov	 rdx, rcx
  00029	49 8b c9	 mov	 rcx, r9
  0002c	41 ff d2	 call	 r10
  0002f	48 8b d8	 mov	 rbx, rax

; 5401 :         if (descr == NULL)

  00032	48 85 c0	 test	 rax, rax
  00035	75 0b		 jne	 SHORT $LN6@call_attri

; 5409 : }

  00037	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0003c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
$LN6@call_attri:

; 5402 :             return NULL;
; 5403 :         else
; 5404 :             attr = descr;

  00042	4c 8b c8	 mov	 r9, rax
$LN5@call_attri:

; 5405 :     }
; 5406 :     res = PyObject_CallFunctionObjArgs(attr, name, NULL);

  00045	45 33 c0	 xor	 r8d, r8d
  00048	48 8b d7	 mov	 rdx, rdi
  0004b	49 8b c9	 mov	 rcx, r9
  0004e	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  00053	48 8b f8	 mov	 rdi, rax

; 5407 :     Py_XDECREF(descr);

  00056	48 85 db	 test	 rbx, rbx
  00059	74 7f		 je	 SHORT $LN3@call_attri
  0005b	e8 00 00 00 00	 call	 _Py_PXCTX
  00060	85 c0		 test	 eax, eax
  00062	75 76		 jne	 SHORT $LN3@call_attri
  00064	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00068	f6 c1 20	 test	 cl, 32			; 00000020H
  0006b	75 65		 jne	 SHORT $LN14@call_attri
  0006d	84 c9		 test	 cl, cl
  0006f	78 61		 js	 SHORT $LN14@call_attri
  00071	f6 c1 02	 test	 cl, 2
  00074	75 64		 jne	 SHORT $LN3@call_attri
  00076	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0007a	75 5e		 jne	 SHORT $LN3@call_attri
  0007c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00083	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0008a	4c 8b cb	 mov	 r9, rbx
  0008d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00093	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0009b	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a0	48 8b cb	 mov	 rcx, rbx
  000a3	85 c0		 test	 eax, eax
  000a5	74 13		 je	 SHORT $LN19@call_attri
  000a7	e8 00 00 00 00	 call	 _Px_Dealloc

; 5408 :     return res;

  000ac	48 8b c7	 mov	 rax, rdi

; 5409 : }

  000af	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b8	5f		 pop	 rdi
  000b9	c3		 ret	 0

; 5407 :     Py_XDECREF(descr);

$LN19@call_attri:
  000ba	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000be	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 5408 :     return res;

  000c4	48 8b c7	 mov	 rax, rdi

; 5409 : }

  000c7	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000cc	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d0	5f		 pop	 rdi
  000d1	c3		 ret	 0

; 5407 :     Py_XDECREF(descr);

$LN14@call_attri:
  000d2	48 8b cb	 mov	 rcx, rbx
  000d5	e8 00 00 00 00	 call	 Px_DecRef
$LN3@call_attri:

; 5408 :     return res;

  000da	48 8b c7	 mov	 rax, rdi

; 5409 : }

  000dd	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e6	5f		 pop	 rdi
  000e7	c3		 ret	 0
call_attribute ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$slot_tp_descr_get DD imagerel slot_tp_descr_get
	DD	imagerel slot_tp_descr_get+228
	DD	imagerel $unwind$slot_tp_descr_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_tp_descr_get DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT slot_tp_descr_get
_TEXT	SEGMENT
self$ = 64
obj$ = 72
type$ = 80
slot_tp_descr_get PROC					; COMDAT

; 5539 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 5540 :     PyTypeObject *tp = Py_TYPE(self);
; 5541 :     PyObject *get;
; 5542 :     _Py_IDENTIFIER(__get__);
; 5543 : 
; 5544 :     get = _PyType_LookupId(tp, &PyId___get__);

  00014	44 8b 0d 00 00
	00 00		 mov	 r9d, DWORD PTR _tls_index
  0001b	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00024	48 8b 79 58	 mov	 rdi, QWORD PTR [rcx+88]
  00028	48 8b ea	 mov	 rbp, rdx
  0002b	48 8b d9	 mov	 rbx, rcx
  0002e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___get__@?1??slot_tp_descr_get@@9@9
  00033	4a 03 14 c8	 add	 rdx, QWORD PTR [rax+r9*8]
  00037	48 8b cf	 mov	 rcx, rdi
  0003a	49 8b f0	 mov	 rsi, r8
  0003d	e8 00 00 00 00	 call	 _PyType_LookupId

; 5545 :     if (get == NULL) {

  00042	48 85 c0	 test	 rax, rax
  00045	75 5e		 jne	 SHORT $LN4@slot_tp_de

; 5546 :         /* Avoid further slowdowns */
; 5547 :         if (tp->tp_descr_get == slot_tp_descr_get)

  00047	48 8b 87 68 01
	00 00		 mov	 rax, QWORD PTR [rdi+360]
  0004e	33 c9		 xor	 ecx, ecx
  00050	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:slot_tp_descr_get
  00057	48 3b c2	 cmp	 rax, rdx
  0005a	48 0f 44 c1	 cmove	 rax, rcx
  0005e	48 89 87 68 01
	00 00		 mov	 QWORD PTR [rdi+360], rax

; 5548 :             tp->tp_descr_get = NULL;
; 5549 :         Py_INCREF(self);

  00065	e8 00 00 00 00	 call	 _Py_PXCTX
  0006a	85 c0		 test	 eax, eax
  0006c	75 32		 jne	 SHORT $LN8@slot_tp_de
  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0007c	4c 8b cb	 mov	 r9, rbx
  0007f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00085	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00092	85 c0		 test	 eax, eax
  00094	75 06		 jne	 SHORT $LN7@slot_tp_de
  00096	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0009a	74 04		 je	 SHORT $LN8@slot_tp_de
$LN7@slot_tp_de:
  0009c	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN8@slot_tp_de:

; 5550 :         return self;

  000a0	48 8b c3	 mov	 rax, rbx
  000a3	eb 2a		 jmp	 SHORT $LN5@slot_tp_de
$LN4@slot_tp_de:

; 5551 :     }
; 5552 :     if (obj == NULL)

  000a5	48 85 ed	 test	 rbp, rbp
  000a8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct

; 5553 :         obj = Py_None;
; 5554 :     if (type == NULL)
; 5555 :         type = Py_None;
; 5556 :     return PyObject_CallFunctionObjArgs(get, self, obj, type, NULL);

  000af	48 8b d3	 mov	 rdx, rbx
  000b2	4d 8b c1	 mov	 r8, r9
  000b5	4c 0f 45 c5	 cmovne	 r8, rbp
  000b9	48 85 f6	 test	 rsi, rsi
  000bc	4c 0f 45 ce	 cmovne	 r9, rsi
  000c0	33 c9		 xor	 ecx, ecx
  000c2	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000c7	48 8b c8	 mov	 rcx, rax
  000ca	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
$LN5@slot_tp_de:

; 5557 : }

  000cf	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d4	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000d9	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000de	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e2	5f		 pop	 rdi
  000e3	c3		 ret	 0
slot_tp_descr_get ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$slot_tp_new DD imagerel slot_tp_new
	DD	imagerel slot_tp_new+182
	DD	imagerel $unwind$slot_tp_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$slot_tp_new DD imagerel slot_tp_new+182
	DD	imagerel slot_tp_new+275
	DD	imagerel $chain$2$slot_tp_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$slot_tp_new DD imagerel slot_tp_new+275
	DD	imagerel slot_tp_new+337
	DD	imagerel $chain$3$slot_tp_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$slot_tp_new DD 021H
	DD	imagerel slot_tp_new
	DD	imagerel slot_tp_new+182
	DD	imagerel $unwind$slot_tp_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$slot_tp_new DD 020521H
	DD	0c7405H
	DD	imagerel slot_tp_new
	DD	imagerel slot_tp_new+182
	DD	imagerel $unwind$slot_tp_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_tp_new DD 0a5801H
	DD	0b6458H
	DD	0a5453H
	DD	0d340fH
	DD	0e00b520fH
	DD	0c007d009H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT slot_tp_new
_TEXT	SEGMENT
type$ = 80
args$ = 88
kwds$ = 96
slot_tp_new PROC					; COMDAT

; 5602 : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 5603 :     PyObject *func;
; 5604 :     PyObject *newargs, *x;
; 5605 :     Py_ssize_t i, n;
; 5606 :     _Py_IDENTIFIER(__new__);
; 5607 : 
; 5608 :     func = _PyObject_GetAttrId((PyObject *)type, &PyId___new__);

  0000f	44 8b 0d 00 00
	00 00		 mov	 r9d, DWORD PTR _tls_index
  00016	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0001f	4c 8b e2	 mov	 r12, rdx
  00022	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___new__@?1??slot_tp_new@@9@9
  00027	4d 8b f0	 mov	 r14, r8
  0002a	48 8b d9	 mov	 rbx, rcx
  0002d	4a 03 14 c8	 add	 rdx, QWORD PTR [rax+r9*8]
  00031	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00036	4c 8b e8	 mov	 r13, rax

; 5609 :     if (func == NULL)

  00039	48 85 c0	 test	 rax, rax
  0003c	75 10		 jne	 SHORT $LN5@slot_tp_ne

; 5627 : }

  0003e	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  00043	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00047	41 5e		 pop	 r14
  00049	41 5d		 pop	 r13
  0004b	41 5c		 pop	 r12
  0004d	c3		 ret	 0
$LN5@slot_tp_ne:
  0004e	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00053	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi

; 5610 :         return NULL;
; 5611 :     assert(PyTuple_Check(args));
; 5612 :     n = PyTuple_GET_SIZE(args);

  00058	49 8b 74 24 60	 mov	 rsi, QWORD PTR [r12+96]

; 5613 :     newargs = PyTuple_New(n+1);

  0005d	48 8d 4e 01	 lea	 rcx, QWORD PTR [rsi+1]
  00061	e8 00 00 00 00	 call	 PyTuple_New
  00066	48 8b e8	 mov	 rbp, rax

; 5614 :     if (newargs == NULL)

  00069	48 85 c0	 test	 rax, rax
  0006c	0f 84 c5 00 00
	00		 je	 $LN19@slot_tp_ne
$LN4@slot_tp_ne:

; 5615 :         return NULL;
; 5616 :     Py_INCREF(type);

  00072	e8 00 00 00 00	 call	 _Py_PXCTX
  00077	85 c0		 test	 eax, eax
  00079	75 32		 jne	 SHORT $LN9@slot_tp_ne
  0007b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00082	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00089	4c 8b cb	 mov	 r9, rbx
  0008c	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00092	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0009a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0009f	85 c0		 test	 eax, eax
  000a1	75 06		 jne	 SHORT $LN8@slot_tp_ne
  000a3	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000a7	74 04		 je	 SHORT $LN9@slot_tp_ne
$LN8@slot_tp_ne:
  000a9	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN9@slot_tp_ne:

; 5617 :     PyTuple_SET_ITEM(newargs, 0, (PyObject *)type);

  000ad	48 89 5d 70	 mov	 QWORD PTR [rbp+112], rbx

; 5618 :     for (i = 0; i < n; i++) {

  000b1	48 85 f6	 test	 rsi, rsi
  000b4	7e 5d		 jle	 SHORT $LN1@slot_tp_ne
  000b6	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  000bb	4c 2b e5	 sub	 r12, rbp
  000be	48 8d 7d 78	 lea	 rdi, QWORD PTR [rbp+120]
$LL3@slot_tp_ne:

; 5619 :         x = PyTuple_GET_ITEM(args, i);

  000c2	49 8b 5c 3c f8	 mov	 rbx, QWORD PTR [r12+rdi-8]

; 5620 :         Py_INCREF(x);

  000c7	e8 00 00 00 00	 call	 _Py_PXCTX
  000cc	85 c0		 test	 eax, eax
  000ce	75 32		 jne	 SHORT $LN13@slot_tp_ne
  000d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000de	4c 8b cb	 mov	 r9, rbx
  000e1	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000e7	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000ef	e8 00 00 00 00	 call	 _PyParallel_Guard
  000f4	85 c0		 test	 eax, eax
  000f6	75 06		 jne	 SHORT $LN12@slot_tp_ne
  000f8	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000fc	74 04		 je	 SHORT $LN13@slot_tp_ne
$LN12@slot_tp_ne:
  000fe	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN13@slot_tp_ne:

; 5621 :         PyTuple_SET_ITEM(newargs, i+1, x);

  00102	48 89 1f	 mov	 QWORD PTR [rdi], rbx
  00105	48 83 c7 08	 add	 rdi, 8
  00109	48 ff ce	 dec	 rsi
  0010c	75 b4		 jne	 SHORT $LL3@slot_tp_ne
  0010e	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
$LN1@slot_tp_ne:

; 5622 :     }
; 5623 :     x = PyObject_Call(func, newargs, kwds);

  00113	4d 8b c6	 mov	 r8, r14
  00116	48 8b d5	 mov	 rdx, rbp
  00119	49 8b cd	 mov	 rcx, r13
  0011c	e8 00 00 00 00	 call	 PyObject_Call

; 5624 :     Py_DECREF(newargs);

  00121	48 8b cd	 mov	 rcx, rbp
  00124	48 8b d8	 mov	 rbx, rax
  00127	e8 00 00 00 00	 call	 _Py_DecRef

; 5625 :     Py_DECREF(func);

  0012c	49 8b cd	 mov	 rcx, r13
  0012f	e8 00 00 00 00	 call	 _Py_DecRef

; 5626 :     return x;

  00134	48 8b c3	 mov	 rax, rbx
$LN19@slot_tp_ne:

; 5627 : }

  00137	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0013c	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00141	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  00146	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0014a	41 5e		 pop	 r14
  0014c	41 5d		 pop	 r13
  0014e	41 5c		 pop	 r12
  00150	c3		 ret	 0
slot_tp_new ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT slotptr
_TEXT	SEGMENT
type$ = 8
ioffset$ = 16
slotptr	PROC						; COMDAT

; 5921 : {

  00000	48 8b c1	 mov	 rax, rcx

; 5922 :     char *ptr;
; 5923 :     long offset = ioffset;
; 5924 : 
; 5925 :     /* Note: this depends on the order of the members of PyHeapTypeObject! */
; 5926 :     assert(offset >= 0);
; 5927 :     assert((size_t)offset < offsetof(PyHeapTypeObject, as_buffer));
; 5928 :     if ((size_t)offset >= offsetof(PyHeapTypeObject, as_sequence)) {

  00003	81 fa 08 03 00
	00		 cmp	 edx, 776		; 00000308H
  00009	72 0f		 jb	 SHORT $LN7@slotptr

; 5929 :         ptr = (char *)type->tp_as_sequence;

  0000b	48 8b 81 c0 00
	00 00		 mov	 rax, QWORD PTR [rcx+192]

; 5930 :         offset -= offsetof(PyHeapTypeObject, as_sequence);

  00012	81 c2 f8 fc ff
	ff		 add	 edx, -776		; fffffffffffffcf8H
  00018	eb 2c		 jmp	 SHORT $LN2@slotptr
$LN7@slotptr:

; 5931 :     }
; 5932 :     else if ((size_t)offset >= offsetof(PyHeapTypeObject, as_mapping)) {

  0001a	81 fa f0 02 00
	00		 cmp	 edx, 752		; 000002f0H
  00020	72 0f		 jb	 SHORT $LN5@slotptr

; 5933 :         ptr = (char *)type->tp_as_mapping;

  00022	48 8b 81 c8 00
	00 00		 mov	 rax, QWORD PTR [rcx+200]

; 5934 :         offset -= offsetof(PyHeapTypeObject, as_mapping);

  00029	81 c2 10 fd ff
	ff		 add	 edx, -752		; fffffffffffffd10H
  0002f	eb 15		 jmp	 SHORT $LN2@slotptr
$LN5@slotptr:

; 5935 :     }
; 5936 :     else if ((size_t)offset >= offsetof(PyHeapTypeObject, as_number)) {

  00031	81 fa e0 01 00
	00		 cmp	 edx, 480		; 000001e0H
  00037	72 0d		 jb	 SHORT $LN2@slotptr

; 5937 :         ptr = (char *)type->tp_as_number;

  00039	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]

; 5938 :         offset -= offsetof(PyHeapTypeObject, as_number);

  00040	81 c2 20 fe ff
	ff		 add	 edx, -480		; fffffffffffffe20H
$LN2@slotptr:

; 5939 :     }
; 5940 :     else {
; 5941 :         ptr = (char *)type;
; 5942 :     }
; 5943 :     if (ptr != NULL)

  00046	48 85 c0	 test	 rax, rax
  00049	74 06		 je	 SHORT $LN10@slotptr

; 5944 :         ptr += offset;

  0004b	48 63 ca	 movsxd	 rcx, edx
  0004e	48 03 c1	 add	 rax, rcx
$LN10@slotptr:

; 5945 :     return (void **)ptr;
; 5946 : }

  00051	f3 c3		 fatret	 0
slotptr	ENDP
_TEXT	ENDS
_BSS	SEGMENT
?ptrs@?1??resolve_slotdups@@9@9 DQ 0aH DUP (?)		; `resolve_slotdups'::`2'::ptrs
?pname@?1??resolve_slotdups@@9@9 DQ 01H DUP (?)		; `resolve_slotdups'::`2'::pname
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$resolve_slotdups DD imagerel resolve_slotdups
	DD	imagerel resolve_slotdups+172
	DD	imagerel $unwind$resolve_slotdups
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$resolve_slotdups DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT resolve_slotdups
_TEXT	SEGMENT
type$ = 48
name$ = 56
resolve_slotdups PROC					; COMDAT

; 5958 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 5959 :     /* XXX Maybe this could be optimized more -- but is it worth it? */
; 5960 : 
; 5961 :     /* pname and ptrs act as a little cache */
; 5962 :     static PyObject *pname;
; 5963 :     static slotdef *ptrs[MAX_EQUIV];
; 5964 :     slotdef *p, **pp;
; 5965 :     void **res, **ptr;
; 5966 : 
; 5967 :     if (pname != name) {

  00006	45 33 d2	 xor	 r10d, r10d
  00009	48 39 15 00 00
	00 00		 cmp	 QWORD PTR ?pname@?1??resolve_slotdups@@9@9, rdx
  00010	48 8b d9	 mov	 rbx, rcx
  00013	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?ptrs@?1??resolve_slotdups@@9@9
  0001a	74 40		 je	 SHORT $LN11@resolve_sl

; 5968 :         /* Collect all slotdefs that match name into ptrs. */
; 5969 :         pname = name;
; 5970 :         pp = ptrs;
; 5971 :         for (p = slotdefs; p->name_strobj; p++) {

  0001c	4c 8b 1d 30 00
	00 00		 mov	 r11, QWORD PTR slotdefs+48
  00023	48 89 15 00 00
	00 00		 mov	 QWORD PTR ?pname@?1??resolve_slotdups@@9@9, rdx
  0002a	49 8b c0	 mov	 rax, r8
  0002d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:slotdefs
  00034	4d 85 db	 test	 r11, r11
  00037	74 20		 je	 SHORT $LN8@resolve_sl
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL10@resolve_sl:

; 5972 :             if (p->name_strobj == name)

  00040	4c 3b da	 cmp	 r11, rdx
  00043	75 07		 jne	 SHORT $LN9@resolve_sl

; 5973 :                 *pp++ = p;

  00045	4c 89 08	 mov	 QWORD PTR [rax], r9
  00048	48 83 c0 08	 add	 rax, 8
$LN9@resolve_sl:

; 5968 :         /* Collect all slotdefs that match name into ptrs. */
; 5969 :         pname = name;
; 5970 :         pp = ptrs;
; 5971 :         for (p = slotdefs; p->name_strobj; p++) {

  0004c	4d 8b 59 68	 mov	 r11, QWORD PTR [r9+104]
  00050	49 83 c1 38	 add	 r9, 56			; 00000038H
  00054	4d 85 db	 test	 r11, r11
  00057	75 e7		 jne	 SHORT $LL10@resolve_sl
$LN8@resolve_sl:

; 5974 :         }
; 5975 :         *pp = NULL;

  00059	4c 89 10	 mov	 QWORD PTR [rax], r10
$LN11@resolve_sl:

; 5976 :     }
; 5977 : 
; 5978 :     /* Look in all matching slots of the type; if exactly one of these has
; 5979 :        a filled-in slot, return its value.      Otherwise return NULL. */
; 5980 :     res = NULL;
; 5981 :     for (pp = ptrs; *pp; pp++) {

  0005c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?ptrs@?1??resolve_slotdups@@9@9
  00063	48 85 c0	 test	 rax, rax
  00066	74 33		 je	 SHORT $LN19@resolve_sl
  00068	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL6@resolve_sl:

; 5982 :         ptr = slotptr(type, (*pp)->offset);

  00070	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  00073	48 8b cb	 mov	 rcx, rbx
  00076	e8 00 00 00 00	 call	 slotptr

; 5983 :         if (ptr == NULL || *ptr == NULL)

  0007b	48 85 c0	 test	 rax, rax
  0007e	74 0e		 je	 SHORT $LN5@resolve_sl
  00080	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00084	74 08		 je	 SHORT $LN5@resolve_sl

; 5984 :             continue;
; 5985 :         if (res != NULL)

  00086	4d 85 d2	 test	 r10, r10
  00089	75 19		 jne	 SHORT $LN16@resolve_sl

; 5987 :         res = ptr;

  0008b	4c 8b d0	 mov	 r10, rax
$LN5@resolve_sl:

; 5976 :     }
; 5977 : 
; 5978 :     /* Look in all matching slots of the type; if exactly one of these has
; 5979 :        a filled-in slot, return its value.      Otherwise return NULL. */
; 5980 :     res = NULL;
; 5981 :     for (pp = ptrs; *pp; pp++) {

  0008e	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  00092	49 83 c0 08	 add	 r8, 8
  00096	48 85 c0	 test	 rax, rax
  00099	75 d5		 jne	 SHORT $LL6@resolve_sl
$LN19@resolve_sl:

; 5988 :     }
; 5989 :     return res;

  0009b	49 8b c2	 mov	 rax, r10

; 5990 : }

  0009e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a2	5b		 pop	 rbx
  000a3	c3		 ret	 0
$LN16@resolve_sl:

; 5986 :             return NULL;

  000a4	33 c0		 xor	 eax, eax

; 5990 : }

  000a6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000aa	5b		 pop	 rbx
  000ab	c3		 ret	 0
resolve_slotdups ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@DNPIJCCM@Out?5of?5memory?5interning?5slotdef?5@ ; `string'
EXTRN	PyUnicode_InternFromString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$init_slotdefs DD imagerel init_slotdefs
	DD	imagerel init_slotdefs+21
	DD	imagerel $unwind$init_slotdefs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$init_slotdefs DD imagerel init_slotdefs+21
	DD	imagerel init_slotdefs+89
	DD	imagerel $chain$0$init_slotdefs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$init_slotdefs DD imagerel init_slotdefs+89
	DD	imagerel init_slotdefs+94
	DD	imagerel $chain$1$init_slotdefs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$init_slotdefs DD 021H
	DD	imagerel init_slotdefs
	DD	imagerel init_slotdefs+21
	DD	imagerel $unwind$init_slotdefs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$init_slotdefs DD 020521H
	DD	043405H
	DD	imagerel init_slotdefs
	DD	imagerel init_slotdefs+21
	DD	imagerel $unwind$init_slotdefs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$init_slotdefs DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CG@DNPIJCCM@Out?5of?5memory?5interning?5slotdef?5@
CONST	SEGMENT
??_C@_0CG@DNPIJCCM@Out?5of?5memory?5interning?5slotdef?5@ DB 'Out of memo'
	DB	'ry interning slotdef names', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT init_slotdefs
_TEXT	SEGMENT
init_slotdefs PROC					; COMDAT

; 6095 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 6096 :     slotdef *p;
; 6097 :     static int initialized = 0;
; 6098 : 
; 6099 :     if (initialized)

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?initialized@?1??init_slotdefs@@9@9, 0
  0000b	75 4c		 jne	 SHORT $LN6@init_slotd

; 6100 :         return;
; 6101 :     for (p = slotdefs; p->name; p++) {

  0000d	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR slotdefs, 0
  00015	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0001a	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:slotdefs
  00021	74 27		 je	 SHORT $LN2@init_slotd
$LL4@init_slotd:

; 6102 :         /* Slots must be ordered by their offset in the PyHeapTypeObject. */
; 6103 :         assert(!p[1].name || p->offset <= p[1].offset);
; 6104 :         p->name_strobj = PyUnicode_InternFromString(p->name);

  00023	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00026	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  0002b	48 89 43 30	 mov	 QWORD PTR [rbx+48], rax

; 6105 :         if (!p->name_strobj)

  0002f	48 85 c0	 test	 rax, rax
  00032	75 0c		 jne	 SHORT $LN3@init_slotd

; 6106 :             Py_FatalError("Out of memory interning slotdef names");

  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CG@DNPIJCCM@Out?5of?5memory?5interning?5slotdef?5@
  0003b	e8 00 00 00 00	 call	 Py_FatalError
$LN3@init_slotd:

; 6100 :         return;
; 6101 :     for (p = slotdefs; p->name; p++) {

  00040	48 83 c3 38	 add	 rbx, 56			; 00000038H
  00044	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  00048	75 d9		 jne	 SHORT $LL4@init_slotd
$LN2@init_slotd:
  0004a	48 8b 5c 24 20	 mov	 rbx, QWORD PTR [rsp+32]

; 6107 :     }
; 6108 :     initialized = 1;

  0004f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?initialized@?1??init_slotdefs@@9@9, 1
$LN6@init_slotd:

; 6109 : }

  00059	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005d	c3		 ret	 0
init_slotdefs ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$update_subclasses DD imagerel update_subclasses
	DD	imagerel update_subclasses+84
	DD	imagerel $unwind$update_subclasses
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$update_subclasses DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT update_subclasses
_TEXT	SEGMENT
type$ = 48
name$ = 56
callback$ = 64
data$ = 72
update_subclasses PROC					; COMDAT

; 6180 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b ea	 mov	 rbp, rdx
  00017	49 8b f8	 mov	 rdi, r8

; 6181 :     if (callback(type, data) < 0)

  0001a	49 8b d1	 mov	 rdx, r9
  0001d	49 8b d9	 mov	 rbx, r9
  00020	48 8b f1	 mov	 rsi, rcx
  00023	ff d7		 call	 rdi
  00025	85 c0		 test	 eax, eax
  00027	79 05		 jns	 SHORT $LN1@update_sub

; 6182 :         return -1;

  00029	83 c8 ff	 or	 eax, -1
  0002c	eb 11		 jmp	 SHORT $LN2@update_sub
$LN1@update_sub:

; 6183 :     return recurse_down_subclasses(type, name, callback, data);

  0002e	4c 8b cb	 mov	 r9, rbx
  00031	4c 8b c7	 mov	 r8, rdi
  00034	48 8b d5	 mov	 rdx, rbp
  00037	48 8b ce	 mov	 rcx, rsi
  0003a	e8 00 00 00 00	 call	 recurse_down_subclasses
$LN2@update_sub:

; 6184 : }

  0003f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00044	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00049	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0004e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00052	5f		 pop	 rdi
  00053	c3		 ret	 0
update_subclasses ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$recurse_down_subclasses DD imagerel recurse_down_subclasses
	DD	imagerel recurse_down_subclasses+47
	DD	imagerel $unwind$recurse_down_subclasses
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$recurse_down_subclasses DD imagerel recurse_down_subclasses+47
	DD	imagerel recurse_down_subclasses+224
	DD	imagerel $chain$3$recurse_down_subclasses
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$recurse_down_subclasses DD imagerel recurse_down_subclasses+224
	DD	imagerel recurse_down_subclasses+229
	DD	imagerel $chain$5$recurse_down_subclasses
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$recurse_down_subclasses DD 080021H
	DD	04f400H
	DD	0c7400H
	DD	0b6400H
	DD	0a3400H
	DD	imagerel recurse_down_subclasses
	DD	imagerel recurse_down_subclasses+47
	DD	imagerel $unwind$recurse_down_subclasses
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$recurse_down_subclasses DD 081a21H
	DD	04f41aH
	DD	0c7415H
	DD	0b640aH
	DD	0a3405H
	DD	imagerel recurse_down_subclasses
	DD	imagerel recurse_down_subclasses+47
	DD	imagerel $unwind$recurse_down_subclasses
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$recurse_down_subclasses DD 050c01H
	DD	0e008420cH
	DD	0c004d006H
	DD	05002H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT recurse_down_subclasses
_TEXT	SEGMENT
type$ = 80
name$ = 88
callback$ = 96
data$ = 104
recurse_down_subclasses PROC				; COMDAT

; 6189 : {

  00000	40 55		 push	 rbp
  00002	41 54		 push	 r12
  00004	41 55		 push	 r13
  00006	41 56		 push	 r14
  00008	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 6190 :     PyTypeObject *subclass;
; 6191 :     PyObject *ref, *subclasses, *dict;
; 6192 :     Py_ssize_t i, n;
; 6193 : 
; 6194 :     subclasses = type->tp_subclasses;

  0000c	48 8b a9 c0 01
	00 00		 mov	 rbp, QWORD PTR [rcx+448]
  00013	4d 8b e9	 mov	 r13, r9
  00016	4d 8b f0	 mov	 r14, r8
  00019	4c 8b e2	 mov	 r12, rdx

; 6195 :     if (subclasses == NULL)

  0001c	48 85 ed	 test	 rbp, rbp
  0001f	75 0e		 jne	 SHORT $LN7@recurse_do

; 6196 :         return 0;

  00021	33 c0		 xor	 eax, eax

; 6216 : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	41 5e		 pop	 r14
  00029	41 5d		 pop	 r13
  0002b	41 5c		 pop	 r12
  0002d	5d		 pop	 rbp
  0002e	c3		 ret	 0
$LN7@recurse_do:
  0002f	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  00034	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi

; 6197 :     assert(PyList_Check(subclasses));
; 6198 :     n = PyList_GET_SIZE(subclasses);

  00039	48 8b 75 60	 mov	 rsi, QWORD PTR [rbp+96]

; 6199 :     for (i = 0; i < n; i++) {

  0003d	33 db		 xor	 ebx, ebx
  0003f	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  00044	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  00049	48 85 f6	 test	 rsi, rsi
  0004c	7e 70		 jle	 SHORT $LN15@recurse_do
  0004e	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:_Py_NoneStruct
  00055	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL6@recurse_do:

; 6200 :         ref = PyList_GET_ITEM(subclasses, i);

  00060	48 8b 45 70	 mov	 rax, QWORD PTR [rbp+112]
  00064	48 8b 0c d8	 mov	 rcx, QWORD PTR [rax+rbx*8]

; 6201 :         assert(PyWeakref_CheckRef(ref));
; 6202 :         subclass = (PyTypeObject *)PyWeakref_GET_OBJECT(ref);

  00068	48 8b 79 60	 mov	 rdi, QWORD PTR [rcx+96]
  0006c	48 83 7f 50 00	 cmp	 QWORD PTR [rdi+80], 0
  00071	7e 43		 jle	 SHORT $LN5@recurse_do

; 6203 :         assert(subclass != NULL);
; 6204 :         if ((PyObject *)subclass == Py_None)

  00073	49 3b ff	 cmp	 rdi, r15
  00076	74 3e		 je	 SHORT $LN5@recurse_do

; 6205 :             continue;
; 6206 :         assert(PyType_Check(subclass));
; 6207 :         /* Avoid recursing down into unaffected classes */
; 6208 :         dict = subclass->tp_dict;

  00078	48 8b 8f 60 01
	00 00		 mov	 rcx, QWORD PTR [rdi+352]

; 6209 :         if (dict != NULL && PyDict_Check(dict) &&
; 6210 :             PyDict_GetItem(dict, name) != NULL)

  0007f	48 85 c9	 test	 rcx, rcx
  00082	74 1d		 je	 SHORT $LN2@recurse_do
  00084	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00088	f7 80 00 01 00
	00 00 00 00 20	 test	 DWORD PTR [rax+256], 536870912 ; 20000000H
  00092	74 0d		 je	 SHORT $LN2@recurse_do
  00094	49 8b d4	 mov	 rdx, r12
  00097	e8 00 00 00 00	 call	 PyDict_GetItem
  0009c	48 85 c0	 test	 rax, rax
  0009f	75 15		 jne	 SHORT $LN5@recurse_do
$LN2@recurse_do:

; 6211 :             continue;
; 6212 :         if (update_subclasses(subclass, name, callback, data) < 0)

  000a1	4d 8b cd	 mov	 r9, r13
  000a4	4d 8b c6	 mov	 r8, r14
  000a7	49 8b d4	 mov	 rdx, r12
  000aa	48 8b cf	 mov	 rcx, rdi
  000ad	e8 00 00 00 00	 call	 update_subclasses
  000b2	85 c0		 test	 eax, eax
  000b4	78 2a		 js	 SHORT $LN13@recurse_do
$LN5@recurse_do:

; 6199 :     for (i = 0; i < n; i++) {

  000b6	48 ff c3	 inc	 rbx
  000b9	48 3b de	 cmp	 rbx, rsi
  000bc	7c a2		 jl	 SHORT $LL6@recurse_do
$LN15@recurse_do:

; 6214 :     }
; 6215 :     return 0;

  000be	33 c0		 xor	 eax, eax
$LN19@recurse_do:
  000c0	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  000c5	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  000ca	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000cf	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]

; 6216 : }

  000d4	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000d8	41 5e		 pop	 r14
  000da	41 5d		 pop	 r13
  000dc	41 5c		 pop	 r12
  000de	5d		 pop	 rbp
  000df	c3		 ret	 0
$LN13@recurse_do:

; 6213 :             return -1;

  000e0	83 c8 ff	 or	 eax, -1
  000e3	eb db		 jmp	 SHORT $LN19@recurse_do
recurse_down_subclasses ENDP
_TEXT	ENDS
EXTRN	PyDescr_NewWrapper:PROC
EXTRN	PyObject_HashNotImplemented:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_operators DD imagerel add_operators
	DD	imagerel add_operators+264
	DD	imagerel $unwind$add_operators
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_operators DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT add_operators
_TEXT	SEGMENT
type$ = 48
add_operators PROC					; COMDAT

; 6250 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 6251 :     PyObject *dict = type->tp_dict;

  0001a	48 8b a9 60 01
	00 00		 mov	 rbp, QWORD PTR [rcx+352]
  00021	48 8b f1	 mov	 rsi, rcx

; 6252 :     slotdef *p;
; 6253 :     PyObject *descr;
; 6254 :     void **ptr;
; 6255 : 
; 6256 :     init_slotdefs();

  00024	e8 00 00 00 00	 call	 init_slotdefs

; 6257 :     for (p = slotdefs; p->name; p++) {

  00029	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR slotdefs, 0
  00031	0f 84 9e 00 00
	00		 je	 $LN22@add_operat

; 6251 :     PyObject *dict = type->tp_dict;

  00037	48 8d 1d 30 00
	00 00		 lea	 rbx, OFFSET FLAT:slotdefs+48
  0003e	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:PyObject_HashNotImplemented
$LL14@add_operat:

; 6258 :         if (p->wrapper == NULL)

  00045	48 83 7b e8 00	 cmp	 QWORD PTR [rbx-24], 0
  0004a	74 7a		 je	 SHORT $LN13@add_operat

; 6259 :             continue;
; 6260 :         ptr = slotptr(type, p->offset);

  0004c	8b 53 d8	 mov	 edx, DWORD PTR [rbx-40]
  0004f	48 8b ce	 mov	 rcx, rsi
  00052	e8 00 00 00 00	 call	 slotptr
  00057	48 8b f8	 mov	 rdi, rax

; 6261 :         if (!ptr || !*ptr)

  0005a	48 85 c0	 test	 rax, rax
  0005d	74 67		 je	 SHORT $LN13@add_operat
  0005f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00063	74 61		 je	 SHORT $LN13@add_operat

; 6262 :             continue;
; 6263 :         if (PyDict_GetItem(dict, p->name_strobj))

  00065	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  00068	48 8b cd	 mov	 rcx, rbp
  0006b	e8 00 00 00 00	 call	 PyDict_GetItem
  00070	48 85 c0	 test	 rax, rax
  00073	75 51		 jne	 SHORT $LN13@add_operat

; 6264 :             continue;
; 6265 :         if (*ptr == (void *)PyObject_HashNotImplemented) {

  00075	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
  00078	4d 3b c4	 cmp	 r8, r12
  0007b	75 1b		 jne	 SHORT $LN7@add_operat

; 6266 :             /* Classes may prevent the inheritance of the tp_hash
; 6267 :                slot by storing PyObject_HashNotImplemented in it. Make it
; 6268 :                visible as a None value for the __hash__ attribute. */
; 6269 :             if (PyDict_SetItem(dict, p->name_strobj, Py_None) < 0)

  0007d	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  00080	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_NoneStruct
  00087	48 8b cd	 mov	 rcx, rbp
  0008a	e8 00 00 00 00	 call	 PyDict_SetItem
  0008f	85 c0		 test	 eax, eax
  00091	79 33		 jns	 SHORT $LN13@add_operat
$LN18@add_operat:

; 6270 :                 return -1;

  00093	83 c8 ff	 or	 eax, -1
  00096	eb 55		 jmp	 SHORT $LN15@add_operat
$LN7@add_operat:

; 6271 :         }
; 6272 :         else {
; 6273 :             descr = PyDescr_NewWrapper(type, p, *ptr);

  00098	48 8d 53 d0	 lea	 rdx, QWORD PTR [rbx-48]
  0009c	48 8b ce	 mov	 rcx, rsi
  0009f	e8 00 00 00 00	 call	 PyDescr_NewWrapper
  000a4	48 8b f8	 mov	 rdi, rax

; 6274 :             if (descr == NULL)

  000a7	48 85 c0	 test	 rax, rax
  000aa	74 e7		 je	 SHORT $LN18@add_operat

; 6275 :                 return -1;
; 6276 :             if (PyDict_SetItem(dict, p->name_strobj, descr) < 0)

  000ac	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  000af	4c 8b c0	 mov	 r8, rax
  000b2	48 8b cd	 mov	 rcx, rbp
  000b5	e8 00 00 00 00	 call	 PyDict_SetItem
  000ba	85 c0		 test	 eax, eax
  000bc	78 d5		 js	 SHORT $LN18@add_operat

; 6277 :                 return -1;
; 6278 :             Py_DECREF(descr);

  000be	48 8b cf	 mov	 rcx, rdi
  000c1	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@add_operat:

; 6257 :     for (p = slotdefs; p->name; p++) {

  000c6	48 83 c3 38	 add	 rbx, 56			; 00000038H
  000ca	48 83 7b d0 00	 cmp	 QWORD PTR [rbx-48], 0
  000cf	0f 85 70 ff ff
	ff		 jne	 $LL14@add_operat
$LN22@add_operat:

; 6279 :         }
; 6280 :     }
; 6281 :     if (type->tp_new != NULL) {

  000d5	48 83 be 90 01
	00 00 00	 cmp	 QWORD PTR [rsi+400], 0
  000dd	74 0c		 je	 SHORT $LN1@add_operat

; 6282 :         if (add_tp_new_wrapper(type) < 0)

  000df	48 8b ce	 mov	 rcx, rsi
  000e2	e8 00 00 00 00	 call	 add_tp_new_wrapper
  000e7	85 c0		 test	 eax, eax

; 6283 :             return -1;

  000e9	78 a8		 js	 SHORT $LN18@add_operat
$LN1@add_operat:

; 6284 :     }
; 6285 :     return 0;

  000eb	33 c0		 xor	 eax, eax
$LN15@add_operat:

; 6286 : }

  000ed	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000f2	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000f7	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000fc	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00101	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00105	41 5c		 pop	 r12
  00107	c3		 ret	 0
add_operators ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@CLOBMIMP@super_dealloc?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$super_dealloc DD imagerel super_dealloc
	DD	imagerel super_dealloc+491
	DD	imagerel $unwind$super_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$super_dealloc DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0O@CLOBMIMP@super_dealloc?$AA@
CONST	SEGMENT
??_C@_0O@CLOBMIMP@super_dealloc?$AA@ DB 'super_dealloc', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
CONST	ENDS
;	COMDAT super_dealloc
_TEXT	SEGMENT
self$ = 64
super_dealloc PROC					; COMDAT

; 6310 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 6311 :     superobject *su = (superobject *)self;
; 6312 : 
; 6313 :     _PyObject_GC_UNTRACK(self);

  0000d	4c 8b c9	 mov	 r9, rcx
  00010	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@CLOBMIMP@super_dealloc?$AA@
  0001e	41 b8 a9 18 00
	00		 mov	 r8d, 6313		; 000018a9H
  00024	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0002c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00031	85 c0		 test	 eax, eax
  00033	75 54		 jne	 SHORT $LN13@super_deal
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@CLOBMIMP@super_dealloc?$AA@
  00043	4c 8b cf	 mov	 r9, rdi
  00046	41 b8 a9 18 00
	00		 mov	 r8d, 6313		; 000018a9H
  0004c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00054	e8 00 00 00 00	 call	 _PyParallel_Guard
  00059	85 c0		 test	 eax, eax
  0005b	74 04		 je	 SHORT $LN19@super_deal
  0005d	33 d2		 xor	 edx, edx
  0005f	eb 04		 jmp	 SHORT $LN20@super_deal
$LN19@super_deal:
  00061	48 8d 57 e8	 lea	 rdx, QWORD PTR [rdi-24]
$LN20@super_deal:
  00065	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00068	48 8b 4a 08	 mov	 rcx, QWORD PTR [rdx+8]
  0006c	48 c7 42 10 fe
	ff ff ff	 mov	 QWORD PTR [rdx+16], -2
  00074	48 89 01	 mov	 QWORD PTR [rcx], rax
  00077	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  0007a	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0007e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00082	48 c7 02 00 00
	00 00		 mov	 QWORD PTR [rdx], 0
$LN13@super_deal:

; 6314 :     Py_XDECREF(su->obj);

  00089	48 8b 5f 68	 mov	 rbx, QWORD PTR [rdi+104]
  0008d	48 85 db	 test	 rbx, rbx
  00090	74 65		 je	 SHORT $LN11@super_deal
  00092	e8 00 00 00 00	 call	 _Py_PXCTX
  00097	85 c0		 test	 eax, eax
  00099	75 5c		 jne	 SHORT $LN11@super_deal
  0009b	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0009f	a8 20		 test	 al, 32			; 00000020H
  000a1	75 4c		 jne	 SHORT $LN25@super_deal
  000a3	84 c0		 test	 al, al
  000a5	78 48		 js	 SHORT $LN25@super_deal
  000a7	a8 02		 test	 al, 2
  000a9	75 4c		 jne	 SHORT $LN11@super_deal
  000ab	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000af	75 46		 jne	 SHORT $LN11@super_deal
  000b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000bf	4c 8b cb	 mov	 r9, rbx
  000c2	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000c8	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000d0	e8 00 00 00 00	 call	 _PyParallel_Guard
  000d5	48 8b cb	 mov	 rcx, rbx
  000d8	85 c0		 test	 eax, eax
  000da	74 07		 je	 SHORT $LN30@super_deal
  000dc	e8 00 00 00 00	 call	 _Px_Dealloc
  000e1	eb 14		 jmp	 SHORT $LN11@super_deal
$LN30@super_deal:
  000e3	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000e7	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000ed	eb 08		 jmp	 SHORT $LN11@super_deal
$LN25@super_deal:
  000ef	48 8b cb	 mov	 rcx, rbx
  000f2	e8 00 00 00 00	 call	 Px_DecRef
$LN11@super_deal:

; 6315 :     Py_XDECREF(su->type);

  000f7	48 8b 5f 60	 mov	 rbx, QWORD PTR [rdi+96]
  000fb	48 85 db	 test	 rbx, rbx
  000fe	74 65		 je	 SHORT $LN7@super_deal
  00100	e8 00 00 00 00	 call	 _Py_PXCTX
  00105	85 c0		 test	 eax, eax
  00107	75 5c		 jne	 SHORT $LN7@super_deal
  00109	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0010d	a8 20		 test	 al, 32			; 00000020H
  0010f	75 4c		 jne	 SHORT $LN36@super_deal
  00111	84 c0		 test	 al, al
  00113	78 48		 js	 SHORT $LN36@super_deal
  00115	a8 02		 test	 al, 2
  00117	75 4c		 jne	 SHORT $LN7@super_deal
  00119	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0011d	75 46		 jne	 SHORT $LN7@super_deal
  0011f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00126	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0012d	4c 8b cb	 mov	 r9, rbx
  00130	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00136	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0013e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00143	48 8b cb	 mov	 rcx, rbx
  00146	85 c0		 test	 eax, eax
  00148	74 07		 je	 SHORT $LN41@super_deal
  0014a	e8 00 00 00 00	 call	 _Px_Dealloc
  0014f	eb 14		 jmp	 SHORT $LN7@super_deal
$LN41@super_deal:
  00151	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00155	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0015b	eb 08		 jmp	 SHORT $LN7@super_deal
$LN36@super_deal:
  0015d	48 8b cb	 mov	 rcx, rbx
  00160	e8 00 00 00 00	 call	 Px_DecRef
$LN7@super_deal:

; 6316 :     Py_XDECREF(su->obj_type);

  00165	48 8b 5f 70	 mov	 rbx, QWORD PTR [rdi+112]
  00169	48 85 db	 test	 rbx, rbx
  0016c	74 65		 je	 SHORT $LN3@super_deal
  0016e	e8 00 00 00 00	 call	 _Py_PXCTX
  00173	85 c0		 test	 eax, eax
  00175	75 5c		 jne	 SHORT $LN3@super_deal
  00177	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0017b	a8 20		 test	 al, 32			; 00000020H
  0017d	75 4c		 jne	 SHORT $LN47@super_deal
  0017f	84 c0		 test	 al, al
  00181	78 48		 js	 SHORT $LN47@super_deal
  00183	a8 02		 test	 al, 2
  00185	75 4c		 jne	 SHORT $LN3@super_deal
  00187	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0018b	75 46		 jne	 SHORT $LN3@super_deal
  0018d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00194	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0019b	4c 8b cb	 mov	 r9, rbx
  0019e	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001ac	e8 00 00 00 00	 call	 _PyParallel_Guard
  001b1	48 8b cb	 mov	 rcx, rbx
  001b4	85 c0		 test	 eax, eax
  001b6	74 07		 je	 SHORT $LN52@super_deal
  001b8	e8 00 00 00 00	 call	 _Px_Dealloc
  001bd	eb 14		 jmp	 SHORT $LN3@super_deal
$LN52@super_deal:
  001bf	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  001c3	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001c9	eb 08		 jmp	 SHORT $LN3@super_deal
$LN47@super_deal:
  001cb	48 8b cb	 mov	 rcx, rbx
  001ce	e8 00 00 00 00	 call	 Px_DecRef
$LN3@super_deal:

; 6317 :     Py_TYPE(self)->tp_free(self);

  001d3	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  001d7	48 8b cf	 mov	 rcx, rdi

; 6318 : }

  001da	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001df	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001e3	5f		 pop	 rdi
  001e4	48 ff a0 98 01
	00 00		 rex_jmp QWORD PTR [rax+408]
super_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@MCAPHNNK@?$DMsuper?3?5?$DMclass?5?8?$CFs?8?$DO?0?5NULL?$DO?$AA@ ; `string'
PUBLIC	??_C@_0CD@LNFHHGFH@?$DMsuper?3?5?$DMclass?5?8?$CFs?8?$DO?0?5?$DM?$CFs?5object@ ; `string'
PUBLIC	??_C@_04HIBGFPH@NULL?$AA@			; `string'
;	COMDAT ??_C@_0BM@MCAPHNNK@?$DMsuper?3?5?$DMclass?5?8?$CFs?8?$DO?0?5NULL?$DO?$AA@
CONST	SEGMENT
??_C@_0BM@MCAPHNNK@?$DMsuper?3?5?$DMclass?5?8?$CFs?8?$DO?0?5NULL?$DO?$AA@ DB '<'
	DB	'super: <class ''%s''>, NULL>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LNFHHGFH@?$DMsuper?3?5?$DMclass?5?8?$CFs?8?$DO?0?5?$DM?$CFs?5object@
CONST	SEGMENT
??_C@_0CD@LNFHHGFH@?$DMsuper?3?5?$DMclass?5?8?$CFs?8?$DO?0?5?$DM?$CFs?5object@ DB '<'
	DB	'super: <class ''%s''>, <%s object>>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HIBGFPH@NULL?$AA@
CONST	SEGMENT
??_C@_04HIBGFPH@NULL?$AA@ DB 'NULL', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT super_repr
_TEXT	SEGMENT
self$ = 8
super_repr PROC						; COMDAT

; 6323 :     superobject *su = (superobject *)self;
; 6324 : 
; 6325 :     if (su->obj_type)

  00000	4c 8b 41 70	 mov	 r8, QWORD PTR [rcx+112]

; 6326 :         return PyUnicode_FromFormat(
; 6327 :             "<super: <class '%s'>, <%s object>>",
; 6328 :             su->type ? su->type->tp_name : "NULL",
; 6329 :             su->obj_type->tp_name);

  00004	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00008	4d 85 c0	 test	 r8, r8
  0000b	74 22		 je	 SHORT $LN2@super_repr
  0000d	48 85 d2	 test	 rdx, rdx
  00010	74 06		 je	 SHORT $LN5@super_repr
  00012	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  00016	eb 07		 jmp	 SHORT $LN6@super_repr
$LN5@super_repr:
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04HIBGFPH@NULL?$AA@
$LN6@super_repr:
  0001f	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@LNFHHGFH@?$DMsuper?3?5?$DMclass?5?8?$CFs?8?$DO?0?5?$DM?$CFs?5object@

; 6334 : }

  0002a	e9 00 00 00 00	 jmp	 PyUnicode_FromFormat
$LN2@super_repr:

; 6330 :     else
; 6331 :         return PyUnicode_FromFormat(
; 6332 :             "<super: <class '%s'>, NULL>",
; 6333 :             su->type ? su->type->tp_name : "NULL");

  0002f	48 85 d2	 test	 rdx, rdx
  00032	74 10		 je	 SHORT $LN7@super_repr
  00034	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@MCAPHNNK@?$DMsuper?3?5?$DMclass?5?8?$CFs?8?$DO?0?5NULL?$DO?$AA@

; 6334 : }

  0003f	e9 00 00 00 00	 jmp	 PyUnicode_FromFormat
$LN7@super_repr:

; 6330 :     else
; 6331 :         return PyUnicode_FromFormat(
; 6332 :             "<super: <class '%s'>, NULL>",
; 6333 :             su->type ? su->type->tp_name : "NULL");

  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04HIBGFPH@NULL?$AA@
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@MCAPHNNK@?$DMsuper?3?5?$DMclass?5?8?$CFs?8?$DO?0?5NULL?$DO?$AA@

; 6334 : }

  00052	e9 00 00 00 00	 jmp	 PyUnicode_FromFormat
super_repr ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$super_getattro DD imagerel super_getattro
	DD	imagerel super_getattro+789
	DD	imagerel $unwind$super_getattro
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$super_getattro DD 0c1c01H
	DD	0e641cH
	DD	0d541cH
	DD	0c341cH
	DD	0f018521cH
	DD	0d014e016H
	DD	07010c012H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT super_getattro
_TEXT	SEGMENT
self$ = 96
name$ = 104
super_getattro PROC					; COMDAT

; 6338 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0001c	4c 8b f1	 mov	 r14, rcx

; 6339 :     superobject *su = (superobject *)self;
; 6340 :     int skip = su->obj_type == NULL;

  0001f	33 c9		 xor	 ecx, ecx
  00021	4c 8b ea	 mov	 r13, rdx
  00024	8b c1		 mov	 eax, ecx
  00026	49 39 46 70	 cmp	 QWORD PTR [r14+112], rax
  0002a	0f 94 c0	 sete	 al

; 6341 : 
; 6342 :     if (!skip) {

  0002d	85 c0		 test	 eax, eax
  0002f	0f 85 b8 02 00
	00		 jne	 $LN62@super_geta

; 6343 :         /* We want __class__ to return the class of the super object
; 6344 :            (i.e. super, or a subclass), not the class of su->obj. */
; 6345 :         skip = (PyUnicode_Check(name) &&
; 6346 :             PyUnicode_GET_LENGTH(name) == 9 &&
; 6347 :             PyUnicode_CompareWithASCIIString(name, "__class__") == 0);

  00035	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00039	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00043	74 20		 je	 SHORT $LN18@super_geta
  00045	48 83 7a 60 09	 cmp	 QWORD PTR [rdx+96], 9
  0004a	75 19		 jne	 SHORT $LN18@super_geta
  0004c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09LFGACEKG@__class__?$AA@
  00053	49 8b cd	 mov	 rcx, r13
  00056	e8 00 00 00 00	 call	 PyUnicode_CompareWithASCIIString
  0005b	85 c0		 test	 eax, eax
  0005d	0f 84 8a 02 00
	00		 je	 $LN62@super_geta
  00063	33 c9		 xor	 ecx, ecx
$LN18@super_geta:

; 6348 :     }
; 6349 : 
; 6350 :     if (!skip) {
; 6351 :         PyObject *mro, *res, *tmp, *dict;
; 6352 :         PyTypeObject *starttype;
; 6353 :         descrgetfunc f;
; 6354 :         Py_ssize_t i, n;
; 6355 : 
; 6356 :         starttype = su->obj_type;

  00065	4d 8b 7e 70	 mov	 r15, QWORD PTR [r14+112]

; 6357 :         mro = starttype->tp_mro;
; 6358 : 
; 6359 :         if (mro == NULL)
; 6360 :             n = 0;

  00069	48 8b e9	 mov	 rbp, rcx
  0006c	49 8b 9f b0 01
	00 00		 mov	 rbx, QWORD PTR [r15+432]
  00073	48 85 db	 test	 rbx, rbx
  00076	74 04		 je	 SHORT $LN12@super_geta

; 6361 :         else {
; 6362 :             assert(PyTuple_Check(mro));
; 6363 :             n = PyTuple_GET_SIZE(mro);

  00078	48 8b 6b 60	 mov	 rbp, QWORD PTR [rbx+96]
$LN12@super_geta:

; 6364 :         }
; 6365 :         for (i = 0; i < n; i++) {

  0007c	48 8b f9	 mov	 rdi, rcx
  0007f	48 85 ed	 test	 rbp, rbp
  00082	7e 1d		 jle	 SHORT $LN71@super_geta
  00084	49 8b 4e 60	 mov	 rcx, QWORD PTR [r14+96]
  00088	48 8d 43 70	 lea	 rax, QWORD PTR [rbx+112]
  0008c	0f 1f 40 00	 npad	 4
$LL11@super_geta:

; 6366 :             if ((PyObject *)(su->type) == PyTuple_GET_ITEM(mro, i))

  00090	48 3b 08	 cmp	 rcx, QWORD PTR [rax]
  00093	74 0c		 je	 SHORT $LN71@super_geta

; 6364 :         }
; 6365 :         for (i = 0; i < n; i++) {

  00095	48 ff c7	 inc	 rdi
  00098	48 83 c0 08	 add	 rax, 8
  0009c	48 3b fd	 cmp	 rdi, rbp
  0009f	7c ef		 jl	 SHORT $LL11@super_geta
$LN71@super_geta:

; 6367 :                 break;
; 6368 :         }
; 6369 :         i++;

  000a1	48 ff c7	 inc	 rdi

; 6370 :         res = NULL;
; 6371 :         /* keep a strong reference to mro because starttype->tp_mro can be
; 6372 :            replaced during PyDict_GetItem(dict, name)  */
; 6373 :         Py_INCREF(mro);

  000a4	e8 00 00 00 00	 call	 _Py_PXCTX
  000a9	85 c0		 test	 eax, eax
  000ab	75 32		 jne	 SHORT $LN23@super_geta
  000ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000bb	4c 8b cb	 mov	 r9, rbx
  000be	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000c4	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000cc	e8 00 00 00 00	 call	 _PyParallel_Guard
  000d1	85 c0		 test	 eax, eax
  000d3	75 06		 jne	 SHORT $LN22@super_geta
  000d5	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000d9	74 04		 je	 SHORT $LN23@super_geta
$LN22@super_geta:
  000db	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN23@super_geta:

; 6374 :         for (; i < n; i++) {

  000df	48 3b fd	 cmp	 rdi, rbp
  000e2	7d 43		 jge	 SHORT $LN70@super_geta
  000e4	4c 8d 64 fb 70	 lea	 r12, QWORD PTR [rbx+rdi*8+112]
  000e9	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@super_geta:

; 6375 :             tmp = PyTuple_GET_ITEM(mro, i);

  000f0	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]

; 6376 :             if (PyType_Check(tmp))

  000f4	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  000f8	f7 80 00 01 00
	00 00 00 00 80	 test	 DWORD PTR [rax+256], -2147483648 ; ffffffff80000000H
  00102	74 17		 je	 SHORT $LN6@super_geta

; 6377 :                 dict = ((PyTypeObject *)tmp)->tp_dict;
; 6378 :             else
; 6379 :                 continue;
; 6380 :             res = PyDict_GetItem(dict, name);

  00104	48 8b 89 60 01
	00 00		 mov	 rcx, QWORD PTR [rcx+352]
  0010b	49 8b d5	 mov	 rdx, r13
  0010e	e8 00 00 00 00	 call	 PyDict_GetItem
  00113	48 8b f0	 mov	 rsi, rax

; 6381 :             if (res != NULL) {

  00116	48 85 c0	 test	 rax, rax
  00119	75 78		 jne	 SHORT $LN66@super_geta
$LN6@super_geta:

; 6374 :         for (; i < n; i++) {

  0011b	48 ff c7	 inc	 rdi
  0011e	49 83 c4 08	 add	 r12, 8
  00122	48 3b fd	 cmp	 rdi, rbp
  00125	7c c9		 jl	 SHORT $LL7@super_geta
$LN70@super_geta:

; 6400 :             }
; 6401 :         }
; 6402 :         Py_DECREF(mro);

  00127	e8 00 00 00 00	 call	 _Py_PXCTX
  0012c	85 c0		 test	 eax, eax
  0012e	0f 85 b9 01 00
	00		 jne	 $LN62@super_geta
  00134	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00138	a8 20		 test	 al, 32			; 00000020H
  0013a	0f 85 a5 01 00
	00		 jne	 $LN56@super_geta
  00140	84 c0		 test	 al, al
  00142	0f 88 9d 01 00
	00		 js	 $LN56@super_geta
  00148	a8 02		 test	 al, 2
  0014a	0f 85 9d 01 00
	00		 jne	 $LN62@super_geta
  00150	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00154	0f 85 93 01 00
	00		 jne	 $LN62@super_geta
  0015a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00161	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00168	4c 8b cb	 mov	 r9, rbx
  0016b	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00171	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00179	e8 00 00 00 00	 call	 _PyParallel_Guard
  0017e	48 8b cb	 mov	 rcx, rbx
  00181	85 c0		 test	 eax, eax
  00183	0f 84 50 01 00
	00		 je	 $LN61@super_geta
  00189	e8 00 00 00 00	 call	 _Px_Dealloc
  0018e	e9 5a 01 00 00	 jmp	 $LN62@super_geta
$LN66@super_geta:

; 6382 :                 Py_INCREF(res);

  00193	e8 00 00 00 00	 call	 _Py_PXCTX
  00198	85 c0		 test	 eax, eax
  0019a	75 32		 jne	 SHORT $LN27@super_geta
  0019c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  001aa	4c 8b ce	 mov	 r9, rsi
  001ad	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  001b3	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001bb	e8 00 00 00 00	 call	 _PyParallel_Guard
  001c0	85 c0		 test	 eax, eax
  001c2	75 06		 jne	 SHORT $LN26@super_geta
  001c4	f6 46 20 20	 test	 BYTE PTR [rsi+32], 32	; 00000020H
  001c8	74 04		 je	 SHORT $LN27@super_geta
$LN26@super_geta:
  001ca	48 ff 46 50	 inc	 QWORD PTR [rsi+80]
$LN27@super_geta:

; 6383 :                 f = Py_TYPE(res)->tp_descr_get;

  001ce	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  001d2	4c 8b 88 68 01
	00 00		 mov	 r9, QWORD PTR [rax+360]

; 6384 :                 if (f != NULL) {

  001d9	4d 85 c9	 test	 r9, r9
  001dc	0f 84 87 00 00
	00		 je	 $LN1@super_geta

; 6385 :                     tmp = f(res,
; 6386 :                         /* Only pass 'obj' param if
; 6387 :                            this is instance-mode super
; 6388 :                            (See SF ID #743627)
; 6389 :                         */
; 6390 :                         (su->obj == (PyObject *)
; 6391 :                                     su->obj_type
; 6392 :                             ? (PyObject *)NULL
; 6393 :                             : su->obj),
; 6394 :                         (PyObject *)starttype);

  001e2	49 8b 56 68	 mov	 rdx, QWORD PTR [r14+104]
  001e6	b8 00 00 00 00	 mov	 eax, 0
  001eb	4d 8b c7	 mov	 r8, r15
  001ee	49 3b 56 70	 cmp	 rdx, QWORD PTR [r14+112]
  001f2	48 8b ce	 mov	 rcx, rsi
  001f5	48 0f 44 d0	 cmove	 rdx, rax
  001f9	41 ff d1	 call	 r9
  001fc	48 8b f8	 mov	 rdi, rax

; 6395 :                     Py_DECREF(res);

  001ff	e8 00 00 00 00	 call	 _Py_PXCTX
  00204	85 c0		 test	 eax, eax
  00206	75 5e		 jne	 SHORT $LN40@super_geta
  00208	48 8b 4e 20	 mov	 rcx, QWORD PTR [rsi+32]
  0020c	f6 c1 20	 test	 cl, 32			; 00000020H
  0020f	75 4d		 jne	 SHORT $LN34@super_geta
  00211	84 c9		 test	 cl, cl
  00213	78 49		 js	 SHORT $LN34@super_geta
  00215	f6 c1 02	 test	 cl, 2
  00218	75 4c		 jne	 SHORT $LN40@super_geta
  0021a	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  0021e	75 46		 jne	 SHORT $LN40@super_geta
  00220	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00227	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0022e	4c 8b ce	 mov	 r9, rsi
  00231	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00237	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0023f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00244	48 8b ce	 mov	 rcx, rsi
  00247	85 c0		 test	 eax, eax
  00249	74 07		 je	 SHORT $LN39@super_geta
  0024b	e8 00 00 00 00	 call	 _Px_Dealloc
  00250	eb 14		 jmp	 SHORT $LN40@super_geta
$LN39@super_geta:
  00252	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  00256	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0025c	eb 08		 jmp	 SHORT $LN40@super_geta
$LN34@super_geta:
  0025e	48 8b ce	 mov	 rcx, rsi
  00261	e8 00 00 00 00	 call	 Px_DecRef
$LN40@super_geta:

; 6396 :                     res = tmp;

  00266	48 8b f7	 mov	 rsi, rdi
$LN1@super_geta:

; 6397 :                 }
; 6398 :                 Py_DECREF(mro);

  00269	e8 00 00 00 00	 call	 _Py_PXCTX
  0026e	85 c0		 test	 eax, eax
  00270	75 62		 jne	 SHORT $LN51@super_geta
  00272	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00276	a8 20		 test	 al, 32			; 00000020H
  00278	75 52		 jne	 SHORT $LN45@super_geta
  0027a	84 c0		 test	 al, al
  0027c	78 4e		 js	 SHORT $LN45@super_geta
  0027e	a8 02		 test	 al, 2
  00280	75 52		 jne	 SHORT $LN51@super_geta
  00282	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00286	75 4c		 jne	 SHORT $LN51@super_geta
  00288	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0028f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00296	4c 8b cb	 mov	 r9, rbx
  00299	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0029f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  002a7	e8 00 00 00 00	 call	 _PyParallel_Guard
  002ac	48 8b cb	 mov	 rcx, rbx
  002af	85 c0		 test	 eax, eax
  002b1	74 0a		 je	 SHORT $LN50@super_geta
  002b3	e8 00 00 00 00	 call	 _Px_Dealloc

; 6399 :                 return res;

  002b8	48 8b c6	 mov	 rax, rsi
  002bb	eb 3b		 jmp	 SHORT $LN16@super_geta

; 6397 :                 }
; 6398 :                 Py_DECREF(mro);

$LN50@super_geta:
  002bd	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  002c1	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 6399 :                 return res;

  002c7	48 8b c6	 mov	 rax, rsi
  002ca	eb 2c		 jmp	 SHORT $LN16@super_geta

; 6397 :                 }
; 6398 :                 Py_DECREF(mro);

$LN45@super_geta:
  002cc	48 8b cb	 mov	 rcx, rbx
  002cf	e8 00 00 00 00	 call	 Px_DecRef
$LN51@super_geta:

; 6399 :                 return res;

  002d4	48 8b c6	 mov	 rax, rsi
  002d7	eb 1f		 jmp	 SHORT $LN16@super_geta

; 6400 :             }
; 6401 :         }
; 6402 :         Py_DECREF(mro);

$LN61@super_geta:
  002d9	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  002dd	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  002e3	eb 08		 jmp	 SHORT $LN62@super_geta
$LN56@super_geta:
  002e5	48 8b cb	 mov	 rcx, rbx
  002e8	e8 00 00 00 00	 call	 Px_DecRef
$LN62@super_geta:

; 6403 :     }
; 6404 :     return PyObject_GenericGetAttr(self, name);

  002ed	49 8b d5	 mov	 rdx, r13
  002f0	49 8b ce	 mov	 rcx, r14
  002f3	e8 00 00 00 00	 call	 PyObject_GenericGetAttr
$LN16@super_geta:

; 6405 : }

  002f8	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  002fd	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  00302	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  00307	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0030b	41 5f		 pop	 r15
  0030d	41 5e		 pop	 r14
  0030f	41 5d		 pop	 r13
  00311	41 5c		 pop	 r12
  00313	5f		 pop	 rdi
  00314	c3		 ret	 0
super_getattro ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DN@MCJHLACM@super?$CItype?0?5obj?$CJ?3?5obj?5must?5be?5an@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$supercheck DD imagerel supercheck
	DD	imagerel supercheck+372
	DD	imagerel $unwind$supercheck
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$supercheck DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0DN@MCJHLACM@super?$CItype?0?5obj?$CJ?3?5obj?5must?5be?5an@
CONST	SEGMENT
??_C@_0DN@MCJHLACM@super?$CItype?0?5obj?$CJ?3?5obj?5must?5be?5an@ DB 'sup'
	DB	'er(type, obj): obj must be an instance or subtype of type', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
CONST	ENDS
;	COMDAT supercheck
_TEXT	SEGMENT
type$ = 64
obj$ = 72
supercheck PROC						; COMDAT

; 6409 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 6410 :     /* Check that a super() call makes sense.  Return a type object.
; 6411 : 
; 6412 :        obj can be a class, or an instance of one:
; 6413 : 
; 6414 :        - If it is a class, it must be a subclass of 'type'.      This case is
; 6415 :          used for class methods; the return value is obj.
; 6416 : 
; 6417 :        - If it is an instance, it must be an instance of 'type'.  This is
; 6418 :          the normal case; the return value is obj.__class__.
; 6419 : 
; 6420 :        But... when obj is an instance, we want to allow for the case where
; 6421 :        Py_TYPE(obj) is not a subclass of type, but obj.__class__ is!
; 6422 :        This will allow using super() with a proxy for obj.
; 6423 :     */
; 6424 : 
; 6425 :     /* Check for first bullet above (special case) */
; 6426 :     if (PyType_Check(obj) && PyType_IsSubtype((PyTypeObject *)obj, type)) {

  0000f	48 8b 7a 58	 mov	 rdi, QWORD PTR [rdx+88]
  00013	48 8b da	 mov	 rbx, rdx
  00016	48 8b f1	 mov	 rsi, rcx
  00019	f7 87 00 01 00
	00 00 00 00 80	 test	 DWORD PTR [rdi+256], -2147483648 ; ffffffff80000000H
  00023	74 5d		 je	 SHORT $LN7@supercheck
  00025	48 8b d1	 mov	 rdx, rcx
  00028	48 8b cb	 mov	 rcx, rbx
  0002b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00030	85 c0		 test	 eax, eax
  00032	74 4e		 je	 SHORT $LN7@supercheck

; 6427 :         Py_INCREF(obj);

  00034	e8 00 00 00 00	 call	 _Py_PXCTX
  00039	85 c0		 test	 eax, eax
  0003b	75 32		 jne	 SHORT $LN11@supercheck
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0004b	4c 8b cb	 mov	 r9, rbx
  0004e	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00054	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0005c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00061	85 c0		 test	 eax, eax
  00063	75 06		 jne	 SHORT $LN10@supercheck
  00065	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00069	74 04		 je	 SHORT $LN11@supercheck
$LN10@supercheck:
  0006b	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN11@supercheck:

; 6428 :         return (PyTypeObject *)obj;

  0006f	48 8b c3	 mov	 rax, rbx

; 6460 :     return NULL;
; 6461 : }

  00072	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00077	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0007c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00080	5f		 pop	 rdi
  00081	c3		 ret	 0
$LN7@supercheck:

; 6429 :     }
; 6430 : 
; 6431 :     /* Normal case */
; 6432 :     if (PyType_IsSubtype(Py_TYPE(obj), type)) {

  00082	48 8b d6	 mov	 rdx, rsi
  00085	48 8b cf	 mov	 rcx, rdi
  00088	e8 00 00 00 00	 call	 PyType_IsSubtype
  0008d	85 c0		 test	 eax, eax
  0008f	74 4f		 je	 SHORT $LN6@supercheck

; 6433 :         Py_INCREF(Py_TYPE(obj));

  00091	e8 00 00 00 00	 call	 _Py_PXCTX
  00096	85 c0		 test	 eax, eax
  00098	75 32		 jne	 SHORT $LN15@supercheck
  0009a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000a8	4c 8b cf	 mov	 r9, rdi
  000ab	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000b1	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000b9	e8 00 00 00 00	 call	 _PyParallel_Guard
  000be	85 c0		 test	 eax, eax
  000c0	75 06		 jne	 SHORT $LN14@supercheck
  000c2	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  000c6	74 04		 je	 SHORT $LN15@supercheck
$LN14@supercheck:
  000c8	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN15@supercheck:

; 6434 :         return Py_TYPE(obj);

  000cc	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 6460 :     return NULL;
; 6461 : }

  000d0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d5	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000da	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000de	5f		 pop	 rdi
  000df	c3		 ret	 0
$LN6@supercheck:

; 6435 :     }
; 6436 :     else {
; 6437 :         /* Try the slow way */
; 6438 :         PyObject *class_attr;
; 6439 : 
; 6440 :         class_attr = _PyObject_GetAttrId(obj, &PyId___class__);

  000e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000e6	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  000ef	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId___class__
  000f4	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  000f8	48 8b cb	 mov	 rcx, rbx
  000fb	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00100	4c 8b d8	 mov	 r11, rax

; 6441 :         if (class_attr != NULL &&
; 6442 :             PyType_Check(class_attr) &&
; 6443 :             (PyTypeObject *)class_attr != Py_TYPE(obj))

  00103	48 85 c0	 test	 rax, rax
  00106	74 42		 je	 SHORT $LN18@supercheck
  00108	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0010c	f7 81 00 01 00
	00 00 00 00 80	 test	 DWORD PTR [rcx+256], -2147483648 ; ffffffff80000000H
  00116	74 28		 je	 SHORT $LN2@supercheck
  00118	48 3b 43 58	 cmp	 rax, QWORD PTR [rbx+88]
  0011c	74 22		 je	 SHORT $LN2@supercheck

; 6444 :         {
; 6445 :             int ok = PyType_IsSubtype(
; 6446 :                 (PyTypeObject *)class_attr, type);

  0011e	48 8b d6	 mov	 rdx, rsi
  00121	48 8b c8	 mov	 rcx, rax
  00124	e8 00 00 00 00	 call	 PyType_IsSubtype

; 6447 :             if (ok)

  00129	85 c0		 test	 eax, eax
  0012b	74 13		 je	 SHORT $LN2@supercheck

; 6448 :                 return (PyTypeObject *)class_attr;

  0012d	49 8b c3	 mov	 rax, r11

; 6460 :     return NULL;
; 6461 : }

  00130	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00135	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0013a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0013e	5f		 pop	 rdi
  0013f	c3		 ret	 0
$LN2@supercheck:

; 6453 :         else
; 6454 :             Py_DECREF(class_attr);

  00140	49 8b cb	 mov	 rcx, r11
  00143	e8 00 00 00 00	 call	 _Py_DecRef
  00148	eb 05		 jmp	 SHORT $LN1@supercheck
$LN18@supercheck:

; 6449 :         }
; 6450 : 
; 6451 :         if (class_attr == NULL)
; 6452 :             PyErr_Clear();

  0014a	e8 00 00 00 00	 call	 PyErr_Clear
$LN1@supercheck:

; 6455 :     }
; 6456 : 
; 6457 :     PyErr_SetString(PyExc_TypeError,
; 6458 :                     "super(type, obj): "
; 6459 :                     "obj must be an instance or subtype of type");

  0014f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00156	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DN@MCJHLACM@super?$CItype?0?5obj?$CJ?3?5obj?5must?5be?5an@
  0015d	e8 00 00 00 00	 call	 PyErr_SetString

; 6460 :     return NULL;
; 6461 : }

  00162	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00167	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0016c	33 c0		 xor	 eax, eax
  0016e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00172	5f		 pop	 rdi
  00173	c3		 ret	 0
supercheck ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$super_descr_get DD imagerel super_descr_get
	DD	imagerel super_descr_get+56
	DD	imagerel $unwind$super_descr_get
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$super_descr_get DD imagerel super_descr_get+56
	DD	imagerel super_descr_get+103
	DD	imagerel $chain$0$super_descr_get
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$super_descr_get DD imagerel super_descr_get+103
	DD	imagerel super_descr_get+170
	DD	imagerel $chain$3$super_descr_get
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$super_descr_get DD imagerel super_descr_get+170
	DD	imagerel super_descr_get+208
	DD	imagerel $chain$5$super_descr_get
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$super_descr_get DD imagerel super_descr_get+208
	DD	imagerel super_descr_get+281
	DD	imagerel $chain$6$super_descr_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$super_descr_get DD 021H
	DD	imagerel super_descr_get
	DD	imagerel super_descr_get+56
	DD	imagerel $unwind$super_descr_get
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$super_descr_get DD 040021H
	DD	096400H
	DD	085400H
	DD	imagerel super_descr_get
	DD	imagerel super_descr_get+56
	DD	imagerel $unwind$super_descr_get
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$super_descr_get DD 040921H
	DD	085409H
	DD	096400H
	DD	imagerel super_descr_get
	DD	imagerel super_descr_get+56
	DD	imagerel $unwind$super_descr_get
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$super_descr_get DD 020521H
	DD	096405H
	DD	imagerel super_descr_get
	DD	imagerel super_descr_get+56
	DD	imagerel $unwind$super_descr_get
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$super_descr_get DD 040a01H
	DD	0a340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT super_descr_get
_TEXT	SEGMENT
self$ = 64
obj$ = 72
type$ = 80
super_descr_get PROC					; COMDAT

; 6465 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 6466 :     superobject *su = (superobject *)self;
; 6467 :     superobject *newobj;
; 6468 : 
; 6469 :     if (obj == NULL || obj == Py_None || su->obj != NULL) {

  00010	48 85 d2	 test	 rdx, rdx
  00013	0f 84 b7 00 00
	00		 je	 $LN5@super_desc
  00019	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00020	48 3b d0	 cmp	 rdx, rax
  00023	0f 84 a7 00 00
	00		 je	 $LN5@super_desc
  00029	48 83 79 68 00	 cmp	 QWORD PTR [rcx+104], 0
  0002e	0f 85 9c 00 00
	00		 jne	 $LN5@super_desc

; 6473 :     }
; 6474 :     if (Py_TYPE(su) != &PySuper_Type)

  00034	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00038	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  0003d	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PySuper_Type
  00044	48 3b ce	 cmp	 rcx, rsi
  00047	74 1e		 je	 SHORT $LN4@super_desc

; 6475 :         /* If su is an instance of a (strict) subclass of super,
; 6476 :            call its type */
; 6477 :         return PyObject_CallFunctionObjArgs((PyObject *)Py_TYPE(su),
; 6478 :                                             su->type, obj, NULL);

  00049	4c 8b c2	 mov	 r8, rdx
  0004c	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  00050	45 33 c9	 xor	 r9d, r9d
  00053	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 6494 :     }
; 6495 : }

  00058	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0005d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00061	5f		 pop	 rdi
  00062	e9 00 00 00 00	 jmp	 PyObject_CallFunctionObjArgs
$LN4@super_desc:

; 6479 :     else {
; 6480 :         /* Inline the common case */
; 6481 :         PyTypeObject *obj_type = supercheck(su->type, obj);

  00067	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  0006b	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  00070	e8 00 00 00 00	 call	 supercheck
  00075	48 8b e8	 mov	 rbp, rax

; 6482 :         if (obj_type == NULL)

  00078	48 85 c0	 test	 rax, rax

; 6483 :             return NULL;

  0007b	74 16		 je	 SHORT $LN15@super_desc

; 6484 :         newobj = (superobject *)PySuper_Type.tp_new(&PySuper_Type,
; 6485 :                                                  NULL, NULL);

  0007d	45 33 c0	 xor	 r8d, r8d
  00080	33 d2		 xor	 edx, edx
  00082	48 8b ce	 mov	 rcx, rsi
  00085	ff 15 90 01 00
	00		 call	 QWORD PTR PySuper_Type+400
  0008b	48 8b f0	 mov	 rsi, rax

; 6486 :         if (newobj == NULL)

  0008e	48 85 c0	 test	 rax, rax
  00091	75 17		 jne	 SHORT $LN1@super_desc
$LN15@super_desc:

; 6487 :             return NULL;

  00093	33 c0		 xor	 eax, eax
$LN14@super_desc:
  00095	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0009a	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 6494 :     }
; 6495 : }

  0009f	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000a4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a8	5f		 pop	 rdi
  000a9	c3		 ret	 0
$LN1@super_desc:

; 6488 :         Py_INCREF(su->type);

  000aa	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  000ae	e8 00 00 00 00	 call	 _Py_IncRef

; 6489 :         Py_INCREF(obj);

  000b3	48 8b cf	 mov	 rcx, rdi
  000b6	e8 00 00 00 00	 call	 _Py_IncRef

; 6490 :         newobj->type = su->type;

  000bb	4c 8b 5b 60	 mov	 r11, QWORD PTR [rbx+96]

; 6491 :         newobj->obj = obj;

  000bf	48 89 7e 68	 mov	 QWORD PTR [rsi+104], rdi
  000c3	4c 89 5e 60	 mov	 QWORD PTR [rsi+96], r11

; 6492 :         newobj->obj_type = obj_type;

  000c7	48 89 6e 70	 mov	 QWORD PTR [rsi+112], rbp

; 6493 :         return (PyObject *)newobj;

  000cb	48 8b c6	 mov	 rax, rsi
  000ce	eb c5		 jmp	 SHORT $LN14@super_desc
$LN5@super_desc:

; 6470 :         /* Not binding to an object, or already bound */
; 6471 :         Py_INCREF(self);

  000d0	e8 00 00 00 00	 call	 _Py_PXCTX
  000d5	85 c0		 test	 eax, eax
  000d7	75 32		 jne	 SHORT $LN10@super_desc
  000d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000e7	4c 8b cb	 mov	 r9, rbx
  000ea	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000f0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000f8	e8 00 00 00 00	 call	 _PyParallel_Guard
  000fd	85 c0		 test	 eax, eax
  000ff	75 06		 jne	 SHORT $LN9@super_desc
  00101	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00105	74 04		 je	 SHORT $LN10@super_desc
$LN9@super_desc:
  00107	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN10@super_desc:

; 6472 :         return self;

  0010b	48 8b c3	 mov	 rax, rbx

; 6494 :     }
; 6495 : }

  0010e	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00113	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00117	5f		 pop	 rdi
  00118	c3		 ret	 0
super_descr_get ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@OPAPJHIO@super?$CI?$CJ?3?5bad?5__class__?5cell?$AA@ ; `string'
PUBLIC	??_C@_0CG@NNBMGMFD@super?$CI?$CJ?3?5__class__?5is?5not?5a?5type@ ; `string'
PUBLIC	??_C@_0BO@HJPNCDNH@super?$CI?$CJ?3?5empty?5__class__?5cell?$AA@ ; `string'
PUBLIC	??_C@_0CC@MOBJHGCC@super?$CI?$CJ?3?5__class__?5cell?5not?5foun@ ; `string'
PUBLIC	??_C@_0BI@IIFFKHKI@super?$CI?$CJ?3?5arg?$FL0?$FN?5deleted?$AA@ ; `string'
PUBLIC	??_C@_0BG@NHMPAMBE@super?$CI?$CJ?3?5no?5arguments?$AA@ ; `string'
PUBLIC	??_C@_0BI@CDPMACLC@super?$CI?$CJ?3?5no?5code?5object?$AA@ ; `string'
PUBLIC	??_C@_0L@OCHLMMEE@?$HMO?$CBO?3super?$AA@	; `string'
EXTRN	PyCell_Type:BYTE
EXTRN	PyExc_RuntimeError:QWORD
EXTRN	_PyArg_NoKeywords:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$super_init DD imagerel super_init
	DD	imagerel super_init+761
	DD	imagerel $unwind$super_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$super_init DD 0c7f01H
	DD	06d47fH
	DD	07747aH
	DD	0e6475H
	DD	0d5470H
	DD	0e006720aH
	DD	03002c004H
xdata	ENDS
;	COMDAT ??_C@_0BM@OPAPJHIO@super?$CI?$CJ?3?5bad?5__class__?5cell?$AA@
CONST	SEGMENT
??_C@_0BM@OPAPJHIO@super?$CI?$CJ?3?5bad?5__class__?5cell?$AA@ DB 'super()'
	DB	': bad __class__ cell', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NNBMGMFD@super?$CI?$CJ?3?5__class__?5is?5not?5a?5type@
CONST	SEGMENT
??_C@_0CG@NNBMGMFD@super?$CI?$CJ?3?5__class__?5is?5not?5a?5type@ DB 'supe'
	DB	'r(): __class__ is not a type (%s)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HJPNCDNH@super?$CI?$CJ?3?5empty?5__class__?5cell?$AA@
CONST	SEGMENT
??_C@_0BO@HJPNCDNH@super?$CI?$CJ?3?5empty?5__class__?5cell?$AA@ DB 'super'
	DB	'(): empty __class__ cell', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@MOBJHGCC@super?$CI?$CJ?3?5__class__?5cell?5not?5foun@
CONST	SEGMENT
??_C@_0CC@MOBJHGCC@super?$CI?$CJ?3?5__class__?5cell?5not?5foun@ DB 'super'
	DB	'(): __class__ cell not found', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IIFFKHKI@super?$CI?$CJ?3?5arg?$FL0?$FN?5deleted?$AA@
CONST	SEGMENT
??_C@_0BI@IIFFKHKI@super?$CI?$CJ?3?5arg?$FL0?$FN?5deleted?$AA@ DB 'super('
	DB	'): arg[0] deleted', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NHMPAMBE@super?$CI?$CJ?3?5no?5arguments?$AA@
CONST	SEGMENT
??_C@_0BG@NHMPAMBE@super?$CI?$CJ?3?5no?5arguments?$AA@ DB 'super(): no ar'
	DB	'guments', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CDPMACLC@super?$CI?$CJ?3?5no?5code?5object?$AA@
CONST	SEGMENT
??_C@_0BI@CDPMACLC@super?$CI?$CJ?3?5no?5code?5object?$AA@ DB 'super(): no'
	DB	' code object', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OCHLMMEE@?$HMO?$CBO?3super?$AA@
CONST	SEGMENT
??_C@_0L@OCHLMMEE@?$HMO?$CBO?3super?$AA@ DB '|O!O:super', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT super_init
_TEXT	SEGMENT
obj$ = 96
self$ = 96
args$ = 104
kwds$ = 112
type$ = 120
super_init PROC						; COMDAT

; 6499 : {

  00000	40 53		 push	 rbx
  00002	41 54		 push	 r12
  00004	41 56		 push	 r14
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	4c 8b f1	 mov	 r14, rcx
  0000d	48 8b da	 mov	 rbx, rdx

; 6500 :     superobject *su = (superobject *)self;
; 6501 :     PyTypeObject *type = NULL;

  00010	45 33 e4	 xor	 r12d, r12d

; 6502 :     PyObject *obj = NULL;
; 6503 :     PyTypeObject *obj_type = NULL;
; 6504 : 
; 6505 :     if (!_PyArg_NoKeywords("super", kwds))

  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05MKJDPMKP@super?$AA@
  0001a	49 8b d0	 mov	 rdx, r8
  0001d	4c 89 64 24 78	 mov	 QWORD PTR type$[rsp], r12
  00022	4c 89 64 24 60	 mov	 QWORD PTR obj$[rsp], r12
  00027	e8 00 00 00 00	 call	 _PyArg_NoKeywords
  0002c	85 c0		 test	 eax, eax
  0002e	75 0d		 jne	 SHORT $LN25@super_init
$LN45@super_init:

; 6506 :         return -1;

  00030	83 c8 ff	 or	 eax, -1

; 6598 : }

  00033	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00037	41 5e		 pop	 r14
  00039	41 5c		 pop	 r12
  0003b	5b		 pop	 rbx
  0003c	c3		 ret	 0
$LN25@super_init:

; 6507 :     if (!PyArg_ParseTuple(args, "|O!O:super", &PyType_Type, &type, &obj))

  0003d	48 8d 44 24 60	 lea	 rax, QWORD PTR obj$[rsp]
  00042	4c 8d 4c 24 78	 lea	 r9, QWORD PTR type$[rsp]
  00047	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyType_Type
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@OCHLMMEE@?$HMO?$CBO?3super?$AA@
  00055	48 8b cb	 mov	 rcx, rbx
  00058	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005d	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00062	85 c0		 test	 eax, eax

; 6508 :         return -1;

  00064	74 ca		 je	 SHORT $LN45@super_init

; 6509 : 
; 6510 :     if (type == NULL) {

  00066	48 8b 4c 24 78	 mov	 rcx, QWORD PTR type$[rsp]
  0006b	48 89 6c 24 68	 mov	 QWORD PTR [rsp+104], rbp
  00070	48 89 74 24 70	 mov	 QWORD PTR [rsp+112], rsi
  00075	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0007a	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13
  0007f	48 85 c9	 test	 rcx, rcx
  00082	0f 85 f9 01 00
	00		 jne	 $LN39@super_init

; 6511 :         /* Call super(), without args -- fill in from __class__
; 6512 :            and first local variable on the stack. */
; 6513 :         PyFrameObject *f = PyThreadState_GET()->frame;

  00088	e8 00 00 00 00	 call	 _Py_PXCTX
  0008d	85 c0		 test	 eax, eax
  0008f	74 07		 je	 SHORT $LN28@super_init
  00091	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00096	eb 07		 jmp	 SHORT $LN29@super_init
$LN28@super_init:
  00098	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN29@super_init:
  0009f	4c 8b 68 10	 mov	 r13, QWORD PTR [rax+16]

; 6514 :         PyCodeObject *co = f->f_code;

  000a3	49 8b 75 78	 mov	 rsi, QWORD PTR [r13+120]

; 6515 :         Py_ssize_t i, n;
; 6516 :         if (co == NULL) {

  000a7	48 85 f6	 test	 rsi, rsi
  000aa	75 1b		 jne	 SHORT $LN22@super_init

; 6517 :             PyErr_SetString(PyExc_RuntimeError,
; 6518 :                             "super(): no code object");

  000ac	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  000b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@CDPMACLC@super?$CI?$CJ?3?5no?5code?5object?$AA@
  000ba	e8 00 00 00 00	 call	 PyErr_SetString

; 6519 :             return -1;

  000bf	83 c8 ff	 or	 eax, -1
  000c2	e9 14 02 00 00	 jmp	 $LN43@super_init
$LN22@super_init:

; 6520 :         }
; 6521 :         if (co->co_argcount == 0) {

  000c7	44 39 66 60	 cmp	 DWORD PTR [rsi+96], r12d
  000cb	75 1b		 jne	 SHORT $LN21@super_init

; 6522 :             PyErr_SetString(PyExc_RuntimeError,
; 6523 :                             "super(): no arguments");

  000cd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  000d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@NHMPAMBE@super?$CI?$CJ?3?5no?5arguments?$AA@
  000db	e8 00 00 00 00	 call	 PyErr_SetString

; 6524 :             return -1;

  000e0	83 c8 ff	 or	 eax, -1
  000e3	e9 f3 01 00 00	 jmp	 $LN43@super_init
$LN21@super_init:

; 6525 :         }
; 6526 :         obj = f->f_localsplus[0];

  000e8	49 8b 95 d0 01
	00 00		 mov	 rdx, QWORD PTR [r13+464]
  000ef	48 89 54 24 60	 mov	 QWORD PTR obj$[rsp], rdx

; 6527 :         if (obj == NULL && co->co_cell2arg) {

  000f4	48 85 d2	 test	 rdx, rdx
  000f7	75 67		 jne	 SHORT $LN15@super_init
  000f9	48 8b 96 a8 00
	00 00		 mov	 rdx, QWORD PTR [rsi+168]
  00100	48 85 d2	 test	 rdx, rdx
  00103	74 40		 je	 SHORT $LN36@super_init

; 6528 :             /* The first argument might be a cell. */
; 6529 :             n = PyTuple_GET_SIZE(co->co_cellvars);

  00105	48 8b 86 a0 00
	00 00		 mov	 rax, QWORD PTR [rsi+160]

; 6530 :             for (i = 0; i < n; i++) {

  0010c	49 8b cc	 mov	 rcx, r12
  0010f	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00113	4d 85 c0	 test	 r8, r8
  00116	7e 2d		 jle	 SHORT $LN36@super_init
$LL19@super_init:

; 6531 :                 if (co->co_cell2arg[i] == 0) {

  00118	44 38 24 0a	 cmp	 BYTE PTR [rdx+rcx], r12b
  0011c	74 0a		 je	 SHORT $LN32@super_init

; 6530 :             for (i = 0; i < n; i++) {

  0011e	48 ff c1	 inc	 rcx
  00121	49 3b c8	 cmp	 rcx, r8
  00124	7c f2		 jl	 SHORT $LL19@super_init

; 6552 :             assert(PyUnicode_Check(name));
; 6553 :             if (!PyUnicode_CompareWithASCIIString(name,
; 6554 :                                                   "__class__")) {

  00126	eb 1d		 jmp	 SHORT $LN36@super_init
$LN32@super_init:

; 6532 :                     PyObject *cell = f->f_localsplus[co->co_nlocals + i];
; 6533 :                     assert(PyCell_Check(cell));
; 6534 :                     obj = PyCell_GET(cell);

  00128	48 63 46 68	 movsxd	 rax, DWORD PTR [rsi+104]
  0012c	48 03 c1	 add	 rax, rcx
  0012f	49 8b 84 c5 d0
	01 00 00	 mov	 rax, QWORD PTR [r13+rax*8+464]
  00137	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  0013b	48 89 54 24 60	 mov	 QWORD PTR obj$[rsp], rdx

; 6535 :                     break;
; 6536 :                 }
; 6537 :             }
; 6538 :         }
; 6539 :         if (obj == NULL) {

  00140	48 85 d2	 test	 rdx, rdx
  00143	75 1b		 jne	 SHORT $LN15@super_init
$LN36@super_init:

; 6540 :             PyErr_SetString(PyExc_RuntimeError,
; 6541 :                             "super(): arg[0] deleted");

  00145	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  0014c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@IIFFKHKI@super?$CI?$CJ?3?5arg?$FL0?$FN?5deleted?$AA@
  00153	e8 00 00 00 00	 call	 PyErr_SetString

; 6542 :             return -1;

  00158	83 c8 ff	 or	 eax, -1
  0015b	e9 7b 01 00 00	 jmp	 $LN43@super_init
$LN15@super_init:

; 6543 :         }
; 6544 :         if (co->co_freevars == NULL)

  00160	48 8b ae 98 00
	00 00		 mov	 rbp, QWORD PTR [rsi+152]
  00167	48 85 ed	 test	 rbp, rbp
  0016a	75 05		 jne	 SHORT $LN14@super_init

; 6545 :             n = 0;

  0016c	49 8b ec	 mov	 rbp, r12

; 6546 :         else {

  0016f	eb 04		 jmp	 SHORT $LN13@super_init
$LN14@super_init:

; 6547 :             assert(PyTuple_Check(co->co_freevars));
; 6548 :             n = PyTuple_GET_SIZE(co->co_freevars);

  00171	48 8b 6d 60	 mov	 rbp, QWORD PTR [rbp+96]
$LN13@super_init:

; 6549 :         }
; 6550 :         for (i = 0; i < n; i++) {

  00175	49 8b dc	 mov	 rbx, r12
  00178	48 85 ed	 test	 rbp, rbp
  0017b	7e 31		 jle	 SHORT $LN37@super_init
  0017d	bf 70 00 00 00	 mov	 edi, 112		; 00000070H
$LL12@super_init:

; 6551 :             PyObject *name = PyTuple_GET_ITEM(co->co_freevars, i);

  00182	48 8b 86 98 00
	00 00		 mov	 rax, QWORD PTR [rsi+152]

; 6552 :             assert(PyUnicode_Check(name));
; 6553 :             if (!PyUnicode_CompareWithASCIIString(name,
; 6554 :                                                   "__class__")) {

  00189	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09LFGACEKG@__class__?$AA@
  00190	48 8b 0c 07	 mov	 rcx, QWORD PTR [rdi+rax]
  00194	e8 00 00 00 00	 call	 PyUnicode_CompareWithASCIIString
  00199	85 c0		 test	 eax, eax
  0019b	74 3a		 je	 SHORT $LN33@super_init

; 6549 :         }
; 6550 :         for (i = 0; i < n; i++) {

  0019d	48 ff c3	 inc	 rbx
  001a0	48 83 c7 08	 add	 rdi, 8
  001a4	48 3b dd	 cmp	 rbx, rbp
  001a7	7c d9		 jl	 SHORT $LL12@super_init

; 6552 :             assert(PyUnicode_Check(name));
; 6553 :             if (!PyUnicode_CompareWithASCIIString(name,
; 6554 :                                                   "__class__")) {

  001a9	48 8b 54 24 60	 mov	 rdx, QWORD PTR obj$[rsp]
$LN37@super_init:

; 6561 :                     return -1;

  001ae	48 8b 4c 24 78	 mov	 rcx, QWORD PTR type$[rsp]
$LN10@super_init:

; 6574 :                 }
; 6575 :                 break;
; 6576 :             }
; 6577 :         }
; 6578 :         if (type == NULL) {

  001b3	48 85 c9	 test	 rcx, rcx
  001b6	0f 85 ca 00 00
	00		 jne	 $LN4@super_init

; 6579 :             PyErr_SetString(PyExc_RuntimeError,
; 6580 :                             "super(): __class__ cell not found");

  001bc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  001c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@MOBJHGCC@super?$CI?$CJ?3?5__class__?5cell?5not?5foun@
  001ca	e8 00 00 00 00	 call	 PyErr_SetString
$LN44@super_init:

; 6581 :             return -1;

  001cf	83 c8 ff	 or	 eax, -1
  001d2	e9 04 01 00 00	 jmp	 $LN43@super_init
$LN33@super_init:

; 6555 :                 Py_ssize_t index = co->co_nlocals +
; 6556 :                     PyTuple_GET_SIZE(co->co_cellvars) + i;
; 6557 :                 PyObject *cell = f->f_localsplus[index];

  001d7	48 63 4e 68	 movsxd	 rcx, DWORD PTR [rsi+104]
  001db	48 8b 86 a0 00
	00 00		 mov	 rax, QWORD PTR [rsi+160]
  001e2	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  001e6	48 03 d1	 add	 rdx, rcx
  001e9	48 03 d3	 add	 rdx, rbx
  001ec	49 8b 8c d5 d0
	01 00 00	 mov	 rcx, QWORD PTR [r13+rdx*8+464]

; 6558 :                 if (cell == NULL || !PyCell_Check(cell)) {

  001f4	48 85 c9	 test	 rcx, rcx
  001f7	74 70		 je	 SHORT $LN7@super_init
  001f9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyCell_Type
  00200	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00204	75 63		 jne	 SHORT $LN7@super_init

; 6562 :                 }
; 6563 :                 type = (PyTypeObject *) PyCell_GET(cell);

  00206	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0020a	48 89 4c 24 78	 mov	 QWORD PTR type$[rsp], rcx

; 6564 :                 if (type == NULL) {

  0020f	48 85 c9	 test	 rcx, rcx
  00212	75 1b		 jne	 SHORT $LN6@super_init

; 6565 :                     PyErr_SetString(PyExc_RuntimeError,
; 6566 :                       "super(): empty __class__ cell");

  00214	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  0021b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@HJPNCDNH@super?$CI?$CJ?3?5empty?5__class__?5cell?$AA@
  00222	e8 00 00 00 00	 call	 PyErr_SetString

; 6567 :                     return -1;

  00227	83 c8 ff	 or	 eax, -1
  0022a	e9 ac 00 00 00	 jmp	 $LN43@super_init
$LN6@super_init:

; 6568 :                 }
; 6569 :                 if (!PyType_Check(type)) {

  0022f	4c 8b 41 58	 mov	 r8, QWORD PTR [rcx+88]
  00233	41 f7 80 00 01
	00 00 00 00 00
	80		 test	 DWORD PTR [r8+256], -2147483648 ; ffffffff80000000H
  0023e	75 1f		 jne	 SHORT $LN38@super_init

; 6570 :                     PyErr_Format(PyExc_RuntimeError,
; 6571 :                       "super(): __class__ is not a type (%s)",
; 6572 :                       Py_TYPE(type)->tp_name);

  00240	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00244	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  0024b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@NNBMGMFD@super?$CI?$CJ?3?5__class__?5is?5not?5a?5type@
  00252	e8 00 00 00 00	 call	 PyErr_Format

; 6573 :                     return -1;

  00257	83 c8 ff	 or	 eax, -1
  0025a	e9 7c 00 00 00	 jmp	 $LN43@super_init
$LN38@super_init:

; 6552 :             assert(PyUnicode_Check(name));
; 6553 :             if (!PyUnicode_CompareWithASCIIString(name,
; 6554 :                                                   "__class__")) {

  0025f	48 8b 54 24 60	 mov	 rdx, QWORD PTR obj$[rsp]
  00264	e9 4a ff ff ff	 jmp	 $LN10@super_init
$LN7@super_init:

; 6559 :                     PyErr_SetString(PyExc_RuntimeError,
; 6560 :                       "super(): bad __class__ cell");

  00269	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00270	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@OPAPJHIO@super?$CI?$CJ?3?5bad?5__class__?5cell?$AA@
  00277	e8 00 00 00 00	 call	 PyErr_SetString

; 6561 :                     return -1;

  0027c	83 c8 ff	 or	 eax, -1
  0027f	eb 5a		 jmp	 SHORT $LN43@super_init
$LN39@super_init:

; 6581 :             return -1;

  00281	48 8b 54 24 60	 mov	 rdx, QWORD PTR obj$[rsp]
$LN4@super_init:

; 6582 :         }
; 6583 :     }
; 6584 : 
; 6585 :     if (obj == Py_None)

  00286	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0028d	48 3b d0	 cmp	 rdx, rax
  00290	75 07		 jne	 SHORT $LN3@super_init

; 6586 :         obj = NULL;

  00292	4c 89 64 24 60	 mov	 QWORD PTR obj$[rsp], r12

; 6587 :     if (obj != NULL) {

  00297	eb 25		 jmp	 SHORT $LN2@super_init
$LN3@super_init:
  00299	48 85 d2	 test	 rdx, rdx
  0029c	74 20		 je	 SHORT $LN2@super_init

; 6588 :         obj_type = supercheck(type, obj);

  0029e	e8 00 00 00 00	 call	 supercheck
  002a3	4c 8b e0	 mov	 r12, rax

; 6589 :         if (obj_type == NULL)

  002a6	48 85 c0	 test	 rax, rax

; 6590 :             return -1;

  002a9	0f 84 20 ff ff
	ff		 je	 $LN44@super_init

; 6591 :         Py_INCREF(obj);

  002af	48 8b 4c 24 60	 mov	 rcx, QWORD PTR obj$[rsp]
  002b4	e8 00 00 00 00	 call	 _Py_IncRef
  002b9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR type$[rsp]
$LN2@super_init:

; 6592 :     }
; 6593 :     Py_INCREF(type);

  002be	e8 00 00 00 00	 call	 _Py_IncRef

; 6594 :     su->type = type;
; 6595 :     su->obj = obj;

  002c3	48 8b 44 24 60	 mov	 rax, QWORD PTR obj$[rsp]
  002c8	4c 8b 5c 24 78	 mov	 r11, QWORD PTR type$[rsp]
  002cd	49 89 46 68	 mov	 QWORD PTR [r14+104], rax
  002d1	4d 89 5e 60	 mov	 QWORD PTR [r14+96], r11

; 6596 :     su->obj_type = obj_type;

  002d5	4d 89 66 70	 mov	 QWORD PTR [r14+112], r12

; 6597 :     return 0;

  002d9	33 c0		 xor	 eax, eax
$LN43@super_init:
  002db	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  002e0	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  002e5	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  002ea	4c 8b 6c 24 30	 mov	 r13, QWORD PTR [rsp+48]

; 6598 : }

  002ef	48 83 c4 40	 add	 rsp, 64			; 00000040H
  002f3	41 5e		 pop	 r14
  002f5	41 5c		 pop	 r12
  002f7	5b		 pop	 rbx
  002f8	c3		 ret	 0
super_init ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@NIMMLEPG@super_traverse?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$super_traverse DD imagerel super_traverse
	DD	imagerel super_traverse+207
	DD	imagerel $unwind$super_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$super_traverse DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0P@NIMMLEPG@super_traverse?$AA@
CONST	SEGMENT
??_C@_0P@NIMMLEPG@super_traverse?$AA@ DB 'super_traverse', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT super_traverse
_TEXT	SEGMENT
self$ = 48
visit$ = 56
arg$ = 64
super_traverse PROC					; COMDAT

; 6617 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 6618 :     superobject *su = (superobject *)self;
; 6619 : 
; 6620 :     Py_VISIT(su->obj);

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 1c		 je	 SHORT $LN15@super_trav
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@NIMMLEPG@super_traverse?$AA@
  0002f	45 33 c9	 xor	 r9d, r9d
  00032	41 b8 dc 19 00
	00		 mov	 r8d, 6620		; 000019dcH
  00038	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN15@super_trav:
  0003d	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  00041	48 85 c9	 test	 rcx, rcx
  00044	74 09		 je	 SHORT $LN17@super_trav
  00046	48 8b d7	 mov	 rdx, rdi
  00049	ff d6		 call	 rsi
  0004b	85 c0		 test	 eax, eax
  0004d	75 70		 jne	 SHORT $LN19@super_trav
$LN17@super_trav:

; 6621 :     Py_VISIT(su->type);

  0004f	e8 00 00 00 00	 call	 _Py_PXCTX
  00054	85 c0		 test	 eax, eax
  00056	74 1c		 je	 SHORT $LN9@super_trav
  00058	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  0005f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@NIMMLEPG@super_traverse?$AA@
  00066	45 33 c9	 xor	 r9d, r9d
  00069	41 b8 dd 19 00
	00		 mov	 r8d, 6621		; 000019ddH
  0006f	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@super_trav:
  00074	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00078	48 85 c9	 test	 rcx, rcx
  0007b	74 09		 je	 SHORT $LN11@super_trav
  0007d	48 8b d7	 mov	 rdx, rdi
  00080	ff d6		 call	 rsi
  00082	85 c0		 test	 eax, eax
  00084	75 39		 jne	 SHORT $LN19@super_trav
$LN11@super_trav:

; 6622 :     Py_VISIT(su->obj_type);

  00086	e8 00 00 00 00	 call	 _Py_PXCTX
  0008b	85 c0		 test	 eax, eax
  0008d	74 1c		 je	 SHORT $LN3@super_trav
  0008f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@NIMMLEPG@super_traverse?$AA@
  0009d	45 33 c9	 xor	 r9d, r9d
  000a0	41 b8 de 19 00
	00		 mov	 r8d, 6622		; 000019deH
  000a6	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@super_trav:
  000ab	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  000af	48 85 c9	 test	 rcx, rcx
  000b2	74 09		 je	 SHORT $LN5@super_trav
  000b4	48 8b d7	 mov	 rdx, rdi
  000b7	ff d6		 call	 rsi
  000b9	85 c0		 test	 eax, eax
  000bb	75 02		 jne	 SHORT $LN19@super_trav
$LN5@super_trav:

; 6623 : 
; 6624 :     return 0;

  000bd	33 c0		 xor	 eax, eax
$LN19@super_trav:

; 6625 : }

  000bf	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000c4	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000c9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cd	5f		 pop	 rdi
  000ce	c3		 ret	 0
super_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@HNKCEFEF@PyType_ClearCache?$AA@	; `string'
PUBLIC	PyType_ClearCache
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyType_ClearCache DD imagerel $LN24
	DD	imagerel $LN24+320
	DD	imagerel $unwind$PyType_ClearCache
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyType_ClearCache DD 0a5301H
	DD	083453H
	DD	0b7415H
	DD	0a6415H
	DD	095415H
	DD	0c0115215H
xdata	ENDS
;	COMDAT ??_C@_0BC@HNKCEFEF@PyType_ClearCache?$AA@
CONST	SEGMENT
??_C@_0BC@HNKCEFEF@PyType_ClearCache?$AA@ DB 'PyType_ClearCache', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
CONST	ENDS
;	COMDAT PyType_ClearCache
_TEXT	SEGMENT
PyType_ClearCache PROC					; COMDAT

; 53   : {

$LN24:
  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	41 54		 push	 r12
  00011	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 54   :     Py_ssize_t i;
; 55   :     unsigned int cur_version_tag = next_version_tag - 1;

  00015	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR next_version_tag

; 56   :     Py_GUARD

  0001b	e8 00 00 00 00	 call	 _Py_PXCTX
  00020	85 c0		 test	 eax, eax
  00022	74 1a		 je	 SHORT $LN8@PyType_Cle
  00024	45 33 c9	 xor	 r9d, r9d
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@HNKCEFEF@PyType_ClearCache?$AA@
  00035	45 8d 41 38	 lea	 r8d, QWORD PTR [r9+56]
  00039	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN8@PyType_Cle:

; 57   : 
; 58   :     for (i = 0; i < (1 << MCACHE_SIZE_EXP); i++) {

  0003e	48 8d 3d 08 00
	00 00		 lea	 rdi, OFFSET FLAT:method_cache+8
  00045	33 ed		 xor	 ebp, ebp
  00047	4c 8d 25 08 30
	00 00		 lea	 r12, OFFSET FLAT:method_cache+12296
  0004e	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00053	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL7@PyType_Cle:

; 59   :         method_cache[i].version = 0;
; 60   :         Py_CLEAR(method_cache[i].name);

  00060	4c 8b 0f	 mov	 r9, QWORD PTR [rdi]
  00063	89 6f f8	 mov	 DWORD PTR [rdi-8], ebp
  00066	4d 85 c9	 test	 r9, r9
  00069	0f 84 90 00 00
	00		 je	 $LN3@PyType_Cle
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@HNKCEFEF@PyType_ClearCache?$AA@
  0007d	41 b8 3c 00 00
	00		 mov	 r8d, 60			; 0000003cH
  00083	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0008b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00090	85 c0		 test	 eax, eax
  00092	75 6b		 jne	 SHORT $LN3@PyType_Cle
  00094	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
  00097	48 89 2f	 mov	 QWORD PTR [rdi], rbp
  0009a	e8 00 00 00 00	 call	 _Py_PXCTX
  0009f	85 c0		 test	 eax, eax
  000a1	75 5c		 jne	 SHORT $LN3@PyType_Cle
  000a3	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000a7	a8 20		 test	 al, 32			; 00000020H
  000a9	75 4c		 jne	 SHORT $LN15@PyType_Cle
  000ab	84 c0		 test	 al, al
  000ad	78 48		 js	 SHORT $LN15@PyType_Cle
  000af	a8 02		 test	 al, 2
  000b1	75 4c		 jne	 SHORT $LN3@PyType_Cle
  000b3	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000b7	75 46		 jne	 SHORT $LN3@PyType_Cle
  000b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c7	4c 8b cb	 mov	 r9, rbx
  000ca	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000d0	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000d8	e8 00 00 00 00	 call	 _PyParallel_Guard
  000dd	48 8b cb	 mov	 rcx, rbx
  000e0	85 c0		 test	 eax, eax
  000e2	74 07		 je	 SHORT $LN20@PyType_Cle
  000e4	e8 00 00 00 00	 call	 _Px_Dealloc
  000e9	eb 14		 jmp	 SHORT $LN3@PyType_Cle
$LN20@PyType_Cle:
  000eb	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000ef	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000f5	eb 08		 jmp	 SHORT $LN3@PyType_Cle
$LN15@PyType_Cle:
  000f7	48 8b cb	 mov	 rcx, rbx
  000fa	e8 00 00 00 00	 call	 Px_DecRef
$LN3@PyType_Cle:

; 61   :         method_cache[i].value = NULL;

  000ff	48 89 6f 08	 mov	 QWORD PTR [rdi+8], rbp
  00103	48 83 c7 18	 add	 rdi, 24
  00107	49 3b fc	 cmp	 rdi, r12
  0010a	0f 8c 50 ff ff
	ff		 jl	 $LL7@PyType_Cle

; 62   :     }
; 63   :     next_version_tag = 0;
; 64   :     /* mark all version tags as invalid */
; 65   :     PyType_Modified(&PyBaseObject_Type);

  00110	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBaseObject_Type
  00117	89 2d 00 00 00
	00		 mov	 DWORD PTR next_version_tag, ebp
  0011d	e8 00 00 00 00	 call	 PyType_Modified
  00122	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 66   :     return cur_version_tag;
; 67   : }

  00127	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0012c	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00131	8d 46 ff	 lea	 eax, DWORD PTR [rsi-1]
  00134	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00139	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0013d	41 5c		 pop	 r12
  0013f	c3		 ret	 0
PyType_ClearCache ENDP
_TEXT	ENDS
PUBLIC	_PyType_Fini
; Function compile flags: /Ogtpy
;	COMDAT _PyType_Fini
_TEXT	SEGMENT
_PyType_Fini PROC					; COMDAT

; 72   :     PyType_ClearCache();
; 73   : }

  00000	e9 00 00 00 00	 jmp	 PyType_ClearCache
_PyType_Fini ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$type_mro_modified DD imagerel type_mro_modified
	DD	imagerel type_mro_modified+25
	DD	imagerel $unwind$type_mro_modified
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$type_mro_modified DD imagerel type_mro_modified+25
	DD	imagerel type_mro_modified+103
	DD	imagerel $chain$0$type_mro_modified
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$type_mro_modified DD imagerel type_mro_modified+103
	DD	imagerel type_mro_modified+120
	DD	imagerel $chain$2$type_mro_modified
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$type_mro_modified DD imagerel type_mro_modified+120
	DD	imagerel type_mro_modified+131
	DD	imagerel $chain$3$type_mro_modified
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$type_mro_modified DD 021H
	DD	imagerel type_mro_modified
	DD	imagerel type_mro_modified+25
	DD	imagerel $unwind$type_mro_modified
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$type_mro_modified DD 020021H
	DD	063400H
	DD	imagerel type_mro_modified
	DD	imagerel type_mro_modified+25
	DD	imagerel $unwind$type_mro_modified
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$type_mro_modified DD 020521H
	DD	063405H
	DD	imagerel type_mro_modified
	DD	imagerel type_mro_modified+25
	DD	imagerel $unwind$type_mro_modified
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_mro_modified DD 040a01H
	DD	07640aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT type_mro_modified
_TEXT	SEGMENT
type$ = 48
bases$ = 56
type_mro_modified PROC					; COMDAT

; 118  : type_mro_modified(PyTypeObject *type, PyObject *bases) {

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 119  :     /*
; 120  :        Check that all base classes or elements of the MRO of type are
; 121  :        able to be cached.  This function is called after the base
; 122  :        classes or mro of the type are altered.
; 123  : 
; 124  :        Unset HAVE_VERSION_TAG and VALID_VERSION_TAG if the type
; 125  :        has a custom MRO that includes a type which is not officially
; 126  :        super type.
; 127  : 
; 128  :        Called from mro_internal, which will subsequently be called on
; 129  :        each subclass when their mro is recursively updated.
; 130  :      */
; 131  :     Py_ssize_t i, n;
; 132  :     int clear = 0;
; 133  : 
; 134  :     if (!PyType_HasFeature(type, Py_TPFLAGS_HAVE_VERSION_TAG))

  0000a	8b b9 00 01 00
	00		 mov	 edi, DWORD PTR [rcx+256]
  00010	48 8b f1	 mov	 rsi, rcx
  00013	0f ba e7 12	 bt	 edi, 18
  00017	73 5f		 jae	 SHORT $LN1@type_mro_m

; 135  :         return;
; 136  : 
; 137  :     n = PyTuple_GET_SIZE(bases);

  00019	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0001e	48 8b 5a 60	 mov	 rbx, QWORD PTR [rdx+96]

; 138  :     for (i = 0; i < n; i++) {

  00022	45 33 d2	 xor	 r10d, r10d
  00025	48 85 db	 test	 rbx, rbx
  00028	7e 49		 jle	 SHORT $LN14@type_mro_m

; 135  :         return;
; 136  : 
; 137  :     n = PyTuple_GET_SIZE(bases);

  0002a	4c 8d 5a 70	 lea	 r11, QWORD PTR [rdx+112]
  0002e	66 90		 npad	 2
$LL6@type_mro_m:

; 139  :         PyObject *b = PyTuple_GET_ITEM(bases, i);
; 140  :         PyTypeObject *cls;
; 141  : 
; 142  :         assert(PyType_Check(b));
; 143  :         cls = (PyTypeObject *)b;

  00030	49 8b 13	 mov	 rdx, QWORD PTR [r11]

; 144  : 
; 145  :         if (!PyType_HasFeature(cls, Py_TPFLAGS_HAVE_VERSION_TAG) ||
; 146  :             !PyType_IsSubtype(type, cls)) {

  00033	f7 82 00 01 00
	00 00 00 04 00	 test	 DWORD PTR [rdx+256], 262144 ; 00040000H
  0003d	74 28		 je	 SHORT $LN11@type_mro_m
  0003f	48 8b ce	 mov	 rcx, rsi
  00042	e8 00 00 00 00	 call	 PyType_IsSubtype
  00047	85 c0		 test	 eax, eax
  00049	74 1c		 je	 SHORT $LN11@type_mro_m

; 138  :     for (i = 0; i < n; i++) {

  0004b	49 ff c2	 inc	 r10
  0004e	49 83 c3 08	 add	 r11, 8
  00052	4c 3b d3	 cmp	 r10, rbx
  00055	7c d9		 jl	 SHORT $LL6@type_mro_m
  00057	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 155  : }

  0005c	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00061	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00065	5f		 pop	 rdi
  00066	c3		 ret	 0
$LN11@type_mro_m:

; 147  :             clear = 1;
; 148  :             break;
; 149  :         }
; 150  :     }
; 151  : 
; 152  :     if (clear)
; 153  :         type->tp_flags &= ~(Py_TPFLAGS_HAVE_VERSION_TAG|
; 154  :                             Py_TPFLAGS_VALID_VERSION_TAG);

  00067	81 e7 ff ff f3
	ff		 and	 edi, -786433		; fffffffffff3ffffH
  0006d	89 be 00 01 00
	00		 mov	 DWORD PTR [rsi+256], edi
$LN14@type_mro_m:
  00073	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
$LN1@type_mro_m:

; 155  : }

  00078	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00081	5f		 pop	 rdi
  00082	c3		 ret	 0
type_mro_modified ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@DBBFJFOD@cannot?5create?5?8?$CF?4100s?8?5instances@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$type_call DD imagerel type_call
	DD	imagerel type_call+241
	DD	imagerel $unwind$type_call
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_call DD 085201H
	DD	063452H
	DD	08640fH
	DD	07540fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0CB@DBBFJFOD@cannot?5create?5?8?$CF?4100s?8?5instances@
CONST	SEGMENT
??_C@_0CB@DBBFJFOD@cannot?5create?5?8?$CF?4100s?8?5instances@ DB 'cannot '
	DB	'create ''%.100s'' instances', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT type_call
_TEXT	SEGMENT
type$ = 48
args$ = 56
kwds$ = 64
type_call PROC						; COMDAT

; 722  : {

  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 723  :     PyObject *obj;
; 724  : 
; 725  :     if (type->tp_new == NULL) {

  0000f	48 8b 81 90 01
	00 00		 mov	 rax, QWORD PTR [rcx+400]
  00016	49 8b f0	 mov	 rsi, r8
  00019	48 8b ea	 mov	 rbp, rdx
  0001c	48 8b f9	 mov	 rdi, rcx
  0001f	48 85 c0	 test	 rax, rax
  00022	75 29		 jne	 SHORT $LN6@type_call

; 726  :         PyErr_Format(PyExc_TypeError,
; 727  :                      "cannot create '%.100s' instances",
; 728  :                      type->tp_name);

  00024	4c 8b 41 70	 mov	 r8, QWORD PTR [rcx+112]
  00028	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@DBBFJFOD@cannot?5create?5?8?$CF?4100s?8?5instances@
  00036	e8 00 00 00 00	 call	 PyErr_Format

; 729  :         return NULL;

  0003b	33 c0		 xor	 eax, eax

; 750  :         }
; 751  :     }
; 752  :     return obj;
; 753  : }

  0003d	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00042	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5f		 pop	 rdi
  0004c	c3		 ret	 0
$LN6@type_call:
  0004d	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 730  :     }
; 731  : 
; 732  :     obj = type->tp_new(type, args, kwds);

  00052	ff d0		 call	 rax
  00054	48 8b d8	 mov	 rbx, rax

; 733  :     if (obj != NULL) {

  00057	48 85 c0	 test	 rax, rax
  0005a	74 7d		 je	 SHORT $LN1@type_call

; 734  :         /* Ugly exception: when the call was type(something),
; 735  :            don't call tp_init on the result. */
; 736  :         if (type == &PyType_Type &&
; 737  :             PyTuple_Check(args) && PyTuple_GET_SIZE(args) == 1 &&
; 738  :             (kwds == NULL ||
; 739  :              (PyDict_Check(kwds) && PyDict_Size(kwds) == 0)))

  0005c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyType_Type
  00063	48 3b f8	 cmp	 rdi, rax
  00066	75 39		 jne	 SHORT $LN4@type_call
  00068	48 8b 4d 58	 mov	 rcx, QWORD PTR [rbp+88]
  0006c	f7 81 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rcx+256], 67108864 ; 04000000H
  00076	74 29		 je	 SHORT $LN4@type_call
  00078	48 83 7d 60 01	 cmp	 QWORD PTR [rbp+96], 1
  0007d	75 22		 jne	 SHORT $LN4@type_call
  0007f	48 85 f6	 test	 rsi, rsi
  00082	74 55		 je	 SHORT $LN1@type_call
  00084	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  00088	f7 80 00 01 00
	00 00 00 00 20	 test	 DWORD PTR [rax+256], 536870912 ; 20000000H
  00092	74 0d		 je	 SHORT $LN4@type_call
  00094	48 8b ce	 mov	 rcx, rsi
  00097	e8 00 00 00 00	 call	 PyDict_Size
  0009c	48 85 c0	 test	 rax, rax

; 740  :             return obj;

  0009f	74 38		 je	 SHORT $LN1@type_call
$LN4@type_call:

; 741  :         /* If the returned object is not an instance of type,
; 742  :            it won't be initialized. */
; 743  :         if (!PyType_IsSubtype(Py_TYPE(obj), type))

  000a1	4c 8b 53 58	 mov	 r10, QWORD PTR [rbx+88]
  000a5	48 8b d7	 mov	 rdx, rdi
  000a8	49 8b ca	 mov	 rcx, r10
  000ab	e8 00 00 00 00	 call	 PyType_IsSubtype
  000b0	85 c0		 test	 eax, eax

; 744  :             return obj;

  000b2	74 25		 je	 SHORT $LN1@type_call

; 745  :         type = Py_TYPE(obj);
; 746  :         if (type->tp_init != NULL &&
; 747  :             type->tp_init(obj, args, kwds) < 0) {

  000b4	49 8b 82 80 01
	00 00		 mov	 rax, QWORD PTR [r10+384]
  000bb	48 85 c0	 test	 rax, rax
  000be	74 19		 je	 SHORT $LN1@type_call
  000c0	4c 8b c6	 mov	 r8, rsi
  000c3	48 8b d5	 mov	 rdx, rbp
  000c6	48 8b cb	 mov	 rcx, rbx
  000c9	ff d0		 call	 rax
  000cb	85 c0		 test	 eax, eax
  000cd	79 0a		 jns	 SHORT $LN1@type_call

; 748  :             Py_DECREF(obj);

  000cf	48 8b cb	 mov	 rcx, rbx
  000d2	e8 00 00 00 00	 call	 _Py_DecRef

; 749  :             obj = NULL;

  000d7	33 db		 xor	 ebx, ebx
$LN1@type_call:

; 750  :         }
; 751  :     }
; 752  :     return obj;
; 753  : }

  000d9	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000de	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000e3	48 8b c3	 mov	 rax, rbx
  000e6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000eb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ef	5f		 pop	 rdi
  000f0	c3		 ret	 0
type_call ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$lookup_maybe DD imagerel lookup_maybe
	DD	imagerel lookup_maybe+142
	DD	imagerel $unwind$lookup_maybe
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lookup_maybe DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT lookup_maybe
_TEXT	SEGMENT
self$ = 64
attrid$ = 72
lookup_maybe PROC					; COMDAT

; 1195 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 1196 :     PyObject *res;
; 1197 : 
; 1198 :     res = _PyType_LookupId(Py_TYPE(self), attrid);

  0000d	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00011	e8 00 00 00 00	 call	 _PyType_LookupId
  00016	48 8b d8	 mov	 rbx, rax

; 1199 :     if (res != NULL) {

  00019	48 85 c0	 test	 rax, rax
  0001c	74 65		 je	 SHORT $LN1@lookup_may

; 1200 :         descrgetfunc f;
; 1201 :         if ((f = Py_TYPE(res)->tp_descr_get) == NULL)

  0001e	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00022	48 8b 82 68 01
	00 00		 mov	 rax, QWORD PTR [rdx+360]
  00029	48 85 c0	 test	 rax, rax
  0002c	75 49		 jne	 SHORT $LN2@lookup_may

; 1202 :             Py_INCREF(res);

  0002e	e8 00 00 00 00	 call	 _Py_PXCTX
  00033	85 c0		 test	 eax, eax
  00035	75 32		 jne	 SHORT $LN11@lookup_may
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00045	4c 8b cb	 mov	 r9, rbx
  00048	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0004e	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00056	e8 00 00 00 00	 call	 _PyParallel_Guard
  0005b	85 c0		 test	 eax, eax
  0005d	75 06		 jne	 SHORT $LN6@lookup_may
  0005f	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H

; 1203 :         else
; 1204 :             res = f(res, self, (PyObject *)(Py_TYPE(self)));

  00063	74 04		 je	 SHORT $LN11@lookup_may

; 1202 :             Py_INCREF(res);

$LN6@lookup_may:
  00065	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN11@lookup_may:

; 1205 :     }
; 1206 :     return res;

  00069	48 8b c3	 mov	 rax, rbx

; 1207 : }

  0006c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00071	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00075	5f		 pop	 rdi
  00076	c3		 ret	 0
$LN2@lookup_may:

; 1203 :         else
; 1204 :             res = f(res, self, (PyObject *)(Py_TYPE(self)));

  00077	4c 8b 47 58	 mov	 r8, QWORD PTR [rdi+88]
  0007b	48 8b d7	 mov	 rdx, rdi
  0007e	48 8b cb	 mov	 rcx, rbx
  00081	ff d0		 call	 rax
$LN1@lookup_may:

; 1207 : }

  00083	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00088	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008c	5f		 pop	 rdi
  0008d	c3		 ret	 0
lookup_maybe ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lookup_method DD imagerel lookup_method
	DD	imagerel lookup_method+66
	DD	imagerel $unwind$lookup_method
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lookup_method DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT lookup_method
_TEXT	SEGMENT
self$ = 48
attrid$ = 56
lookup_method PROC					; COMDAT

; 1211 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx

; 1212 :     PyObject *res = lookup_maybe(self, attrid);

  0000d	e8 00 00 00 00	 call	 lookup_maybe
  00012	48 8b d8	 mov	 rbx, rax

; 1213 :     if (res == NULL && !PyErr_Occurred())

  00015	48 85 c0	 test	 rax, rax
  00018	75 1d		 jne	 SHORT $LN1@lookup_met
  0001a	e8 00 00 00 00	 call	 PyErr_Occurred
  0001f	48 85 c0	 test	 rax, rax
  00022	75 10		 jne	 SHORT $LN5@lookup_met

; 1214 :         PyErr_SetObject(PyExc_AttributeError, attrid->object);

  00024	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  00028	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  0002f	e8 00 00 00 00	 call	 PyErr_SetObject
$LN5@lookup_met:

; 1215 :     return res;

  00034	48 8b c3	 mov	 rax, rbx
$LN1@lookup_met:

; 1216 : }

  00037	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
lookup_method ENDP
_TEXT	ENDS
PUBLIC	_PyObject_LookupSpecial
; Function compile flags: /Ogtpy
;	COMDAT _PyObject_LookupSpecial
_TEXT	SEGMENT
self$ = 8
attrid$ = 16
_PyObject_LookupSpecial PROC				; COMDAT

; 1221 :     return lookup_maybe(self, attrid);
; 1222 : }

  00000	e9 00 00 00 00	 jmp	 lookup_maybe
_PyObject_LookupSpecial ENDP
_TEXT	ENDS
EXTRN	Py_VaBuildValue:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$call_method DD imagerel call_method
	DD	imagerel call_method+158
	DD	imagerel $unwind$call_method
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$call_method DD 041101H
	DD	0700d3211H
	DD	0300b600cH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT call_method
_TEXT	SEGMENT
o$ = 64
nameid$ = 72
format$ = 80
call_method PROC					; COMDAT

; 1230 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000a	53		 push	 rbx
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00011	48 8b da	 mov	 rbx, rdx

; 1231 :     va_list va;
; 1232 :     PyObject *args, *func = 0, *retval;
; 1233 :     va_start(va, format);

  00014	48 8d 7c 24 58	 lea	 rdi, QWORD PTR format$[rsp+8]

; 1234 : 
; 1235 :     func = lookup_maybe(o, nameid);

  00019	e8 00 00 00 00	 call	 lookup_maybe
  0001e	48 8b f0	 mov	 rsi, rax

; 1236 :     if (func == NULL) {

  00021	48 85 c0	 test	 rax, rax
  00024	75 24		 jne	 SHORT $LN5@call_metho

; 1237 :         va_end(va);
; 1238 :         if (!PyErr_Occurred())

  00026	e8 00 00 00 00	 call	 PyErr_Occurred
  0002b	48 85 c0	 test	 rax, rax
  0002e	75 10		 jne	 SHORT $LN4@call_metho

; 1239 :             PyErr_SetObject(PyExc_AttributeError, nameid->object);

  00030	48 8b 53 10	 mov	 rdx, QWORD PTR [rbx+16]
  00034	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  0003b	e8 00 00 00 00	 call	 PyErr_SetObject
$LN4@call_metho:

; 1240 :         return NULL;

  00040	33 c0		 xor	 eax, eax

; 1260 : }

  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	5e		 pop	 rsi
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
$LN5@call_metho:

; 1241 :     }
; 1242 : 
; 1243 :     if (format && *format)

  0004a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR format$[rsp]
  0004f	48 85 c9	 test	 rcx, rcx
  00052	74 0f		 je	 SHORT $LN3@call_metho
  00054	80 39 00	 cmp	 BYTE PTR [rcx], 0
  00057	74 0a		 je	 SHORT $LN3@call_metho

; 1244 :         args = Py_VaBuildValue(format, va);

  00059	48 8b d7	 mov	 rdx, rdi
  0005c	e8 00 00 00 00	 call	 Py_VaBuildValue

; 1245 :     else

  00061	eb 07		 jmp	 SHORT $LN8@call_metho
$LN3@call_metho:

; 1246 :         args = PyTuple_New(0);

  00063	33 c9		 xor	 ecx, ecx
  00065	e8 00 00 00 00	 call	 PyTuple_New
$LN8@call_metho:
  0006a	48 8b f8	 mov	 rdi, rax

; 1247 : 
; 1248 :     va_end(va);
; 1249 : 
; 1250 :     if (args == NULL)

  0006d	48 85 c0	 test	 rax, rax

; 1251 :         return NULL;

  00070	74 ce		 je	 SHORT $LN4@call_metho

; 1252 : 
; 1253 :     assert(PyTuple_Check(args));
; 1254 :     retval = PyObject_Call(func, args, NULL);

  00072	45 33 c0	 xor	 r8d, r8d
  00075	48 8b d0	 mov	 rdx, rax
  00078	48 8b ce	 mov	 rcx, rsi
  0007b	e8 00 00 00 00	 call	 PyObject_Call

; 1255 : 
; 1256 :     Py_DECREF(args);

  00080	48 8b cf	 mov	 rcx, rdi
  00083	48 8b d8	 mov	 rbx, rax
  00086	e8 00 00 00 00	 call	 _Py_DecRef

; 1257 :     Py_DECREF(func);

  0008b	48 8b ce	 mov	 rcx, rsi
  0008e	e8 00 00 00 00	 call	 _Py_DecRef

; 1258 : 
; 1259 :     return retval;

  00093	48 8b c3	 mov	 rax, rbx

; 1260 : }

  00096	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009a	5f		 pop	 rdi
  0009b	5e		 pop	 rsi
  0009c	5b		 pop	 rbx
  0009d	c3		 ret	 0
call_method ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$call_maybe DD imagerel call_maybe
	DD	imagerel call_maybe+141
	DD	imagerel $unwind$call_maybe
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$call_maybe DD imagerel call_maybe+141
	DD	imagerel call_maybe+193
	DD	imagerel $chain$0$call_maybe
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$call_maybe DD imagerel call_maybe+193
	DD	imagerel call_maybe+241
	DD	imagerel $chain$2$call_maybe
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$call_maybe DD 020021H
	DD	067400H
	DD	imagerel call_maybe
	DD	imagerel call_maybe+141
	DD	imagerel $unwind$call_maybe
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$call_maybe DD 020521H
	DD	067405H
	DD	imagerel call_maybe
	DD	imagerel call_maybe+141
	DD	imagerel $unwind$call_maybe
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$call_maybe DD 031001H
	DD	0600c6210H
	DD	0300bH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT call_maybe
_TEXT	SEGMENT
o$ = 80
nameid$ = 88
format$ = 96
call_maybe PROC						; COMDAT

; 1266 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000a	53		 push	 rbx
  0000b	56		 push	 rsi
  0000c	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1267 :     va_list va;
; 1268 :     PyObject *args, *func = 0, *retval;
; 1269 :     va_start(va, format);

  00010	48 8d 5c 24 68	 lea	 rbx, QWORD PTR format$[rsp+8]

; 1270 : 
; 1271 :     func = lookup_maybe(o, nameid);

  00015	e8 00 00 00 00	 call	 lookup_maybe
  0001a	48 8b f0	 mov	 rsi, rax

; 1272 :     if (func == NULL) {

  0001d	48 85 c0	 test	 rax, rax
  00020	75 66		 jne	 SHORT $LN5@call_maybe

; 1273 :         va_end(va);
; 1274 :         if (!PyErr_Occurred())

  00022	e8 00 00 00 00	 call	 PyErr_Occurred
  00027	48 85 c0	 test	 rax, rax
  0002a	75 53		 jne	 SHORT $LN4@call_maybe

; 1275 :             Py_RETURN_NOTIMPLEMENTED;

  0002c	e8 00 00 00 00	 call	 _Py_PXCTX
  00031	85 c0		 test	 eax, eax
  00033	75 3c		 jne	 SHORT $LN9@call_maybe
  00035	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0004a	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00050	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00058	e8 00 00 00 00	 call	 _PyParallel_Guard
  0005d	85 c0		 test	 eax, eax
  0005f	75 09		 jne	 SHORT $LN8@call_maybe
  00061	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  00068	74 07		 je	 SHORT $LN9@call_maybe
$LN8@call_maybe:
  0006a	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN9@call_maybe:
  00071	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 1296 : }

  00078	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007c	5e		 pop	 rsi
  0007d	5b		 pop	 rbx
  0007e	c3		 ret	 0
$LN4@call_maybe:

; 1276 :         return NULL;

  0007f	33 c0		 xor	 eax, eax

; 1296 : }

  00081	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00085	5e		 pop	 rsi
  00086	5b		 pop	 rbx
  00087	c3		 ret	 0
$LN5@call_maybe:

; 1277 :     }
; 1278 : 
; 1279 :     if (format && *format)

  00088	48 8b 4c 24 60	 mov	 rcx, QWORD PTR format$[rsp]
  0008d	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00092	48 85 c9	 test	 rcx, rcx
  00095	74 0f		 je	 SHORT $LN3@call_maybe
  00097	80 39 00	 cmp	 BYTE PTR [rcx], 0
  0009a	74 0a		 je	 SHORT $LN3@call_maybe

; 1280 :         args = Py_VaBuildValue(format, va);

  0009c	48 8b d3	 mov	 rdx, rbx
  0009f	e8 00 00 00 00	 call	 Py_VaBuildValue

; 1281 :     else

  000a4	eb 07		 jmp	 SHORT $LN13@call_maybe
$LN3@call_maybe:

; 1282 :         args = PyTuple_New(0);

  000a6	33 c9		 xor	 ecx, ecx
  000a8	e8 00 00 00 00	 call	 PyTuple_New
$LN13@call_maybe:
  000ad	48 8b f8	 mov	 rdi, rax

; 1283 : 
; 1284 :     va_end(va);
; 1285 : 
; 1286 :     if (args == NULL)

  000b0	48 85 c0	 test	 rax, rax
  000b3	75 0c		 jne	 SHORT $LN1@call_maybe
  000b5	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1296 : }

  000ba	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000be	5e		 pop	 rsi
  000bf	5b		 pop	 rbx
  000c0	c3		 ret	 0
$LN1@call_maybe:

; 1287 :         return NULL;
; 1288 : 
; 1289 :     assert(PyTuple_Check(args));
; 1290 :     retval = PyObject_Call(func, args, NULL);

  000c1	45 33 c0	 xor	 r8d, r8d
  000c4	48 8b d7	 mov	 rdx, rdi
  000c7	48 8b ce	 mov	 rcx, rsi
  000ca	e8 00 00 00 00	 call	 PyObject_Call

; 1291 : 
; 1292 :     Py_DECREF(args);

  000cf	48 8b cf	 mov	 rcx, rdi
  000d2	48 8b d8	 mov	 rbx, rax
  000d5	e8 00 00 00 00	 call	 _Py_DecRef

; 1293 :     Py_DECREF(func);

  000da	48 8b ce	 mov	 rcx, rsi
  000dd	e8 00 00 00 00	 call	 _Py_DecRef
  000e2	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1294 : 
; 1295 :     return retval;

  000e7	48 8b c3	 mov	 rax, rbx

; 1296 : }

  000ea	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ee	5e		 pop	 rsi
  000ef	5b		 pop	 rbx
  000f0	c3		 ret	 0
call_maybe ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@JPMDLIMJ@mro?$CI?$CJ?5returned?5a?5non?9class?5?$CI?8?$CF?45@ ; `string'
PUBLIC	??_C@_0DG@JNNGGHAI@mro?$CI?$CJ?5returned?5base?5with?5unsuita@ ; `string'
EXTRN	PySequence_Tuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$mro_internal DD imagerel mro_internal
	DD	imagerel mro_internal+394
	DD	imagerel $unwind$mro_internal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mro_internal DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
xdata	ENDS
;	COMDAT ??_C@_0CG@JPMDLIMJ@mro?$CI?$CJ?5returned?5a?5non?9class?5?$CI?8?$CF?45@
CONST	SEGMENT
??_C@_0CG@JPMDLIMJ@mro?$CI?$CJ?5returned?5a?5non?9class?5?$CI?8?$CF?45@ DB 'm'
	DB	'ro() returned a non-class (''%.500s'')', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@JNNGGHAI@mro?$CI?$CJ?5returned?5base?5with?5unsuita@
CONST	SEGMENT
??_C@_0DG@JNNGGHAI@mro?$CI?$CJ?5returned?5base?5with?5unsuita@ DB 'mro() '
	DB	'returned base with unsuitable layout (''%.500s'')', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT mro_internal
_TEXT	SEGMENT
type$ = 48
mro_internal PROC					; COMDAT

; 1588 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1589 :     PyObject *mro, *result, *tuple;
; 1590 :     int checkit = 0;

  0001a	33 db		 xor	 ebx, ebx

; 1591 : 
; 1592 :     if (Py_TYPE(type) == &PyType_Type) {

  0001c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyType_Type
  00023	48 8b f9	 mov	 rdi, rcx
  00026	44 8b e3	 mov	 r12d, ebx
  00029	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0002d	75 0a		 jne	 SHORT $LN11@mro_intern

; 1593 :         result = mro_implementation(type);

  0002f	e8 00 00 00 00	 call	 mro_implementation
  00034	48 8b e8	 mov	 rbp, rax

; 1594 :     }
; 1595 :     else {

  00037	eb 47		 jmp	 SHORT $LN10@mro_intern
$LN11@mro_intern:

; 1596 :         _Py_IDENTIFIER(mro);
; 1597 :         checkit = 1;
; 1598 :         mro = lookup_method((PyObject *)type, &PyId_mro);

  00039	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0003f	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00048	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_mro@?3??mro_internal@@9@9
  0004d	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00051	48 8b cf	 mov	 rcx, rdi
  00054	41 bc 01 00 00
	00		 mov	 r12d, 1
  0005a	e8 00 00 00 00	 call	 lookup_method
  0005f	48 8b f0	 mov	 rsi, rax

; 1599 :         if (mro == NULL)

  00062	48 85 c0	 test	 rax, rax

; 1600 :             return -1;

  00065	0f 84 1a 01 00
	00		 je	 $LN18@mro_intern

; 1601 :         result = PyObject_CallObject(mro, NULL);

  0006b	33 d2		 xor	 edx, edx
  0006d	48 8b c8	 mov	 rcx, rax
  00070	e8 00 00 00 00	 call	 PyObject_CallObject

; 1602 :         Py_DECREF(mro);

  00075	48 8b ce	 mov	 rcx, rsi
  00078	48 8b e8	 mov	 rbp, rax
  0007b	e8 00 00 00 00	 call	 _Py_DecRef
$LN10@mro_intern:

; 1603 :     }
; 1604 :     if (result == NULL)

  00080	48 85 ed	 test	 rbp, rbp

; 1605 :         return -1;

  00083	0f 84 fc 00 00
	00		 je	 $LN18@mro_intern

; 1606 :     tuple = PySequence_Tuple(result);

  00089	48 8b cd	 mov	 rcx, rbp
  0008c	e8 00 00 00 00	 call	 PySequence_Tuple

; 1607 :     Py_DECREF(result);

  00091	48 8b cd	 mov	 rcx, rbp
  00094	48 8b f0	 mov	 rsi, rax
  00097	e8 00 00 00 00	 call	 _Py_DecRef

; 1608 :     if (tuple == NULL)

  0009c	48 85 f6	 test	 rsi, rsi

; 1609 :         return -1;

  0009f	0f 84 e0 00 00
	00		 je	 $LN18@mro_intern

; 1610 :     if (checkit) {

  000a5	45 85 e4	 test	 r12d, r12d
  000a8	74 52		 je	 SHORT $LN3@mro_intern

; 1611 :         Py_ssize_t i, len;
; 1612 :         PyObject *cls;
; 1613 :         PyTypeObject *solid;
; 1614 : 
; 1615 :         solid = solid_base(type);

  000aa	48 8b cf	 mov	 rcx, rdi
  000ad	e8 00 00 00 00	 call	 solid_base

; 1616 : 
; 1617 :         len = PyTuple_GET_SIZE(tuple);

  000b2	48 8b 6e 60	 mov	 rbp, QWORD PTR [rsi+96]
  000b6	4c 8b e0	 mov	 r12, rax

; 1618 : 
; 1619 :         for (i = 0; i < len; i++) {

  000b9	48 85 ed	 test	 rbp, rbp
  000bc	7e 3e		 jle	 SHORT $LN3@mro_intern

; 1611 :         Py_ssize_t i, len;
; 1612 :         PyObject *cls;
; 1613 :         PyTypeObject *solid;
; 1614 : 
; 1615 :         solid = solid_base(type);

  000be	4c 8d 56 70	 lea	 r10, QWORD PTR [rsi+112]
$LL5@mro_intern:

; 1620 :             PyTypeObject *t;
; 1621 :             cls = PyTuple_GET_ITEM(tuple, i);

  000c2	4d 8b 1a	 mov	 r11, QWORD PTR [r10]

; 1622 :             if (!PyType_Check(cls)) {

  000c5	49 8b 4b 58	 mov	 rcx, QWORD PTR [r11+88]
  000c9	f7 81 00 01 00
	00 00 00 00 80	 test	 DWORD PTR [rcx+256], -2147483648 ; ffffffff80000000H
  000d3	0f 84 8d 00 00
	00		 je	 $LN15@mro_intern

; 1628 :             }
; 1629 :             t = (PyTypeObject*)cls;
; 1630 :             if (!PyType_IsSubtype(solid, solid_base(t))) {

  000d9	49 8b cb	 mov	 rcx, r11
  000dc	e8 00 00 00 00	 call	 solid_base
  000e1	49 8b cc	 mov	 rcx, r12
  000e4	48 8b d0	 mov	 rdx, rax
  000e7	e8 00 00 00 00	 call	 PyType_IsSubtype
  000ec	85 c0		 test	 eax, eax
  000ee	74 52		 je	 SHORT $LN16@mro_intern

; 1618 : 
; 1619 :         for (i = 0; i < len; i++) {

  000f0	48 ff c3	 inc	 rbx
  000f3	49 83 c2 08	 add	 r10, 8
  000f7	48 3b dd	 cmp	 rbx, rbp
  000fa	7c c6		 jl	 SHORT $LL5@mro_intern
$LN3@mro_intern:

; 1636 :             }
; 1637 :         }
; 1638 :     }
; 1639 :     type->tp_mro = tuple;
; 1640 : 
; 1641 :     type_mro_modified(type, type->tp_mro);

  000fc	48 8b d6	 mov	 rdx, rsi
  000ff	48 8b cf	 mov	 rcx, rdi
  00102	48 89 b7 b0 01
	00 00		 mov	 QWORD PTR [rdi+432], rsi
  00109	e8 00 00 00 00	 call	 type_mro_modified

; 1642 :     /* corner case: the super class might have been hidden
; 1643 :        from the custom MRO */
; 1644 :     type_mro_modified(type, type->tp_bases);

  0010e	48 8b 97 a8 01
	00 00		 mov	 rdx, QWORD PTR [rdi+424]
  00115	48 8b cf	 mov	 rcx, rdi
  00118	e8 00 00 00 00	 call	 type_mro_modified

; 1645 : 
; 1646 :     PyType_Modified(type);

  0011d	48 8b cf	 mov	 rcx, rdi
  00120	e8 00 00 00 00	 call	 PyType_Modified

; 1647 : 
; 1648 :     return 0;

  00125	33 c0		 xor	 eax, eax
$LN12@mro_intern:

; 1649 : }

  00127	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0012c	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00131	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00136	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0013b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0013f	41 5c		 pop	 r12
  00141	c3		 ret	 0
$LN16@mro_intern:

; 1631 :                 PyErr_Format(PyExc_TypeError,
; 1632 :              "mro() returned base with unsuitable layout ('%.500s')",
; 1633 :                                      t->tp_name);

  00142	4d 8b 43 70	 mov	 r8, QWORD PTR [r11+112]
  00146	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0014d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@JNNGGHAI@mro?$CI?$CJ?5returned?5base?5with?5unsuita@
  00154	e8 00 00 00 00	 call	 PyErr_Format

; 1634 :                         Py_DECREF(tuple);

  00159	48 8b ce	 mov	 rcx, rsi
  0015c	e8 00 00 00 00	 call	 _Py_DecRef

; 1635 :                         return -1;

  00161	83 c8 ff	 or	 eax, -1
  00164	eb c1		 jmp	 SHORT $LN12@mro_intern
$LN15@mro_intern:

; 1623 :                 PyErr_Format(PyExc_TypeError,
; 1624 :                  "mro() returned a non-class ('%.500s')",
; 1625 :                                  Py_TYPE(cls)->tp_name);

  00166	4c 8b 41 70	 mov	 r8, QWORD PTR [rcx+112]
  0016a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00171	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@JPMDLIMJ@mro?$CI?$CJ?5returned?5a?5non?9class?5?$CI?8?$CF?45@
  00178	e8 00 00 00 00	 call	 PyErr_Format

; 1626 :                 Py_DECREF(tuple);

  0017d	48 8b ce	 mov	 rcx, rsi
  00180	e8 00 00 00 00	 call	 _Py_DecRef
$LN18@mro_intern:

; 1627 :                 return -1;

  00185	83 c8 ff	 or	 eax, -1
  00188	eb 9d		 jmp	 SHORT $LN12@mro_intern
mro_internal ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_dict_descriptor DD imagerel get_dict_descriptor
	DD	imagerel get_dict_descriptor+60
	DD	imagerel $unwind$get_dict_descriptor
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_dict_descriptor DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT get_dict_descriptor
_TEXT	SEGMENT
type$ = 48
get_dict_descriptor PROC				; COMDAT

; 1767 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1768 :     PyObject *descr;
; 1769 : 
; 1770 :     descr = _PyType_LookupId(type, &PyId___dict__);

  00004	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0000b	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00014	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId___dict__
  00019	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  0001d	e8 00 00 00 00	 call	 _PyType_LookupId

; 1771 :     if (descr == NULL || !PyDescr_IsData(descr))

  00022	48 85 c0	 test	 rax, rax
  00025	74 0e		 je	 SHORT $LN1@get_dict_d
  00027	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0002b	48 83 b9 70 01
	00 00 00	 cmp	 QWORD PTR [rcx+368], 0

; 1773 : 
; 1774 :     return descr;

  00033	75 02		 jne	 SHORT $LN3@get_dict_d
$LN1@get_dict_d:

; 1772 :         return NULL;

  00035	33 c0		 xor	 eax, eax
$LN3@get_dict_d:

; 1775 : }

  00037	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003b	c3		 ret	 0
get_dict_descriptor ENDP
_TEXT	ENDS
EXTRN	PyObject_GenericGetDict:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$subtype_dict DD imagerel subtype_dict
	DD	imagerel subtype_dict+99
	DD	imagerel $unwind$subtype_dict
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$subtype_dict DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT subtype_dict
_TEXT	SEGMENT
obj$ = 48
context$ = 56
subtype_dict PROC					; COMDAT

; 1787 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1788 :     PyTypeObject *base;
; 1789 : 
; 1790 :     base = get_builtin_base_with_dict(Py_TYPE(obj));

  00009	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0000d	e8 00 00 00 00	 call	 get_builtin_base_with_dict

; 1791 :     if (base != NULL) {

  00012	48 85 c0	 test	 rax, rax
  00015	74 3f		 je	 SHORT $LN3@subtype_di

; 1792 :         descrgetfunc func;
; 1793 :         PyObject *descr = get_dict_descriptor(base);

  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 get_dict_descriptor
  0001f	48 8b c8	 mov	 rcx, rax

; 1794 :         if (descr == NULL) {

  00022	48 85 c0	 test	 rax, rax
  00025	75 10		 jne	 SHORT $LN2@subtype_di
$LN6@subtype_di:

; 1795 :             raise_dict_descr_error(obj);

  00027	48 8b cb	 mov	 rcx, rbx
  0002a	e8 00 00 00 00	 call	 raise_dict_descr_error

; 1796 :             return NULL;

  0002f	33 c0		 xor	 eax, eax

; 1806 : }

  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5b		 pop	 rbx
  00036	c3		 ret	 0
$LN2@subtype_di:

; 1797 :         }
; 1798 :         func = Py_TYPE(descr)->tp_descr_get;

  00037	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003b	4c 8b 88 68 01
	00 00		 mov	 r9, QWORD PTR [rax+360]

; 1799 :         if (func == NULL) {

  00042	4d 85 c9	 test	 r9, r9

; 1800 :             raise_dict_descr_error(obj);
; 1801 :             return NULL;

  00045	74 e0		 je	 SHORT $LN6@subtype_di

; 1802 :         }
; 1803 :         return func(descr, obj, (PyObject *)(Py_TYPE(obj)));

  00047	4c 8b 43 58	 mov	 r8, QWORD PTR [rbx+88]
  0004b	48 8b d3	 mov	 rdx, rbx

; 1806 : }

  0004e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00052	5b		 pop	 rbx
  00053	49 ff e1	 rex_jmp r9
$LN3@subtype_di:

; 1804 :     }
; 1805 :     return PyObject_GenericGetDict(obj, context);

  00056	48 8b cb	 mov	 rcx, rbx

; 1806 : }

  00059	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005d	5b		 pop	 rbx
  0005e	e9 00 00 00 00	 jmp	 PyObject_GenericGetDict
subtype_dict ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@NPFGEKPJ@__dict__?5must?5be?5set?5to?5a?5dictio@ ; `string'
PUBLIC	??_C@_0BM@OFDEHIMA@This?5object?5has?5no?5__dict__?$AA@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$subtype_setdict DD imagerel subtype_setdict
	DD	imagerel subtype_setdict+317
	DD	imagerel $unwind$subtype_setdict
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$subtype_setdict DD 06d801H
	DD	0864d8H
	DD	09340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0DF@NPFGEKPJ@__dict__?5must?5be?5set?5to?5a?5dictio@
CONST	SEGMENT
??_C@_0DF@NPFGEKPJ@__dict__?5must?5be?5set?5to?5a?5dictio@ DB '__dict__ m'
	DB	'ust be set to a dictionary, not a ''%.200s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OFDEHIMA@This?5object?5has?5no?5__dict__?$AA@
CONST	SEGMENT
??_C@_0BM@OFDEHIMA@This?5object?5has?5no?5__dict__?$AA@ DB 'This object h'
	DB	'as no __dict__', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
CONST	ENDS
;	COMDAT subtype_setdict
_TEXT	SEGMENT
obj$ = 64
value$ = 72
context$ = 80
subtype_setdict PROC					; COMDAT

; 1810 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 1811 :     PyObject *dict, **dictptr;
; 1812 :     PyTypeObject *base;
; 1813 : 
; 1814 :     base = get_builtin_base_with_dict(Py_TYPE(obj));

  0000d	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00011	48 8b da	 mov	 rbx, rdx
  00014	e8 00 00 00 00	 call	 get_builtin_base_with_dict

; 1815 :     if (base != NULL) {

  00019	48 85 c0	 test	 rax, rax
  0001c	74 49		 je	 SHORT $LN13@subtype_se

; 1816 :         descrsetfunc func;
; 1817 :         PyObject *descr = get_dict_descriptor(base);

  0001e	48 8b c8	 mov	 rcx, rax
  00021	e8 00 00 00 00	 call	 get_dict_descriptor
  00026	48 8b c8	 mov	 rcx, rax

; 1818 :         if (descr == NULL) {

  00029	48 85 c0	 test	 rax, rax
  0002c	75 16		 jne	 SHORT $LN12@subtype_se
$LN20@subtype_se:

; 1819 :             raise_dict_descr_error(obj);

  0002e	48 8b cf	 mov	 rcx, rdi
  00031	e8 00 00 00 00	 call	 raise_dict_descr_error

; 1820 :             return -1;

  00036	83 c8 ff	 or	 eax, -1

; 1846 :     return 0;
; 1847 : }

  00039	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0003e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00042	5f		 pop	 rdi
  00043	c3		 ret	 0
$LN12@subtype_se:

; 1821 :         }
; 1822 :         func = Py_TYPE(descr)->tp_descr_set;

  00044	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00048	4c 8b 88 70 01
	00 00		 mov	 r9, QWORD PTR [rax+368]

; 1823 :         if (func == NULL) {

  0004f	4d 85 c9	 test	 r9, r9

; 1824 :             raise_dict_descr_error(obj);
; 1825 :             return -1;

  00052	74 da		 je	 SHORT $LN20@subtype_se

; 1826 :         }
; 1827 :         return func(descr, obj, value);

  00054	4c 8b c3	 mov	 r8, rbx
  00057	48 8b d7	 mov	 rdx, rdi

; 1846 :     return 0;
; 1847 : }

  0005a	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0005f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00063	5f		 pop	 rdi
  00064	49 ff e1	 rex_jmp r9
$LN13@subtype_se:

; 1828 :     }
; 1829 :     /* Almost like PyObject_GenericSetDict, but allow __dict__ to be deleted. */
; 1830 :     dictptr = _PyObject_GetDictPtr(obj);

  00067	48 8b cf	 mov	 rcx, rdi
  0006a	e8 00 00 00 00	 call	 _PyObject_GetDictPtr
  0006f	48 8b f8	 mov	 rdi, rax

; 1831 :     if (dictptr == NULL) {

  00072	48 85 c0	 test	 rax, rax
  00075	75 21		 jne	 SHORT $LN10@subtype_se

; 1832 :         PyErr_SetString(PyExc_AttributeError,
; 1833 :                         "This object has no __dict__");

  00077	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  0007e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@OFDEHIMA@This?5object?5has?5no?5__dict__?$AA@
  00085	e8 00 00 00 00	 call	 PyErr_SetString

; 1834 :         return -1;

  0008a	83 c8 ff	 or	 eax, -1

; 1846 :     return 0;
; 1847 : }

  0008d	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00092	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00096	5f		 pop	 rdi
  00097	c3		 ret	 0
$LN10@subtype_se:

; 1835 :     }
; 1836 :     if (value != NULL && !PyDict_Check(value)) {

  00098	48 85 db	 test	 rbx, rbx
  0009b	74 36		 je	 SHORT $LN9@subtype_se
  0009d	4c 8b 43 58	 mov	 r8, QWORD PTR [rbx+88]
  000a1	41 f7 80 00 01
	00 00 00 00 00
	20		 test	 DWORD PTR [r8+256], 536870912 ; 20000000H
  000ac	75 25		 jne	 SHORT $LN9@subtype_se

; 1837 :         PyErr_Format(PyExc_TypeError,
; 1838 :                      "__dict__ must be set to a dictionary, "
; 1839 :                      "not a '%.200s'", Py_TYPE(value)->tp_name);

  000ae	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  000b2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@NPFGEKPJ@__dict__?5must?5be?5set?5to?5a?5dictio@
  000c0	e8 00 00 00 00	 call	 PyErr_Format

; 1840 :         return -1;

  000c5	83 c8 ff	 or	 eax, -1

; 1846 :     return 0;
; 1847 : }

  000c8	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000cd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d1	5f		 pop	 rdi
  000d2	c3		 ret	 0
$LN9@subtype_se:
  000d3	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi

; 1841 :     }
; 1842 :     dict = *dictptr;

  000d8	48 8b 30	 mov	 rsi, QWORD PTR [rax]

; 1843 :     Py_XINCREF(value);

  000db	48 85 db	 test	 rbx, rbx
  000de	74 3b		 je	 SHORT $LN7@subtype_se
  000e0	e8 00 00 00 00	 call	 _Py_PXCTX
  000e5	85 c0		 test	 eax, eax
  000e7	75 32		 jne	 SHORT $LN7@subtype_se
  000e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000f7	4c 8b cb	 mov	 r9, rbx
  000fa	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00100	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00108	e8 00 00 00 00	 call	 _PyParallel_Guard
  0010d	85 c0		 test	 eax, eax
  0010f	75 06		 jne	 SHORT $LN16@subtype_se
  00111	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00115	74 04		 je	 SHORT $LN7@subtype_se
$LN16@subtype_se:
  00117	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN7@subtype_se:

; 1844 :     *dictptr = value;

  0011b	48 89 1f	 mov	 QWORD PTR [rdi], rbx

; 1845 :     Py_XDECREF(dict);

  0011e	48 85 f6	 test	 rsi, rsi
  00121	74 08		 je	 SHORT $LN3@subtype_se
  00123	48 8b ce	 mov	 rcx, rsi
  00126	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@subtype_se:

; 1846 :     return 0;
; 1847 : }

  0012b	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00130	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00135	33 c0		 xor	 eax, eax
  00137	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0013b	5f		 pop	 rdi
  0013c	c3		 ret	 0
subtype_setdict ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@NJLOGGPG@type?4__init__?$CI?$CJ?5takes?51?5or?53?5arg@ ; `string'
PUBLIC	??_C@_0CL@FELHNPNO@type?4__init__?$CI?$CJ?5takes?5no?5keyword@ ; `string'
EXTRN	PyTuple_GetSlice:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$type_init DD imagerel type_init
	DD	imagerel type_init+216
	DD	imagerel $unwind$type_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_init DD 06a601H
	DD	0674a6H
	DD	07340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT ??_C@_0CH@NJLOGGPG@type?4__init__?$CI?$CJ?5takes?51?5or?53?5arg@
CONST	SEGMENT
??_C@_0CH@NJLOGGPG@type?4__init__?$CI?$CJ?5takes?51?5or?53?5arg@ DB 'type'
	DB	'.__init__() takes 1 or 3 arguments', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@FELHNPNO@type?4__init__?$CI?$CJ?5takes?5no?5keyword@
CONST	SEGMENT
??_C@_0CL@FELHNPNO@type?4__init__?$CI?$CJ?5takes?5no?5keyword@ DB 'type._'
	DB	'_init__() takes no keyword arguments', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT type_init
_TEXT	SEGMENT
cls$ = 48
args$ = 56
kwds$ = 64
type_init PROC						; COMDAT

; 1918 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	48 8b f1	 mov	 rsi, rcx

; 1919 :     int res;
; 1920 : 
; 1921 :     assert(args != NULL && PyTuple_Check(args));
; 1922 :     assert(kwds == NULL || PyDict_Check(kwds));
; 1923 : 
; 1924 :     if (kwds != NULL && PyDict_Check(kwds) && PyDict_Size(kwds) != 0) {

  00010	4d 85 c0	 test	 r8, r8
  00013	74 3e		 je	 SHORT $LN2@type_init
  00015	49 8b 40 58	 mov	 rax, QWORD PTR [r8+88]
  00019	f7 80 00 01 00
	00 00 00 00 20	 test	 DWORD PTR [rax+256], 536870912 ; 20000000H
  00023	74 2e		 je	 SHORT $LN2@type_init
  00025	49 8b c8	 mov	 rcx, r8
  00028	e8 00 00 00 00	 call	 PyDict_Size
  0002d	48 85 c0	 test	 rax, rax
  00030	74 21		 je	 SHORT $LN2@type_init

; 1925 :         PyErr_SetString(PyExc_TypeError,
; 1926 :                         "type.__init__() takes no keyword arguments");

  00032	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@FELHNPNO@type?4__init__?$CI?$CJ?5takes?5no?5keyword@
  00040	e8 00 00 00 00	 call	 PyErr_SetString

; 1927 :         return -1;

  00045	83 c8 ff	 or	 eax, -1

; 1943 : }

  00048	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0004d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00051	5e		 pop	 rsi
  00052	c3		 ret	 0
$LN2@type_init:

; 1928 :     }
; 1929 : 
; 1930 :     if (args != NULL && PyTuple_Check(args) &&
; 1931 :         (PyTuple_GET_SIZE(args) != 1 && PyTuple_GET_SIZE(args) != 3)) {

  00053	48 85 db	 test	 rbx, rbx
  00056	74 41		 je	 SHORT $LN1@type_init
  00058	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0005c	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  00066	74 31		 je	 SHORT $LN1@type_init
  00068	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  0006c	48 83 f8 01	 cmp	 rax, 1
  00070	74 27		 je	 SHORT $LN1@type_init
  00072	48 83 f8 03	 cmp	 rax, 3
  00076	74 21		 je	 SHORT $LN1@type_init

; 1932 :         PyErr_SetString(PyExc_TypeError,
; 1933 :                         "type.__init__() takes 1 or 3 arguments");

  00078	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@NJLOGGPG@type?4__init__?$CI?$CJ?5takes?51?5or?53?5arg@
  00086	e8 00 00 00 00	 call	 PyErr_SetString

; 1934 :         return -1;

  0008b	83 c8 ff	 or	 eax, -1

; 1943 : }

  0008e	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00093	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00097	5e		 pop	 rsi
  00098	c3		 ret	 0
$LN1@type_init:

; 1935 :     }
; 1936 : 
; 1937 :     /* Call object.__init__(self) now. */
; 1938 :     /* XXX Could call super(type, cls).__init__() but what's the point? */
; 1939 :     args = PyTuple_GetSlice(args, 0, 0);

  00099	45 33 c0	 xor	 r8d, r8d
  0009c	33 d2		 xor	 edx, edx
  0009e	48 8b cb	 mov	 rcx, rbx
  000a1	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  000a6	e8 00 00 00 00	 call	 PyTuple_GetSlice

; 1940 :     res = object_init(cls, args, NULL);

  000ab	45 33 c0	 xor	 r8d, r8d
  000ae	48 8b d0	 mov	 rdx, rax
  000b1	48 8b ce	 mov	 rcx, rsi
  000b4	48 8b f8	 mov	 rdi, rax
  000b7	e8 00 00 00 00	 call	 object_init

; 1941 :     Py_DECREF(args);

  000bc	48 8b cf	 mov	 rcx, rdi
  000bf	8b d8		 mov	 ebx, eax
  000c1	e8 00 00 00 00	 call	 _Py_DecRef
  000c6	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1942 :     return res;

  000cb	8b c3		 mov	 eax, ebx

; 1943 : }

  000cd	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000d2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d6	5e		 pop	 rsi
  000d7	c3		 ret	 0
type_init ENDP
_TEXT	ENDS
PUBLIC	??_C@_0HG@JFHEBFHK@Type?5?$CF?4100s?5defines?5tp_reserved?5@ ; `string'
PUBLIC	??_C@_0FH@BCBGLIHM@type?5?8?$CF?4100s?8?5participates?5in?5gc@ ; `string'
EXTRN	PyErr_WarnFormat:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyType_Ready DD imagerel $LN58
	DD	imagerel $LN58+29
	DD	imagerel $unwind$PyType_Ready
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyType_Ready DD imagerel $LN58+29
	DD	imagerel $LN58+532
	DD	imagerel $chain$2$PyType_Ready
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyType_Ready DD imagerel $LN58+532
	DD	imagerel $LN58+997
	DD	imagerel $chain$4$PyType_Ready
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyType_Ready DD 060021H
	DD	097400H
	DD	086400H
	DD	075400H
	DD	imagerel $LN58
	DD	imagerel $LN58+29
	DD	imagerel $unwind$PyType_Ready
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyType_Ready DD 061321H
	DD	097413H
	DD	08640eH
	DD	075405H
	DD	imagerel $LN58
	DD	imagerel $LN58+29
	DD	imagerel $unwind$PyType_Ready
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyType_Ready DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0HG@JFHEBFHK@Type?5?$CF?4100s?5defines?5tp_reserved?5@
CONST	SEGMENT
??_C@_0HG@JFHEBFHK@Type?5?$CF?4100s?5defines?5tp_reserved?5@ DB 'Type %.1'
	DB	'00s defines tp_reserved (formerly tp_compare) but not tp_rich'
	DB	'compare. Comparisons may not behave as intended.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FH@BCBGLIHM@type?5?8?$CF?4100s?8?5participates?5in?5gc@
CONST	SEGMENT
??_C@_0FH@BCBGLIHM@type?5?8?$CF?4100s?8?5participates?5in?5gc@ DB 'type '''
	DB	'%.100s'' participates in gc and is a base type but has inappr'
	DB	'opriate tp_free slot', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyType_Ready
_TEXT	SEGMENT
tv185 = 48
type$ = 48
PyType_Ready PROC					; COMDAT

; 4136 : {

$LN58:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4137 :     PyObject *dict, *bases;
; 4138 :     PyTypeObject *base;
; 4139 :     Py_ssize_t i, n;
; 4140 : 
; 4141 :     if (type->tp_flags & Py_TPFLAGS_READY) {

  00006	8b 81 00 01 00
	00		 mov	 eax, DWORD PTR [rcx+256]
  0000c	48 8b d9	 mov	 rbx, rcx
  0000f	0f ba e0 0c	 bt	 eax, 12
  00013	73 08		 jae	 SHORT $LN44@PyType_Rea

; 4142 :         assert(type->tp_dict != NULL);
; 4143 :         return 0;

  00015	33 c0		 xor	 eax, eax

; 4329 : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5b		 pop	 rbx
  0001c	c3		 ret	 0
$LN44@PyType_Rea:
  0001d	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp

; 4144 :     }
; 4145 :     assert((type->tp_flags & Py_TPFLAGS_READYING) == 0);
; 4146 : 
; 4147 :     type->tp_flags |= Py_TPFLAGS_READYING;

  00022	0f ba e8 0d	 bts	 eax, 13
  00026	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  0002b	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi

; 4148 : 
; 4149 : #ifdef Py_TRACE_REFS
; 4150 :     /* PyType_Ready is the closest thing we have to a choke point
; 4151 :      * for type objects, so is the best place I can think of to try
; 4152 :      * to get type objects into the doubly-linked list of all objects.
; 4153 :      * Still, not all type objects go thru PyType_Ready.
; 4154 :      */
; 4155 :     _Py_AddToAllObjects((PyObject *)type, 0);
; 4156 : #endif
; 4157 : 
; 4158 :     /* Initialize tp_base (defaults to BaseObject unless that's us) */
; 4159 :     base = type->tp_base;

  00030	48 8b b9 58 01
	00 00		 mov	 rdi, QWORD PTR [rcx+344]
  00037	89 81 00 01 00
	00		 mov	 DWORD PTR [rcx+256], eax

; 4160 :     if (base == NULL && type != &PyBaseObject_Type) {

  0003d	48 85 ff	 test	 rdi, rdi
  00040	75 1b		 jne	 SHORT $LN54@PyType_Rea
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBaseObject_Type
  00049	48 3b d9	 cmp	 rbx, rcx
  0004c	74 29		 je	 SHORT $LN41@PyType_Rea

; 4161 :         base = type->tp_base = &PyBaseObject_Type;

  0004e	48 89 8b 58 01
	00 00		 mov	 QWORD PTR [rbx+344], rcx
  00055	48 8b f9	 mov	 rdi, rcx

; 4162 :         Py_INCREF(base);

  00058	e8 00 00 00 00	 call	 _Py_IncRef
$LN54@PyType_Rea:

; 4163 :     }
; 4164 : 
; 4165 :     /* Now the only way base can still be NULL is if type is
; 4166 :      * &PyBaseObject_Type.
; 4167 :      */
; 4168 : 
; 4169 :     /* Initialize the base class */
; 4170 :     if (base != NULL && base->tp_dict == NULL) {

  0005d	48 83 bf 60 01
	00 00 00	 cmp	 QWORD PTR [rdi+352], 0
  00065	75 10		 jne	 SHORT $LN41@PyType_Rea

; 4171 :         if (PyType_Ready(base) < 0)

  00067	48 8b cf	 mov	 rcx, rdi
  0006a	e8 00 00 00 00	 call	 PyType_Ready
  0006f	85 c0		 test	 eax, eax
  00071	0f 88 7b 01 00
	00		 js	 $error$23796
$LN41@PyType_Rea:

; 4172 :             goto error;
; 4173 :     }
; 4174 : 
; 4175 :     /* Initialize ob_type if NULL.      This means extensions that want to be
; 4176 :        compilable separately on Windows can call PyType_Ready() instead of
; 4177 :        initializing the ob_type field of their type objects. */
; 4178 :     /* The test for base != NULL is really unnecessary, since base is only
; 4179 :        NULL when type is &PyBaseObject_Type, and we know its ob_type is
; 4180 :        not NULL (it's initialized to &PyType_Type).      But coverity doesn't
; 4181 :        know that. */
; 4182 :     if (Py_TYPE(type) == NULL && base != NULL)

  00077	48 83 7b 58 00	 cmp	 QWORD PTR [rbx+88], 0
  0007c	75 0d		 jne	 SHORT $LN40@PyType_Rea
  0007e	48 85 ff	 test	 rdi, rdi
  00081	74 08		 je	 SHORT $LN40@PyType_Rea

; 4183 :         Py_TYPE(type) = Py_TYPE(base);

  00083	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00087	48 89 43 58	 mov	 QWORD PTR [rbx+88], rax
$LN40@PyType_Rea:

; 4184 : 
; 4185 :     /* Initialize tp_bases */
; 4186 :     bases = type->tp_bases;
; 4187 :     if (bases == NULL) {

  0008b	48 83 bb a8 01
	00 00 00	 cmp	 QWORD PTR [rbx+424], 0
  00093	75 2b		 jne	 SHORT $LN39@PyType_Rea

; 4188 :         if (base == NULL)

  00095	48 85 ff	 test	 rdi, rdi
  00098	75 09		 jne	 SHORT $LN38@PyType_Rea

; 4189 :             bases = PyTuple_New(0);

  0009a	33 c9		 xor	 ecx, ecx
  0009c	e8 00 00 00 00	 call	 PyTuple_New

; 4190 :         else

  000a1	eb 0d		 jmp	 SHORT $LN37@PyType_Rea
$LN38@PyType_Rea:

; 4191 :             bases = PyTuple_Pack(1, base);

  000a3	48 8b d7	 mov	 rdx, rdi
  000a6	b9 01 00 00 00	 mov	 ecx, 1
  000ab	e8 00 00 00 00	 call	 PyTuple_Pack
$LN37@PyType_Rea:

; 4192 :         if (bases == NULL)

  000b0	48 85 c0	 test	 rax, rax
  000b3	0f 84 39 01 00
	00		 je	 $error$23796

; 4193 :             goto error;
; 4194 :         type->tp_bases = bases;

  000b9	48 89 83 a8 01
	00 00		 mov	 QWORD PTR [rbx+424], rax
$LN39@PyType_Rea:

; 4195 :     }
; 4196 : 
; 4197 :     /* Initialize tp_dict */
; 4198 :     dict = type->tp_dict;
; 4199 :     if (dict == NULL) {

  000c0	48 83 bb 60 01
	00 00 00	 cmp	 QWORD PTR [rbx+352], 0
  000c8	75 15		 jne	 SHORT $LN35@PyType_Rea

; 4200 :         dict = PyDict_New();

  000ca	e8 00 00 00 00	 call	 PyDict_New

; 4201 :         if (dict == NULL)

  000cf	48 85 c0	 test	 rax, rax
  000d2	0f 84 1a 01 00
	00		 je	 $error$23796

; 4202 :             goto error;
; 4203 :         type->tp_dict = dict;

  000d8	48 89 83 60 01
	00 00		 mov	 QWORD PTR [rbx+352], rax
$LN35@PyType_Rea:

; 4204 :     }
; 4205 : 
; 4206 :     /* Add type-specific descriptors to tp_dict */
; 4207 :     if (add_operators(type) < 0)

  000df	48 8b cb	 mov	 rcx, rbx
  000e2	e8 00 00 00 00	 call	 add_operators
  000e7	85 c0		 test	 eax, eax
  000e9	0f 88 03 01 00
	00		 js	 $error$23796

; 4208 :         goto error;
; 4209 :     if (type->tp_methods != NULL) {

  000ef	48 8b 93 40 01
	00 00		 mov	 rdx, QWORD PTR [rbx+320]
  000f6	48 85 d2	 test	 rdx, rdx
  000f9	74 10		 je	 SHORT $LN31@PyType_Rea

; 4210 :         if (add_methods(type, type->tp_methods) < 0)

  000fb	48 8b cb	 mov	 rcx, rbx
  000fe	e8 00 00 00 00	 call	 add_methods
  00103	85 c0		 test	 eax, eax
  00105	0f 88 e7 00 00
	00		 js	 $error$23796
$LN31@PyType_Rea:

; 4211 :             goto error;
; 4212 :     }
; 4213 :     if (type->tp_members != NULL) {

  0010b	48 8b 93 48 01
	00 00		 mov	 rdx, QWORD PTR [rbx+328]
  00112	48 85 d2	 test	 rdx, rdx
  00115	74 10		 je	 SHORT $LN29@PyType_Rea

; 4214 :         if (add_members(type, type->tp_members) < 0)

  00117	48 8b cb	 mov	 rcx, rbx
  0011a	e8 00 00 00 00	 call	 add_members
  0011f	85 c0		 test	 eax, eax
  00121	0f 88 cb 00 00
	00		 js	 $error$23796
$LN29@PyType_Rea:

; 4215 :             goto error;
; 4216 :     }
; 4217 :     if (type->tp_getset != NULL) {

  00127	48 8b 93 50 01
	00 00		 mov	 rdx, QWORD PTR [rbx+336]
  0012e	48 85 d2	 test	 rdx, rdx
  00131	74 10		 je	 SHORT $LN27@PyType_Rea

; 4218 :         if (add_getset(type, type->tp_getset) < 0)

  00133	48 8b cb	 mov	 rcx, rbx
  00136	e8 00 00 00 00	 call	 add_getset
  0013b	85 c0		 test	 eax, eax
  0013d	0f 88 af 00 00
	00		 js	 $error$23796
$LN27@PyType_Rea:

; 4219 :             goto error;
; 4220 :     }
; 4221 : 
; 4222 :     /* Calculate method resolution order */
; 4223 :     if (mro_internal(type) < 0) {

  00143	48 8b cb	 mov	 rcx, rbx
  00146	e8 00 00 00 00	 call	 mro_internal
  0014b	85 c0		 test	 eax, eax
  0014d	0f 88 9f 00 00
	00		 js	 $error$23796

; 4224 :         goto error;
; 4225 :     }
; 4226 : 
; 4227 :     /* Inherit special flags from dominant base */
; 4228 :     if (type->tp_base != NULL)

  00153	48 8b 93 58 01
	00 00		 mov	 rdx, QWORD PTR [rbx+344]
  0015a	48 85 d2	 test	 rdx, rdx
  0015d	74 08		 je	 SHORT $LN25@PyType_Rea

; 4229 :         inherit_special(type, type->tp_base);

  0015f	48 8b cb	 mov	 rcx, rbx
  00162	e8 00 00 00 00	 call	 inherit_special
$LN25@PyType_Rea:

; 4230 : 
; 4231 :     /* Initialize tp_dict properly */
; 4232 :     bases = type->tp_mro;

  00167	48 8b bb b0 01
	00 00		 mov	 rdi, QWORD PTR [rbx+432]

; 4233 :     assert(bases != NULL);
; 4234 :     assert(PyTuple_Check(bases));
; 4235 :     n = PyTuple_GET_SIZE(bases);

  0016e	48 8b 77 60	 mov	 rsi, QWORD PTR [rdi+96]

; 4236 :     for (i = 1; i < n; i++) {

  00172	48 83 fe 01	 cmp	 rsi, 1
  00176	7e 2c		 jle	 SHORT $LN22@PyType_Rea

; 4230 : 
; 4231 :     /* Initialize tp_dict properly */
; 4232 :     bases = type->tp_mro;

  00178	48 83 c7 78	 add	 rdi, 120		; 00000078H
  0017c	48 ff ce	 dec	 rsi
  0017f	90		 npad	 1
$LL24@PyType_Rea:

; 4237 :         PyObject *b = PyTuple_GET_ITEM(bases, i);

  00180	48 8b 17	 mov	 rdx, QWORD PTR [rdi]

; 4238 :         if (PyType_Check(b))

  00183	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00187	f7 80 00 01 00
	00 00 00 00 80	 test	 DWORD PTR [rax+256], -2147483648 ; ffffffff80000000H
  00191	74 08		 je	 SHORT $LN23@PyType_Rea

; 4239 :             inherit_slots(type, (PyTypeObject *)b);

  00193	48 8b cb	 mov	 rcx, rbx
  00196	e8 00 00 00 00	 call	 inherit_slots
$LN23@PyType_Rea:

; 4236 :     for (i = 1; i < n; i++) {

  0019b	48 83 c7 08	 add	 rdi, 8
  0019f	48 ff ce	 dec	 rsi
  001a2	75 dc		 jne	 SHORT $LL24@PyType_Rea
$LN22@PyType_Rea:

; 4240 :     }
; 4241 : 
; 4242 :     /* Sanity check for tp_free. */
; 4243 :     if (PyType_IS_GC(type) && (type->tp_flags & Py_TPFLAGS_BASETYPE) &&
; 4244 :         (type->tp_free == NULL || type->tp_free == PyObject_Del)) {

  001a4	e8 00 00 00 00	 call	 _Py_PXCTX
  001a9	85 c0		 test	 eax, eax
  001ab	75 67		 jne	 SHORT $LN20@PyType_Rea
  001ad	8b 8b 00 01 00
	00		 mov	 ecx, DWORD PTR [rbx+256]
  001b3	8b c1		 mov	 eax, ecx
  001b5	c1 e8 0e	 shr	 eax, 14
  001b8	83 e0 01	 and	 eax, 1
  001bb	74 57		 je	 SHORT $LN20@PyType_Rea
  001bd	0f ba e1 0a	 bt	 ecx, 10
  001c1	73 51		 jae	 SHORT $LN20@PyType_Rea
  001c3	48 8b 83 98 01
	00 00		 mov	 rax, QWORD PTR [rbx+408]
  001ca	48 85 c0	 test	 rax, rax
  001cd	74 0c		 je	 SHORT $LN19@PyType_Rea
  001cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyObject_Free
  001d6	48 3b c1	 cmp	 rax, rcx
  001d9	75 39		 jne	 SHORT $LN20@PyType_Rea
$LN19@PyType_Rea:

; 4245 :         /* This base class needs to call tp_free, but doesn't have
; 4246 :          * one, or its tp_free is for non-gc'ed objects.
; 4247 :          */
; 4248 :         PyErr_Format(PyExc_TypeError, "type '%.100s' participates in "
; 4249 :                      "gc and is a base type but has inappropriate "
; 4250 :                      "tp_free slot",
; 4251 :                      type->tp_name);

  001db	4c 8b 43 70	 mov	 r8, QWORD PTR [rbx+112]
  001df	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  001e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FH@BCBGLIHM@type?5?8?$CF?4100s?8?5participates?5in?5gc@
  001ed	e8 00 00 00 00	 call	 PyErr_Format
$error$23796:

; 4325 : 
; 4326 :   error:
; 4327 :     type->tp_flags &= ~Py_TPFLAGS_READYING;

  001f2	81 a3 00 01 00
	00 ff df ff ff	 and	 DWORD PTR [rbx+256], -8193 ; ffffffffffffdfffH

; 4328 :     return -1;

  001fc	83 c8 ff	 or	 eax, -1
$LN57@PyType_Rea:
  001ff	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00204	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00209	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 4329 : }

  0020e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00212	5b		 pop	 rbx
  00213	c3		 ret	 0
$LN20@PyType_Rea:

; 4252 :         goto error;
; 4253 :     }
; 4254 : 
; 4255 :     /* if the type dictionary doesn't contain a __doc__, set it from
; 4256 :        the tp_doc slot.
; 4257 :      */
; 4258 :     if (_PyDict_GetItemId(type->tp_dict, &PyId___doc__) == NULL) {

  00214	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0021a	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00223	be 00 00 00 00	 mov	 esi, OFFSET FLAT:PyId___doc__
  00228	48 8b 2c c8	 mov	 rbp, QWORD PTR [rax+rcx*8]
  0022c	48 8b 8b 60 01
	00 00		 mov	 rcx, QWORD PTR [rbx+352]
  00233	48 03 f5	 add	 rsi, rbp
  00236	48 8b d6	 mov	 rdx, rsi
  00239	e8 00 00 00 00	 call	 _PyDict_GetItemId
  0023e	48 85 c0	 test	 rax, rax
  00241	75 4b		 jne	 SHORT $LN15@PyType_Rea

; 4259 :         if (type->tp_doc != NULL) {

  00243	48 8b 8b 08 01
	00 00		 mov	 rcx, QWORD PTR [rbx+264]
  0024a	48 85 c9	 test	 rcx, rcx
  0024d	74 29		 je	 SHORT $LN17@PyType_Rea

; 4260 :             PyObject *doc = PyUnicode_FromString(type->tp_doc);

  0024f	e8 00 00 00 00	 call	 PyUnicode_FromString
  00254	48 8b f8	 mov	 rdi, rax

; 4261 :             if (doc == NULL)

  00257	48 85 c0	 test	 rax, rax
  0025a	74 96		 je	 SHORT $error$23796

; 4262 :                 goto error;
; 4263 :             _PyDict_SetItemId(type->tp_dict, &PyId___doc__, doc);

  0025c	48 8b 8b 60 01
	00 00		 mov	 rcx, QWORD PTR [rbx+352]
  00263	4c 8b c0	 mov	 r8, rax
  00266	48 8b d6	 mov	 rdx, rsi
  00269	e8 00 00 00 00	 call	 _PyDict_SetItemId

; 4264 :             Py_DECREF(doc);

  0026e	48 8b cf	 mov	 rcx, rdi
  00271	e8 00 00 00 00	 call	 _Py_DecRef

; 4265 :         } else {

  00276	eb 16		 jmp	 SHORT $LN15@PyType_Rea
$LN17@PyType_Rea:

; 4266 :             _PyDict_SetItemId(type->tp_dict,
; 4267 :                               &PyId___doc__, Py_None);

  00278	48 8b 8b 60 01
	00 00		 mov	 rcx, QWORD PTR [rbx+352]
  0027f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_NoneStruct
  00286	48 8b d6	 mov	 rdx, rsi
  00289	e8 00 00 00 00	 call	 _PyDict_SetItemId
$LN15@PyType_Rea:

; 4268 :         }
; 4269 :     }
; 4270 : 
; 4271 :     /* Hack for tp_hash and __hash__.
; 4272 :        If after all that, tp_hash is still NULL, and __hash__ is not in
; 4273 :        tp_dict, set tp_hash to PyObject_HashNotImplemented and
; 4274 :        tp_dict['__hash__'] equal to None.
; 4275 :        This signals that __hash__ is not inherited.
; 4276 :      */
; 4277 :     if (type->tp_hash == NULL) {

  0028e	48 83 bb d0 00
	00 00 00	 cmp	 QWORD PTR [rbx+208], 0
  00296	75 48		 jne	 SHORT $LN13@PyType_Rea

; 4278 :         if (_PyDict_GetItemId(type->tp_dict, &PyId___hash__) == NULL) {

  00298	48 8b 8b 60 01
	00 00		 mov	 rcx, QWORD PTR [rbx+352]
  0029f	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:PyId___hash__
  002a4	48 03 fd	 add	 rdi, rbp
  002a7	48 8b d7	 mov	 rdx, rdi
  002aa	e8 00 00 00 00	 call	 _PyDict_GetItemId
  002af	48 85 c0	 test	 rax, rax
  002b2	75 2c		 jne	 SHORT $LN13@PyType_Rea

; 4279 :             if (_PyDict_SetItemId(type->tp_dict, &PyId___hash__, Py_None) < 0)

  002b4	48 8b 8b 60 01
	00 00		 mov	 rcx, QWORD PTR [rbx+352]
  002bb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_NoneStruct
  002c2	48 8b d7	 mov	 rdx, rdi
  002c5	e8 00 00 00 00	 call	 _PyDict_SetItemId
  002ca	85 c0		 test	 eax, eax
  002cc	0f 88 20 ff ff
	ff		 js	 $error$23796

; 4280 :                 goto error;
; 4281 :             type->tp_hash = PyObject_HashNotImplemented;

  002d2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyObject_HashNotImplemented
  002d9	48 89 83 d0 00
	00 00		 mov	 QWORD PTR [rbx+208], rax
$LN13@PyType_Rea:

; 4282 :         }
; 4283 :     }
; 4284 : 
; 4285 :     /* Some more special stuff */
; 4286 :     base = type->tp_base;

  002e0	48 8b 8b 58 01
	00 00		 mov	 rcx, QWORD PTR [rbx+344]

; 4287 :     if (base != NULL) {

  002e7	48 85 c9	 test	 rcx, rcx
  002ea	74 60		 je	 SHORT $LN7@PyType_Rea

; 4288 :         if (type->tp_as_number == NULL)

  002ec	48 83 bb b8 00
	00 00 00	 cmp	 QWORD PTR [rbx+184], 0
  002f4	75 0e		 jne	 SHORT $LN10@PyType_Rea

; 4289 :             type->tp_as_number = base->tp_as_number;

  002f6	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  002fd	48 89 83 b8 00
	00 00		 mov	 QWORD PTR [rbx+184], rax
$LN10@PyType_Rea:

; 4290 :         if (type->tp_as_sequence == NULL)

  00304	48 83 bb c0 00
	00 00 00	 cmp	 QWORD PTR [rbx+192], 0
  0030c	75 0e		 jne	 SHORT $LN9@PyType_Rea

; 4291 :             type->tp_as_sequence = base->tp_as_sequence;

  0030e	48 8b 81 c0 00
	00 00		 mov	 rax, QWORD PTR [rcx+192]
  00315	48 89 83 c0 00
	00 00		 mov	 QWORD PTR [rbx+192], rax
$LN9@PyType_Rea:

; 4292 :         if (type->tp_as_mapping == NULL)

  0031c	48 83 bb c8 00
	00 00 00	 cmp	 QWORD PTR [rbx+200], 0
  00324	75 0e		 jne	 SHORT $LN8@PyType_Rea

; 4293 :             type->tp_as_mapping = base->tp_as_mapping;

  00326	48 8b 81 c8 00
	00 00		 mov	 rax, QWORD PTR [rcx+200]
  0032d	48 89 83 c8 00
	00 00		 mov	 QWORD PTR [rbx+200], rax
$LN8@PyType_Rea:

; 4294 :         if (type->tp_as_buffer == NULL)

  00334	48 83 bb f8 00
	00 00 00	 cmp	 QWORD PTR [rbx+248], 0
  0033c	75 0e		 jne	 SHORT $LN7@PyType_Rea

; 4295 :             type->tp_as_buffer = base->tp_as_buffer;

  0033e	48 8b 81 f8 00
	00 00		 mov	 rax, QWORD PTR [rcx+248]
  00345	48 89 83 f8 00
	00 00		 mov	 QWORD PTR [rbx+248], rax
$LN7@PyType_Rea:

; 4296 :     }
; 4297 : 
; 4298 :     /* Link into each base class's list of subclasses */
; 4299 :     bases = type->tp_bases;

  0034c	48 8b b3 a8 01
	00 00		 mov	 rsi, QWORD PTR [rbx+424]

; 4300 :     n = PyTuple_GET_SIZE(bases);
; 4301 :     for (i = 0; i < n; i++) {

  00353	33 ff		 xor	 edi, edi
  00355	48 8b 6e 60	 mov	 rbp, QWORD PTR [rsi+96]
  00359	48 85 ed	 test	 rbp, rbp
  0035c	7e 33		 jle	 SHORT $LN4@PyType_Rea

; 4296 :     }
; 4297 : 
; 4298 :     /* Link into each base class's list of subclasses */
; 4299 :     bases = type->tp_bases;

  0035e	48 83 c6 70	 add	 rsi, 112		; 00000070H
$LL6@PyType_Rea:

; 4302 :         PyObject *b = PyTuple_GET_ITEM(bases, i);

  00362	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]

; 4303 :         if (PyType_Check(b) &&
; 4304 :             add_subclass((PyTypeObject *)b, type) < 0)

  00365	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00369	f7 80 00 01 00
	00 00 00 00 80	 test	 DWORD PTR [rax+256], -2147483648 ; ffffffff80000000H
  00373	74 10		 je	 SHORT $LN5@PyType_Rea
  00375	48 8b d3	 mov	 rdx, rbx
  00378	e8 00 00 00 00	 call	 add_subclass
  0037d	85 c0		 test	 eax, eax
  0037f	0f 88 6d fe ff
	ff		 js	 $error$23796
$LN5@PyType_Rea:

; 4300 :     n = PyTuple_GET_SIZE(bases);
; 4301 :     for (i = 0; i < n; i++) {

  00385	48 ff c7	 inc	 rdi
  00388	48 83 c6 08	 add	 rsi, 8
  0038c	48 3b fd	 cmp	 rdi, rbp
  0038f	7c d1		 jl	 SHORT $LL6@PyType_Rea
$LN4@PyType_Rea:

; 4305 :             goto error;
; 4306 :     }
; 4307 : 
; 4308 :     /* Warn for a type that implements tp_compare (now known as
; 4309 :        tp_reserved) but not tp_richcompare. */
; 4310 :     if (type->tp_reserved && !type->tp_richcompare) {

  00391	48 83 bb a8 00
	00 00 00	 cmp	 QWORD PTR [rbx+168], 0
  00399	74 2f		 je	 SHORT $LN1@PyType_Rea
  0039b	48 83 bb 20 01
	00 00 00	 cmp	 QWORD PTR [rbx+288], 0
  003a3	75 25		 jne	 SHORT $LN1@PyType_Rea

; 4311 :         int error;
; 4312 :         error = PyErr_WarnFormat(PyExc_DeprecationWarning, 1,
; 4313 :             "Type %.100s defines tp_reserved (formerly tp_compare) "
; 4314 :             "but not tp_richcompare. Comparisons may not behave as intended.",
; 4315 :             type->tp_name);

  003a5	4c 8b 4b 70	 mov	 r9, QWORD PTR [rbx+112]
  003a9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_DeprecationWarning
  003b0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0HG@JFHEBFHK@Type?5?$CF?4100s?5defines?5tp_reserved?5@
  003b7	ba 01 00 00 00	 mov	 edx, 1
  003bc	e8 00 00 00 00	 call	 PyErr_WarnFormat

; 4316 :         if (error == -1)

  003c1	83 f8 ff	 cmp	 eax, -1
  003c4	0f 84 28 fe ff
	ff		 je	 $error$23796
$LN1@PyType_Rea:

; 4317 :             goto error;
; 4318 :     }
; 4319 : 
; 4320 :     /* All done -- set the ready flag */
; 4321 :     assert(type->tp_dict != NULL);
; 4322 :     type->tp_flags =
; 4323 :         (type->tp_flags & ~Py_TPFLAGS_READYING) | Py_TPFLAGS_READY;

  003ca	81 a3 00 01 00
	00 ff df ff ff	 and	 DWORD PTR [rbx+256], -8193 ; ffffffffffffdfffH
  003d4	81 8b 00 01 00
	00 00 10 00 00	 or	 DWORD PTR [rbx+256], 4096 ; 00001000H

; 4324 :     return 0;

  003de	33 c0		 xor	 eax, eax
  003e0	e9 1a fe ff ff	 jmp	 $LN57@PyType_Rea
PyType_Ready ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@LLBIFAAG@?$CFs?4__new__?$CI?$CJ?3?5not?5enough?5argumen@ ; `string'
PUBLIC	??_C@_0CN@MPLIKKOK@?$CFs?4__new__?$CI?$CFs?$CJ?5is?5not?5safe?0?5use?5@ ; `string'
PUBLIC	??_C@_0CK@JKGADFBI@?$CFs?4__new__?$CI?$CFs?$CJ?3?5?$CFs?5is?5not?5a?5subt@ ; `string'
PUBLIC	??_C@_0CL@OJLAAAPD@?$CFs?4__new__?$CIX?$CJ?3?5X?5is?5not?5a?5type?5o@ ; `string'
PUBLIC	??_C@_0CG@LMPOEJHA@__new__?$CI?$CJ?5called?5with?5non?9type?5?8@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$tp_new_wrapper DD imagerel tp_new_wrapper
	DD	imagerel tp_new_wrapper+91
	DD	imagerel $unwind$tp_new_wrapper
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$tp_new_wrapper DD imagerel tp_new_wrapper+91
	DD	imagerel tp_new_wrapper+167
	DD	imagerel $chain$0$tp_new_wrapper
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$tp_new_wrapper DD imagerel tp_new_wrapper+167
	DD	imagerel tp_new_wrapper+371
	DD	imagerel $chain$2$tp_new_wrapper
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$tp_new_wrapper DD imagerel tp_new_wrapper+371
	DD	imagerel tp_new_wrapper+412
	DD	imagerel $chain$3$tp_new_wrapper
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$tp_new_wrapper DD 021H
	DD	imagerel tp_new_wrapper
	DD	imagerel tp_new_wrapper+91
	DD	imagerel $unwind$tp_new_wrapper
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$tp_new_wrapper DD 020021H
	DD	087400H
	DD	imagerel tp_new_wrapper
	DD	imagerel tp_new_wrapper+91
	DD	imagerel $unwind$tp_new_wrapper
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$tp_new_wrapper DD 020521H
	DD	087405H
	DD	imagerel tp_new_wrapper
	DD	imagerel tp_new_wrapper+91
	DD	imagerel $unwind$tp_new_wrapper
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tp_new_wrapper DD 060f01H
	DD	0a540fH
	DD	09340fH
	DD	0600b520fH
xdata	ENDS
;	COMDAT ??_C@_0CD@LLBIFAAG@?$CFs?4__new__?$CI?$CJ?3?5not?5enough?5argumen@
CONST	SEGMENT
??_C@_0CD@LLBIFAAG@?$CFs?4__new__?$CI?$CJ?3?5not?5enough?5argumen@ DB '%s'
	DB	'.__new__(): not enough arguments', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@MPLIKKOK@?$CFs?4__new__?$CI?$CFs?$CJ?5is?5not?5safe?0?5use?5@
CONST	SEGMENT
??_C@_0CN@MPLIKKOK@?$CFs?4__new__?$CI?$CFs?$CJ?5is?5not?5safe?0?5use?5@ DB '%'
	DB	's.__new__(%s) is not safe, use %s.__new__()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@JKGADFBI@?$CFs?4__new__?$CI?$CFs?$CJ?3?5?$CFs?5is?5not?5a?5subt@
CONST	SEGMENT
??_C@_0CK@JKGADFBI@?$CFs?4__new__?$CI?$CFs?$CJ?3?5?$CFs?5is?5not?5a?5subt@ DB '%'
	DB	's.__new__(%s): %s is not a subtype of %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@OJLAAAPD@?$CFs?4__new__?$CIX?$CJ?3?5X?5is?5not?5a?5type?5o@
CONST	SEGMENT
??_C@_0CL@OJLAAAPD@?$CFs?4__new__?$CIX?$CJ?3?5X?5is?5not?5a?5type?5o@ DB '%'
	DB	's.__new__(X): X is not a type object (%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@LMPOEJHA@__new__?$CI?$CJ?5called?5with?5non?9type?5?8@
CONST	SEGMENT
??_C@_0CG@LMPOEJHA@__new__?$CI?$CJ?5called?5with?5non?9type?5?8@ DB '__ne'
	DB	'w__() called with non-type ''self''', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT tp_new_wrapper
_TEXT	SEGMENT
self$ = 64
args$ = 72
kwds$ = 80
tp_new_wrapper PROC					; COMDAT

; 4840 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	49 8b e8	 mov	 rbp, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 4841 :     PyTypeObject *type, *subtype, *staticbase;
; 4842 :     PyObject *arg0, *res;
; 4843 : 
; 4844 :     if (self == NULL || !PyType_Check(self))

  00018	48 85 c9	 test	 rcx, rcx
  0001b	74 10		 je	 SHORT $LN9@tp_new_wra
  0001d	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00021	f7 80 00 01 00
	00 00 00 00 80	 test	 DWORD PTR [rax+256], -2147483648 ; ffffffff80000000H
  0002b	75 0c		 jne	 SHORT $LN10@tp_new_wra
$LN9@tp_new_wra:

; 4845 :         Py_FatalError("__new__() called with non-type 'self'");

  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CG@LMPOEJHA@__new__?$CI?$CJ?5called?5with?5non?9type?5?8@
  00034	e8 00 00 00 00	 call	 Py_FatalError
$LN10@tp_new_wra:

; 4846 :     type = (PyTypeObject *)self;
; 4847 :     if (!PyTuple_Check(args) || PyTuple_GET_SIZE(args) < 1) {

  00039	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  0003d	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  00047	0f 84 26 01 00
	00		 je	 $LN7@tp_new_wra
  0004d	4c 8b 56 60	 mov	 r10, QWORD PTR [rsi+96]
  00051	49 83 fa 01	 cmp	 r10, 1
  00055	0f 8c 18 01 00
	00		 jl	 $LN7@tp_new_wra

; 4851 :         return NULL;
; 4852 :     }
; 4853 :     arg0 = PyTuple_GET_ITEM(args, 0);

  0005b	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00060	48 8b 7e 70	 mov	 rdi, QWORD PTR [rsi+112]

; 4854 :     if (!PyType_Check(arg0)) {

  00064	4c 8b 4f 58	 mov	 r9, QWORD PTR [rdi+88]
  00068	41 f7 81 00 01
	00 00 00 00 00
	80		 test	 DWORD PTR [r9+256], -2147483648 ; ffffffff80000000H
  00073	75 32		 jne	 SHORT $LN6@tp_new_wra

; 4855 :         PyErr_Format(PyExc_TypeError,
; 4856 :                      "%s.__new__(X): X is not a type object (%s)",
; 4857 :                      type->tp_name,
; 4858 :                      Py_TYPE(arg0)->tp_name);

  00075	4d 8b 49 70	 mov	 r9, QWORD PTR [r9+112]
  00079	4c 8b 43 70	 mov	 r8, QWORD PTR [rbx+112]
  0007d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00084	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@OJLAAAPD@?$CFs?4__new__?$CIX?$CJ?3?5X?5is?5not?5a?5type?5o@
  0008b	e8 00 00 00 00	 call	 PyErr_Format
$LN18@tp_new_wra:

; 4869 :         return NULL;

  00090	33 c0		 xor	 eax, eax
$LN17@tp_new_wra:
  00092	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 4895 : }

  00097	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0009c	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  000a1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a5	5e		 pop	 rsi
  000a6	c3		 ret	 0
$LN6@tp_new_wra:

; 4859 :         return NULL;
; 4860 :     }
; 4861 :     subtype = (PyTypeObject *)arg0;
; 4862 :     if (!PyType_IsSubtype(subtype, type)) {

  000a7	48 8b d3	 mov	 rdx, rbx
  000aa	48 8b cf	 mov	 rcx, rdi
  000ad	e8 00 00 00 00	 call	 PyType_IsSubtype
  000b2	85 c0		 test	 eax, eax
  000b4	75 27		 jne	 SHORT $LN5@tp_new_wra

; 4863 :         PyErr_Format(PyExc_TypeError,
; 4864 :                      "%s.__new__(%s): %s is not a subtype of %s",
; 4865 :                      type->tp_name,
; 4866 :                      subtype->tp_name,
; 4867 :                      subtype->tp_name,
; 4868 :                      type->tp_name);

  000b6	4c 8b 43 70	 mov	 r8, QWORD PTR [rbx+112]
  000ba	4c 8b 4f 70	 mov	 r9, QWORD PTR [rdi+112]
  000be	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000c5	4c 89 44 24 28	 mov	 QWORD PTR [rsp+40], r8
  000ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@JKGADFBI@?$CFs?4__new__?$CI?$CFs?$CJ?3?5?$CFs?5is?5not?5a?5subt@
  000d1	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  000d6	e8 00 00 00 00	 call	 PyErr_Format

; 4869 :         return NULL;

  000db	eb b3		 jmp	 SHORT $LN18@tp_new_wra
$LN5@tp_new_wra:

; 4870 :     }
; 4871 : 
; 4872 :     /* Check that the use doesn't do something silly and unsafe like
; 4873 :        object.__new__(dict).  To do this, we check that the
; 4874 :        most derived base that's not a heap type is this type. */
; 4875 :     staticbase = subtype;

  000dd	48 8b cf	 mov	 rcx, rdi
  000e0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:slot_tp_new
$LL4@tp_new_wra:

; 4876 :     while (staticbase && (staticbase->tp_new == slot_tp_new))

  000e7	48 39 81 90 01
	00 00		 cmp	 QWORD PTR [rcx+400], rax
  000ee	75 4a		 jne	 SHORT $LN3@tp_new_wra

; 4877 :         staticbase = staticbase->tp_base;

  000f0	48 8b 89 58 01
	00 00		 mov	 rcx, QWORD PTR [rcx+344]
  000f7	48 85 c9	 test	 rcx, rcx
  000fa	75 eb		 jne	 SHORT $LL4@tp_new_wra
$LN2@tp_new_wra:

; 4887 :     }
; 4888 : 
; 4889 :     args = PyTuple_GetSlice(args, 1, PyTuple_GET_SIZE(args));

  000fc	4d 8b c2	 mov	 r8, r10
  000ff	ba 01 00 00 00	 mov	 edx, 1
  00104	48 8b ce	 mov	 rcx, rsi
  00107	e8 00 00 00 00	 call	 PyTuple_GetSlice
  0010c	48 8b f0	 mov	 rsi, rax

; 4890 :     if (args == NULL)

  0010f	48 85 c0	 test	 rax, rax

; 4891 :         return NULL;

  00112	0f 84 78 ff ff
	ff		 je	 $LN18@tp_new_wra

; 4892 :     res = type->tp_new(subtype, args, kwds);

  00118	4c 8b c5	 mov	 r8, rbp
  0011b	48 8b d0	 mov	 rdx, rax
  0011e	48 8b cf	 mov	 rcx, rdi
  00121	ff 93 90 01 00
	00		 call	 QWORD PTR [rbx+400]

; 4893 :     Py_DECREF(args);

  00127	48 8b ce	 mov	 rcx, rsi
  0012a	48 8b d8	 mov	 rbx, rax
  0012d	e8 00 00 00 00	 call	 _Py_DecRef

; 4894 :     return res;

  00132	48 8b c3	 mov	 rax, rbx
  00135	e9 58 ff ff ff	 jmp	 $LN17@tp_new_wra
$LN3@tp_new_wra:

; 4878 :     /* If staticbase is NULL now, it is a really weird type.
; 4879 :        In the spirit of backwards compatibility (?), just shut up. */
; 4880 :     if (staticbase && staticbase->tp_new != type->tp_new) {

  0013a	48 8b 83 90 01
	00 00		 mov	 rax, QWORD PTR [rbx+400]
  00141	48 39 81 90 01
	00 00		 cmp	 QWORD PTR [rcx+400], rax
  00148	74 b2		 je	 SHORT $LN2@tp_new_wra

; 4881 :         PyErr_Format(PyExc_TypeError,
; 4882 :                      "%s.__new__(%s) is not safe, use %s.__new__()",
; 4883 :                      type->tp_name,
; 4884 :                      subtype->tp_name,
; 4885 :                      staticbase == NULL ? "?" : staticbase->tp_name);

  0014a	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  0014e	4c 8b 4f 70	 mov	 r9, QWORD PTR [rdi+112]
  00152	4c 8b 43 70	 mov	 r8, QWORD PTR [rbx+112]
  00156	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0015d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@MPLIKKOK@?$CFs?4__new__?$CI?$CFs?$CJ?5is?5not?5safe?0?5use?5@
  00164	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00169	e8 00 00 00 00	 call	 PyErr_Format

; 4886 :         return NULL;

  0016e	e9 1d ff ff ff	 jmp	 $LN18@tp_new_wra
$LN7@tp_new_wra:

; 4848 :         PyErr_Format(PyExc_TypeError,
; 4849 :                      "%s.__new__(): not enough arguments",
; 4850 :                      type->tp_name);

  00173	4c 8b 43 70	 mov	 r8, QWORD PTR [rbx+112]
  00177	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0017e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@LLBIFAAG@?$CFs?4__new__?$CI?$CJ?3?5not?5enough?5argumen@
  00185	e8 00 00 00 00	 call	 PyErr_Format

; 4895 : }

  0018a	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0018f	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00194	33 c0		 xor	 eax, eax
  00196	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0019a	5e		 pop	 rsi
  0019b	c3		 ret	 0
tp_new_wrapper ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@OBBJFMLI@__len__?$CI?$CJ?5should?5return?5?$DO?$DN?50?$AA@ ; `string'
PUBLIC	??_C@_02HCKGKOFO@?$CI?$CJ?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$slot_sq_length DD imagerel slot_sq_length
	DD	imagerel slot_sq_length+71
	DD	imagerel $unwind$slot_sq_length
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$slot_sq_length DD imagerel slot_sq_length+71
	DD	imagerel slot_sq_length+141
	DD	imagerel $chain$0$slot_sq_length
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$slot_sq_length DD imagerel slot_sq_length+141
	DD	imagerel slot_sq_length+155
	DD	imagerel $chain$2$slot_sq_length
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$slot_sq_length DD 020021H
	DD	063400H
	DD	imagerel slot_sq_length
	DD	imagerel slot_sq_length+71
	DD	imagerel $unwind$slot_sq_length
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$slot_sq_length DD 020521H
	DD	063405H
	DD	imagerel slot_sq_length
	DD	imagerel slot_sq_length+71
	DD	imagerel $unwind$slot_sq_length
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_sq_length DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT ??_C@_0BN@OBBJFMLI@__len__?$CI?$CJ?5should?5return?5?$DO?$DN?50?$AA@
CONST	SEGMENT
??_C@_0BN@OBBJFMLI@__len__?$CI?$CJ?5should?5return?5?$DO?$DN?50?$AA@ DB '_'
	DB	'_len__() should return >= 0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_02HCKGKOFO@?$CI?$CJ?$AA@ DB '()', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT slot_sq_length
_TEXT	SEGMENT
self$ = 48
slot_sq_length PROC					; COMDAT

; 5022 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 5023 :     _Py_IDENTIFIER(__len__);
; 5024 :     PyObject *res = call_method(self, &PyId___len__, "()");

  00006	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0000d	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00016	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___len__@?1??slot_sq_length@@9@9
  0001b	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  0001f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00026	e8 00 00 00 00	 call	 call_method
  0002b	48 8b f8	 mov	 rdi, rax

; 5025 :     Py_ssize_t len;
; 5026 : 
; 5027 :     if (res == NULL)

  0002e	48 85 c0	 test	 rax, rax
  00031	75 0a		 jne	 SHORT $LN3@slot_sq_le

; 5028 :         return -1;

  00033	48 83 c8 ff	 or	 rax, -1

; 5038 : }

  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5f		 pop	 rdi
  0003c	c3		 ret	 0
$LN3@slot_sq_le:

; 5029 :     len = PyNumber_AsSsize_t(res, PyExc_OverflowError);

  0003d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_OverflowError
  00044	48 8b c8	 mov	 rcx, rax
  00047	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0004c	e8 00 00 00 00	 call	 PyNumber_AsSsize_t

; 5030 :     Py_DECREF(res);

  00051	48 8b cf	 mov	 rcx, rdi
  00054	48 8b d8	 mov	 rbx, rax
  00057	e8 00 00 00 00	 call	 _Py_DecRef

; 5031 :     if (len < 0) {

  0005c	48 85 db	 test	 rbx, rbx
  0005f	79 2c		 jns	 SHORT $LN2@slot_sq_le

; 5032 :         if (!PyErr_Occurred())

  00061	e8 00 00 00 00	 call	 PyErr_Occurred
  00066	48 85 c0	 test	 rax, rax
  00069	75 13		 jne	 SHORT $LN1@slot_sq_le

; 5033 :             PyErr_SetString(PyExc_ValueError,
; 5034 :                             "__len__() should return >= 0");

  0006b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00072	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@OBBJFMLI@__len__?$CI?$CJ?5should?5return?5?$DO?$DN?50?$AA@
  00079	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@slot_sq_le:

; 5035 :         return -1;

  0007e	48 83 c8 ff	 or	 rax, -1
  00082	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 5038 : }

  00087	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008b	5f		 pop	 rdi
  0008c	c3		 ret	 0
$LN2@slot_sq_le:

; 5036 :     }
; 5037 :     return len;

  0008d	48 8b c3	 mov	 rax, rbx
  00090	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 5038 : }

  00095	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00099	5f		 pop	 rdi
  0009a	c3		 ret	 0
slot_sq_length ENDP
_TEXT	ENDS
PUBLIC	??_C@_04CMBFLJAB@?$CInO?$CJ?$AA@		; `string'
PUBLIC	??_C@_03LNDCNOPD@?$CIn?$CJ?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$slot_sq_ass_item DD imagerel slot_sq_ass_item
	DD	imagerel slot_sq_ass_item+117
	DD	imagerel $unwind$slot_sq_ass_item
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_sq_ass_item DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_04CMBFLJAB@?$CInO?$CJ?$AA@
CONST	SEGMENT
??_C@_04CMBFLJAB@?$CInO?$CJ?$AA@ DB '(nO)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LNDCNOPD@?$CIn?$CJ?$AA@
CONST	SEGMENT
??_C@_03LNDCNOPD@?$CIn?$CJ?$AA@ DB '(n)', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT slot_sq_ass_item
_TEXT	SEGMENT
self$ = 64
index$ = 72
value$ = 80
slot_sq_ass_item PROC					; COMDAT

; 5082 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 5083 :     PyObject *res;
; 5084 :     _Py_IDENTIFIER(__delitem__);
; 5085 :     _Py_IDENTIFIER(__setitem__);
; 5086 : 
; 5087 :     if (value == NULL)
; 5088 :         res = call_method(self, &PyId___delitem__, "(n)", index);

  00004	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0000d	4c 8b ca	 mov	 r9, rdx
  00010	4c 8b d1	 mov	 r10, rcx
  00013	4d 85 c0	 test	 r8, r8
  00016	75 1e		 jne	 SHORT $LN3@slot_sq_as
  00018	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0001f	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___delitem__@?1??slot_sq_ass_item@@9@9
  00024	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  00028	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03LNDCNOPD@?$CIn?$CJ?$AA@
  0002f	e8 00 00 00 00	 call	 call_method

; 5089 :     else

  00034	eb 23		 jmp	 SHORT $LN2@slot_sq_as
$LN3@slot_sq_as:

; 5090 :         res = call_method(self, &PyId___setitem__, "(nO)", index, value);

  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0003c	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  00041	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___setitem__@?1??slot_sq_ass_item@@9@9
  00046	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  0004a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04CMBFLJAB@?$CInO?$CJ?$AA@
  00051	49 8b ca	 mov	 rcx, r10
  00054	e8 00 00 00 00	 call	 call_method
$LN2@slot_sq_as:

; 5091 :     if (res == NULL)

  00059	48 85 c0	 test	 rax, rax
  0005c	75 08		 jne	 SHORT $LN1@slot_sq_as

; 5092 :         return -1;

  0005e	83 c8 ff	 or	 eax, -1

; 5095 : }

  00061	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00065	c3		 ret	 0
$LN1@slot_sq_as:

; 5093 :     Py_DECREF(res);

  00066	48 8b c8	 mov	 rcx, rax
  00069	e8 00 00 00 00	 call	 _Py_DecRef

; 5094 :     return 0;

  0006e	33 c0		 xor	 eax, eax

; 5095 : }

  00070	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00074	c3		 ret	 0
slot_sq_ass_item ENDP
_TEXT	ENDS
EXTRN	_PySequence_IterSearch:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$slot_sq_contains DD imagerel slot_sq_contains
	DD	imagerel slot_sq_contains+217
	DD	imagerel $unwind$slot_sq_contains
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_sq_contains DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT slot_sq_contains
_TEXT	SEGMENT
self$ = 48
value$ = 56
slot_sq_contains PROC					; COMDAT

; 5099 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 5100 :     PyObject *func, *res, *args;
; 5101 :     int result = -1;
; 5102 :     _Py_IDENTIFIER(__contains__);
; 5103 : 
; 5104 :     func = lookup_maybe(self, &PyId___contains__);

  0000f	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00016	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0001f	48 8b da	 mov	 rbx, rdx
  00022	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___contains__@?1??slot_sq_contains@@9@9
  00027	48 8b f9	 mov	 rdi, rcx
  0002a	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  0002e	e8 00 00 00 00	 call	 lookup_maybe
  00033	48 8b f0	 mov	 rsi, rax

; 5105 :     if (func != NULL) {

  00036	48 85 c0	 test	 rax, rax
  00039	74 63		 je	 SHORT $LN6@slot_sq_co

; 5106 :         args = PyTuple_Pack(1, value);

  0003b	48 8b d3	 mov	 rdx, rbx
  0003e	b9 01 00 00 00	 mov	 ecx, 1
  00043	e8 00 00 00 00	 call	 PyTuple_Pack
  00048	48 8b d8	 mov	 rbx, rax

; 5107 :         if (args == NULL)

  0004b	48 85 c0	 test	 rax, rax
  0004e	75 04		 jne	 SHORT $LN5@slot_sq_co

; 5108 :             res = NULL;

  00050	33 ff		 xor	 edi, edi

; 5109 :         else {

  00052	eb 19		 jmp	 SHORT $LN4@slot_sq_co
$LN5@slot_sq_co:

; 5110 :             res = PyObject_Call(func, args, NULL);

  00054	45 33 c0	 xor	 r8d, r8d
  00057	48 8b d0	 mov	 rdx, rax
  0005a	48 8b ce	 mov	 rcx, rsi
  0005d	e8 00 00 00 00	 call	 PyObject_Call

; 5111 :             Py_DECREF(args);

  00062	48 8b cb	 mov	 rcx, rbx
  00065	48 8b f8	 mov	 rdi, rax
  00068	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@slot_sq_co:

; 5112 :         }
; 5113 :         Py_DECREF(func);

  0006d	48 8b ce	 mov	 rcx, rsi
  00070	e8 00 00 00 00	 call	 _Py_DecRef

; 5114 :         if (res != NULL) {

  00075	48 85 ff	 test	 rdi, rdi
  00078	74 4c		 je	 SHORT $LN9@slot_sq_co

; 5115 :             result = PyObject_IsTrue(res);

  0007a	48 8b cf	 mov	 rcx, rdi
  0007d	e8 00 00 00 00	 call	 PyObject_IsTrue

; 5116 :             Py_DECREF(res);

  00082	48 8b cf	 mov	 rcx, rdi
  00085	8b d8		 mov	 ebx, eax
  00087	e8 00 00 00 00	 call	 _Py_DecRef

; 5123 :     }
; 5124 :     return result;

  0008c	8b c3		 mov	 eax, ebx

; 5125 : }

  0008e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00093	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00098	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009c	5f		 pop	 rdi
  0009d	c3		 ret	 0
$LN6@slot_sq_co:

; 5117 :         }
; 5118 :     }
; 5119 :     else if (! PyErr_Occurred()) {

  0009e	e8 00 00 00 00	 call	 PyErr_Occurred
  000a3	48 85 c0	 test	 rax, rax
  000a6	75 1e		 jne	 SHORT $LN9@slot_sq_co

; 5120 :         /* Possible results: -1 and 1 */
; 5121 :         result = (int)_PySequence_IterSearch(self, value,
; 5122 :                                          PY_ITERSEARCH_CONTAINS);

  000a8	44 8d 40 03	 lea	 r8d, QWORD PTR [rax+3]
  000ac	48 8b d3	 mov	 rdx, rbx
  000af	48 8b cf	 mov	 rcx, rdi

; 5125 : }

  000b2	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b7	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000bc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c0	5f		 pop	 rdi
  000c1	e9 00 00 00 00	 jmp	 _PySequence_IterSearch
$LN9@slot_sq_co:
  000c6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000cb	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000d0	83 c8 ff	 or	 eax, -1
  000d3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d7	5f		 pop	 rdi
  000d8	c3		 ret	 0
slot_sq_contains ENDP
_TEXT	ENDS
PUBLIC	??_C@_03IELNPCCE@?$CIO?$CJ?$AA@			; `string'
;	COMDAT ??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
CONST	SEGMENT
??_C@_03IELNPCCE@?$CIO?$CJ?$AA@ DB '(O)', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT slot_mp_subscript
_TEXT	SEGMENT
self$ = 8
arg1$ = 16
slot_mp_subscript PROC					; COMDAT

; 5129 : SLOT1(slot_mp_subscript, "__getitem__", PyObject *, "O")

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00007	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00010	4c 8b ca	 mov	 r9, rdx
  00013	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?id@?1??slot_mp_subscript@@9@9
  00018	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  0001c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  00023	e9 00 00 00 00	 jmp	 call_method
slot_mp_subscript ENDP
_TEXT	ENDS
PUBLIC	??_C@_04DEJLHBFK@?$CIOO?$CJ?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$slot_mp_ass_subscript DD imagerel slot_mp_ass_subscript
	DD	imagerel slot_mp_ass_subscript+117
	DD	imagerel $unwind$slot_mp_ass_subscript
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_mp_ass_subscript DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_04DEJLHBFK@?$CIOO?$CJ?$AA@
CONST	SEGMENT
??_C@_04DEJLHBFK@?$CIOO?$CJ?$AA@ DB '(OO)', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT slot_mp_ass_subscript
_TEXT	SEGMENT
self$ = 64
key$ = 72
value$ = 80
slot_mp_ass_subscript PROC				; COMDAT

; 5133 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 5134 :     PyObject *res;
; 5135 :     _Py_IDENTIFIER(__delitem__);
; 5136 :     _Py_IDENTIFIER(__setitem__);
; 5137 : 
; 5138 :     if (value == NULL)
; 5139 :         res = call_method(self, &PyId___delitem__, "(O)", key);

  00004	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0000d	4c 8b ca	 mov	 r9, rdx
  00010	4c 8b d1	 mov	 r10, rcx
  00013	4d 85 c0	 test	 r8, r8
  00016	75 1e		 jne	 SHORT $LN3@slot_mp_as
  00018	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0001f	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___delitem__@?1??slot_mp_ass_subscript@@9@9
  00024	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  00028	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  0002f	e8 00 00 00 00	 call	 call_method

; 5140 :     else

  00034	eb 23		 jmp	 SHORT $LN2@slot_mp_as
$LN3@slot_mp_as:

; 5141 :         res = call_method(self, &PyId___setitem__, "(OO)", key, value);

  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0003c	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  00041	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___setitem__@?1??slot_mp_ass_subscript@@9@9
  00046	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  0004a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04DEJLHBFK@?$CIOO?$CJ?$AA@
  00051	49 8b ca	 mov	 rcx, r10
  00054	e8 00 00 00 00	 call	 call_method
$LN2@slot_mp_as:

; 5142 : 
; 5143 :     if (res == NULL)

  00059	48 85 c0	 test	 rax, rax
  0005c	75 08		 jne	 SHORT $LN1@slot_mp_as

; 5144 :         return -1;

  0005e	83 c8 ff	 or	 eax, -1

; 5147 : }

  00061	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00065	c3		 ret	 0
$LN1@slot_mp_as:

; 5145 :     Py_DECREF(res);

  00066	48 8b c8	 mov	 rcx, rax
  00069	e8 00 00 00 00	 call	 _Py_DecRef

; 5146 :     return 0;

  0006e	33 c0		 xor	 eax, eax

; 5147 : }

  00070	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00074	c3		 ret	 0
slot_mp_ass_subscript ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$slot_nb_add DD imagerel slot_nb_add
	DD	imagerel slot_nb_add+418
	DD	imagerel $unwind$slot_nb_add
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_nb_add DD 0a5301H
	DD	0a5453H
	DD	0c6413H
	DD	0b3413H
	DD	0e00f5213H
	DD	0700bd00dH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT slot_nb_add
_TEXT	SEGMENT
self$ = 80
other$ = 88
slot_nb_add PROC					; COMDAT

; 5149 : SLOT1BIN(slot_nb_add, nb_add, "__add__", "__radd__")

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fa	 mov	 rdi, rdx
  00016	48 8b 51 58	 mov	 rdx, QWORD PTR [rcx+88]
  0001a	48 8b f1	 mov	 rsi, rcx
  0001d	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00021	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:slot_nb_add
  00028	48 3b d1	 cmp	 rdx, rcx
  0002b	74 18		 je	 SHORT $LN9@slot_nb_ad
  0002d	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00034	48 85 c0	 test	 rax, rax
  00037	74 0c		 je	 SHORT $LN9@slot_nb_ad
  00039	4c 39 00	 cmp	 QWORD PTR [rax], r8
  0003c	75 07		 jne	 SHORT $LN9@slot_nb_ad
  0003e	bb 01 00 00 00	 mov	 ebx, 1
  00043	eb 02		 jmp	 SHORT $LN10@slot_nb_ad
$LN9@slot_nb_ad:
  00045	33 db		 xor	 ebx, ebx
$LN10@slot_nb_ad:
  00047	48 8b 82 b8 00
	00 00		 mov	 rax, QWORD PTR [rdx+184]
  0004e	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00053	41 be 00 00 00
	00		 mov	 r14d, OFFSET FLAT:?rop_id@?1??slot_nb_add@@9@9
  00059	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_NotImplementedStruct
  00060	48 85 c0	 test	 rax, rax
  00063	0f 84 ae 00 00
	00		 je	 $LN6@slot_nb_ad
  00069	4c 39 00	 cmp	 QWORD PTR [rax], r8
  0006c	0f 85 a5 00 00
	00		 jne	 $LN6@slot_nb_ad
  00072	85 db		 test	 ebx, ebx
  00074	74 5c		 je	 SHORT $LN5@slot_nb_ad
  00076	e8 00 00 00 00	 call	 PyType_IsSubtype
  0007b	85 c0		 test	 eax, eax
  0007d	74 53		 je	 SHORT $LN5@slot_nb_ad
  0007f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00085	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0008e	41 8b ce	 mov	 ecx, r14d
  00091	48 8b 2c d0	 mov	 rbp, QWORD PTR [rax+rdx*8]
  00095	48 8b d7	 mov	 rdx, rdi
  00098	48 03 e9	 add	 rbp, rcx
  0009b	48 8b ce	 mov	 rcx, rsi
  0009e	4c 8b c5	 mov	 r8, rbp
  000a1	e8 00 00 00 00	 call	 method_is_overloaded
  000a6	85 c0		 test	 eax, eax
  000a8	74 28		 je	 SHORT $LN5@slot_nb_ad
  000aa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  000b1	4c 8b ce	 mov	 r9, rsi
  000b4	48 8b d5	 mov	 rdx, rbp
  000b7	48 8b cf	 mov	 rcx, rdi
  000ba	e8 00 00 00 00	 call	 call_maybe
  000bf	49 3b c5	 cmp	 rax, r13
  000c2	0f 85 c1 00 00
	00		 jne	 $LN7@slot_nb_ad
  000c8	48 8b c8	 mov	 rcx, rax
  000cb	e8 00 00 00 00	 call	 _Py_DecRef
  000d0	33 db		 xor	 ebx, ebx
$LN5@slot_nb_ad:
  000d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000d8	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  000e1	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?op_id@?1??slot_nb_add@@9@9
  000e6	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  000ea	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  000f1	4c 8b cf	 mov	 r9, rdi
  000f4	48 8b ce	 mov	 rcx, rsi
  000f7	e8 00 00 00 00	 call	 call_maybe
  000fc	49 3b c5	 cmp	 rax, r13
  000ff	0f 85 84 00 00
	00		 jne	 $LN7@slot_nb_ad
  00105	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  00109	48 39 4f 58	 cmp	 QWORD PTR [rdi+88], rcx
  0010d	74 7a		 je	 SHORT $LN7@slot_nb_ad
  0010f	48 8b c8	 mov	 rcx, rax
  00112	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@slot_nb_ad:
  00117	85 db		 test	 ebx, ebx
  00119	74 2a		 je	 SHORT $LN1@slot_nb_ad
  0011b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00121	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0012a	41 8b d6	 mov	 edx, r14d
  0012d	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00131	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  00138	4c 8b ce	 mov	 r9, rsi
  0013b	48 8b cf	 mov	 rcx, rdi
  0013e	e8 00 00 00 00	 call	 call_maybe
  00143	eb 44		 jmp	 SHORT $LN7@slot_nb_ad
$LN1@slot_nb_ad:
  00145	e8 00 00 00 00	 call	 _Py_PXCTX
  0014a	85 c0		 test	 eax, eax
  0014c	75 38		 jne	 SHORT $LN12@slot_nb_ad
  0014e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00155	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0015c	4d 8b cd	 mov	 r9, r13
  0015f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00165	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0016d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00172	85 c0		 test	 eax, eax
  00174	75 09		 jne	 SHORT $LN11@slot_nb_ad
  00176	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  0017d	74 07		 je	 SHORT $LN12@slot_nb_ad
$LN11@slot_nb_ad:
  0017f	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN12@slot_nb_ad:
  00186	49 8b c5	 mov	 rax, r13
$LN7@slot_nb_ad:
  00189	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0018e	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00193	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00198	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0019c	41 5e		 pop	 r14
  0019e	41 5d		 pop	 r13
  001a0	5f		 pop	 rdi
  001a1	c3		 ret	 0
slot_nb_add ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$slot_nb_subtract DD imagerel slot_nb_subtract
	DD	imagerel slot_nb_subtract+420
	DD	imagerel $unwind$slot_nb_subtract
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_nb_subtract DD 0a5401H
	DD	0a5454H
	DD	0c6413H
	DD	0b3413H
	DD	0e00f5213H
	DD	0700bd00dH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT slot_nb_subtract
_TEXT	SEGMENT
self$ = 80
other$ = 88
slot_nb_subtract PROC					; COMDAT

; 5150 : SLOT1BIN(slot_nb_subtract, nb_subtract, "__sub__", "__rsub__")

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fa	 mov	 rdi, rdx
  00016	48 8b 51 58	 mov	 rdx, QWORD PTR [rcx+88]
  0001a	48 8b f1	 mov	 rsi, rcx
  0001d	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00021	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:slot_nb_subtract
  00028	48 3b d1	 cmp	 rdx, rcx
  0002b	74 19		 je	 SHORT $LN9@slot_nb_su
  0002d	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00034	48 85 c0	 test	 rax, rax
  00037	74 0d		 je	 SHORT $LN9@slot_nb_su
  00039	4c 39 40 08	 cmp	 QWORD PTR [rax+8], r8
  0003d	75 07		 jne	 SHORT $LN9@slot_nb_su
  0003f	bb 01 00 00 00	 mov	 ebx, 1
  00044	eb 02		 jmp	 SHORT $LN10@slot_nb_su
$LN9@slot_nb_su:
  00046	33 db		 xor	 ebx, ebx
$LN10@slot_nb_su:
  00048	48 8b 82 b8 00
	00 00		 mov	 rax, QWORD PTR [rdx+184]
  0004f	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00054	41 be 00 00 00
	00		 mov	 r14d, OFFSET FLAT:?rop_id@?1??slot_nb_subtract@@9@9
  0005a	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_NotImplementedStruct
  00061	48 85 c0	 test	 rax, rax
  00064	0f 84 af 00 00
	00		 je	 $LN6@slot_nb_su
  0006a	4c 39 40 08	 cmp	 QWORD PTR [rax+8], r8
  0006e	0f 85 a5 00 00
	00		 jne	 $LN6@slot_nb_su
  00074	85 db		 test	 ebx, ebx
  00076	74 5c		 je	 SHORT $LN5@slot_nb_su
  00078	e8 00 00 00 00	 call	 PyType_IsSubtype
  0007d	85 c0		 test	 eax, eax
  0007f	74 53		 je	 SHORT $LN5@slot_nb_su
  00081	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00087	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00090	41 8b ce	 mov	 ecx, r14d
  00093	48 8b 2c d0	 mov	 rbp, QWORD PTR [rax+rdx*8]
  00097	48 8b d7	 mov	 rdx, rdi
  0009a	48 03 e9	 add	 rbp, rcx
  0009d	48 8b ce	 mov	 rcx, rsi
  000a0	4c 8b c5	 mov	 r8, rbp
  000a3	e8 00 00 00 00	 call	 method_is_overloaded
  000a8	85 c0		 test	 eax, eax
  000aa	74 28		 je	 SHORT $LN5@slot_nb_su
  000ac	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  000b3	4c 8b ce	 mov	 r9, rsi
  000b6	48 8b d5	 mov	 rdx, rbp
  000b9	48 8b cf	 mov	 rcx, rdi
  000bc	e8 00 00 00 00	 call	 call_maybe
  000c1	49 3b c5	 cmp	 rax, r13
  000c4	0f 85 c1 00 00
	00		 jne	 $LN7@slot_nb_su
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 _Py_DecRef
  000d2	33 db		 xor	 ebx, ebx
$LN5@slot_nb_su:
  000d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000da	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  000e3	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?op_id@?1??slot_nb_subtract@@9@9
  000e8	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  000ec	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  000f3	4c 8b cf	 mov	 r9, rdi
  000f6	48 8b ce	 mov	 rcx, rsi
  000f9	e8 00 00 00 00	 call	 call_maybe
  000fe	49 3b c5	 cmp	 rax, r13
  00101	0f 85 84 00 00
	00		 jne	 $LN7@slot_nb_su
  00107	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  0010b	48 39 4f 58	 cmp	 QWORD PTR [rdi+88], rcx
  0010f	74 7a		 je	 SHORT $LN7@slot_nb_su
  00111	48 8b c8	 mov	 rcx, rax
  00114	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@slot_nb_su:
  00119	85 db		 test	 ebx, ebx
  0011b	74 2a		 je	 SHORT $LN1@slot_nb_su
  0011d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00123	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0012c	41 8b d6	 mov	 edx, r14d
  0012f	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00133	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  0013a	4c 8b ce	 mov	 r9, rsi
  0013d	48 8b cf	 mov	 rcx, rdi
  00140	e8 00 00 00 00	 call	 call_maybe
  00145	eb 44		 jmp	 SHORT $LN7@slot_nb_su
$LN1@slot_nb_su:
  00147	e8 00 00 00 00	 call	 _Py_PXCTX
  0014c	85 c0		 test	 eax, eax
  0014e	75 38		 jne	 SHORT $LN12@slot_nb_su
  00150	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00157	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0015e	4d 8b cd	 mov	 r9, r13
  00161	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00167	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0016f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00174	85 c0		 test	 eax, eax
  00176	75 09		 jne	 SHORT $LN11@slot_nb_su
  00178	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  0017f	74 07		 je	 SHORT $LN12@slot_nb_su
$LN11@slot_nb_su:
  00181	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN12@slot_nb_su:
  00188	49 8b c5	 mov	 rax, r13
$LN7@slot_nb_su:
  0018b	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00190	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00195	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0019a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0019e	41 5e		 pop	 r14
  001a0	41 5d		 pop	 r13
  001a2	5f		 pop	 rdi
  001a3	c3		 ret	 0
slot_nb_subtract ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$slot_nb_multiply DD imagerel slot_nb_multiply
	DD	imagerel slot_nb_multiply+420
	DD	imagerel $unwind$slot_nb_multiply
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_nb_multiply DD 0a5401H
	DD	0a5454H
	DD	0c6413H
	DD	0b3413H
	DD	0e00f5213H
	DD	0700bd00dH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT slot_nb_multiply
_TEXT	SEGMENT
self$ = 80
other$ = 88
slot_nb_multiply PROC					; COMDAT

; 5151 : SLOT1BIN(slot_nb_multiply, nb_multiply, "__mul__", "__rmul__")

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fa	 mov	 rdi, rdx
  00016	48 8b 51 58	 mov	 rdx, QWORD PTR [rcx+88]
  0001a	48 8b f1	 mov	 rsi, rcx
  0001d	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00021	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:slot_nb_multiply
  00028	48 3b d1	 cmp	 rdx, rcx
  0002b	74 19		 je	 SHORT $LN9@slot_nb_mu
  0002d	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00034	48 85 c0	 test	 rax, rax
  00037	74 0d		 je	 SHORT $LN9@slot_nb_mu
  00039	4c 39 40 10	 cmp	 QWORD PTR [rax+16], r8
  0003d	75 07		 jne	 SHORT $LN9@slot_nb_mu
  0003f	bb 01 00 00 00	 mov	 ebx, 1
  00044	eb 02		 jmp	 SHORT $LN10@slot_nb_mu
$LN9@slot_nb_mu:
  00046	33 db		 xor	 ebx, ebx
$LN10@slot_nb_mu:
  00048	48 8b 82 b8 00
	00 00		 mov	 rax, QWORD PTR [rdx+184]
  0004f	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00054	41 be 00 00 00
	00		 mov	 r14d, OFFSET FLAT:?rop_id@?1??slot_nb_multiply@@9@9
  0005a	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_NotImplementedStruct
  00061	48 85 c0	 test	 rax, rax
  00064	0f 84 af 00 00
	00		 je	 $LN6@slot_nb_mu
  0006a	4c 39 40 10	 cmp	 QWORD PTR [rax+16], r8
  0006e	0f 85 a5 00 00
	00		 jne	 $LN6@slot_nb_mu
  00074	85 db		 test	 ebx, ebx
  00076	74 5c		 je	 SHORT $LN5@slot_nb_mu
  00078	e8 00 00 00 00	 call	 PyType_IsSubtype
  0007d	85 c0		 test	 eax, eax
  0007f	74 53		 je	 SHORT $LN5@slot_nb_mu
  00081	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00087	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00090	41 8b ce	 mov	 ecx, r14d
  00093	48 8b 2c d0	 mov	 rbp, QWORD PTR [rax+rdx*8]
  00097	48 8b d7	 mov	 rdx, rdi
  0009a	48 03 e9	 add	 rbp, rcx
  0009d	48 8b ce	 mov	 rcx, rsi
  000a0	4c 8b c5	 mov	 r8, rbp
  000a3	e8 00 00 00 00	 call	 method_is_overloaded
  000a8	85 c0		 test	 eax, eax
  000aa	74 28		 je	 SHORT $LN5@slot_nb_mu
  000ac	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  000b3	4c 8b ce	 mov	 r9, rsi
  000b6	48 8b d5	 mov	 rdx, rbp
  000b9	48 8b cf	 mov	 rcx, rdi
  000bc	e8 00 00 00 00	 call	 call_maybe
  000c1	49 3b c5	 cmp	 rax, r13
  000c4	0f 85 c1 00 00
	00		 jne	 $LN7@slot_nb_mu
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 _Py_DecRef
  000d2	33 db		 xor	 ebx, ebx
$LN5@slot_nb_mu:
  000d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000da	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  000e3	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?op_id@?1??slot_nb_multiply@@9@9
  000e8	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  000ec	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  000f3	4c 8b cf	 mov	 r9, rdi
  000f6	48 8b ce	 mov	 rcx, rsi
  000f9	e8 00 00 00 00	 call	 call_maybe
  000fe	49 3b c5	 cmp	 rax, r13
  00101	0f 85 84 00 00
	00		 jne	 $LN7@slot_nb_mu
  00107	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  0010b	48 39 4f 58	 cmp	 QWORD PTR [rdi+88], rcx
  0010f	74 7a		 je	 SHORT $LN7@slot_nb_mu
  00111	48 8b c8	 mov	 rcx, rax
  00114	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@slot_nb_mu:
  00119	85 db		 test	 ebx, ebx
  0011b	74 2a		 je	 SHORT $LN1@slot_nb_mu
  0011d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00123	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0012c	41 8b d6	 mov	 edx, r14d
  0012f	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00133	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  0013a	4c 8b ce	 mov	 r9, rsi
  0013d	48 8b cf	 mov	 rcx, rdi
  00140	e8 00 00 00 00	 call	 call_maybe
  00145	eb 44		 jmp	 SHORT $LN7@slot_nb_mu
$LN1@slot_nb_mu:
  00147	e8 00 00 00 00	 call	 _Py_PXCTX
  0014c	85 c0		 test	 eax, eax
  0014e	75 38		 jne	 SHORT $LN12@slot_nb_mu
  00150	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00157	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0015e	4d 8b cd	 mov	 r9, r13
  00161	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00167	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0016f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00174	85 c0		 test	 eax, eax
  00176	75 09		 jne	 SHORT $LN11@slot_nb_mu
  00178	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  0017f	74 07		 je	 SHORT $LN12@slot_nb_mu
$LN11@slot_nb_mu:
  00181	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN12@slot_nb_mu:
  00188	49 8b c5	 mov	 rax, r13
$LN7@slot_nb_mu:
  0018b	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00190	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00195	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0019a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0019e	41 5e		 pop	 r14
  001a0	41 5d		 pop	 r13
  001a2	5f		 pop	 rdi
  001a3	c3		 ret	 0
slot_nb_multiply ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$slot_nb_remainder DD imagerel slot_nb_remainder
	DD	imagerel slot_nb_remainder+420
	DD	imagerel $unwind$slot_nb_remainder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_nb_remainder DD 0a5401H
	DD	0a5454H
	DD	0c6413H
	DD	0b3413H
	DD	0e00f5213H
	DD	0700bd00dH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT slot_nb_remainder
_TEXT	SEGMENT
self$ = 80
other$ = 88
slot_nb_remainder PROC					; COMDAT

; 5152 : SLOT1BIN(slot_nb_remainder, nb_remainder, "__mod__", "__rmod__")

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fa	 mov	 rdi, rdx
  00016	48 8b 51 58	 mov	 rdx, QWORD PTR [rcx+88]
  0001a	48 8b f1	 mov	 rsi, rcx
  0001d	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00021	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:slot_nb_remainder
  00028	48 3b d1	 cmp	 rdx, rcx
  0002b	74 19		 je	 SHORT $LN9@slot_nb_re
  0002d	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00034	48 85 c0	 test	 rax, rax
  00037	74 0d		 je	 SHORT $LN9@slot_nb_re
  00039	4c 39 40 18	 cmp	 QWORD PTR [rax+24], r8
  0003d	75 07		 jne	 SHORT $LN9@slot_nb_re
  0003f	bb 01 00 00 00	 mov	 ebx, 1
  00044	eb 02		 jmp	 SHORT $LN10@slot_nb_re
$LN9@slot_nb_re:
  00046	33 db		 xor	 ebx, ebx
$LN10@slot_nb_re:
  00048	48 8b 82 b8 00
	00 00		 mov	 rax, QWORD PTR [rdx+184]
  0004f	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00054	41 be 00 00 00
	00		 mov	 r14d, OFFSET FLAT:?rop_id@?1??slot_nb_remainder@@9@9
  0005a	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_NotImplementedStruct
  00061	48 85 c0	 test	 rax, rax
  00064	0f 84 af 00 00
	00		 je	 $LN6@slot_nb_re
  0006a	4c 39 40 18	 cmp	 QWORD PTR [rax+24], r8
  0006e	0f 85 a5 00 00
	00		 jne	 $LN6@slot_nb_re
  00074	85 db		 test	 ebx, ebx
  00076	74 5c		 je	 SHORT $LN5@slot_nb_re
  00078	e8 00 00 00 00	 call	 PyType_IsSubtype
  0007d	85 c0		 test	 eax, eax
  0007f	74 53		 je	 SHORT $LN5@slot_nb_re
  00081	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00087	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00090	41 8b ce	 mov	 ecx, r14d
  00093	48 8b 2c d0	 mov	 rbp, QWORD PTR [rax+rdx*8]
  00097	48 8b d7	 mov	 rdx, rdi
  0009a	48 03 e9	 add	 rbp, rcx
  0009d	48 8b ce	 mov	 rcx, rsi
  000a0	4c 8b c5	 mov	 r8, rbp
  000a3	e8 00 00 00 00	 call	 method_is_overloaded
  000a8	85 c0		 test	 eax, eax
  000aa	74 28		 je	 SHORT $LN5@slot_nb_re
  000ac	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  000b3	4c 8b ce	 mov	 r9, rsi
  000b6	48 8b d5	 mov	 rdx, rbp
  000b9	48 8b cf	 mov	 rcx, rdi
  000bc	e8 00 00 00 00	 call	 call_maybe
  000c1	49 3b c5	 cmp	 rax, r13
  000c4	0f 85 c1 00 00
	00		 jne	 $LN7@slot_nb_re
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 _Py_DecRef
  000d2	33 db		 xor	 ebx, ebx
$LN5@slot_nb_re:
  000d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000da	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  000e3	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?op_id@?1??slot_nb_remainder@@9@9
  000e8	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  000ec	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  000f3	4c 8b cf	 mov	 r9, rdi
  000f6	48 8b ce	 mov	 rcx, rsi
  000f9	e8 00 00 00 00	 call	 call_maybe
  000fe	49 3b c5	 cmp	 rax, r13
  00101	0f 85 84 00 00
	00		 jne	 $LN7@slot_nb_re
  00107	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  0010b	48 39 4f 58	 cmp	 QWORD PTR [rdi+88], rcx
  0010f	74 7a		 je	 SHORT $LN7@slot_nb_re
  00111	48 8b c8	 mov	 rcx, rax
  00114	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@slot_nb_re:
  00119	85 db		 test	 ebx, ebx
  0011b	74 2a		 je	 SHORT $LN1@slot_nb_re
  0011d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00123	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0012c	41 8b d6	 mov	 edx, r14d
  0012f	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00133	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  0013a	4c 8b ce	 mov	 r9, rsi
  0013d	48 8b cf	 mov	 rcx, rdi
  00140	e8 00 00 00 00	 call	 call_maybe
  00145	eb 44		 jmp	 SHORT $LN7@slot_nb_re
$LN1@slot_nb_re:
  00147	e8 00 00 00 00	 call	 _Py_PXCTX
  0014c	85 c0		 test	 eax, eax
  0014e	75 38		 jne	 SHORT $LN12@slot_nb_re
  00150	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00157	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0015e	4d 8b cd	 mov	 r9, r13
  00161	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00167	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0016f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00174	85 c0		 test	 eax, eax
  00176	75 09		 jne	 SHORT $LN11@slot_nb_re
  00178	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  0017f	74 07		 je	 SHORT $LN12@slot_nb_re
$LN11@slot_nb_re:
  00181	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN12@slot_nb_re:
  00188	49 8b c5	 mov	 rax, r13
$LN7@slot_nb_re:
  0018b	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00190	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00195	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0019a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0019e	41 5e		 pop	 r14
  001a0	41 5d		 pop	 r13
  001a2	5f		 pop	 rdi
  001a3	c3		 ret	 0
slot_nb_remainder ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$slot_nb_divmod DD imagerel slot_nb_divmod
	DD	imagerel slot_nb_divmod+420
	DD	imagerel $unwind$slot_nb_divmod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_nb_divmod DD 0a5401H
	DD	0a5454H
	DD	0c6413H
	DD	0b3413H
	DD	0e00f5213H
	DD	0700bd00dH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT slot_nb_divmod
_TEXT	SEGMENT
self$ = 80
other$ = 88
slot_nb_divmod PROC					; COMDAT

; 5153 : SLOT1BIN(slot_nb_divmod, nb_divmod, "__divmod__", "__rdivmod__")

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fa	 mov	 rdi, rdx
  00016	48 8b 51 58	 mov	 rdx, QWORD PTR [rcx+88]
  0001a	48 8b f1	 mov	 rsi, rcx
  0001d	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00021	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:slot_nb_divmod
  00028	48 3b d1	 cmp	 rdx, rcx
  0002b	74 19		 je	 SHORT $LN9@slot_nb_di
  0002d	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00034	48 85 c0	 test	 rax, rax
  00037	74 0d		 je	 SHORT $LN9@slot_nb_di
  00039	4c 39 40 20	 cmp	 QWORD PTR [rax+32], r8
  0003d	75 07		 jne	 SHORT $LN9@slot_nb_di
  0003f	bb 01 00 00 00	 mov	 ebx, 1
  00044	eb 02		 jmp	 SHORT $LN10@slot_nb_di
$LN9@slot_nb_di:
  00046	33 db		 xor	 ebx, ebx
$LN10@slot_nb_di:
  00048	48 8b 82 b8 00
	00 00		 mov	 rax, QWORD PTR [rdx+184]
  0004f	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00054	41 be 00 00 00
	00		 mov	 r14d, OFFSET FLAT:?rop_id@?1??slot_nb_divmod@@9@9
  0005a	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_NotImplementedStruct
  00061	48 85 c0	 test	 rax, rax
  00064	0f 84 af 00 00
	00		 je	 $LN6@slot_nb_di
  0006a	4c 39 40 20	 cmp	 QWORD PTR [rax+32], r8
  0006e	0f 85 a5 00 00
	00		 jne	 $LN6@slot_nb_di
  00074	85 db		 test	 ebx, ebx
  00076	74 5c		 je	 SHORT $LN5@slot_nb_di
  00078	e8 00 00 00 00	 call	 PyType_IsSubtype
  0007d	85 c0		 test	 eax, eax
  0007f	74 53		 je	 SHORT $LN5@slot_nb_di
  00081	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00087	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00090	41 8b ce	 mov	 ecx, r14d
  00093	48 8b 2c d0	 mov	 rbp, QWORD PTR [rax+rdx*8]
  00097	48 8b d7	 mov	 rdx, rdi
  0009a	48 03 e9	 add	 rbp, rcx
  0009d	48 8b ce	 mov	 rcx, rsi
  000a0	4c 8b c5	 mov	 r8, rbp
  000a3	e8 00 00 00 00	 call	 method_is_overloaded
  000a8	85 c0		 test	 eax, eax
  000aa	74 28		 je	 SHORT $LN5@slot_nb_di
  000ac	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  000b3	4c 8b ce	 mov	 r9, rsi
  000b6	48 8b d5	 mov	 rdx, rbp
  000b9	48 8b cf	 mov	 rcx, rdi
  000bc	e8 00 00 00 00	 call	 call_maybe
  000c1	49 3b c5	 cmp	 rax, r13
  000c4	0f 85 c1 00 00
	00		 jne	 $LN7@slot_nb_di
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 _Py_DecRef
  000d2	33 db		 xor	 ebx, ebx
$LN5@slot_nb_di:
  000d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000da	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  000e3	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?op_id@?1??slot_nb_divmod@@9@9
  000e8	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  000ec	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  000f3	4c 8b cf	 mov	 r9, rdi
  000f6	48 8b ce	 mov	 rcx, rsi
  000f9	e8 00 00 00 00	 call	 call_maybe
  000fe	49 3b c5	 cmp	 rax, r13
  00101	0f 85 84 00 00
	00		 jne	 $LN7@slot_nb_di
  00107	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  0010b	48 39 4f 58	 cmp	 QWORD PTR [rdi+88], rcx
  0010f	74 7a		 je	 SHORT $LN7@slot_nb_di
  00111	48 8b c8	 mov	 rcx, rax
  00114	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@slot_nb_di:
  00119	85 db		 test	 ebx, ebx
  0011b	74 2a		 je	 SHORT $LN1@slot_nb_di
  0011d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00123	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0012c	41 8b d6	 mov	 edx, r14d
  0012f	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00133	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  0013a	4c 8b ce	 mov	 r9, rsi
  0013d	48 8b cf	 mov	 rcx, rdi
  00140	e8 00 00 00 00	 call	 call_maybe
  00145	eb 44		 jmp	 SHORT $LN7@slot_nb_di
$LN1@slot_nb_di:
  00147	e8 00 00 00 00	 call	 _Py_PXCTX
  0014c	85 c0		 test	 eax, eax
  0014e	75 38		 jne	 SHORT $LN12@slot_nb_di
  00150	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00157	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0015e	4d 8b cd	 mov	 r9, r13
  00161	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00167	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0016f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00174	85 c0		 test	 eax, eax
  00176	75 09		 jne	 SHORT $LN11@slot_nb_di
  00178	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  0017f	74 07		 je	 SHORT $LN12@slot_nb_di
$LN11@slot_nb_di:
  00181	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN12@slot_nb_di:
  00188	49 8b c5	 mov	 rax, r13
$LN7@slot_nb_di:
  0018b	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00190	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00195	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0019a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0019e	41 5e		 pop	 r14
  001a0	41 5d		 pop	 r13
  001a2	5f		 pop	 rdi
  001a3	c3		 ret	 0
slot_nb_divmod ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$slot_nb_power_binary DD imagerel slot_nb_power_binary
	DD	imagerel slot_nb_power_binary+420
	DD	imagerel $unwind$slot_nb_power_binary
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_nb_power_binary DD 0a5401H
	DD	0a5454H
	DD	0c6413H
	DD	0b3413H
	DD	0e00f5213H
	DD	0700bd00dH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT slot_nb_power_binary
_TEXT	SEGMENT
self$ = 80
other$ = 88
slot_nb_power_binary PROC				; COMDAT

; 5158 :              nb_power, "__pow__", "__rpow__")

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fa	 mov	 rdi, rdx
  00016	48 8b 51 58	 mov	 rdx, QWORD PTR [rcx+88]
  0001a	48 8b f1	 mov	 rsi, rcx
  0001d	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00021	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:slot_nb_power
  00028	48 3b d1	 cmp	 rdx, rcx
  0002b	74 19		 je	 SHORT $LN9@slot_nb_po
  0002d	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00034	48 85 c0	 test	 rax, rax
  00037	74 0d		 je	 SHORT $LN9@slot_nb_po
  00039	4c 39 40 28	 cmp	 QWORD PTR [rax+40], r8
  0003d	75 07		 jne	 SHORT $LN9@slot_nb_po
  0003f	bb 01 00 00 00	 mov	 ebx, 1
  00044	eb 02		 jmp	 SHORT $LN10@slot_nb_po
$LN9@slot_nb_po:
  00046	33 db		 xor	 ebx, ebx
$LN10@slot_nb_po:
  00048	48 8b 82 b8 00
	00 00		 mov	 rax, QWORD PTR [rdx+184]
  0004f	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00054	41 be 00 00 00
	00		 mov	 r14d, OFFSET FLAT:?rop_id@?1??slot_nb_power_binary@@9@9
  0005a	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_NotImplementedStruct
  00061	48 85 c0	 test	 rax, rax
  00064	0f 84 af 00 00
	00		 je	 $LN6@slot_nb_po
  0006a	4c 39 40 28	 cmp	 QWORD PTR [rax+40], r8
  0006e	0f 85 a5 00 00
	00		 jne	 $LN6@slot_nb_po
  00074	85 db		 test	 ebx, ebx
  00076	74 5c		 je	 SHORT $LN5@slot_nb_po
  00078	e8 00 00 00 00	 call	 PyType_IsSubtype
  0007d	85 c0		 test	 eax, eax
  0007f	74 53		 je	 SHORT $LN5@slot_nb_po
  00081	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00087	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00090	41 8b ce	 mov	 ecx, r14d
  00093	48 8b 2c d0	 mov	 rbp, QWORD PTR [rax+rdx*8]
  00097	48 8b d7	 mov	 rdx, rdi
  0009a	48 03 e9	 add	 rbp, rcx
  0009d	48 8b ce	 mov	 rcx, rsi
  000a0	4c 8b c5	 mov	 r8, rbp
  000a3	e8 00 00 00 00	 call	 method_is_overloaded
  000a8	85 c0		 test	 eax, eax
  000aa	74 28		 je	 SHORT $LN5@slot_nb_po
  000ac	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  000b3	4c 8b ce	 mov	 r9, rsi
  000b6	48 8b d5	 mov	 rdx, rbp
  000b9	48 8b cf	 mov	 rcx, rdi
  000bc	e8 00 00 00 00	 call	 call_maybe
  000c1	49 3b c5	 cmp	 rax, r13
  000c4	0f 85 c1 00 00
	00		 jne	 $LN7@slot_nb_po
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 _Py_DecRef
  000d2	33 db		 xor	 ebx, ebx
$LN5@slot_nb_po:
  000d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000da	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  000e3	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?op_id@?1??slot_nb_power_binary@@9@9
  000e8	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  000ec	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  000f3	4c 8b cf	 mov	 r9, rdi
  000f6	48 8b ce	 mov	 rcx, rsi
  000f9	e8 00 00 00 00	 call	 call_maybe
  000fe	49 3b c5	 cmp	 rax, r13
  00101	0f 85 84 00 00
	00		 jne	 $LN7@slot_nb_po
  00107	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  0010b	48 39 4f 58	 cmp	 QWORD PTR [rdi+88], rcx
  0010f	74 7a		 je	 SHORT $LN7@slot_nb_po
  00111	48 8b c8	 mov	 rcx, rax
  00114	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@slot_nb_po:
  00119	85 db		 test	 ebx, ebx
  0011b	74 2a		 je	 SHORT $LN1@slot_nb_po
  0011d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00123	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0012c	41 8b d6	 mov	 edx, r14d
  0012f	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00133	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  0013a	4c 8b ce	 mov	 r9, rsi
  0013d	48 8b cf	 mov	 rcx, rdi
  00140	e8 00 00 00 00	 call	 call_maybe
  00145	eb 44		 jmp	 SHORT $LN7@slot_nb_po
$LN1@slot_nb_po:
  00147	e8 00 00 00 00	 call	 _Py_PXCTX
  0014c	85 c0		 test	 eax, eax
  0014e	75 38		 jne	 SHORT $LN12@slot_nb_po
  00150	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00157	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0015e	4d 8b cd	 mov	 r9, r13
  00161	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00167	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0016f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00174	85 c0		 test	 eax, eax
  00176	75 09		 jne	 SHORT $LN11@slot_nb_po
  00178	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  0017f	74 07		 je	 SHORT $LN12@slot_nb_po
$LN11@slot_nb_po:
  00181	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN12@slot_nb_po:
  00188	49 8b c5	 mov	 rax, r13
$LN7@slot_nb_po:
  0018b	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00190	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00195	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0019a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0019e	41 5e		 pop	 r14
  001a0	41 5d		 pop	 r13
  001a2	5f		 pop	 rdi
  001a3	c3		 ret	 0
slot_nb_power_binary ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$slot_nb_power DD imagerel slot_nb_power
	DD	imagerel slot_nb_power+190
	DD	imagerel $unwind$slot_nb_power
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_nb_power DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT slot_nb_power
_TEXT	SEGMENT
self$ = 64
other$ = 72
modulus$ = 80
slot_nb_power PROC					; COMDAT

; 5162 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 5163 :     _Py_IDENTIFIER(__pow__);
; 5164 : 
; 5165 :     if (modulus == Py_None)

  00004	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0000b	4c 8b ca	 mov	 r9, rdx
  0000e	4c 8b d1	 mov	 r10, rcx
  00011	4c 3b c0	 cmp	 r8, rax
  00014	75 09		 jne	 SHORT $LN2@slot_nb_po@2

; 5175 : }

  00016	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001a	e9 00 00 00 00	 jmp	 slot_nb_power_binary
$LN2@slot_nb_po@2:

; 5166 :         return slot_nb_power_binary(self, other);
; 5167 :     /* Three-arg power doesn't use __rpow__.  But ternary_op
; 5168 :        can call this when the second argument's type uses
; 5169 :        slot_nb_power, so check before calling self.__pow__. */
; 5170 :     if (Py_TYPE(self)->tp_as_number != NULL &&
; 5171 :         Py_TYPE(self)->tp_as_number->nb_power == slot_nb_power) {

  0001f	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00023	48 8b 88 b8 00
	00 00		 mov	 rcx, QWORD PTR [rax+184]
  0002a	48 85 c9	 test	 rcx, rcx
  0002d	74 3e		 je	 SHORT $LN1@slot_nb_po@2
  0002f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:slot_nb_power
  00036	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  0003a	75 31		 jne	 SHORT $LN1@slot_nb_po@2

; 5172 :         return call_method(self, &PyId___pow__, "(OO)", other, modulus);

  0003c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00042	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0004b	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  00050	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___pow__@?1??slot_nb_power@@9@9
  00055	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04DEJLHBFK@?$CIOO?$CJ?$AA@
  0005c	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00060	49 8b ca	 mov	 rcx, r10
  00063	e8 00 00 00 00	 call	 call_method

; 5175 : }

  00068	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006c	c3		 ret	 0
$LN1@slot_nb_po@2:

; 5173 :     }
; 5174 :     Py_RETURN_NOTIMPLEMENTED;

  0006d	e8 00 00 00 00	 call	 _Py_PXCTX
  00072	85 c0		 test	 eax, eax
  00074	75 3c		 jne	 SHORT $LN6@slot_nb_po@2
  00076	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  0007d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0008b	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00091	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00099	e8 00 00 00 00	 call	 _PyParallel_Guard
  0009e	85 c0		 test	 eax, eax
  000a0	75 09		 jne	 SHORT $LN5@slot_nb_po@2
  000a2	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  000a9	74 07		 je	 SHORT $LN6@slot_nb_po@2
$LN5@slot_nb_po@2:
  000ab	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN6@slot_nb_po@2:
  000b2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 5175 : }

  000b9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bd	c3		 ret	 0
slot_nb_power ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT slot_nb_negative
_TEXT	SEGMENT
self$ = 8
slot_nb_negative PROC					; COMDAT

; 5177 : SLOT0(slot_nb_negative, "__neg__")

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00007	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00010	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?id@?1??slot_nb_negative@@9@9
  00015	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  00019	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00020	e9 00 00 00 00	 jmp	 call_method
slot_nb_negative ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT slot_nb_positive
_TEXT	SEGMENT
self$ = 8
slot_nb_positive PROC					; COMDAT

; 5178 : SLOT0(slot_nb_positive, "__pos__")

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00007	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00010	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?id@?1??slot_nb_positive@@9@9
  00015	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  00019	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00020	e9 00 00 00 00	 jmp	 call_method
slot_nb_positive ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT slot_nb_absolute
_TEXT	SEGMENT
self$ = 8
slot_nb_absolute PROC					; COMDAT

; 5179 : SLOT0(slot_nb_absolute, "__abs__")

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00007	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00010	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?id@?1??slot_nb_absolute@@9@9
  00015	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  00019	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00020	e9 00 00 00 00	 jmp	 call_method
slot_nb_absolute ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@KHBICFOO@__bool__?5should?5return?5bool?0?5ret@ ; `string'
EXTRN	PyBool_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$slot_nb_bool DD imagerel slot_nb_bool
	DD	imagerel slot_nb_bool+282
	DD	imagerel $unwind$slot_nb_bool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_nb_bool DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
xdata	ENDS
;	COMDAT ??_C@_0CJ@KHBICFOO@__bool__?5should?5return?5bool?0?5ret@
CONST	SEGMENT
??_C@_0CJ@KHBICFOO@__bool__?5should?5return?5bool?0?5ret@ DB '__bool__ sh'
	DB	'ould return bool, returned %s', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT slot_nb_bool
_TEXT	SEGMENT
self$ = 48
slot_nb_bool PROC					; COMDAT

; 5183 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 5184 :     PyObject *func, *args;
; 5185 :     int result = -1;
; 5186 :     int using_len = 0;
; 5187 :     _Py_IDENTIFIER(__len__);
; 5188 :     _Py_IDENTIFIER(__bool__);
; 5189 : 
; 5190 :     func = lookup_maybe(self, &PyId___bool__);

  0001a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00020	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00029	48 8b f1	 mov	 rsi, rcx
  0002c	4c 8b 24 d0	 mov	 r12, QWORD PTR [rax+rdx*8]
  00030	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___bool__@?1??slot_nb_bool@@9@9
  00035	83 cb ff	 or	 ebx, -1
  00038	49 03 d4	 add	 rdx, r12
  0003b	33 ff		 xor	 edi, edi
  0003d	e8 00 00 00 00	 call	 lookup_maybe
  00042	48 8b e8	 mov	 rbp, rax

; 5191 :     if (func == NULL) {

  00045	48 85 c0	 test	 rax, rax
  00048	75 3f		 jne	 SHORT $LN9@slot_nb_bo

; 5192 :         if (PyErr_Occurred())

  0004a	e8 00 00 00 00	 call	 PyErr_Occurred
  0004f	48 85 c0	 test	 rax, rax

; 5193 :             return -1;

  00052	0f 85 a5 00 00
	00		 jne	 $LN12@slot_nb_bo

; 5194 :         func = lookup_maybe(self, &PyId___len__);

  00058	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___len__@?1??slot_nb_bool@@9@9
  0005d	48 8b ce	 mov	 rcx, rsi
  00060	49 03 d4	 add	 rdx, r12
  00063	e8 00 00 00 00	 call	 lookup_maybe
  00068	48 8b e8	 mov	 rbp, rax

; 5195 :         if (func == NULL)

  0006b	48 85 c0	 test	 rax, rax
  0006e	75 14		 jne	 SHORT $LN7@slot_nb_bo

; 5196 :             return PyErr_Occurred() ? -1 : 1;

  00070	e8 00 00 00 00	 call	 PyErr_Occurred
  00075	bf 01 00 00 00	 mov	 edi, 1
  0007a	48 85 c0	 test	 rax, rax
  0007d	0f 45 fb	 cmovne	 edi, ebx
  00080	8b c7		 mov	 eax, edi
  00082	eb 7b		 jmp	 SHORT $LN10@slot_nb_bo
$LN7@slot_nb_bo:

; 5197 :         using_len = 1;

  00084	bf 01 00 00 00	 mov	 edi, 1
$LN9@slot_nb_bo:

; 5198 :     }
; 5199 :     args = PyTuple_New(0);

  00089	33 c9		 xor	 ecx, ecx
  0008b	e8 00 00 00 00	 call	 PyTuple_New
  00090	4c 8b e0	 mov	 r12, rax

; 5200 :     if (args != NULL) {

  00093	48 85 c0	 test	 rax, rax
  00096	74 5d		 je	 SHORT $LN5@slot_nb_bo

; 5201 :         PyObject *temp = PyObject_Call(func, args, NULL);

  00098	45 33 c0	 xor	 r8d, r8d
  0009b	48 8b d0	 mov	 rdx, rax
  0009e	48 8b cd	 mov	 rcx, rbp
  000a1	e8 00 00 00 00	 call	 PyObject_Call

; 5202 :         Py_DECREF(args);

  000a6	49 8b cc	 mov	 rcx, r12
  000a9	48 8b f0	 mov	 rsi, rax
  000ac	e8 00 00 00 00	 call	 _Py_DecRef

; 5203 :         if (temp != NULL) {

  000b1	48 85 f6	 test	 rsi, rsi
  000b4	74 3f		 je	 SHORT $LN5@slot_nb_bo

; 5204 :             if (using_len) {

  000b6	85 ff		 test	 edi, edi

; 5205 :                 /* enforced by slot_nb_len */
; 5206 :                 result = PyObject_IsTrue(temp);

  000b8	75 10		 jne	 SHORT $LN13@slot_nb_bo

; 5207 :             }
; 5208 :             else if (PyBool_Check(temp)) {

  000ba	4c 8b 46 58	 mov	 r8, QWORD PTR [rsi+88]
  000be	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBool_Type
  000c5	4c 3b c0	 cmp	 r8, rax
  000c8	75 0c		 jne	 SHORT $LN2@slot_nb_bo
$LN13@slot_nb_bo:

; 5209 :                 result = PyObject_IsTrue(temp);

  000ca	48 8b ce	 mov	 rcx, rsi
  000cd	e8 00 00 00 00	 call	 PyObject_IsTrue
  000d2	8b d8		 mov	 ebx, eax

; 5210 :             }
; 5211 :             else {

  000d4	eb 17		 jmp	 SHORT $LN1@slot_nb_bo
$LN2@slot_nb_bo:

; 5212 :                 PyErr_Format(PyExc_TypeError,
; 5213 :                              "__bool__ should return "
; 5214 :                              "bool, returned %s",
; 5215 :                              Py_TYPE(temp)->tp_name);

  000d6	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  000da	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@KHBICFOO@__bool__?5should?5return?5bool?0?5ret@
  000e8	e8 00 00 00 00	 call	 PyErr_Format
$LN1@slot_nb_bo:

; 5216 :                 result = -1;
; 5217 :             }
; 5218 :             Py_DECREF(temp);

  000ed	48 8b ce	 mov	 rcx, rsi
  000f0	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@slot_nb_bo:

; 5219 :         }
; 5220 :     }
; 5221 :     Py_DECREF(func);

  000f5	48 8b cd	 mov	 rcx, rbp
  000f8	e8 00 00 00 00	 call	 _Py_DecRef
$LN12@slot_nb_bo:

; 5222 :     return result;

  000fd	8b c3		 mov	 eax, ebx
$LN10@slot_nb_bo:

; 5223 : }

  000ff	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00104	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00109	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0010e	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00113	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00117	41 5c		 pop	 r12
  00119	c3		 ret	 0
slot_nb_bool ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT slot_nb_index
_TEXT	SEGMENT
self$ = 8
slot_nb_index PROC					; COMDAT

; 5229 :     _Py_IDENTIFIER(__index__);
; 5230 :     return call_method(self, &PyId___index__, "()");

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00007	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00010	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___index__@?1??slot_nb_index@@9@9
  00015	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  00019	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@

; 5231 : }

  00020	e9 00 00 00 00	 jmp	 call_method
slot_nb_index ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT slot_nb_invert
_TEXT	SEGMENT
self$ = 8
slot_nb_invert PROC					; COMDAT

; 5234 : SLOT0(slot_nb_invert, "__invert__")

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00007	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00010	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?id@?1??slot_nb_invert@@9@9
  00015	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  00019	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00020	e9 00 00 00 00	 jmp	 call_method
slot_nb_invert ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$slot_nb_lshift DD imagerel slot_nb_lshift
	DD	imagerel slot_nb_lshift+420
	DD	imagerel $unwind$slot_nb_lshift
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_nb_lshift DD 0a5401H
	DD	0a5454H
	DD	0c6413H
	DD	0b3413H
	DD	0e00f5213H
	DD	0700bd00dH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT slot_nb_lshift
_TEXT	SEGMENT
self$ = 80
other$ = 88
slot_nb_lshift PROC					; COMDAT

; 5235 : SLOT1BIN(slot_nb_lshift, nb_lshift, "__lshift__", "__rlshift__")

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fa	 mov	 rdi, rdx
  00016	48 8b 51 58	 mov	 rdx, QWORD PTR [rcx+88]
  0001a	48 8b f1	 mov	 rsi, rcx
  0001d	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00021	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:slot_nb_lshift
  00028	48 3b d1	 cmp	 rdx, rcx
  0002b	74 19		 je	 SHORT $LN9@slot_nb_ls
  0002d	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00034	48 85 c0	 test	 rax, rax
  00037	74 0d		 je	 SHORT $LN9@slot_nb_ls
  00039	4c 39 40 58	 cmp	 QWORD PTR [rax+88], r8
  0003d	75 07		 jne	 SHORT $LN9@slot_nb_ls
  0003f	bb 01 00 00 00	 mov	 ebx, 1
  00044	eb 02		 jmp	 SHORT $LN10@slot_nb_ls
$LN9@slot_nb_ls:
  00046	33 db		 xor	 ebx, ebx
$LN10@slot_nb_ls:
  00048	48 8b 82 b8 00
	00 00		 mov	 rax, QWORD PTR [rdx+184]
  0004f	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00054	41 be 00 00 00
	00		 mov	 r14d, OFFSET FLAT:?rop_id@?1??slot_nb_lshift@@9@9
  0005a	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_NotImplementedStruct
  00061	48 85 c0	 test	 rax, rax
  00064	0f 84 af 00 00
	00		 je	 $LN6@slot_nb_ls
  0006a	4c 39 40 58	 cmp	 QWORD PTR [rax+88], r8
  0006e	0f 85 a5 00 00
	00		 jne	 $LN6@slot_nb_ls
  00074	85 db		 test	 ebx, ebx
  00076	74 5c		 je	 SHORT $LN5@slot_nb_ls
  00078	e8 00 00 00 00	 call	 PyType_IsSubtype
  0007d	85 c0		 test	 eax, eax
  0007f	74 53		 je	 SHORT $LN5@slot_nb_ls
  00081	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00087	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00090	41 8b ce	 mov	 ecx, r14d
  00093	48 8b 2c d0	 mov	 rbp, QWORD PTR [rax+rdx*8]
  00097	48 8b d7	 mov	 rdx, rdi
  0009a	48 03 e9	 add	 rbp, rcx
  0009d	48 8b ce	 mov	 rcx, rsi
  000a0	4c 8b c5	 mov	 r8, rbp
  000a3	e8 00 00 00 00	 call	 method_is_overloaded
  000a8	85 c0		 test	 eax, eax
  000aa	74 28		 je	 SHORT $LN5@slot_nb_ls
  000ac	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  000b3	4c 8b ce	 mov	 r9, rsi
  000b6	48 8b d5	 mov	 rdx, rbp
  000b9	48 8b cf	 mov	 rcx, rdi
  000bc	e8 00 00 00 00	 call	 call_maybe
  000c1	49 3b c5	 cmp	 rax, r13
  000c4	0f 85 c1 00 00
	00		 jne	 $LN7@slot_nb_ls
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 _Py_DecRef
  000d2	33 db		 xor	 ebx, ebx
$LN5@slot_nb_ls:
  000d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000da	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  000e3	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?op_id@?1??slot_nb_lshift@@9@9
  000e8	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  000ec	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  000f3	4c 8b cf	 mov	 r9, rdi
  000f6	48 8b ce	 mov	 rcx, rsi
  000f9	e8 00 00 00 00	 call	 call_maybe
  000fe	49 3b c5	 cmp	 rax, r13
  00101	0f 85 84 00 00
	00		 jne	 $LN7@slot_nb_ls
  00107	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  0010b	48 39 4f 58	 cmp	 QWORD PTR [rdi+88], rcx
  0010f	74 7a		 je	 SHORT $LN7@slot_nb_ls
  00111	48 8b c8	 mov	 rcx, rax
  00114	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@slot_nb_ls:
  00119	85 db		 test	 ebx, ebx
  0011b	74 2a		 je	 SHORT $LN1@slot_nb_ls
  0011d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00123	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0012c	41 8b d6	 mov	 edx, r14d
  0012f	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00133	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  0013a	4c 8b ce	 mov	 r9, rsi
  0013d	48 8b cf	 mov	 rcx, rdi
  00140	e8 00 00 00 00	 call	 call_maybe
  00145	eb 44		 jmp	 SHORT $LN7@slot_nb_ls
$LN1@slot_nb_ls:
  00147	e8 00 00 00 00	 call	 _Py_PXCTX
  0014c	85 c0		 test	 eax, eax
  0014e	75 38		 jne	 SHORT $LN12@slot_nb_ls
  00150	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00157	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0015e	4d 8b cd	 mov	 r9, r13
  00161	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00167	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0016f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00174	85 c0		 test	 eax, eax
  00176	75 09		 jne	 SHORT $LN11@slot_nb_ls
  00178	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  0017f	74 07		 je	 SHORT $LN12@slot_nb_ls
$LN11@slot_nb_ls:
  00181	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN12@slot_nb_ls:
  00188	49 8b c5	 mov	 rax, r13
$LN7@slot_nb_ls:
  0018b	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00190	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00195	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0019a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0019e	41 5e		 pop	 r14
  001a0	41 5d		 pop	 r13
  001a2	5f		 pop	 rdi
  001a3	c3		 ret	 0
slot_nb_lshift ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$slot_nb_rshift DD imagerel slot_nb_rshift
	DD	imagerel slot_nb_rshift+420
	DD	imagerel $unwind$slot_nb_rshift
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_nb_rshift DD 0a5401H
	DD	0a5454H
	DD	0c6413H
	DD	0b3413H
	DD	0e00f5213H
	DD	0700bd00dH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT slot_nb_rshift
_TEXT	SEGMENT
self$ = 80
other$ = 88
slot_nb_rshift PROC					; COMDAT

; 5236 : SLOT1BIN(slot_nb_rshift, nb_rshift, "__rshift__", "__rrshift__")

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fa	 mov	 rdi, rdx
  00016	48 8b 51 58	 mov	 rdx, QWORD PTR [rcx+88]
  0001a	48 8b f1	 mov	 rsi, rcx
  0001d	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00021	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:slot_nb_rshift
  00028	48 3b d1	 cmp	 rdx, rcx
  0002b	74 19		 je	 SHORT $LN9@slot_nb_rs
  0002d	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00034	48 85 c0	 test	 rax, rax
  00037	74 0d		 je	 SHORT $LN9@slot_nb_rs
  00039	4c 39 40 60	 cmp	 QWORD PTR [rax+96], r8
  0003d	75 07		 jne	 SHORT $LN9@slot_nb_rs
  0003f	bb 01 00 00 00	 mov	 ebx, 1
  00044	eb 02		 jmp	 SHORT $LN10@slot_nb_rs
$LN9@slot_nb_rs:
  00046	33 db		 xor	 ebx, ebx
$LN10@slot_nb_rs:
  00048	48 8b 82 b8 00
	00 00		 mov	 rax, QWORD PTR [rdx+184]
  0004f	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00054	41 be 00 00 00
	00		 mov	 r14d, OFFSET FLAT:?rop_id@?1??slot_nb_rshift@@9@9
  0005a	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_NotImplementedStruct
  00061	48 85 c0	 test	 rax, rax
  00064	0f 84 af 00 00
	00		 je	 $LN6@slot_nb_rs
  0006a	4c 39 40 60	 cmp	 QWORD PTR [rax+96], r8
  0006e	0f 85 a5 00 00
	00		 jne	 $LN6@slot_nb_rs
  00074	85 db		 test	 ebx, ebx
  00076	74 5c		 je	 SHORT $LN5@slot_nb_rs
  00078	e8 00 00 00 00	 call	 PyType_IsSubtype
  0007d	85 c0		 test	 eax, eax
  0007f	74 53		 je	 SHORT $LN5@slot_nb_rs
  00081	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00087	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00090	41 8b ce	 mov	 ecx, r14d
  00093	48 8b 2c d0	 mov	 rbp, QWORD PTR [rax+rdx*8]
  00097	48 8b d7	 mov	 rdx, rdi
  0009a	48 03 e9	 add	 rbp, rcx
  0009d	48 8b ce	 mov	 rcx, rsi
  000a0	4c 8b c5	 mov	 r8, rbp
  000a3	e8 00 00 00 00	 call	 method_is_overloaded
  000a8	85 c0		 test	 eax, eax
  000aa	74 28		 je	 SHORT $LN5@slot_nb_rs
  000ac	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  000b3	4c 8b ce	 mov	 r9, rsi
  000b6	48 8b d5	 mov	 rdx, rbp
  000b9	48 8b cf	 mov	 rcx, rdi
  000bc	e8 00 00 00 00	 call	 call_maybe
  000c1	49 3b c5	 cmp	 rax, r13
  000c4	0f 85 c1 00 00
	00		 jne	 $LN7@slot_nb_rs
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 _Py_DecRef
  000d2	33 db		 xor	 ebx, ebx
$LN5@slot_nb_rs:
  000d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000da	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  000e3	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?op_id@?1??slot_nb_rshift@@9@9
  000e8	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  000ec	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  000f3	4c 8b cf	 mov	 r9, rdi
  000f6	48 8b ce	 mov	 rcx, rsi
  000f9	e8 00 00 00 00	 call	 call_maybe
  000fe	49 3b c5	 cmp	 rax, r13
  00101	0f 85 84 00 00
	00		 jne	 $LN7@slot_nb_rs
  00107	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  0010b	48 39 4f 58	 cmp	 QWORD PTR [rdi+88], rcx
  0010f	74 7a		 je	 SHORT $LN7@slot_nb_rs
  00111	48 8b c8	 mov	 rcx, rax
  00114	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@slot_nb_rs:
  00119	85 db		 test	 ebx, ebx
  0011b	74 2a		 je	 SHORT $LN1@slot_nb_rs
  0011d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00123	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0012c	41 8b d6	 mov	 edx, r14d
  0012f	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00133	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  0013a	4c 8b ce	 mov	 r9, rsi
  0013d	48 8b cf	 mov	 rcx, rdi
  00140	e8 00 00 00 00	 call	 call_maybe
  00145	eb 44		 jmp	 SHORT $LN7@slot_nb_rs
$LN1@slot_nb_rs:
  00147	e8 00 00 00 00	 call	 _Py_PXCTX
  0014c	85 c0		 test	 eax, eax
  0014e	75 38		 jne	 SHORT $LN12@slot_nb_rs
  00150	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00157	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0015e	4d 8b cd	 mov	 r9, r13
  00161	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00167	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0016f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00174	85 c0		 test	 eax, eax
  00176	75 09		 jne	 SHORT $LN11@slot_nb_rs
  00178	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  0017f	74 07		 je	 SHORT $LN12@slot_nb_rs
$LN11@slot_nb_rs:
  00181	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN12@slot_nb_rs:
  00188	49 8b c5	 mov	 rax, r13
$LN7@slot_nb_rs:
  0018b	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00190	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00195	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0019a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0019e	41 5e		 pop	 r14
  001a0	41 5d		 pop	 r13
  001a2	5f		 pop	 rdi
  001a3	c3		 ret	 0
slot_nb_rshift ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$slot_nb_and DD imagerel slot_nb_and
	DD	imagerel slot_nb_and+420
	DD	imagerel $unwind$slot_nb_and
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_nb_and DD 0a5401H
	DD	0a5454H
	DD	0c6413H
	DD	0b3413H
	DD	0e00f5213H
	DD	0700bd00dH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT slot_nb_and
_TEXT	SEGMENT
self$ = 80
other$ = 88
slot_nb_and PROC					; COMDAT

; 5237 : SLOT1BIN(slot_nb_and, nb_and, "__and__", "__rand__")

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fa	 mov	 rdi, rdx
  00016	48 8b 51 58	 mov	 rdx, QWORD PTR [rcx+88]
  0001a	48 8b f1	 mov	 rsi, rcx
  0001d	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00021	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:slot_nb_and
  00028	48 3b d1	 cmp	 rdx, rcx
  0002b	74 19		 je	 SHORT $LN9@slot_nb_an
  0002d	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00034	48 85 c0	 test	 rax, rax
  00037	74 0d		 je	 SHORT $LN9@slot_nb_an
  00039	4c 39 40 68	 cmp	 QWORD PTR [rax+104], r8
  0003d	75 07		 jne	 SHORT $LN9@slot_nb_an
  0003f	bb 01 00 00 00	 mov	 ebx, 1
  00044	eb 02		 jmp	 SHORT $LN10@slot_nb_an
$LN9@slot_nb_an:
  00046	33 db		 xor	 ebx, ebx
$LN10@slot_nb_an:
  00048	48 8b 82 b8 00
	00 00		 mov	 rax, QWORD PTR [rdx+184]
  0004f	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00054	41 be 00 00 00
	00		 mov	 r14d, OFFSET FLAT:?rop_id@?1??slot_nb_and@@9@9
  0005a	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_NotImplementedStruct
  00061	48 85 c0	 test	 rax, rax
  00064	0f 84 af 00 00
	00		 je	 $LN6@slot_nb_an
  0006a	4c 39 40 68	 cmp	 QWORD PTR [rax+104], r8
  0006e	0f 85 a5 00 00
	00		 jne	 $LN6@slot_nb_an
  00074	85 db		 test	 ebx, ebx
  00076	74 5c		 je	 SHORT $LN5@slot_nb_an
  00078	e8 00 00 00 00	 call	 PyType_IsSubtype
  0007d	85 c0		 test	 eax, eax
  0007f	74 53		 je	 SHORT $LN5@slot_nb_an
  00081	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00087	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00090	41 8b ce	 mov	 ecx, r14d
  00093	48 8b 2c d0	 mov	 rbp, QWORD PTR [rax+rdx*8]
  00097	48 8b d7	 mov	 rdx, rdi
  0009a	48 03 e9	 add	 rbp, rcx
  0009d	48 8b ce	 mov	 rcx, rsi
  000a0	4c 8b c5	 mov	 r8, rbp
  000a3	e8 00 00 00 00	 call	 method_is_overloaded
  000a8	85 c0		 test	 eax, eax
  000aa	74 28		 je	 SHORT $LN5@slot_nb_an
  000ac	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  000b3	4c 8b ce	 mov	 r9, rsi
  000b6	48 8b d5	 mov	 rdx, rbp
  000b9	48 8b cf	 mov	 rcx, rdi
  000bc	e8 00 00 00 00	 call	 call_maybe
  000c1	49 3b c5	 cmp	 rax, r13
  000c4	0f 85 c1 00 00
	00		 jne	 $LN7@slot_nb_an
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 _Py_DecRef
  000d2	33 db		 xor	 ebx, ebx
$LN5@slot_nb_an:
  000d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000da	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  000e3	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?op_id@?1??slot_nb_and@@9@9
  000e8	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  000ec	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  000f3	4c 8b cf	 mov	 r9, rdi
  000f6	48 8b ce	 mov	 rcx, rsi
  000f9	e8 00 00 00 00	 call	 call_maybe
  000fe	49 3b c5	 cmp	 rax, r13
  00101	0f 85 84 00 00
	00		 jne	 $LN7@slot_nb_an
  00107	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  0010b	48 39 4f 58	 cmp	 QWORD PTR [rdi+88], rcx
  0010f	74 7a		 je	 SHORT $LN7@slot_nb_an
  00111	48 8b c8	 mov	 rcx, rax
  00114	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@slot_nb_an:
  00119	85 db		 test	 ebx, ebx
  0011b	74 2a		 je	 SHORT $LN1@slot_nb_an
  0011d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00123	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0012c	41 8b d6	 mov	 edx, r14d
  0012f	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00133	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  0013a	4c 8b ce	 mov	 r9, rsi
  0013d	48 8b cf	 mov	 rcx, rdi
  00140	e8 00 00 00 00	 call	 call_maybe
  00145	eb 44		 jmp	 SHORT $LN7@slot_nb_an
$LN1@slot_nb_an:
  00147	e8 00 00 00 00	 call	 _Py_PXCTX
  0014c	85 c0		 test	 eax, eax
  0014e	75 38		 jne	 SHORT $LN12@slot_nb_an
  00150	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00157	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0015e	4d 8b cd	 mov	 r9, r13
  00161	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00167	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0016f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00174	85 c0		 test	 eax, eax
  00176	75 09		 jne	 SHORT $LN11@slot_nb_an
  00178	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  0017f	74 07		 je	 SHORT $LN12@slot_nb_an
$LN11@slot_nb_an:
  00181	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN12@slot_nb_an:
  00188	49 8b c5	 mov	 rax, r13
$LN7@slot_nb_an:
  0018b	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00190	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00195	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0019a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0019e	41 5e		 pop	 r14
  001a0	41 5d		 pop	 r13
  001a2	5f		 pop	 rdi
  001a3	c3		 ret	 0
slot_nb_and ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$slot_nb_xor DD imagerel slot_nb_xor
	DD	imagerel slot_nb_xor+420
	DD	imagerel $unwind$slot_nb_xor
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_nb_xor DD 0a5401H
	DD	0a5454H
	DD	0c6413H
	DD	0b3413H
	DD	0e00f5213H
	DD	0700bd00dH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT slot_nb_xor
_TEXT	SEGMENT
self$ = 80
other$ = 88
slot_nb_xor PROC					; COMDAT

; 5238 : SLOT1BIN(slot_nb_xor, nb_xor, "__xor__", "__rxor__")

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fa	 mov	 rdi, rdx
  00016	48 8b 51 58	 mov	 rdx, QWORD PTR [rcx+88]
  0001a	48 8b f1	 mov	 rsi, rcx
  0001d	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00021	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:slot_nb_xor
  00028	48 3b d1	 cmp	 rdx, rcx
  0002b	74 19		 je	 SHORT $LN9@slot_nb_xo
  0002d	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00034	48 85 c0	 test	 rax, rax
  00037	74 0d		 je	 SHORT $LN9@slot_nb_xo
  00039	4c 39 40 70	 cmp	 QWORD PTR [rax+112], r8
  0003d	75 07		 jne	 SHORT $LN9@slot_nb_xo
  0003f	bb 01 00 00 00	 mov	 ebx, 1
  00044	eb 02		 jmp	 SHORT $LN10@slot_nb_xo
$LN9@slot_nb_xo:
  00046	33 db		 xor	 ebx, ebx
$LN10@slot_nb_xo:
  00048	48 8b 82 b8 00
	00 00		 mov	 rax, QWORD PTR [rdx+184]
  0004f	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00054	41 be 00 00 00
	00		 mov	 r14d, OFFSET FLAT:?rop_id@?1??slot_nb_xor@@9@9
  0005a	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_NotImplementedStruct
  00061	48 85 c0	 test	 rax, rax
  00064	0f 84 af 00 00
	00		 je	 $LN6@slot_nb_xo
  0006a	4c 39 40 70	 cmp	 QWORD PTR [rax+112], r8
  0006e	0f 85 a5 00 00
	00		 jne	 $LN6@slot_nb_xo
  00074	85 db		 test	 ebx, ebx
  00076	74 5c		 je	 SHORT $LN5@slot_nb_xo
  00078	e8 00 00 00 00	 call	 PyType_IsSubtype
  0007d	85 c0		 test	 eax, eax
  0007f	74 53		 je	 SHORT $LN5@slot_nb_xo
  00081	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00087	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00090	41 8b ce	 mov	 ecx, r14d
  00093	48 8b 2c d0	 mov	 rbp, QWORD PTR [rax+rdx*8]
  00097	48 8b d7	 mov	 rdx, rdi
  0009a	48 03 e9	 add	 rbp, rcx
  0009d	48 8b ce	 mov	 rcx, rsi
  000a0	4c 8b c5	 mov	 r8, rbp
  000a3	e8 00 00 00 00	 call	 method_is_overloaded
  000a8	85 c0		 test	 eax, eax
  000aa	74 28		 je	 SHORT $LN5@slot_nb_xo
  000ac	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  000b3	4c 8b ce	 mov	 r9, rsi
  000b6	48 8b d5	 mov	 rdx, rbp
  000b9	48 8b cf	 mov	 rcx, rdi
  000bc	e8 00 00 00 00	 call	 call_maybe
  000c1	49 3b c5	 cmp	 rax, r13
  000c4	0f 85 c1 00 00
	00		 jne	 $LN7@slot_nb_xo
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 _Py_DecRef
  000d2	33 db		 xor	 ebx, ebx
$LN5@slot_nb_xo:
  000d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000da	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  000e3	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?op_id@?1??slot_nb_xor@@9@9
  000e8	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  000ec	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  000f3	4c 8b cf	 mov	 r9, rdi
  000f6	48 8b ce	 mov	 rcx, rsi
  000f9	e8 00 00 00 00	 call	 call_maybe
  000fe	49 3b c5	 cmp	 rax, r13
  00101	0f 85 84 00 00
	00		 jne	 $LN7@slot_nb_xo
  00107	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  0010b	48 39 4f 58	 cmp	 QWORD PTR [rdi+88], rcx
  0010f	74 7a		 je	 SHORT $LN7@slot_nb_xo
  00111	48 8b c8	 mov	 rcx, rax
  00114	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@slot_nb_xo:
  00119	85 db		 test	 ebx, ebx
  0011b	74 2a		 je	 SHORT $LN1@slot_nb_xo
  0011d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00123	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0012c	41 8b d6	 mov	 edx, r14d
  0012f	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00133	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  0013a	4c 8b ce	 mov	 r9, rsi
  0013d	48 8b cf	 mov	 rcx, rdi
  00140	e8 00 00 00 00	 call	 call_maybe
  00145	eb 44		 jmp	 SHORT $LN7@slot_nb_xo
$LN1@slot_nb_xo:
  00147	e8 00 00 00 00	 call	 _Py_PXCTX
  0014c	85 c0		 test	 eax, eax
  0014e	75 38		 jne	 SHORT $LN12@slot_nb_xo
  00150	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00157	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0015e	4d 8b cd	 mov	 r9, r13
  00161	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00167	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0016f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00174	85 c0		 test	 eax, eax
  00176	75 09		 jne	 SHORT $LN11@slot_nb_xo
  00178	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  0017f	74 07		 je	 SHORT $LN12@slot_nb_xo
$LN11@slot_nb_xo:
  00181	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN12@slot_nb_xo:
  00188	49 8b c5	 mov	 rax, r13
$LN7@slot_nb_xo:
  0018b	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00190	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00195	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0019a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0019e	41 5e		 pop	 r14
  001a0	41 5d		 pop	 r13
  001a2	5f		 pop	 rdi
  001a3	c3		 ret	 0
slot_nb_xor ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$slot_nb_or DD imagerel slot_nb_or
	DD	imagerel slot_nb_or+420
	DD	imagerel $unwind$slot_nb_or
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_nb_or DD 0a5401H
	DD	0a5454H
	DD	0c6413H
	DD	0b3413H
	DD	0e00f5213H
	DD	0700bd00dH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT slot_nb_or
_TEXT	SEGMENT
self$ = 80
other$ = 88
slot_nb_or PROC						; COMDAT

; 5239 : SLOT1BIN(slot_nb_or, nb_or, "__or__", "__ror__")

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fa	 mov	 rdi, rdx
  00016	48 8b 51 58	 mov	 rdx, QWORD PTR [rcx+88]
  0001a	48 8b f1	 mov	 rsi, rcx
  0001d	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00021	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:slot_nb_or
  00028	48 3b d1	 cmp	 rdx, rcx
  0002b	74 19		 je	 SHORT $LN9@slot_nb_or
  0002d	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00034	48 85 c0	 test	 rax, rax
  00037	74 0d		 je	 SHORT $LN9@slot_nb_or
  00039	4c 39 40 78	 cmp	 QWORD PTR [rax+120], r8
  0003d	75 07		 jne	 SHORT $LN9@slot_nb_or
  0003f	bb 01 00 00 00	 mov	 ebx, 1
  00044	eb 02		 jmp	 SHORT $LN10@slot_nb_or
$LN9@slot_nb_or:
  00046	33 db		 xor	 ebx, ebx
$LN10@slot_nb_or:
  00048	48 8b 82 b8 00
	00 00		 mov	 rax, QWORD PTR [rdx+184]
  0004f	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00054	41 be 00 00 00
	00		 mov	 r14d, OFFSET FLAT:?rop_id@?1??slot_nb_or@@9@9
  0005a	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_NotImplementedStruct
  00061	48 85 c0	 test	 rax, rax
  00064	0f 84 af 00 00
	00		 je	 $LN6@slot_nb_or
  0006a	4c 39 40 78	 cmp	 QWORD PTR [rax+120], r8
  0006e	0f 85 a5 00 00
	00		 jne	 $LN6@slot_nb_or
  00074	85 db		 test	 ebx, ebx
  00076	74 5c		 je	 SHORT $LN5@slot_nb_or
  00078	e8 00 00 00 00	 call	 PyType_IsSubtype
  0007d	85 c0		 test	 eax, eax
  0007f	74 53		 je	 SHORT $LN5@slot_nb_or
  00081	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00087	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00090	41 8b ce	 mov	 ecx, r14d
  00093	48 8b 2c d0	 mov	 rbp, QWORD PTR [rax+rdx*8]
  00097	48 8b d7	 mov	 rdx, rdi
  0009a	48 03 e9	 add	 rbp, rcx
  0009d	48 8b ce	 mov	 rcx, rsi
  000a0	4c 8b c5	 mov	 r8, rbp
  000a3	e8 00 00 00 00	 call	 method_is_overloaded
  000a8	85 c0		 test	 eax, eax
  000aa	74 28		 je	 SHORT $LN5@slot_nb_or
  000ac	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  000b3	4c 8b ce	 mov	 r9, rsi
  000b6	48 8b d5	 mov	 rdx, rbp
  000b9	48 8b cf	 mov	 rcx, rdi
  000bc	e8 00 00 00 00	 call	 call_maybe
  000c1	49 3b c5	 cmp	 rax, r13
  000c4	0f 85 c1 00 00
	00		 jne	 $LN7@slot_nb_or
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 _Py_DecRef
  000d2	33 db		 xor	 ebx, ebx
$LN5@slot_nb_or:
  000d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000da	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  000e3	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?op_id@?1??slot_nb_or@@9@9
  000e8	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  000ec	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  000f3	4c 8b cf	 mov	 r9, rdi
  000f6	48 8b ce	 mov	 rcx, rsi
  000f9	e8 00 00 00 00	 call	 call_maybe
  000fe	49 3b c5	 cmp	 rax, r13
  00101	0f 85 84 00 00
	00		 jne	 $LN7@slot_nb_or
  00107	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  0010b	48 39 4f 58	 cmp	 QWORD PTR [rdi+88], rcx
  0010f	74 7a		 je	 SHORT $LN7@slot_nb_or
  00111	48 8b c8	 mov	 rcx, rax
  00114	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@slot_nb_or:
  00119	85 db		 test	 ebx, ebx
  0011b	74 2a		 je	 SHORT $LN1@slot_nb_or
  0011d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00123	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0012c	41 8b d6	 mov	 edx, r14d
  0012f	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00133	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  0013a	4c 8b ce	 mov	 r9, rsi
  0013d	48 8b cf	 mov	 rcx, rdi
  00140	e8 00 00 00 00	 call	 call_maybe
  00145	eb 44		 jmp	 SHORT $LN7@slot_nb_or
$LN1@slot_nb_or:
  00147	e8 00 00 00 00	 call	 _Py_PXCTX
  0014c	85 c0		 test	 eax, eax
  0014e	75 38		 jne	 SHORT $LN12@slot_nb_or
  00150	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00157	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0015e	4d 8b cd	 mov	 r9, r13
  00161	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00167	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0016f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00174	85 c0		 test	 eax, eax
  00176	75 09		 jne	 SHORT $LN11@slot_nb_or
  00178	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  0017f	74 07		 je	 SHORT $LN12@slot_nb_or
$LN11@slot_nb_or:
  00181	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN12@slot_nb_or:
  00188	49 8b c5	 mov	 rax, r13
$LN7@slot_nb_or:
  0018b	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00190	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00195	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0019a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0019e	41 5e		 pop	 r14
  001a0	41 5d		 pop	 r13
  001a2	5f		 pop	 rdi
  001a3	c3		 ret	 0
slot_nb_or ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT slot_nb_int
_TEXT	SEGMENT
self$ = 8
slot_nb_int PROC					; COMDAT

; 5241 : SLOT0(slot_nb_int, "__int__")

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00007	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00010	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?id@?1??slot_nb_int@@9@9
  00015	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  00019	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00020	e9 00 00 00 00	 jmp	 call_method
slot_nb_int ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT slot_nb_float
_TEXT	SEGMENT
self$ = 8
slot_nb_float PROC					; COMDAT

; 5242 : SLOT0(slot_nb_float, "__float__")

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00007	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00010	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?id@?1??slot_nb_float@@9@9
  00015	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  00019	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00020	e9 00 00 00 00	 jmp	 call_method
slot_nb_float ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT slot_nb_inplace_add
_TEXT	SEGMENT
self$ = 8
arg1$ = 16
slot_nb_inplace_add PROC				; COMDAT

; 5243 : SLOT1(slot_nb_inplace_add, "__iadd__", PyObject *, "O")

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00007	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00010	4c 8b ca	 mov	 r9, rdx
  00013	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?id@?1??slot_nb_inplace_add@@9@9
  00018	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  0001c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  00023	e9 00 00 00 00	 jmp	 call_method
slot_nb_inplace_add ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT slot_nb_inplace_subtract
_TEXT	SEGMENT
self$ = 8
arg1$ = 16
slot_nb_inplace_subtract PROC				; COMDAT

; 5244 : SLOT1(slot_nb_inplace_subtract, "__isub__", PyObject *, "O")

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00007	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00010	4c 8b ca	 mov	 r9, rdx
  00013	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?id@?1??slot_nb_inplace_subtract@@9@9
  00018	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  0001c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  00023	e9 00 00 00 00	 jmp	 call_method
slot_nb_inplace_subtract ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT slot_nb_inplace_multiply
_TEXT	SEGMENT
self$ = 8
arg1$ = 16
slot_nb_inplace_multiply PROC				; COMDAT

; 5245 : SLOT1(slot_nb_inplace_multiply, "__imul__", PyObject *, "O")

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00007	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00010	4c 8b ca	 mov	 r9, rdx
  00013	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?id@?1??slot_nb_inplace_multiply@@9@9
  00018	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  0001c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  00023	e9 00 00 00 00	 jmp	 call_method
slot_nb_inplace_multiply ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT slot_nb_inplace_remainder
_TEXT	SEGMENT
self$ = 8
arg1$ = 16
slot_nb_inplace_remainder PROC				; COMDAT

; 5246 : SLOT1(slot_nb_inplace_remainder, "__imod__", PyObject *, "O")

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00007	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00010	4c 8b ca	 mov	 r9, rdx
  00013	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?id@?1??slot_nb_inplace_remainder@@9@9
  00018	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  0001c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  00023	e9 00 00 00 00	 jmp	 call_method
slot_nb_inplace_remainder ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT slot_nb_inplace_power
_TEXT	SEGMENT
self$ = 8
arg1$ = 16
arg2$ = 24
slot_nb_inplace_power PROC				; COMDAT

; 5251 :     _Py_IDENTIFIER(__ipow__);
; 5252 :     return call_method(self, &PyId___ipow__, "(" "O" ")", arg1);

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00007	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00010	4c 8b ca	 mov	 r9, rdx
  00013	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___ipow__@?1??slot_nb_inplace_power@@9@9
  00018	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  0001c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@

; 5253 : }

  00023	e9 00 00 00 00	 jmp	 call_method
slot_nb_inplace_power ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT slot_nb_inplace_lshift
_TEXT	SEGMENT
self$ = 8
arg1$ = 16
slot_nb_inplace_lshift PROC				; COMDAT

; 5254 : SLOT1(slot_nb_inplace_lshift, "__ilshift__", PyObject *, "O")

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00007	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00010	4c 8b ca	 mov	 r9, rdx
  00013	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?id@?1??slot_nb_inplace_lshift@@9@9
  00018	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  0001c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  00023	e9 00 00 00 00	 jmp	 call_method
slot_nb_inplace_lshift ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT slot_nb_inplace_rshift
_TEXT	SEGMENT
self$ = 8
arg1$ = 16
slot_nb_inplace_rshift PROC				; COMDAT

; 5255 : SLOT1(slot_nb_inplace_rshift, "__irshift__", PyObject *, "O")

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00007	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00010	4c 8b ca	 mov	 r9, rdx
  00013	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?id@?1??slot_nb_inplace_rshift@@9@9
  00018	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  0001c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  00023	e9 00 00 00 00	 jmp	 call_method
slot_nb_inplace_rshift ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT slot_nb_inplace_and
_TEXT	SEGMENT
self$ = 8
arg1$ = 16
slot_nb_inplace_and PROC				; COMDAT

; 5256 : SLOT1(slot_nb_inplace_and, "__iand__", PyObject *, "O")

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00007	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00010	4c 8b ca	 mov	 r9, rdx
  00013	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?id@?1??slot_nb_inplace_and@@9@9
  00018	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  0001c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  00023	e9 00 00 00 00	 jmp	 call_method
slot_nb_inplace_and ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT slot_nb_inplace_xor
_TEXT	SEGMENT
self$ = 8
arg1$ = 16
slot_nb_inplace_xor PROC				; COMDAT

; 5257 : SLOT1(slot_nb_inplace_xor, "__ixor__", PyObject *, "O")

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00007	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00010	4c 8b ca	 mov	 r9, rdx
  00013	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?id@?1??slot_nb_inplace_xor@@9@9
  00018	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  0001c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  00023	e9 00 00 00 00	 jmp	 call_method
slot_nb_inplace_xor ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT slot_nb_inplace_or
_TEXT	SEGMENT
self$ = 8
arg1$ = 16
slot_nb_inplace_or PROC					; COMDAT

; 5258 : SLOT1(slot_nb_inplace_or, "__ior__", PyObject *, "O")

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00007	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00010	4c 8b ca	 mov	 r9, rdx
  00013	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?id@?1??slot_nb_inplace_or@@9@9
  00018	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  0001c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  00023	e9 00 00 00 00	 jmp	 call_method
slot_nb_inplace_or ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$slot_nb_floor_divide DD imagerel slot_nb_floor_divide
	DD	imagerel slot_nb_floor_divide+426
	DD	imagerel $unwind$slot_nb_floor_divide
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_nb_floor_divide DD 0a5701H
	DD	0a5457H
	DD	0c6413H
	DD	0b3413H
	DD	0e00f5213H
	DD	0700bd00dH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT slot_nb_floor_divide
_TEXT	SEGMENT
self$ = 80
other$ = 88
slot_nb_floor_divide PROC				; COMDAT

; 5260 :          "__floordiv__", "__rfloordiv__")

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fa	 mov	 rdi, rdx
  00016	48 8b 51 58	 mov	 rdx, QWORD PTR [rcx+88]
  0001a	48 8b f1	 mov	 rsi, rcx
  0001d	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00021	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:slot_nb_floor_divide
  00028	48 3b d1	 cmp	 rdx, rcx
  0002b	74 1c		 je	 SHORT $LN9@slot_nb_fl
  0002d	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00034	48 85 c0	 test	 rax, rax
  00037	74 10		 je	 SHORT $LN9@slot_nb_fl
  00039	4c 39 80 e8 00
	00 00		 cmp	 QWORD PTR [rax+232], r8
  00040	75 07		 jne	 SHORT $LN9@slot_nb_fl
  00042	bb 01 00 00 00	 mov	 ebx, 1
  00047	eb 02		 jmp	 SHORT $LN10@slot_nb_fl
$LN9@slot_nb_fl:
  00049	33 db		 xor	 ebx, ebx
$LN10@slot_nb_fl:
  0004b	48 8b 82 b8 00
	00 00		 mov	 rax, QWORD PTR [rdx+184]
  00052	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00057	41 be 00 00 00
	00		 mov	 r14d, OFFSET FLAT:?rop_id@?1??slot_nb_floor_divide@@9@9
  0005d	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_NotImplementedStruct
  00064	48 85 c0	 test	 rax, rax
  00067	0f 84 b2 00 00
	00		 je	 $LN6@slot_nb_fl
  0006d	4c 39 80 e8 00
	00 00		 cmp	 QWORD PTR [rax+232], r8
  00074	0f 85 a5 00 00
	00		 jne	 $LN6@slot_nb_fl
  0007a	85 db		 test	 ebx, ebx
  0007c	74 5c		 je	 SHORT $LN5@slot_nb_fl
  0007e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00083	85 c0		 test	 eax, eax
  00085	74 53		 je	 SHORT $LN5@slot_nb_fl
  00087	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  0008d	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00096	41 8b ce	 mov	 ecx, r14d
  00099	48 8b 2c d0	 mov	 rbp, QWORD PTR [rax+rdx*8]
  0009d	48 8b d7	 mov	 rdx, rdi
  000a0	48 03 e9	 add	 rbp, rcx
  000a3	48 8b ce	 mov	 rcx, rsi
  000a6	4c 8b c5	 mov	 r8, rbp
  000a9	e8 00 00 00 00	 call	 method_is_overloaded
  000ae	85 c0		 test	 eax, eax
  000b0	74 28		 je	 SHORT $LN5@slot_nb_fl
  000b2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  000b9	4c 8b ce	 mov	 r9, rsi
  000bc	48 8b d5	 mov	 rdx, rbp
  000bf	48 8b cf	 mov	 rcx, rdi
  000c2	e8 00 00 00 00	 call	 call_maybe
  000c7	49 3b c5	 cmp	 rax, r13
  000ca	0f 85 c1 00 00
	00		 jne	 $LN7@slot_nb_fl
  000d0	48 8b c8	 mov	 rcx, rax
  000d3	e8 00 00 00 00	 call	 _Py_DecRef
  000d8	33 db		 xor	 ebx, ebx
$LN5@slot_nb_fl:
  000da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000e0	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  000e9	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?op_id@?1??slot_nb_floor_divide@@9@9
  000ee	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  000f2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  000f9	4c 8b cf	 mov	 r9, rdi
  000fc	48 8b ce	 mov	 rcx, rsi
  000ff	e8 00 00 00 00	 call	 call_maybe
  00104	49 3b c5	 cmp	 rax, r13
  00107	0f 85 84 00 00
	00		 jne	 $LN7@slot_nb_fl
  0010d	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  00111	48 39 4f 58	 cmp	 QWORD PTR [rdi+88], rcx
  00115	74 7a		 je	 SHORT $LN7@slot_nb_fl
  00117	48 8b c8	 mov	 rcx, rax
  0011a	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@slot_nb_fl:
  0011f	85 db		 test	 ebx, ebx
  00121	74 2a		 je	 SHORT $LN1@slot_nb_fl
  00123	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00129	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00132	41 8b d6	 mov	 edx, r14d
  00135	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00139	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  00140	4c 8b ce	 mov	 r9, rsi
  00143	48 8b cf	 mov	 rcx, rdi
  00146	e8 00 00 00 00	 call	 call_maybe
  0014b	eb 44		 jmp	 SHORT $LN7@slot_nb_fl
$LN1@slot_nb_fl:
  0014d	e8 00 00 00 00	 call	 _Py_PXCTX
  00152	85 c0		 test	 eax, eax
  00154	75 38		 jne	 SHORT $LN12@slot_nb_fl
  00156	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0015d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00164	4d 8b cd	 mov	 r9, r13
  00167	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0016d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00175	e8 00 00 00 00	 call	 _PyParallel_Guard
  0017a	85 c0		 test	 eax, eax
  0017c	75 09		 jne	 SHORT $LN11@slot_nb_fl
  0017e	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  00185	74 07		 je	 SHORT $LN12@slot_nb_fl
$LN11@slot_nb_fl:
  00187	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN12@slot_nb_fl:
  0018e	49 8b c5	 mov	 rax, r13
$LN7@slot_nb_fl:
  00191	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00196	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0019b	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  001a0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001a4	41 5e		 pop	 r14
  001a6	41 5d		 pop	 r13
  001a8	5f		 pop	 rdi
  001a9	c3		 ret	 0
slot_nb_floor_divide ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$slot_nb_true_divide DD imagerel slot_nb_true_divide
	DD	imagerel slot_nb_true_divide+426
	DD	imagerel $unwind$slot_nb_true_divide
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_nb_true_divide DD 0a5701H
	DD	0a5457H
	DD	0c6413H
	DD	0b3413H
	DD	0e00f5213H
	DD	0700bd00dH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT slot_nb_true_divide
_TEXT	SEGMENT
self$ = 80
other$ = 88
slot_nb_true_divide PROC				; COMDAT

; 5261 : SLOT1BIN(slot_nb_true_divide, nb_true_divide, "__truediv__", "__rtruediv__")

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fa	 mov	 rdi, rdx
  00016	48 8b 51 58	 mov	 rdx, QWORD PTR [rcx+88]
  0001a	48 8b f1	 mov	 rsi, rcx
  0001d	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00021	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:slot_nb_true_divide
  00028	48 3b d1	 cmp	 rdx, rcx
  0002b	74 1c		 je	 SHORT $LN9@slot_nb_tr
  0002d	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00034	48 85 c0	 test	 rax, rax
  00037	74 10		 je	 SHORT $LN9@slot_nb_tr
  00039	4c 39 80 f0 00
	00 00		 cmp	 QWORD PTR [rax+240], r8
  00040	75 07		 jne	 SHORT $LN9@slot_nb_tr
  00042	bb 01 00 00 00	 mov	 ebx, 1
  00047	eb 02		 jmp	 SHORT $LN10@slot_nb_tr
$LN9@slot_nb_tr:
  00049	33 db		 xor	 ebx, ebx
$LN10@slot_nb_tr:
  0004b	48 8b 82 b8 00
	00 00		 mov	 rax, QWORD PTR [rdx+184]
  00052	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00057	41 be 00 00 00
	00		 mov	 r14d, OFFSET FLAT:?rop_id@?1??slot_nb_true_divide@@9@9
  0005d	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_NotImplementedStruct
  00064	48 85 c0	 test	 rax, rax
  00067	0f 84 b2 00 00
	00		 je	 $LN6@slot_nb_tr
  0006d	4c 39 80 f0 00
	00 00		 cmp	 QWORD PTR [rax+240], r8
  00074	0f 85 a5 00 00
	00		 jne	 $LN6@slot_nb_tr
  0007a	85 db		 test	 ebx, ebx
  0007c	74 5c		 je	 SHORT $LN5@slot_nb_tr
  0007e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00083	85 c0		 test	 eax, eax
  00085	74 53		 je	 SHORT $LN5@slot_nb_tr
  00087	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  0008d	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00096	41 8b ce	 mov	 ecx, r14d
  00099	48 8b 2c d0	 mov	 rbp, QWORD PTR [rax+rdx*8]
  0009d	48 8b d7	 mov	 rdx, rdi
  000a0	48 03 e9	 add	 rbp, rcx
  000a3	48 8b ce	 mov	 rcx, rsi
  000a6	4c 8b c5	 mov	 r8, rbp
  000a9	e8 00 00 00 00	 call	 method_is_overloaded
  000ae	85 c0		 test	 eax, eax
  000b0	74 28		 je	 SHORT $LN5@slot_nb_tr
  000b2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  000b9	4c 8b ce	 mov	 r9, rsi
  000bc	48 8b d5	 mov	 rdx, rbp
  000bf	48 8b cf	 mov	 rcx, rdi
  000c2	e8 00 00 00 00	 call	 call_maybe
  000c7	49 3b c5	 cmp	 rax, r13
  000ca	0f 85 c1 00 00
	00		 jne	 $LN7@slot_nb_tr
  000d0	48 8b c8	 mov	 rcx, rax
  000d3	e8 00 00 00 00	 call	 _Py_DecRef
  000d8	33 db		 xor	 ebx, ebx
$LN5@slot_nb_tr:
  000da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000e0	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  000e9	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?op_id@?1??slot_nb_true_divide@@9@9
  000ee	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  000f2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  000f9	4c 8b cf	 mov	 r9, rdi
  000fc	48 8b ce	 mov	 rcx, rsi
  000ff	e8 00 00 00 00	 call	 call_maybe
  00104	49 3b c5	 cmp	 rax, r13
  00107	0f 85 84 00 00
	00		 jne	 $LN7@slot_nb_tr
  0010d	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  00111	48 39 4f 58	 cmp	 QWORD PTR [rdi+88], rcx
  00115	74 7a		 je	 SHORT $LN7@slot_nb_tr
  00117	48 8b c8	 mov	 rcx, rax
  0011a	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@slot_nb_tr:
  0011f	85 db		 test	 ebx, ebx
  00121	74 2a		 je	 SHORT $LN1@slot_nb_tr
  00123	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00129	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00132	41 8b d6	 mov	 edx, r14d
  00135	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00139	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  00140	4c 8b ce	 mov	 r9, rsi
  00143	48 8b cf	 mov	 rcx, rdi
  00146	e8 00 00 00 00	 call	 call_maybe
  0014b	eb 44		 jmp	 SHORT $LN7@slot_nb_tr
$LN1@slot_nb_tr:
  0014d	e8 00 00 00 00	 call	 _Py_PXCTX
  00152	85 c0		 test	 eax, eax
  00154	75 38		 jne	 SHORT $LN12@slot_nb_tr
  00156	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0015d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00164	4d 8b cd	 mov	 r9, r13
  00167	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0016d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00175	e8 00 00 00 00	 call	 _PyParallel_Guard
  0017a	85 c0		 test	 eax, eax
  0017c	75 09		 jne	 SHORT $LN11@slot_nb_tr
  0017e	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  00185	74 07		 je	 SHORT $LN12@slot_nb_tr
$LN11@slot_nb_tr:
  00187	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN12@slot_nb_tr:
  0018e	49 8b c5	 mov	 rax, r13
$LN7@slot_nb_tr:
  00191	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00196	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0019b	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  001a0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001a4	41 5e		 pop	 r14
  001a6	41 5d		 pop	 r13
  001a8	5f		 pop	 rdi
  001a9	c3		 ret	 0
slot_nb_true_divide ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT slot_nb_inplace_floor_divide
_TEXT	SEGMENT
self$ = 8
arg1$ = 16
slot_nb_inplace_floor_divide PROC			; COMDAT

; 5262 : SLOT1(slot_nb_inplace_floor_divide, "__ifloordiv__", PyObject *, "O")

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00007	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00010	4c 8b ca	 mov	 r9, rdx
  00013	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?id@?1??slot_nb_inplace_floor_divide@@9@9
  00018	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  0001c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  00023	e9 00 00 00 00	 jmp	 call_method
slot_nb_inplace_floor_divide ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT slot_nb_inplace_true_divide
_TEXT	SEGMENT
self$ = 8
arg1$ = 16
slot_nb_inplace_true_divide PROC			; COMDAT

; 5263 : SLOT1(slot_nb_inplace_true_divide, "__itruediv__", PyObject *, "O")

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00007	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00010	4c 8b ca	 mov	 r9, rdx
  00013	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?id@?1??slot_nb_inplace_true_divide@@9@9
  00018	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  0001c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  00023	e9 00 00 00 00	 jmp	 call_method
slot_nb_inplace_true_divide ENDP
_TEXT	ENDS
EXTRN	PyEval_CallObjectWithKeywords:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$slot_tp_repr DD imagerel slot_tp_repr
	DD	imagerel slot_tp_repr+127
	DD	imagerel $unwind$slot_tp_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_tp_repr DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT slot_tp_repr
_TEXT	SEGMENT
self$ = 48
slot_tp_repr PROC					; COMDAT

; 5267 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 5268 :     PyObject *func, *res;
; 5269 :     _Py_IDENTIFIER(__repr__);
; 5270 : 
; 5271 :     func = lookup_method(self, &PyId___repr__);

  0000a	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00011	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0001a	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___repr__@?1??slot_tp_repr@@9@9
  0001f	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  00023	48 8b d9	 mov	 rbx, rcx
  00026	e8 00 00 00 00	 call	 lookup_method
  0002b	48 8b f8	 mov	 rdi, rax

; 5272 :     if (func != NULL) {

  0002e	48 85 c0	 test	 rax, rax
  00031	74 26		 je	 SHORT $LN1@slot_tp_re

; 5273 :         res = PyEval_CallObject(func, NULL);

  00033	45 33 c0	 xor	 r8d, r8d
  00036	33 d2		 xor	 edx, edx
  00038	48 8b c8	 mov	 rcx, rax
  0003b	e8 00 00 00 00	 call	 PyEval_CallObjectWithKeywords

; 5274 :         Py_DECREF(func);

  00040	48 8b cf	 mov	 rcx, rdi
  00043	48 8b d8	 mov	 rbx, rax
  00046	e8 00 00 00 00	 call	 _Py_DecRef

; 5275 :         return res;

  0004b	48 8b c3	 mov	 rax, rbx

; 5280 : }

  0004e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5f		 pop	 rdi
  00058	c3		 ret	 0
$LN1@slot_tp_re:

; 5276 :     }
; 5277 :     PyErr_Clear();

  00059	e8 00 00 00 00	 call	 PyErr_Clear

; 5278 :     return PyUnicode_FromFormat("<%s object at %p>",
; 5279 :                                Py_TYPE(self)->tp_name, self);

  0005e	48 8b 53 58	 mov	 rdx, QWORD PTR [rbx+88]
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@JEBMOEBF@?$DM?$CFs?5object?5at?5?$CFp?$DO?$AA@
  00069	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  0006d	4c 8b c3	 mov	 r8, rbx

; 5280 : }

  00070	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00075	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00079	5f		 pop	 rdi
  0007a	e9 00 00 00 00	 jmp	 PyUnicode_FromFormat
slot_tp_repr ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$slot_tp_str DD imagerel slot_tp_str
	DD	imagerel slot_tp_str+112
	DD	imagerel $unwind$slot_tp_str
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_tp_str DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT slot_tp_str
_TEXT	SEGMENT
self$ = 48
slot_tp_str PROC					; COMDAT

; 5284 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 5285 :     PyObject *func, *res;
; 5286 :     _Py_IDENTIFIER(__str__);
; 5287 : 
; 5288 :     func = lookup_method(self, &PyId___str__);

  0000a	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00011	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0001a	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___str__@?1??slot_tp_str@@9@9
  0001f	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  00023	48 8b d9	 mov	 rbx, rcx
  00026	e8 00 00 00 00	 call	 lookup_method
  0002b	48 8b f8	 mov	 rdi, rax

; 5289 :     if (func != NULL) {

  0002e	48 85 c0	 test	 rax, rax
  00031	74 26		 je	 SHORT $LN3@slot_tp_st

; 5290 :         res = PyEval_CallObject(func, NULL);

  00033	45 33 c0	 xor	 r8d, r8d
  00036	33 d2		 xor	 edx, edx
  00038	48 8b c8	 mov	 rcx, rax
  0003b	e8 00 00 00 00	 call	 PyEval_CallObjectWithKeywords

; 5291 :         Py_DECREF(func);

  00040	48 8b cf	 mov	 rcx, rdi
  00043	48 8b d8	 mov	 rbx, rax
  00046	e8 00 00 00 00	 call	 _Py_DecRef

; 5292 :         return res;

  0004b	48 8b c3	 mov	 rax, rbx

; 5298 :         if (!res)
; 5299 :             return NULL;
; 5300 :         /* XXX this is non-sensical. Why should we return
; 5301 :            a bytes object from __str__. Is this code even
; 5302 :            used? - mvl */
; 5303 :         assert(0);
; 5304 :         return res;
; 5305 :         /*
; 5306 :         ress = _PyUnicode_AsDefaultEncodedString(res);
; 5307 :         Py_DECREF(res);
; 5308 :         return ress;
; 5309 :         */
; 5310 :     }
; 5311 : }

  0004e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5f		 pop	 rdi
  00058	c3		 ret	 0
$LN3@slot_tp_st:

; 5293 :     }
; 5294 :     else {
; 5295 :         /* PyObject *ress; */
; 5296 :         PyErr_Clear();

  00059	e8 00 00 00 00	 call	 PyErr_Clear

; 5297 :         res = slot_tp_repr(self);

  0005e	48 8b cb	 mov	 rcx, rbx

; 5298 :         if (!res)
; 5299 :             return NULL;
; 5300 :         /* XXX this is non-sensical. Why should we return
; 5301 :            a bytes object from __str__. Is this code even
; 5302 :            used? - mvl */
; 5303 :         assert(0);
; 5304 :         return res;
; 5305 :         /*
; 5306 :         ress = _PyUnicode_AsDefaultEncodedString(res);
; 5307 :         Py_DECREF(res);
; 5308 :         return ress;
; 5309 :         */
; 5310 :     }
; 5311 : }

  00061	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00066	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006a	5f		 pop	 rdi
  0006b	e9 00 00 00 00	 jmp	 slot_tp_repr
slot_tp_str ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@MNKAHADD@__hash__?5method?5should?5return?5an@ ; `string'
EXTRN	PyLong_AsSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$slot_tp_hash DD imagerel slot_tp_hash
	DD	imagerel slot_tp_hash+265
	DD	imagerel $unwind$slot_tp_hash
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_tp_hash DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0CJ@MNKAHADD@__hash__?5method?5should?5return?5an@
CONST	SEGMENT
??_C@_0CJ@MNKAHADD@__hash__?5method?5should?5return?5an@ DB '__hash__ met'
	DB	'hod should return an integer', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT slot_tp_hash
_TEXT	SEGMENT
self$ = 48
slot_tp_hash PROC					; COMDAT

; 5315 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 5316 :     PyObject *func, *res;
; 5317 :     Py_ssize_t h;
; 5318 : 
; 5319 :     func = lookup_method(self, &PyId___hash__);

  0000a	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00011	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0001a	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId___hash__
  0001f	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  00023	48 8b f9	 mov	 rdi, rcx
  00026	e8 00 00 00 00	 call	 lookup_method
  0002b	48 8b d8	 mov	 rbx, rax

; 5320 : 
; 5321 :     if (func == Py_None) {

  0002e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00035	48 3b d8	 cmp	 rbx, rax
  00038	75 1a		 jne	 SHORT $LN6@slot_tp_ha

; 5322 :         Py_DECREF(func);

  0003a	48 8b cb	 mov	 rcx, rbx
  0003d	e8 00 00 00 00	 call	 _Py_DecRef

; 5327 :         return PyObject_HashNotImplemented(self);

  00042	48 8b cf	 mov	 rcx, rdi

; 5358 : }

  00045	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004e	5f		 pop	 rdi
  0004f	e9 00 00 00 00	 jmp	 PyObject_HashNotImplemented
$LN6@slot_tp_ha:

; 5323 :         func = NULL;
; 5324 :     }
; 5325 : 
; 5326 :     if (func == NULL) {

  00054	48 85 db	 test	 rbx, rbx
  00057	75 12		 jne	 SHORT $LN5@slot_tp_ha

; 5327 :         return PyObject_HashNotImplemented(self);

  00059	48 8b cf	 mov	 rcx, rdi

; 5358 : }

  0005c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00061	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00065	5f		 pop	 rdi
  00066	e9 00 00 00 00	 jmp	 PyObject_HashNotImplemented
$LN5@slot_tp_ha:

; 5328 :     }
; 5329 : 
; 5330 :     res = PyEval_CallObject(func, NULL);

  0006b	45 33 c0	 xor	 r8d, r8d
  0006e	33 d2		 xor	 edx, edx
  00070	48 8b cb	 mov	 rcx, rbx
  00073	e8 00 00 00 00	 call	 PyEval_CallObjectWithKeywords

; 5331 :     Py_DECREF(func);

  00078	48 8b cb	 mov	 rcx, rbx
  0007b	48 8b f8	 mov	 rdi, rax
  0007e	e8 00 00 00 00	 call	 _Py_DecRef

; 5332 :     if (res == NULL)

  00083	48 85 ff	 test	 rdi, rdi

; 5333 :         return -1;

  00086	74 23		 je	 SHORT $LN11@slot_tp_ha

; 5334 : 
; 5335 :     if (!PyLong_Check(res)) {

  00088	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0008c	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00096	75 22		 jne	 SHORT $LN3@slot_tp_ha

; 5336 :         PyErr_SetString(PyExc_TypeError,
; 5337 :                         "__hash__ method should return an integer");

  00098	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@MNKAHADD@__hash__?5method?5should?5return?5an@
  000a6	e8 00 00 00 00	 call	 PyErr_SetString
$LN11@slot_tp_ha:

; 5338 :         return -1;

  000ab	48 83 c8 ff	 or	 rax, -1

; 5358 : }

  000af	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b8	5f		 pop	 rdi
  000b9	c3		 ret	 0
$LN3@slot_tp_ha:

; 5339 :     }
; 5340 :     /* Transform the PyLong `res` to a Py_hash_t `h`.  For an existing
; 5341 :        hashable Python object x, hash(x) will always lie within the range of
; 5342 :        Py_hash_t.  Therefore our transformation must preserve values that
; 5343 :        already lie within this range, to ensure that if x.__hash__() returns
; 5344 :        hash(y) then hash(x) == hash(y). */
; 5345 :     h = PyLong_AsSsize_t(res);

  000ba	48 8b cf	 mov	 rcx, rdi
  000bd	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  000c2	48 8b d8	 mov	 rbx, rax

; 5346 :     if (h == -1 && PyErr_Occurred()) {

  000c5	48 83 f8 ff	 cmp	 rax, -1
  000c9	75 28		 jne	 SHORT $LN1@slot_tp_ha
  000cb	e8 00 00 00 00	 call	 PyErr_Occurred
  000d0	48 85 c0	 test	 rax, rax
  000d3	74 17		 je	 SHORT $LN10@slot_tp_ha

; 5347 :         /* res was not within the range of a Py_hash_t, so we're free to
; 5348 :            use any sufficiently bit-mixing transformation;
; 5349 :            long.__hash__ will do nicely. */
; 5350 :         PyErr_Clear();

  000d5	e8 00 00 00 00	 call	 PyErr_Clear

; 5351 :         h = PyLong_Type.tp_hash(res);

  000da	48 8b cf	 mov	 rcx, rdi
  000dd	ff 15 d0 00 00
	00		 call	 QWORD PTR PyLong_Type+208
  000e3	48 8b d8	 mov	 rbx, rax

; 5352 :     }
; 5353 :     /* -1 is reserved for errors. */
; 5354 :     if (h == -1)

  000e6	48 83 f8 ff	 cmp	 rax, -1
  000ea	75 07		 jne	 SHORT $LN1@slot_tp_ha
$LN10@slot_tp_ha:

; 5355 :         h = -2;

  000ec	48 c7 c3 fe ff
	ff ff		 mov	 rbx, -2
$LN1@slot_tp_ha:

; 5356 :     Py_DECREF(res);

  000f3	48 8b cf	 mov	 rcx, rdi
  000f6	e8 00 00 00 00	 call	 _Py_DecRef

; 5357 :     return h;

  000fb	48 8b c3	 mov	 rax, rbx

; 5358 : }

  000fe	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00103	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00107	5f		 pop	 rdi
  00108	c3		 ret	 0
slot_tp_hash ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$slot_tp_call DD imagerel slot_tp_call
	DD	imagerel slot_tp_call+119
	DD	imagerel $unwind$slot_tp_call
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_tp_call DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT slot_tp_call
_TEXT	SEGMENT
self$ = 48
args$ = 56
kwds$ = 64
slot_tp_call PROC					; COMDAT

; 5362 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 5363 :     _Py_IDENTIFIER(__call__);
; 5364 :     PyObject *meth = lookup_method(self, &PyId___call__);

  0000f	44 8b 0d 00 00
	00 00		 mov	 r9d, DWORD PTR _tls_index
  00016	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0001f	48 8b f2	 mov	 rsi, rdx
  00022	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___call__@?1??slot_tp_call@@9@9
  00027	49 8b d8	 mov	 rbx, r8
  0002a	4a 03 14 c8	 add	 rdx, QWORD PTR [rax+r9*8]
  0002e	e8 00 00 00 00	 call	 lookup_method
  00033	48 8b f8	 mov	 rdi, rax

; 5365 :     PyObject *res;
; 5366 : 
; 5367 :     if (meth == NULL)

  00036	48 85 c0	 test	 rax, rax
  00039	75 10		 jne	 SHORT $LN1@slot_tp_ca

; 5373 :     return res;
; 5374 : }

  0003b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00040	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5f		 pop	 rdi
  0004a	c3		 ret	 0
$LN1@slot_tp_ca:

; 5368 :         return NULL;
; 5369 : 
; 5370 :     res = PyObject_Call(meth, args, kwds);

  0004b	4c 8b c3	 mov	 r8, rbx
  0004e	48 8b d6	 mov	 rdx, rsi
  00051	48 8b c8	 mov	 rcx, rax
  00054	e8 00 00 00 00	 call	 PyObject_Call

; 5371 : 
; 5372 :     Py_DECREF(meth);

  00059	48 8b cf	 mov	 rcx, rdi
  0005c	48 8b d8	 mov	 rbx, rax
  0005f	e8 00 00 00 00	 call	 _Py_DecRef

; 5373 :     return res;
; 5374 : }

  00064	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00069	48 8b c3	 mov	 rax, rbx
  0006c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00071	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00075	5f		 pop	 rdi
  00076	c3		 ret	 0
slot_tp_call ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT slot_tp_getattro
_TEXT	SEGMENT
self$ = 8
name$ = 16
slot_tp_getattro PROC					; COMDAT

; 5390 :     return call_method(self, &PyId___getattribute__, "(O)", name);

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00007	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00010	4c 8b ca	 mov	 r9, rdx
  00013	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId___getattribute__
  00018	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  0001c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@

; 5391 : }

  00023	e9 00 00 00 00	 jmp	 call_method
slot_tp_getattro ENDP
_TEXT	ENDS
EXTRN	PyWrapperDescr_Type:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$slot_tp_getattr_hook DD imagerel slot_tp_getattr_hook
	DD	imagerel slot_tp_getattr_hook+352
	DD	imagerel $unwind$slot_tp_getattr_hook
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_tp_getattr_hook DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0c016521aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT slot_tp_getattr_hook
_TEXT	SEGMENT
self$ = 64
name$ = 72
slot_tp_getattr_hook PROC				; COMDAT

; 5413 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 5414 :     PyTypeObject *tp = Py_TYPE(self);
; 5415 :     PyObject *getattr, *getattribute, *res;
; 5416 :     _Py_IDENTIFIER(__getattr__);
; 5417 : 
; 5418 :     /* speed hack: we could use lookup_maybe, but that would resolve the
; 5419 :        method fully for each attribute lookup for classes with
; 5420 :        __getattr__, even when the attribute is present. So we use
; 5421 :        _PyType_Lookup and create the method only when needed, with
; 5422 :        call_attribute. */
; 5423 :     getattr = _PyType_LookupId(tp, &PyId___getattr__);

  0001a	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00021	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0002a	48 8b 79 58	 mov	 rdi, QWORD PTR [rcx+88]
  0002e	4a 8b 34 c0	 mov	 rsi, QWORD PTR [rax+r8*8]
  00032	4c 8b e2	 mov	 r12, rdx
  00035	48 8b e9	 mov	 rbp, rcx
  00038	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___getattr__@?1??slot_tp_getattr_hook@@9@9
  0003d	48 8b cf	 mov	 rcx, rdi
  00040	48 03 d6	 add	 rdx, rsi
  00043	e8 00 00 00 00	 call	 _PyType_LookupId
  00048	48 8b d8	 mov	 rbx, rax

; 5424 :     if (getattr == NULL) {

  0004b	48 85 c0	 test	 rax, rax
  0004e	75 1e		 jne	 SHORT $LN5@slot_tp_ge

; 5425 :         /* No __getattr__ hook: use a simpler dispatcher */
; 5426 :         tp->tp_getattro = slot_tp_getattro;

  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:slot_tp_getattro

; 5427 :         return slot_tp_getattro(self, name);

  00057	49 8b d4	 mov	 rdx, r12
  0005a	48 8b cd	 mov	 rcx, rbp
  0005d	48 89 87 e8 00
	00 00		 mov	 QWORD PTR [rdi+232], rax
  00064	e8 00 00 00 00	 call	 slot_tp_getattro
  00069	e9 d7 00 00 00	 jmp	 $LN6@slot_tp_ge
$LN5@slot_tp_ge:

; 5428 :     }
; 5429 :     Py_INCREF(getattr);

  0006e	e8 00 00 00 00	 call	 _Py_PXCTX
  00073	85 c0		 test	 eax, eax
  00075	75 32		 jne	 SHORT $LN9@slot_tp_ge
  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00085	4c 8b cb	 mov	 r9, rbx
  00088	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0008e	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00096	e8 00 00 00 00	 call	 _PyParallel_Guard
  0009b	85 c0		 test	 eax, eax
  0009d	75 06		 jne	 SHORT $LN8@slot_tp_ge
  0009f	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000a3	74 04		 je	 SHORT $LN9@slot_tp_ge
$LN8@slot_tp_ge:
  000a5	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN9@slot_tp_ge:

; 5430 :     /* speed hack: we could use lookup_maybe, but that would resolve the
; 5431 :        method fully for each attribute lookup for classes with
; 5432 :        __getattr__, even when self has the default __getattribute__
; 5433 :        method. So we use _PyType_Lookup and create the method only when
; 5434 :        needed, with call_attribute. */
; 5435 :     getattribute = _PyType_LookupId(tp, &PyId___getattribute__);

  000a9	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId___getattribute__
  000ae	48 8b cf	 mov	 rcx, rdi
  000b1	48 03 d6	 add	 rdx, rsi
  000b4	e8 00 00 00 00	 call	 _PyType_LookupId
  000b9	48 8b f0	 mov	 rsi, rax

; 5436 :     if (getattribute == NULL ||
; 5437 :         (Py_TYPE(getattribute) == &PyWrapperDescr_Type &&
; 5438 :          ((PyWrapperDescrObject *)getattribute)->d_wrapped ==
; 5439 :          (void *)PyObject_GenericGetAttr))

  000bc	48 85 c0	 test	 rax, rax
  000bf	74 40		 je	 SHORT $LN3@slot_tp_ge
  000c1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyWrapperDescr_Type
  000c8	48 39 46 58	 cmp	 QWORD PTR [rsi+88], rax
  000cc	75 10		 jne	 SHORT $LN4@slot_tp_ge
  000ce	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyObject_GenericGetAttr
  000d5	48 39 86 88 00
	00 00		 cmp	 QWORD PTR [rsi+136], rax
  000dc	74 23		 je	 SHORT $LN3@slot_tp_ge
$LN4@slot_tp_ge:

; 5441 :     else {
; 5442 :         Py_INCREF(getattribute);

  000de	48 8b ce	 mov	 rcx, rsi
  000e1	e8 00 00 00 00	 call	 _Py_IncRef

; 5443 :         res = call_attribute(self, getattribute, name);

  000e6	4d 8b c4	 mov	 r8, r12
  000e9	48 8b d6	 mov	 rdx, rsi
  000ec	48 8b cd	 mov	 rcx, rbp
  000ef	e8 00 00 00 00	 call	 call_attribute

; 5444 :         Py_DECREF(getattribute);

  000f4	48 8b ce	 mov	 rcx, rsi
  000f7	48 8b f8	 mov	 rdi, rax
  000fa	e8 00 00 00 00	 call	 _Py_DecRef
  000ff	eb 0e		 jmp	 SHORT $LN2@slot_tp_ge
$LN3@slot_tp_ge:

; 5440 :         res = PyObject_GenericGetAttr(self, name);

  00101	49 8b d4	 mov	 rdx, r12
  00104	48 8b cd	 mov	 rcx, rbp
  00107	e8 00 00 00 00	 call	 PyObject_GenericGetAttr
  0010c	48 8b f8	 mov	 rdi, rax
$LN2@slot_tp_ge:

; 5445 :     }
; 5446 :     if (res == NULL && PyErr_ExceptionMatches(PyExc_AttributeError)) {

  0010f	48 85 ff	 test	 rdi, rdi
  00112	75 26		 jne	 SHORT $LN1@slot_tp_ge
  00114	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  0011b	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00120	85 c0		 test	 eax, eax
  00122	74 16		 je	 SHORT $LN1@slot_tp_ge

; 5447 :         PyErr_Clear();

  00124	e8 00 00 00 00	 call	 PyErr_Clear

; 5448 :         res = call_attribute(self, getattr, name);

  00129	4d 8b c4	 mov	 r8, r12
  0012c	48 8b d3	 mov	 rdx, rbx
  0012f	48 8b cd	 mov	 rcx, rbp
  00132	e8 00 00 00 00	 call	 call_attribute
  00137	48 8b f8	 mov	 rdi, rax
$LN1@slot_tp_ge:

; 5449 :     }
; 5450 :     Py_DECREF(getattr);

  0013a	48 8b cb	 mov	 rcx, rbx
  0013d	e8 00 00 00 00	 call	 _Py_DecRef

; 5451 :     return res;

  00142	48 8b c7	 mov	 rax, rdi
$LN6@slot_tp_ge:

; 5452 : }

  00145	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0014a	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0014f	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00154	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00159	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0015d	41 5c		 pop	 r12
  0015f	c3		 ret	 0
slot_tp_getattr_hook ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$slot_tp_setattro DD imagerel slot_tp_setattro
	DD	imagerel slot_tp_setattro+117
	DD	imagerel $unwind$slot_tp_setattro
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_tp_setattro DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT slot_tp_setattro
_TEXT	SEGMENT
self$ = 64
name$ = 72
value$ = 80
slot_tp_setattro PROC					; COMDAT

; 5456 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 5457 :     PyObject *res;
; 5458 :     _Py_IDENTIFIER(__delattr__);
; 5459 :     _Py_IDENTIFIER(__setattr__);
; 5460 : 
; 5461 :     if (value == NULL)
; 5462 :         res = call_method(self, &PyId___delattr__, "(O)", name);

  00004	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0000d	4c 8b ca	 mov	 r9, rdx
  00010	4c 8b d1	 mov	 r10, rcx
  00013	4d 85 c0	 test	 r8, r8
  00016	75 1e		 jne	 SHORT $LN3@slot_tp_se
  00018	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0001f	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___delattr__@?1??slot_tp_setattro@@9@9
  00024	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  00028	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  0002f	e8 00 00 00 00	 call	 call_method

; 5463 :     else

  00034	eb 23		 jmp	 SHORT $LN2@slot_tp_se
$LN3@slot_tp_se:

; 5464 :         res = call_method(self, &PyId___setattr__, "(OO)", name, value);

  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0003c	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  00041	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___setattr__@?1??slot_tp_setattro@@9@9
  00046	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  0004a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04DEJLHBFK@?$CIOO?$CJ?$AA@
  00051	49 8b ca	 mov	 rcx, r10
  00054	e8 00 00 00 00	 call	 call_method
$LN2@slot_tp_se:

; 5465 :     if (res == NULL)

  00059	48 85 c0	 test	 rax, rax
  0005c	75 08		 jne	 SHORT $LN1@slot_tp_se

; 5466 :         return -1;

  0005e	83 c8 ff	 or	 eax, -1

; 5469 : }

  00061	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00065	c3		 ret	 0
$LN1@slot_tp_se:

; 5467 :     Py_DECREF(res);

  00066	48 8b c8	 mov	 rcx, rax
  00069	e8 00 00 00 00	 call	 _Py_DecRef

; 5468 :     return 0;

  0006e	33 c0		 xor	 eax, eax

; 5469 : }

  00070	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00074	c3		 ret	 0
slot_tp_setattro ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$slot_tp_richcompare DD imagerel slot_tp_richcompare
	DD	imagerel slot_tp_richcompare+218
	DD	imagerel $unwind$slot_tp_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_tp_richcompare DD 069501H
	DD	087495H
	DD	09340aH
	DD	06006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
xdata	ENDS
;	COMDAT slot_tp_richcompare
_TEXT	SEGMENT
self$ = 64
other$ = 72
op$ = 80
slot_tp_richcompare PROC				; COMDAT

; 5482 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 5483 :     PyObject *func, *args, *res;
; 5484 : 
; 5485 :     func = lookup_method(self, &name_op[op]);

  0000a	49 63 c0	 movsxd	 rax, r8d
  0000d	48 8b da	 mov	 rbx, rdx
  00010	4c 8d 04 40	 lea	 r8, QWORD PTR [rax+rax*2]
  00014	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:name_op
  0001b	4a 8d 14 c0	 lea	 rdx, QWORD PTR [rax+r8*8]
  0001f	e8 00 00 00 00	 call	 lookup_method
  00024	48 8b f0	 mov	 rsi, rax

; 5486 :     if (func == NULL) {

  00027	48 85 c0	 test	 rax, rax
  0002a	75 5c		 jne	 SHORT $LN3@slot_tp_ri

; 5487 :         PyErr_Clear();

  0002c	e8 00 00 00 00	 call	 PyErr_Clear

; 5488 :         Py_RETURN_NOTIMPLEMENTED;

  00031	e8 00 00 00 00	 call	 _Py_PXCTX
  00036	85 c0		 test	 eax, eax
  00038	75 3c		 jne	 SHORT $LN7@slot_tp_ri
  0003a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0004f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00055	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0005d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00062	85 c0		 test	 eax, eax
  00064	75 09		 jne	 SHORT $LN6@slot_tp_ri
  00066	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  0006d	74 07		 je	 SHORT $LN7@slot_tp_ri
$LN6@slot_tp_ri:
  0006f	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN7@slot_tp_ri:
  00076	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 5499 : }

  0007d	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00082	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00086	5e		 pop	 rsi
  00087	c3		 ret	 0
$LN3@slot_tp_ri:

; 5489 :     }
; 5490 :     args = PyTuple_Pack(1, other);

  00088	48 8b d3	 mov	 rdx, rbx
  0008b	b9 01 00 00 00	 mov	 ecx, 1
  00090	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00095	e8 00 00 00 00	 call	 PyTuple_Pack
  0009a	48 8b f8	 mov	 rdi, rax

; 5491 :     if (args == NULL)

  0009d	48 85 c0	 test	 rax, rax
  000a0	75 04		 jne	 SHORT $LN2@slot_tp_ri

; 5492 :         res = NULL;

  000a2	33 db		 xor	 ebx, ebx

; 5493 :     else {

  000a4	eb 19		 jmp	 SHORT $LN1@slot_tp_ri
$LN2@slot_tp_ri:

; 5494 :         res = PyObject_Call(func, args, NULL);

  000a6	45 33 c0	 xor	 r8d, r8d
  000a9	48 8b d0	 mov	 rdx, rax
  000ac	48 8b ce	 mov	 rcx, rsi
  000af	e8 00 00 00 00	 call	 PyObject_Call

; 5495 :         Py_DECREF(args);

  000b4	48 8b cf	 mov	 rcx, rdi
  000b7	48 8b d8	 mov	 rbx, rax
  000ba	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@slot_tp_ri:

; 5496 :     }
; 5497 :     Py_DECREF(func);

  000bf	48 8b ce	 mov	 rcx, rsi
  000c2	e8 00 00 00 00	 call	 _Py_DecRef
  000c7	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 5498 :     return res;

  000cc	48 8b c3	 mov	 rax, rbx

; 5499 : }

  000cf	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000d4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d8	5e		 pop	 rsi
  000d9	c3		 ret	 0
slot_tp_richcompare ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@OJDKODEI@?8?$CF?4200s?8?5object?5is?5not?5iterable?$AA@ ; `string'
EXTRN	PySeqIter_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$slot_tp_iter DD imagerel slot_tp_iter
	DD	imagerel slot_tp_iter+230
	DD	imagerel $unwind$slot_tp_iter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_tp_iter DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0CA@OJDKODEI@?8?$CF?4200s?8?5object?5is?5not?5iterable?$AA@
CONST	SEGMENT
??_C@_0CA@OJDKODEI@?8?$CF?4200s?8?5object?5is?5not?5iterable?$AA@ DB '''%'
	DB	'.200s'' object is not iterable', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT slot_tp_iter
_TEXT	SEGMENT
self$ = 48
slot_tp_iter PROC					; COMDAT

; 5503 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 5504 :     PyObject *func, *res;
; 5505 :     _Py_IDENTIFIER(__iter__);
; 5506 : 
; 5507 :     func = lookup_method(self, &PyId___iter__);

  0000f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00015	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0001e	48 8b d9	 mov	 rbx, rcx
  00021	48 8b 34 d0	 mov	 rsi, QWORD PTR [rax+rdx*8]
  00025	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___iter__@?1??slot_tp_iter@@9@9
  0002a	48 03 d6	 add	 rdx, rsi
  0002d	e8 00 00 00 00	 call	 lookup_method
  00032	48 8b f8	 mov	 rdi, rax

; 5508 :     if (func != NULL) {

  00035	48 85 c0	 test	 rax, rax
  00038	74 46		 je	 SHORT $LN3@slot_tp_it

; 5509 :         PyObject *args;
; 5510 :         args = res = PyTuple_New(0);

  0003a	33 c9		 xor	 ecx, ecx
  0003c	e8 00 00 00 00	 call	 PyTuple_New
  00041	48 8b d8	 mov	 rbx, rax
  00044	48 8b f0	 mov	 rsi, rax

; 5511 :         if (args != NULL) {

  00047	48 85 c0	 test	 rax, rax
  0004a	74 19		 je	 SHORT $LN2@slot_tp_it

; 5512 :             res = PyObject_Call(func, args, NULL);

  0004c	45 33 c0	 xor	 r8d, r8d
  0004f	48 8b d0	 mov	 rdx, rax
  00052	48 8b cf	 mov	 rcx, rdi
  00055	e8 00 00 00 00	 call	 PyObject_Call

; 5513 :             Py_DECREF(args);

  0005a	48 8b ce	 mov	 rcx, rsi
  0005d	48 8b d8	 mov	 rbx, rax
  00060	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@slot_tp_it:

; 5514 :         }
; 5515 :         Py_DECREF(func);

  00065	48 8b cf	 mov	 rcx, rdi
  00068	e8 00 00 00 00	 call	 _Py_DecRef

; 5516 :         return res;

  0006d	48 8b c3	 mov	 rax, rbx

; 5528 : }

  00070	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00075	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007e	5f		 pop	 rdi
  0007f	c3		 ret	 0
$LN3@slot_tp_it:

; 5517 :     }
; 5518 :     PyErr_Clear();

  00080	e8 00 00 00 00	 call	 PyErr_Clear

; 5519 :     func = lookup_method(self, &PyId___getitem__);

  00085	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId___getitem__
  0008a	48 8b cb	 mov	 rcx, rbx
  0008d	48 03 d6	 add	 rdx, rsi
  00090	e8 00 00 00 00	 call	 lookup_method

; 5520 :     if (func == NULL) {

  00095	48 85 c0	 test	 rax, rax
  00098	75 2d		 jne	 SHORT $LN1@slot_tp_it

; 5521 :         PyErr_Format(PyExc_TypeError,
; 5522 :                      "'%.200s' object is not iterable",
; 5523 :                      Py_TYPE(self)->tp_name);

  0009a	4c 8b 43 58	 mov	 r8, QWORD PTR [rbx+88]
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@OJDKODEI@?8?$CF?4200s?8?5object?5is?5not?5iterable?$AA@
  000ac	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  000b0	e8 00 00 00 00	 call	 PyErr_Format

; 5524 :         return NULL;

  000b5	33 c0		 xor	 eax, eax

; 5528 : }

  000b7	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000bc	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000c1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c5	5f		 pop	 rdi
  000c6	c3		 ret	 0
$LN1@slot_tp_it:

; 5525 :     }
; 5526 :     Py_DECREF(func);

  000c7	48 8b c8	 mov	 rcx, rax
  000ca	e8 00 00 00 00	 call	 _Py_DecRef

; 5527 :     return PySeqIter_New(self);

  000cf	48 8b cb	 mov	 rcx, rbx

; 5528 : }

  000d2	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000d7	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000dc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e0	5f		 pop	 rdi
  000e1	e9 00 00 00 00	 jmp	 PySeqIter_New
slot_tp_iter ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT slot_tp_iternext
_TEXT	SEGMENT
self$ = 8
slot_tp_iternext PROC					; COMDAT

; 5533 :     _Py_IDENTIFIER(__next__);
; 5534 :     return call_method(self, &PyId___next__, "()");

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00007	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00010	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___next__@?1??slot_tp_iternext@@9@9
  00015	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  00019	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@

; 5535 : }

  00020	e9 00 00 00 00	 jmp	 call_method
slot_tp_iternext ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$slot_tp_descr_set DD imagerel slot_tp_descr_set
	DD	imagerel slot_tp_descr_set+117
	DD	imagerel $unwind$slot_tp_descr_set
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_tp_descr_set DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT slot_tp_descr_set
_TEXT	SEGMENT
self$ = 64
target$ = 72
value$ = 80
slot_tp_descr_set PROC					; COMDAT

; 5561 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 5562 :     PyObject *res;
; 5563 :     _Py_IDENTIFIER(__delete__);
; 5564 :     _Py_IDENTIFIER(__set__);
; 5565 : 
; 5566 :     if (value == NULL)
; 5567 :         res = call_method(self, &PyId___delete__, "(O)", target);

  00004	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0000d	4c 8b ca	 mov	 r9, rdx
  00010	4c 8b d1	 mov	 r10, rcx
  00013	4d 85 c0	 test	 r8, r8
  00016	75 1e		 jne	 SHORT $LN3@slot_tp_de@2
  00018	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0001f	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___delete__@?1??slot_tp_descr_set@@9@9
  00024	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  00028	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  0002f	e8 00 00 00 00	 call	 call_method

; 5568 :     else

  00034	eb 23		 jmp	 SHORT $LN2@slot_tp_de@2
$LN3@slot_tp_de@2:

; 5569 :         res = call_method(self, &PyId___set__, "(OO)", target, value);

  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0003c	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  00041	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___set__@?1??slot_tp_descr_set@@9@9
  00046	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  0004a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04DEJLHBFK@?$CIOO?$CJ?$AA@
  00051	49 8b ca	 mov	 rcx, r10
  00054	e8 00 00 00 00	 call	 call_method
$LN2@slot_tp_de@2:

; 5570 :     if (res == NULL)

  00059	48 85 c0	 test	 rax, rax
  0005c	75 08		 jne	 SHORT $LN1@slot_tp_de@2

; 5571 :         return -1;

  0005e	83 c8 ff	 or	 eax, -1

; 5574 : }

  00061	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00065	c3		 ret	 0
$LN1@slot_tp_de@2:

; 5572 :     Py_DECREF(res);

  00066	48 8b c8	 mov	 rcx, rax
  00069	e8 00 00 00 00	 call	 _Py_DecRef

; 5573 :     return 0;

  0006e	33 c0		 xor	 eax, eax

; 5574 : }

  00070	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00074	c3		 ret	 0
slot_tp_descr_set ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@HKPEOANK@__init__?$CI?$CJ?5should?5return?5None?0?5n@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$slot_tp_init DD imagerel slot_tp_init
	DD	imagerel slot_tp_init+181
	DD	imagerel $unwind$slot_tp_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_tp_init DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0CM@HKPEOANK@__init__?$CI?$CJ?5should?5return?5None?0?5n@
CONST	SEGMENT
??_C@_0CM@HKPEOANK@__init__?$CI?$CJ?5should?5return?5None?0?5n@ DB '__ini'
	DB	't__() should return None, not ''%.200s''', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT slot_tp_init
_TEXT	SEGMENT
self$ = 48
args$ = 56
kwds$ = 64
slot_tp_init PROC					; COMDAT

; 5578 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 5579 :     _Py_IDENTIFIER(__init__);
; 5580 :     PyObject *meth = lookup_method(self, &PyId___init__);

  0000f	44 8b 0d 00 00
	00 00		 mov	 r9d, DWORD PTR _tls_index
  00016	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0001f	48 8b f2	 mov	 rsi, rdx
  00022	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___init__@?1??slot_tp_init@@9@9
  00027	49 8b d8	 mov	 rbx, r8
  0002a	4a 03 14 c8	 add	 rdx, QWORD PTR [rax+r9*8]
  0002e	e8 00 00 00 00	 call	 lookup_method
  00033	48 8b f8	 mov	 rdi, rax

; 5581 :     PyObject *res;
; 5582 : 
; 5583 :     if (meth == NULL)

  00036	48 85 c0	 test	 rax, rax

; 5584 :         return -1;

  00039	74 4d		 je	 SHORT $LN6@slot_tp_in

; 5585 :     res = PyObject_Call(meth, args, kwds);

  0003b	4c 8b c3	 mov	 r8, rbx
  0003e	48 8b d6	 mov	 rdx, rsi
  00041	48 8b c8	 mov	 rcx, rax
  00044	e8 00 00 00 00	 call	 PyObject_Call

; 5586 :     Py_DECREF(meth);

  00049	48 8b cf	 mov	 rcx, rdi
  0004c	48 8b d8	 mov	 rbx, rax
  0004f	e8 00 00 00 00	 call	 _Py_DecRef

; 5587 :     if (res == NULL)

  00054	48 85 db	 test	 rbx, rbx

; 5588 :         return -1;

  00057	74 2f		 je	 SHORT $LN6@slot_tp_in

; 5589 :     if (res != Py_None) {

  00059	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00060	48 3b d8	 cmp	 rbx, rax
  00063	74 36		 je	 SHORT $LN1@slot_tp_in

; 5590 :         PyErr_Format(PyExc_TypeError,
; 5591 :                      "__init__() should return None, not '%.200s'",
; 5592 :                      Py_TYPE(res)->tp_name);

  00065	4c 8b 43 58	 mov	 r8, QWORD PTR [rbx+88]
  00069	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00070	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@HKPEOANK@__init__?$CI?$CJ?5should?5return?5None?0?5n@
  00077	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  0007b	e8 00 00 00 00	 call	 PyErr_Format

; 5593 :         Py_DECREF(res);

  00080	48 8b cb	 mov	 rcx, rbx
  00083	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@slot_tp_in:

; 5594 :         return -1;

  00088	83 c8 ff	 or	 eax, -1

; 5597 :     return 0;
; 5598 : }

  0008b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00090	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00095	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00099	5f		 pop	 rdi
  0009a	c3		 ret	 0
$LN1@slot_tp_in:

; 5595 :     }
; 5596 :     Py_DECREF(res);

  0009b	48 8b cb	 mov	 rcx, rbx
  0009e	e8 00 00 00 00	 call	 _Py_DecRef

; 5597 :     return 0;
; 5598 : }

  000a3	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a8	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000ad	33 c0		 xor	 eax, eax
  000af	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b3	5f		 pop	 rdi
  000b4	c3		 ret	 0
slot_tp_init ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@BGMDKOPC@slot_tp_del?$AA@		; `string'
EXTRN	PyErr_Restore:PROC
EXTRN	PyErr_WriteUnraisable:PROC
EXTRN	PyErr_Fetch:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$slot_tp_del DD imagerel slot_tp_del
	DD	imagerel slot_tp_del+242
	DD	imagerel $unwind$slot_tp_del
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slot_tp_del DD 040a01H
	DD	0b340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0M@BGMDKOPC@slot_tp_del?$AA@
CONST	SEGMENT
??_C@_0M@BGMDKOPC@slot_tp_del?$AA@ DB 'slot_tp_del', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT slot_tp_del
_TEXT	SEGMENT
error_traceback$ = 64
self$ = 64
error_value$ = 72
error_type$ = 80
slot_tp_del PROC					; COMDAT

; 5631 : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b d9	 mov	 rbx, rcx

; 5632 :     _Py_IDENTIFIER(__del__);
; 5633 :     PyObject *del, *res;
; 5634 :     PyObject *error_type, *error_value, *error_traceback;
; 5635 : 
; 5636 :     /* Temporarily resurrect the object. */
; 5637 :     assert(self->ob_refcnt == 0);
; 5638 :     self->ob_refcnt = 1;

  0000d	48 c7 41 50 01
	00 00 00	 mov	 QWORD PTR [rcx+80], 1

; 5639 : 
; 5640 :     /* Save the current exception, if any. */
; 5641 :     PyErr_Fetch(&error_type, &error_value, &error_traceback);

  00015	4c 8d 44 24 40	 lea	 r8, QWORD PTR error_traceback$[rsp]
  0001a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR error_type$[rsp]
  0001f	48 8d 54 24 48	 lea	 rdx, QWORD PTR error_value$[rsp]
  00024	e8 00 00 00 00	 call	 PyErr_Fetch

; 5642 : 
; 5643 :     /* Execute __del__ method, if any. */
; 5644 :     del = lookup_maybe(self, &PyId___del__);

  00029	44 8b 1d 00 00
	00 00		 mov	 r11d, DWORD PTR _tls_index
  00030	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00039	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___del__@?1??slot_tp_del@@9@9
  0003e	48 8b cb	 mov	 rcx, rbx
  00041	4a 03 14 d8	 add	 rdx, QWORD PTR [rax+r11*8]
  00045	e8 00 00 00 00	 call	 lookup_maybe
  0004a	48 8b f8	 mov	 rdi, rax

; 5645 :     if (del != NULL) {

  0004d	48 85 c0	 test	 rax, rax
  00050	74 2c		 je	 SHORT $LN4@slot_tp_de@3

; 5646 :         res = PyEval_CallObject(del, NULL);

  00052	45 33 c0	 xor	 r8d, r8d
  00055	33 d2		 xor	 edx, edx
  00057	48 8b c8	 mov	 rcx, rax
  0005a	e8 00 00 00 00	 call	 PyEval_CallObjectWithKeywords

; 5647 :         if (res == NULL)

  0005f	48 85 c0	 test	 rax, rax
  00062	75 0a		 jne	 SHORT $LN3@slot_tp_de@3

; 5648 :             PyErr_WriteUnraisable(del);

  00064	48 8b cf	 mov	 rcx, rdi
  00067	e8 00 00 00 00	 call	 PyErr_WriteUnraisable

; 5649 :         else

  0006c	eb 08		 jmp	 SHORT $LN2@slot_tp_de@3
$LN3@slot_tp_de@3:

; 5650 :             Py_DECREF(res);

  0006e	48 8b c8	 mov	 rcx, rax
  00071	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@slot_tp_de@3:

; 5651 :         Py_DECREF(del);

  00076	48 8b cf	 mov	 rcx, rdi
  00079	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@slot_tp_de@3:

; 5652 :     }
; 5653 : 
; 5654 :     /* Restore the saved exception. */
; 5655 :     PyErr_Restore(error_type, error_value, error_traceback);

  0007e	4c 8b 44 24 40	 mov	 r8, QWORD PTR error_traceback$[rsp]
  00083	48 8b 54 24 48	 mov	 rdx, QWORD PTR error_value$[rsp]
  00088	48 8b 4c 24 50	 mov	 rcx, QWORD PTR error_type$[rsp]
  0008d	e8 00 00 00 00	 call	 PyErr_Restore

; 5656 : 
; 5657 :     /* Undo the temporary resurrection; can't use DECREF here, it would
; 5658 :      * cause a recursive call.
; 5659 :      */
; 5660 :     assert(self->ob_refcnt > 0);
; 5661 :     if (--self->ob_refcnt == 0)

  00092	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00096	48 8b 7b 50	 mov	 rdi, QWORD PTR [rbx+80]
  0009a	74 4b		 je	 SHORT $LN5@slot_tp_de@3

; 5662 :         return;         /* this is the normal path out */
; 5663 : 
; 5664 :     /* __del__ resurrected it!  Make it look like the original Py_DECREF
; 5665 :      * never happened.
; 5666 :      */
; 5667 :     {
; 5668 :         Py_ssize_t refcnt = self->ob_refcnt;
; 5669 :         _Py_NewReference(self);

  0009c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  000a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@BGMDKOPC@slot_tp_del?$AA@
  000aa	4c 8b cb	 mov	 r9, rbx
  000ad	41 b8 25 16 00
	00		 mov	 r8d, 5669		; 00001625H
  000b3	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000bb	e8 00 00 00 00	 call	 _PyParallel_Guard
  000c0	85 c0		 test	 eax, eax
  000c2	74 17		 je	 SHORT $LN7@slot_tp_de@3
  000c4	48 8b cb	 mov	 rcx, rbx
  000c7	e8 00 00 00 00	 call	 _Px_NewReference

; 5670 :         self->ob_refcnt = refcnt;

  000cc	48 89 7b 50	 mov	 QWORD PTR [rbx+80], rdi

; 5671 :     }
; 5672 :     assert(!PyType_IS_GC(Py_TYPE(self)) ||
; 5673 :            _Py_AS_GC(self)->gc.gc_refs != _PyGC_REFS_UNTRACKED);
; 5674 :     /* If Py_REF_DEBUG, _Py_NewReference bumped _Py_RefTotal, so
; 5675 :      * we need to undo that. */
; 5676 :     _Py_DEC_REFTOTAL;
; 5677 :     /* If Py_TRACE_REFS, _Py_NewReference re-added self to the object
; 5678 :      * chain, so no more to do there.
; 5679 :      * If COUNT_ALLOCS, the original decref bumped tp_frees, and
; 5680 :      * _Py_NewReference bumped tp_allocs:  both of those need to be
; 5681 :      * undone.
; 5682 :      */
; 5683 : #ifdef COUNT_ALLOCS
; 5684 :     --Py_TYPE(self)->tp_frees;
; 5685 :     --Py_TYPE(self)->tp_allocs;
; 5686 : #endif
; 5687 : }

  000d0	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  000d5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d9	5f		 pop	 rdi
  000da	c3		 ret	 0
$LN7@slot_tp_de@3:

; 5662 :         return;         /* this is the normal path out */
; 5663 : 
; 5664 :     /* __del__ resurrected it!  Make it look like the original Py_DECREF
; 5665 :      * never happened.
; 5666 :      */
; 5667 :     {
; 5668 :         Py_ssize_t refcnt = self->ob_refcnt;
; 5669 :         _Py_NewReference(self);

  000db	48 c7 43 50 01
	00 00 00	 mov	 QWORD PTR [rbx+80], 1

; 5670 :         self->ob_refcnt = refcnt;

  000e3	48 89 7b 50	 mov	 QWORD PTR [rbx+80], rdi
$LN5@slot_tp_de@3:

; 5671 :     }
; 5672 :     assert(!PyType_IS_GC(Py_TYPE(self)) ||
; 5673 :            _Py_AS_GC(self)->gc.gc_refs != _PyGC_REFS_UNTRACKED);
; 5674 :     /* If Py_REF_DEBUG, _Py_NewReference bumped _Py_RefTotal, so
; 5675 :      * we need to undo that. */
; 5676 :     _Py_DEC_REFTOTAL;
; 5677 :     /* If Py_TRACE_REFS, _Py_NewReference re-added self to the object
; 5678 :      * chain, so no more to do there.
; 5679 :      * If COUNT_ALLOCS, the original decref bumped tp_frees, and
; 5680 :      * _Py_NewReference bumped tp_allocs:  both of those need to be
; 5681 :      * undone.
; 5682 :      */
; 5683 : #ifdef COUNT_ALLOCS
; 5684 :     --Py_TYPE(self)->tp_frees;
; 5685 :     --Py_TYPE(self)->tp_allocs;
; 5686 : #endif
; 5687 : }

  000e7	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  000ec	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f0	5f		 pop	 rdi
  000f1	c3		 ret	 0
slot_tp_del ENDP
_TEXT	ENDS
EXTRN	PyCFunction_Type:BYTE
EXTRN	_PyObject_NextNotImplemented:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$update_one_slot DD imagerel update_one_slot
	DD	imagerel update_one_slot+79
	DD	imagerel $unwind$update_one_slot
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$update_one_slot DD imagerel update_one_slot+79
	DD	imagerel update_one_slot+363
	DD	imagerel $chain$0$update_one_slot
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$update_one_slot DD imagerel update_one_slot+363
	DD	imagerel update_one_slot+405
	DD	imagerel $chain$1$update_one_slot
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$update_one_slot DD 021H
	DD	imagerel update_one_slot
	DD	imagerel update_one_slot+79
	DD	imagerel $unwind$update_one_slot
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$update_one_slot DD 020521H
	DD	0a7405H
	DD	imagerel update_one_slot
	DD	imagerel update_one_slot+79
	DD	imagerel $unwind$update_one_slot
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$update_one_slot DD 0a1701H
	DD	0c5417H
	DD	0b3417H
	DD	0f0133217H
	DD	0d00fe011H
	DD	0600bc00dH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT update_one_slot
_TEXT	SEGMENT
type$ = 80
p$ = 88
update_one_slot PROC					; COMDAT

; 6000 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	41 56		 push	 r14
  00011	41 57		 push	 r15
  00013	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 6001 :     PyObject *descr;
; 6002 :     PyWrapperDescrObject *d;
; 6003 :     void *generic = NULL, *specific = NULL;
; 6004 :     int use_generic = 0;
; 6005 :     int offset = p->offset;

  00017	44 8b 6a 08	 mov	 r13d, DWORD PTR [rdx+8]
  0001b	48 8b da	 mov	 rbx, rdx
  0001e	45 33 f6	 xor	 r14d, r14d

; 6006 :     void **ptr = slotptr(type, offset);

  00021	41 8b d5	 mov	 edx, r13d
  00024	4c 8b e1	 mov	 r12, rcx
  00027	41 8b f6	 mov	 esi, r14d
  0002a	45 8b fe	 mov	 r15d, r14d
  0002d	e8 00 00 00 00	 call	 slotptr
  00032	48 8b e8	 mov	 rbp, rax

; 6007 : 
; 6008 :     if (ptr == NULL) {

  00035	48 85 c0	 test	 rax, rax
  00038	75 15		 jne	 SHORT $LN29@update_one
  0003a	66 0f 1f 44 00
	00		 npad	 6
$LL22@update_one:

; 6009 :         do {
; 6010 :             ++p;

  00040	48 83 c3 38	 add	 rbx, 56			; 00000038H

; 6011 :         } while (p->offset == offset);

  00044	44 39 6b 08	 cmp	 DWORD PTR [rbx+8], r13d
  00048	74 f6		 je	 SHORT $LL22@update_one

; 6012 :         return p;

  0004a	e9 2b 01 00 00	 jmp	 $LN1@update_one
$LN29@update_one:
  0004f	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
$LL19@update_one:

; 6013 :     }
; 6014 :     do {
; 6015 :         descr = _PyType_Lookup(type, p->name_strobj);

  00054	48 8b 53 30	 mov	 rdx, QWORD PTR [rbx+48]
  00058	49 8b cc	 mov	 rcx, r12
  0005b	e8 00 00 00 00	 call	 _PyType_Lookup
  00060	48 8b f8	 mov	 rdi, rax

; 6016 :         if (descr == NULL) {

  00063	48 85 c0	 test	 rax, rax
  00066	75 1d		 jne	 SHORT $LN16@update_one

; 6017 :             if (ptr == (void**)&type->tp_iternext) {

  00068	49 8d 84 24 38
	01 00 00	 lea	 rax, QWORD PTR [r12+312]
  00070	48 3b e8	 cmp	 rbp, rax
  00073	0f 85 da 00 00
	00		 jne	 $LN18@update_one

; 6018 :                 specific = (void *)_PyObject_NextNotImplemented;

  00079	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:_PyObject_NextNotImplemented

; 6019 :             }
; 6020 :             continue;

  00080	e9 ce 00 00 00	 jmp	 $LN18@update_one
$LN16@update_one:

; 6021 :         }
; 6022 :         if (Py_TYPE(descr) == &PyWrapperDescr_Type &&
; 6023 :             ((PyWrapperDescrObject *)descr)->d_base->name_strobj == p->name_strobj) {

  00085	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00089	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyWrapperDescr_Type
  00090	48 3b c8	 cmp	 rcx, rax
  00093	75 63		 jne	 SHORT $LN14@update_one
  00095	48 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [rdi+128]
  0009c	48 8b 53 30	 mov	 rdx, QWORD PTR [rbx+48]
  000a0	48 39 50 30	 cmp	 QWORD PTR [rax+48], rdx
  000a4	75 52		 jne	 SHORT $LN14@update_one

; 6024 :             void **tptr = resolve_slotdups(type, p->name_strobj);

  000a6	49 8b cc	 mov	 rcx, r12
  000a9	e8 00 00 00 00	 call	 resolve_slotdups

; 6025 :             if (tptr == NULL || tptr == ptr)

  000ae	48 85 c0	 test	 rax, rax
  000b1	74 05		 je	 SHORT $LN12@update_one
  000b3	48 3b c5	 cmp	 rax, rbp
  000b6	75 04		 jne	 SHORT $LN13@update_one
$LN12@update_one:

; 6026 :                 generic = p->function;

  000b8	4c 8b 73 10	 mov	 r14, QWORD PTR [rbx+16]
$LN13@update_one:

; 6027 :             d = (PyWrapperDescrObject *)descr;
; 6028 :             if (d->d_base->wrapper == p->wrapper &&
; 6029 :                 PyType_IsSubtype(type, PyDescr_TYPE(d)))

  000bc	48 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [rdi+128]
  000c3	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  000c7	48 39 41 18	 cmp	 QWORD PTR [rcx+24], rax
  000cb	0f 85 82 00 00
	00		 jne	 $LN18@update_one
  000d1	48 8b 57 60	 mov	 rdx, QWORD PTR [rdi+96]
  000d5	49 8b cc	 mov	 rcx, r12
  000d8	e8 00 00 00 00	 call	 PyType_IsSubtype
  000dd	85 c0		 test	 eax, eax
  000df	74 72		 je	 SHORT $LN18@update_one

; 6030 :             {
; 6031 :                 if (specific == NULL ||
; 6032 :                     specific == d->d_wrapped)

  000e1	48 85 f6	 test	 rsi, rsi
  000e4	74 09		 je	 SHORT $LN9@update_one
  000e6	48 3b b7 88 00
	00 00		 cmp	 rsi, QWORD PTR [rdi+136]

; 6034 :                 else
; 6035 :                     use_generic = 1;

  000ed	75 5e		 jne	 SHORT $LN30@update_one
$LN9@update_one:

; 6033 :                     specific = d->d_wrapped;

  000ef	48 8b b7 88 00
	00 00		 mov	 rsi, QWORD PTR [rdi+136]

; 6036 :             }
; 6037 :         }
; 6038 :         else if (Py_TYPE(descr) == &PyCFunction_Type &&

  000f6	eb 5b		 jmp	 SHORT $LN18@update_one
$LN14@update_one:

; 6039 :                  PyCFunction_GET_FUNCTION(descr) ==
; 6040 :                  (PyCFunction)tp_new_wrapper &&
; 6041 :                  ptr == (void**)&type->tp_new)

  000f8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyCFunction_Type
  000ff	48 3b c8	 cmp	 rcx, rax
  00102	75 23		 jne	 SHORT $LN6@update_one
  00104	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  00108	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tp_new_wrapper
  0010f	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  00113	75 12		 jne	 SHORT $LN6@update_one
  00115	49 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR [r12+400]
  0011d	48 3b e8	 cmp	 rbp, rax
  00120	75 05		 jne	 SHORT $LN6@update_one

; 6042 :         {
; 6043 :             /* The __new__ wrapper is not a wrapper descriptor,
; 6044 :                so must be special-cased differently.
; 6045 :                If we don't do this, creating an instance will
; 6046 :                always use slot_tp_new which will look up
; 6047 :                __new__ in the MRO which will call tp_new_wrapper
; 6048 :                which will look through the base classes looking
; 6049 :                for a static base and call its tp_new (usually
; 6050 :                PyType_GenericNew), after performing various
; 6051 :                sanity checks and constructing a new argument
; 6052 :                list.  Cut all that nonsense short -- this speeds
; 6053 :                up instance creation tremendously. */
; 6054 :             specific = (void *)type->tp_new;

  00122	48 8b 30	 mov	 rsi, QWORD PTR [rax]

; 6055 :             /* XXX I'm not 100% sure that there isn't a hole
; 6056 :                in this reasoning that requires additional
; 6057 :                sanity checks.  I'll buy the first person to
; 6058 :                point out a bug in this reasoning a beer. */
; 6059 :         }
; 6060 :         else if (descr == Py_None &&

  00125	eb 2c		 jmp	 SHORT $LN18@update_one
$LN6@update_one:

; 6061 :                  ptr == (void**)&type->tp_hash) {

  00127	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0012e	48 3b f8	 cmp	 rdi, rax
  00131	75 16		 jne	 SHORT $LN4@update_one
  00133	49 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR [r12+208]
  0013b	48 3b e8	 cmp	 rbp, rax
  0013e	75 09		 jne	 SHORT $LN4@update_one

; 6062 :             /* We specifically allow __hash__ to be set to None
; 6063 :                to prevent inheritance of the default
; 6064 :                implementation from object.__hash__ */
; 6065 :             specific = (void *)PyObject_HashNotImplemented;

  00140	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PyObject_HashNotImplemented

; 6066 :         }
; 6067 :         else {

  00147	eb 0a		 jmp	 SHORT $LN18@update_one
$LN4@update_one:

; 6069 :             generic = p->function;

  00149	4c 8b 73 10	 mov	 r14, QWORD PTR [rbx+16]
$LN30@update_one:

; 6068 :             use_generic = 1;

  0014d	41 bf 01 00 00
	00		 mov	 r15d, 1
$LN18@update_one:

; 6070 :         }
; 6071 :     } while ((++p)->offset == offset);

  00153	48 83 c3 38	 add	 rbx, 56			; 00000038H
  00157	44 39 6b 08	 cmp	 DWORD PTR [rbx+8], r13d
  0015b	0f 84 f3 fe ff
	ff		 je	 $LL19@update_one

; 6072 :     if (specific && !use_generic)

  00161	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  00166	48 85 f6	 test	 rsi, rsi
  00169	74 0b		 je	 SHORT $LN2@update_one
  0016b	45 85 ff	 test	 r15d, r15d
  0016e	75 06		 jne	 SHORT $LN2@update_one

; 6073 :         *ptr = specific;

  00170	48 89 75 00	 mov	 QWORD PTR [rbp], rsi

; 6074 :     else

  00174	eb 04		 jmp	 SHORT $LN1@update_one
$LN2@update_one:

; 6075 :         *ptr = generic;

  00176	4c 89 75 00	 mov	 QWORD PTR [rbp], r14
$LN1@update_one:

; 6076 :     return p;
; 6077 : }

  0017a	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  0017f	48 8b c3	 mov	 rax, rbx
  00182	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00187	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0018b	41 5f		 pop	 r15
  0018d	41 5e		 pop	 r14
  0018f	41 5d		 pop	 r13
  00191	41 5c		 pop	 r12
  00193	5e		 pop	 rsi
  00194	c3		 ret	 0
update_one_slot ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$update_slots_callback DD imagerel update_slots_callback
	DD	imagerel update_slots_callback+69
	DD	imagerel $unwind$update_slots_callback
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$update_slots_callback DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT update_slots_callback
_TEXT	SEGMENT
type$ = 48
data$ = 56
update_slots_callback PROC				; COMDAT

; 6083 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 6084 :     slotdef **pp = (slotdef **)data;
; 6085 : 
; 6086 :     for (; *pp; pp++)

  0000a	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0000d	48 8b da	 mov	 rbx, rdx
  00010	48 8b f9	 mov	 rdi, rcx
  00013	48 85 c0	 test	 rax, rax
  00016	74 20		 je	 SHORT $LN8@update_slo
  00018	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL3@update_slo:

; 6087 :         update_one_slot(type, *pp);

  00020	48 8b d0	 mov	 rdx, rax
  00023	48 8b cf	 mov	 rcx, rdi
  00026	e8 00 00 00 00	 call	 update_one_slot
  0002b	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  0002f	48 83 c3 08	 add	 rbx, 8
  00033	48 85 c0	 test	 rax, rax
  00036	75 e8		 jne	 SHORT $LL3@update_slo
$LN8@update_slo:

; 6088 :     return 0;

  00038	33 c0		 xor	 eax, eax

; 6089 : }

  0003a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00043	5f		 pop	 rdi
  00044	c3		 ret	 0
update_slots_callback ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$update_slot DD imagerel update_slot
	DD	imagerel update_slot+200
	DD	imagerel $unwind$update_slot
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$update_slot DD 040a01H
	DD	010340aH
	DD	07006d20aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT update_slot
_TEXT	SEGMENT
ptrs$ = 32
type$ = 128
name$ = 136
update_slot PROC					; COMDAT

; 6114 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	48 8b f9	 mov	 rdi, rcx

; 6115 :     slotdef *ptrs[MAX_EQUIV];
; 6116 :     slotdef *p;
; 6117 :     slotdef **pp;
; 6118 :     int offset;
; 6119 : 
; 6120 :     /* Clear the VALID_VERSION flag of 'type' and all its
; 6121 :        subclasses.  This could possibly be unified with the
; 6122 :        update_subclasses() recursion below, but carefully:
; 6123 :        they each have their own conditions on which to stop
; 6124 :        recursing into subclasses. */
; 6125 :     PyType_Modified(type);

  00010	e8 00 00 00 00	 call	 PyType_Modified

; 6126 : 
; 6127 :     init_slotdefs();

  00015	e8 00 00 00 00	 call	 init_slotdefs

; 6128 :     pp = ptrs;
; 6129 :     for (p = slotdefs; p->name; p++) {

  0001a	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR slotdefs, 0
  00022	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:slotdefs
  00029	49 8b c0	 mov	 rax, r8
  0002c	4c 8d 5c 24 20	 lea	 r11, QWORD PTR ptrs$[rsp]
  00031	74 17		 je	 SHORT $LN8@update_slo@2
$LL10@update_slo@2:

; 6130 :         /* XXX assume name is interned! */
; 6131 :         if (p->name_strobj == name)

  00033	48 39 58 30	 cmp	 QWORD PTR [rax+48], rbx
  00037	75 07		 jne	 SHORT $LN9@update_slo@2

; 6132 :             *pp++ = p;

  00039	49 89 03	 mov	 QWORD PTR [r11], rax
  0003c	49 83 c3 08	 add	 r11, 8
$LN9@update_slo@2:

; 6128 :     pp = ptrs;
; 6129 :     for (p = slotdefs; p->name; p++) {

  00040	48 83 c0 38	 add	 rax, 56			; 00000038H
  00044	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00048	75 e9		 jne	 SHORT $LL10@update_slo@2
$LN8@update_slo@2:

; 6133 :     }
; 6134 :     *pp = NULL;

  0004a	49 c7 03 00 00
	00 00		 mov	 QWORD PTR [r11], 0

; 6135 :     for (pp = ptrs; *pp; pp++) {

  00051	48 83 7c 24 20
	00		 cmp	 QWORD PTR ptrs$[rsp], 0
  00057	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ptrs$[rsp]
  0005c	74 5a		 je	 SHORT $LN19@update_slo@2
  0005e	66 90		 npad	 2
$LL6@update_slo@2:

; 6136 :         p = *pp;

  00060	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 6137 :         offset = p->offset;

  00063	8b 50 08	 mov	 edx, DWORD PTR [rax+8]

; 6138 :         while (p > slotdefs && (p-1)->offset == offset)

  00066	49 3b c0	 cmp	 rax, r8
  00069	76 13		 jbe	 SHORT $LN20@update_slo@2
  0006b	0f 1f 44 00 00	 npad	 5
$LL3@update_slo@2:
  00070	39 50 d0	 cmp	 DWORD PTR [rax-48], edx
  00073	75 09		 jne	 SHORT $LN20@update_slo@2

; 6139 :             --p;

  00075	48 83 e8 38	 sub	 rax, 56			; 00000038H
  00079	49 3b c0	 cmp	 rax, r8
  0007c	77 f2		 ja	 SHORT $LL3@update_slo@2
$LN20@update_slo@2:

; 6140 :         *pp = p;

  0007e	48 89 01	 mov	 QWORD PTR [rcx], rax
  00081	48 83 c1 08	 add	 rcx, 8
  00085	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  00089	75 d5		 jne	 SHORT $LL6@update_slo@2

; 6141 :     }
; 6142 :     if (ptrs[0] == NULL)

  0008b	48 83 7c 24 20
	00		 cmp	 QWORD PTR ptrs$[rsp], 0
  00091	74 25		 je	 SHORT $LN19@update_slo@2

; 6144 :     return update_subclasses(type, name,
; 6145 :                              update_slots_callback, (void *)ptrs);

  00093	4c 8d 4c 24 20	 lea	 r9, QWORD PTR ptrs$[rsp]
  00098	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:update_slots_callback
  0009f	48 8b d3	 mov	 rdx, rbx
  000a2	48 8b cf	 mov	 rcx, rdi
  000a5	e8 00 00 00 00	 call	 update_subclasses

; 6146 : }

  000aa	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  000b2	48 83 c4 70	 add	 rsp, 112		; 00000070H
  000b6	5f		 pop	 rdi
  000b7	c3		 ret	 0
$LN19@update_slo@2:

; 6143 :         return 0; /* Not an attribute that affects any slots */

  000b8	33 c0		 xor	 eax, eax

; 6146 : }

  000ba	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  000c2	48 83 c4 70	 add	 rsp, 112		; 00000070H
  000c6	5f		 pop	 rdi
  000c7	c3		 ret	 0
update_slot ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fixup_slot_dispatchers DD imagerel fixup_slot_dispatchers
	DD	imagerel fixup_slot_dispatchers+55
	DD	imagerel $unwind$fixup_slot_dispatchers
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fixup_slot_dispatchers DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT fixup_slot_dispatchers
_TEXT	SEGMENT
type$ = 48
fixup_slot_dispatchers PROC				; COMDAT

; 6153 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 6154 :     slotdef *p;
; 6155 : 
; 6156 :     init_slotdefs();

  00009	e8 00 00 00 00	 call	 init_slotdefs

; 6157 :     for (p = slotdefs; p->name; )

  0000e	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR slotdefs, 0
  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:slotdefs
  0001d	74 12		 je	 SHORT $LN1@fixup_slot
  0001f	90		 npad	 1
$LL2@fixup_slot:

; 6158 :         p = update_one_slot(type, p);

  00020	48 8b d0	 mov	 rdx, rax
  00023	48 8b cb	 mov	 rcx, rbx
  00026	e8 00 00 00 00	 call	 update_one_slot
  0002b	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0002f	75 ef		 jne	 SHORT $LL2@fixup_slot
$LN1@fixup_slot:

; 6159 : }

  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5b		 pop	 rbx
  00036	c3		 ret	 0
fixup_slot_dispatchers ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$update_all_slots DD imagerel update_all_slots
	DD	imagerel update_all_slots+68
	DD	imagerel $unwind$update_all_slots
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$update_all_slots DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT update_all_slots
_TEXT	SEGMENT
type$ = 48
update_all_slots PROC					; COMDAT

; 6163 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 6164 :     slotdef *p;
; 6165 : 
; 6166 :     init_slotdefs();

  0000d	e8 00 00 00 00	 call	 init_slotdefs

; 6167 :     for (p = slotdefs; p->name; p++) {

  00012	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR slotdefs, 0
  0001a	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:slotdefs
  00021	74 16		 je	 SHORT $LN1@update_all
$LL3@update_all:

; 6168 :         /* update_slot returns int but can't actually fail */
; 6169 :         update_slot(type, p->name_strobj);

  00023	48 8b 53 30	 mov	 rdx, QWORD PTR [rbx+48]
  00027	48 8b cf	 mov	 rcx, rdi
  0002a	e8 00 00 00 00	 call	 update_slot
  0002f	48 83 c3 38	 add	 rbx, 56			; 00000038H
  00033	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  00037	75 ea		 jne	 SHORT $LL3@update_all
$LN1@update_all:

; 6170 :     }
; 6171 : }

  00039	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00042	5f		 pop	 rdi
  00043	c3		 ret	 0
update_all_slots ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mro_subclasses DD imagerel mro_subclasses
	DD	imagerel mro_subclasses+264
	DD	imagerel $unwind$mro_subclasses
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mro_subclasses DD 093901H
	DD	047439H
	DD	056434H
	DD	06542fH
	DD	0b342aH
	DD	06209H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT mro_subclasses
_TEXT	SEGMENT
n$1$ = 64
type$ = 64
temp$ = 72
subclasses$1$ = 80
mro_subclasses PROC					; COMDAT

; 443  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 444  :     PyTypeObject *subclass;
; 445  :     PyObject *ref, *subclasses, *old_mro;
; 446  :     Py_ssize_t i, n;
; 447  : 
; 448  :     subclasses = type->tp_subclasses;

  00009	48 8b 89 c0 01
	00 00		 mov	 rcx, QWORD PTR [rcx+448]
  00010	48 89 4c 24 50	 mov	 QWORD PTR subclasses$1$[rsp], rcx

; 449  :     if (subclasses == NULL)

  00015	48 85 c9	 test	 rcx, rcx
  00018	75 07		 jne	 SHORT $LN10@mro_subcla

; 450  :         return 0;

  0001a	33 c0		 xor	 eax, eax

; 480  : }

  0001c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00020	c3		 ret	 0
$LN10@mro_subcla:

; 451  :     assert(PyList_Check(subclasses));
; 452  :     n = PyList_GET_SIZE(subclasses);

  00021	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  00025	48 89 5c 24 58	 mov	 QWORD PTR [rsp+88], rbx
  0002a	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0002f	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi
  00034	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi

; 453  :     for (i = 0; i < n; i++) {

  00039	33 ff		 xor	 edi, edi
  0003b	48 89 44 24 40	 mov	 QWORD PTR n$1$[rsp], rax
  00040	48 85 c0	 test	 rax, rax
  00043	0f 8e a4 00 00
	00		 jle	 $LN21@mro_subcla
  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct
$LL9@mro_subcla:

; 454  :         ref = PyList_GET_ITEM(subclasses, i);

  00050	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00054	48 8b 0c f8	 mov	 rcx, QWORD PTR [rax+rdi*8]

; 455  :         assert(PyWeakref_CheckRef(ref));
; 456  :         subclass = (PyTypeObject *)PyWeakref_GET_OBJECT(ref);

  00058	48 8b 59 60	 mov	 rbx, QWORD PTR [rcx+96]
  0005c	48 83 7b 50 00	 cmp	 QWORD PTR [rbx+80], 0
  00061	7e 6a		 jle	 SHORT $LN8@mro_subcla

; 457  :         assert(subclass != NULL);
; 458  :         if ((PyObject *)subclass == Py_None)

  00063	48 3b da	 cmp	 rbx, rdx
  00066	74 65		 je	 SHORT $LN8@mro_subcla

; 459  :             continue;
; 460  :         assert(PyType_Check(subclass));
; 461  :         old_mro = subclass->tp_mro;

  00068	48 8b b3 b0 01
	00 00		 mov	 rsi, QWORD PTR [rbx+432]

; 462  :         if (mro_internal(subclass) < 0) {

  0006f	48 8b cb	 mov	 rcx, rbx
  00072	e8 00 00 00 00	 call	 mro_internal
  00077	85 c0		 test	 eax, eax
  00079	78 66		 js	 SHORT $LN16@mro_subcla

; 465  :         }
; 466  :         else {
; 467  :             PyObject* tuple;
; 468  :             tuple = PyTuple_Pack(2, subclass, old_mro);

  0007b	4c 8b c6	 mov	 r8, rsi
  0007e	48 8b d3	 mov	 rdx, rbx
  00081	b9 02 00 00 00	 mov	 ecx, 2
  00086	e8 00 00 00 00	 call	 PyTuple_Pack

; 469  :             Py_DECREF(old_mro);

  0008b	48 8b ce	 mov	 rcx, rsi
  0008e	48 8b e8	 mov	 rbp, rax
  00091	e8 00 00 00 00	 call	 _Py_DecRef

; 470  :             if (!tuple)

  00096	48 85 ed	 test	 rbp, rbp
  00099	74 4d		 je	 SHORT $LN17@mro_subcla

; 471  :                 return -1;
; 472  :             if (PyList_Append(temp, tuple) < 0)

  0009b	48 8b 74 24 48	 mov	 rsi, QWORD PTR temp$[rsp]
  000a0	48 8b d5	 mov	 rdx, rbp
  000a3	48 8b ce	 mov	 rcx, rsi
  000a6	e8 00 00 00 00	 call	 PyList_Append
  000ab	85 c0		 test	 eax, eax
  000ad	78 39		 js	 SHORT $LN17@mro_subcla

; 473  :                 return -1;
; 474  :             Py_DECREF(tuple);

  000af	48 8b cd	 mov	 rcx, rbp
  000b2	e8 00 00 00 00	 call	 _Py_DecRef

; 475  :         }
; 476  :         if (mro_subclasses(subclass, temp) < 0)

  000b7	48 8b d6	 mov	 rdx, rsi
  000ba	48 8b cb	 mov	 rcx, rbx
  000bd	e8 00 00 00 00	 call	 mro_subclasses
  000c2	85 c0		 test	 eax, eax
  000c4	78 22		 js	 SHORT $LN17@mro_subcla
  000c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct
$LN8@mro_subcla:

; 453  :     for (i = 0; i < n; i++) {

  000cd	48 ff c7	 inc	 rdi
  000d0	48 3b 7c 24 40	 cmp	 rdi, QWORD PTR n$1$[rsp]
  000d5	7d 16		 jge	 SHORT $LN21@mro_subcla
  000d7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR subclasses$1$[rsp]
  000dc	e9 6f ff ff ff	 jmp	 $LL9@mro_subcla
$LN16@mro_subcla:

; 463  :             subclass->tp_mro = old_mro;

  000e1	48 89 b3 b0 01
	00 00		 mov	 QWORD PTR [rbx+432], rsi
$LN17@mro_subcla:

; 464  :             return -1;

  000e8	83 c8 ff	 or	 eax, -1
  000eb	eb 02		 jmp	 SHORT $LN25@mro_subcla
$LN21@mro_subcla:

; 477  :             return -1;
; 478  :     }
; 479  :     return 0;

  000ed	33 c0		 xor	 eax, eax
$LN25@mro_subcla:
  000ef	48 8b 74 24 28	 mov	 rsi, QWORD PTR [rsp+40]
  000f4	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  000f9	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  000fe	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 480  : }

  00103	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00107	c3		 ret	 0
mro_subclasses ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@NNKNACHA@bases?5must?5be?5types?$AA@	; `string'
PUBLIC	??_C@_0CO@LJBIILHK@multiple?5bases?5have?5instance?5lay@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$best_base DD imagerel best_base
	DD	imagerel best_base+241
	DD	imagerel $unwind$best_base
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$best_base DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0d0143218H
	DD	07010c012H
xdata	ENDS
;	COMDAT ??_C@_0BE@NNKNACHA@bases?5must?5be?5types?$AA@
CONST	SEGMENT
??_C@_0BE@NNKNACHA@bases?5must?5be?5types?$AA@ DB 'bases must be types', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@LJBIILHK@multiple?5bases?5have?5instance?5lay@
CONST	SEGMENT
??_C@_0CO@LJBIILHK@multiple?5bases?5have?5instance?5lay@ DB 'multiple bas'
	DB	'es have instance lay-out conflict', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT best_base
_TEXT	SEGMENT
bases$ = 64
best_base PROC						; COMDAT

; 1657 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1658 :     Py_ssize_t i, n;
; 1659 :     PyTypeObject *base, *winner, *candidate, *base_i;
; 1660 :     PyObject *base_proto;
; 1661 : 
; 1662 :     assert(PyTuple_Check(bases));
; 1663 :     n = PyTuple_GET_SIZE(bases);

  00018	4c 8b 69 60	 mov	 r13, QWORD PTR [rcx+96]

; 1664 :     assert(n > 0);
; 1665 :     base = NULL;

  0001c	45 33 e4	 xor	 r12d, r12d

; 1666 :     winner = NULL;

  0001f	41 8b fc	 mov	 edi, r12d

; 1667 :     for (i = 0; i < n; i++) {

  00022	41 8b f4	 mov	 esi, r12d
  00025	4d 85 ed	 test	 r13, r13
  00028	7e 7d		 jle	 SHORT $LN10@best_base

; 1658 :     Py_ssize_t i, n;
; 1659 :     PyTypeObject *base, *winner, *candidate, *base_i;
; 1660 :     PyObject *base_proto;
; 1661 : 
; 1662 :     assert(PyTuple_Check(bases));
; 1663 :     n = PyTuple_GET_SIZE(bases);

  0002a	48 8d 69 70	 lea	 rbp, QWORD PTR [rcx+112]
  0002e	66 90		 npad	 2
$LL12@best_base:

; 1668 :         base_proto = PyTuple_GET_ITEM(bases, i);

  00030	48 8b 5d 00	 mov	 rbx, QWORD PTR [rbp]

; 1669 :         if (!PyType_Check(base_proto)) {

  00034	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00038	f7 80 00 01 00
	00 00 00 00 80	 test	 DWORD PTR [rax+256], -2147483648 ; ffffffff80000000H
  00042	0f 84 92 00 00
	00		 je	 $LN16@best_base

; 1674 :         }
; 1675 :         base_i = (PyTypeObject *)base_proto;
; 1676 :         if (base_i->tp_dict == NULL) {

  00048	48 83 bb 60 01
	00 00 00	 cmp	 QWORD PTR [rbx+352], 0
  00050	75 10		 jne	 SHORT $LN7@best_base

; 1677 :             if (PyType_Ready(base_i) < 0)

  00052	48 8b cb	 mov	 rcx, rbx
  00055	e8 00 00 00 00	 call	 PyType_Ready
  0005a	85 c0		 test	 eax, eax
  0005c	0f 88 8b 00 00
	00		 js	 $LN17@best_base
$LN7@best_base:

; 1678 :                 return NULL;
; 1679 :         }
; 1680 :         candidate = solid_base(base_i);

  00062	48 8b cb	 mov	 rcx, rbx
  00065	e8 00 00 00 00	 call	 solid_base
  0006a	4c 8b d0	 mov	 r10, rax

; 1681 :         if (winner == NULL) {

  0006d	48 85 ff	 test	 rdi, rdi
  00070	75 05		 jne	 SHORT $LN6@best_base

; 1682 :             winner = candidate;

  00072	48 8b f8	 mov	 rdi, rax

; 1683 :             base = base_i;

  00075	eb 21		 jmp	 SHORT $LN20@best_base
$LN6@best_base:

; 1684 :         }
; 1685 :         else if (PyType_IsSubtype(winner, candidate))

  00077	48 8b d0	 mov	 rdx, rax
  0007a	48 8b cf	 mov	 rcx, rdi
  0007d	e8 00 00 00 00	 call	 PyType_IsSubtype
  00082	85 c0		 test	 eax, eax
  00084	75 15		 jne	 SHORT $LN11@best_base

; 1686 :             ;
; 1687 :         else if (PyType_IsSubtype(candidate, winner)) {

  00086	48 8b d7	 mov	 rdx, rdi
  00089	49 8b ca	 mov	 rcx, r10
  0008c	e8 00 00 00 00	 call	 PyType_IsSubtype
  00091	85 c0		 test	 eax, eax
  00093	74 2e		 je	 SHORT $LN2@best_base

; 1688 :             winner = candidate;

  00095	49 8b fa	 mov	 rdi, r10
$LN20@best_base:

; 1689 :             base = base_i;

  00098	4c 8b e3	 mov	 r12, rbx
$LN11@best_base:

; 1667 :     for (i = 0; i < n; i++) {

  0009b	48 ff c6	 inc	 rsi
  0009e	48 83 c5 08	 add	 rbp, 8
  000a2	49 3b f5	 cmp	 rsi, r13
  000a5	7c 89		 jl	 SHORT $LL12@best_base
$LN10@best_base:

; 1697 :         }
; 1698 :     }
; 1699 :     assert (base != NULL);
; 1700 : 
; 1701 :     return base;

  000a7	49 8b c4	 mov	 rax, r12
$LN13@best_base:

; 1702 : }

  000aa	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000af	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000b4	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000b9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bd	41 5d		 pop	 r13
  000bf	41 5c		 pop	 r12
  000c1	5f		 pop	 rdi
  000c2	c3		 ret	 0
$LN2@best_base:

; 1690 :         }
; 1691 :         else {
; 1692 :             PyErr_SetString(
; 1693 :                 PyExc_TypeError,
; 1694 :                 "multiple bases have "
; 1695 :                 "instance lay-out conflict");

  000c3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@LJBIILHK@multiple?5bases?5have?5instance?5lay@
  000d1	e8 00 00 00 00	 call	 PyErr_SetString

; 1696 :             return NULL;

  000d6	33 c0		 xor	 eax, eax
  000d8	eb d0		 jmp	 SHORT $LN13@best_base
$LN16@best_base:

; 1670 :             PyErr_SetString(
; 1671 :                 PyExc_TypeError,
; 1672 :                 "bases must be types");

  000da	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@NNKNACHA@bases?5must?5be?5types?$AA@
  000e8	e8 00 00 00 00	 call	 PyErr_SetString
$LN17@best_base:

; 1673 :             return NULL;

  000ed	33 c0		 xor	 eax, eax
  000ef	eb b9		 jmp	 SHORT $LN13@best_base
best_base ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@INBJKNKC@type?5__qualname__?5must?5be?5a?5str?0@ ; `string'
PUBLIC	??_C@_0CO@KNOILAEF@?$CFR?5in?5__slots__?5conflicts?5with?5c@ ; `string'
PUBLIC	??_C@_08PMCPIDCB@type_new?$AA@			; `string'
PUBLIC	??_C@_0EN@DKLGOPEO@__weakref__?5slot?5disallowed?3?5eit@ ; `string'
PUBLIC	??_C@_0CN@HEEOHDAA@__dict__?5slot?5disallowed?3?5we?5alr@ ; `string'
PUBLIC	??_C@_0DF@HBKAGDPD@nonempty?5__slots__?5not?5supported@ ; `string'
PUBLIC	??_C@_0CN@NKNOGCEG@type?5?8?$CF?4100s?8?5is?5not?5an?5acceptab@ ; `string'
PUBLIC	??_C@_0L@NCCGNLB@UO?$CBO?$CB?3type?$AA@		; `string'
PUBLIC	??_C@_0BO@MDBCPHPL@type?$CI?$CJ?5takes?51?5or?53?5arguments?$AA@ ; `string'
EXTRN	_PyDict_NewKeysForClass:PROC
EXTRN	PyFunction_Type:BYTE
EXTRN	PyDict_DelItem:PROC
EXTRN	PyEval_GetGlobals:PROC
EXTRN	PyList_AsTuple:PROC
EXTRN	PyList_Sort:PROC
EXTRN	_Py_Mangle:PROC
EXTRN	PyArg_ParseTupleAndKeywords:PROC
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$type_new DD imagerel type_new
	DD	imagerel type_new+336
	DD	imagerel $unwind$type_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$type_new DD imagerel type_new+336
	DD	imagerel type_new+853
	DD	imagerel $chain$1$type_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$type_new DD imagerel type_new+853
	DD	imagerel type_new+2860
	DD	imagerel $chain$3$type_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$type_new DD 040021H
	DD	017f400H
	DD	018e400H
	DD	imagerel type_new
	DD	imagerel type_new+336
	DD	imagerel $unwind$type_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$type_new DD 041921H
	DD	017f419H
	DD	018e408H
	DD	imagerel type_new
	DD	imagerel type_new+336
	DD	imagerel $unwind$type_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_new DD 081401H
	DD	0190114H
	DD	0c00bd00dH
	DD	060087009H
	DD	030065007H
xdata	ENDS
;	COMDAT ??_C@_0CI@INBJKNKC@type?5__qualname__?5must?5be?5a?5str?0@
CONST	SEGMENT
??_C@_0CI@INBJKNKC@type?5__qualname__?5must?5be?5a?5str?0@ DB 'type __qua'
	DB	'lname__ must be a str, not %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@KNOILAEF@?$CFR?5in?5__slots__?5conflicts?5with?5c@
CONST	SEGMENT
??_C@_0CO@KNOILAEF@?$CFR?5in?5__slots__?5conflicts?5with?5c@ DB '%R in __'
	DB	'slots__ conflicts with class variable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08PMCPIDCB@type_new?$AA@
CONST	SEGMENT
??_C@_08PMCPIDCB@type_new?$AA@ DB 'type_new', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@DKLGOPEO@__weakref__?5slot?5disallowed?3?5eit@
CONST	SEGMENT
??_C@_0EN@DKLGOPEO@__weakref__?5slot?5disallowed?3?5eit@ DB '__weakref__ '
	DB	'slot disallowed: either we already got one, or __itemsize__ !'
	DB	'= 0', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@HEEOHDAA@__dict__?5slot?5disallowed?3?5we?5alr@
CONST	SEGMENT
??_C@_0CN@HEEOHDAA@__dict__?5slot?5disallowed?3?5we?5alr@ DB '__dict__ sl'
	DB	'ot disallowed: we already got one', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@HBKAGDPD@nonempty?5__slots__?5not?5supported@
CONST	SEGMENT
??_C@_0DF@HBKAGDPD@nonempty?5__slots__?5not?5supported@ DB 'nonempty __sl'
	DB	'ots__ not supported for subtype of ''%s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@NKNOGCEG@type?5?8?$CF?4100s?8?5is?5not?5an?5acceptab@
CONST	SEGMENT
??_C@_0CN@NKNOGCEG@type?5?8?$CF?4100s?8?5is?5not?5an?5acceptab@ DB 'type '
	DB	'''%.100s'' is not an acceptable base type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NCCGNLB@UO?$CBO?$CB?3type?$AA@
CONST	SEGMENT
??_C@_0L@NCCGNLB@UO?$CBO?$CB?3type?$AA@ DB 'UO!O!:type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MDBCPHPL@type?$CI?$CJ?5takes?51?5or?53?5arguments?$AA@
CONST	SEGMENT
??_C@_0BO@MDBCPHPL@type?$CI?$CJ?5takes?51?5or?53?5arguments?$AA@ DB 'type'
	DB	'() takes 1 or 3 arguments', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT type_new
_TEXT	SEGMENT
slots$1$ = 80
bases$ = 88
base$1$ = 96
name$ = 104
dict$1$ = 112
tv1320 = 120
nbases$1$ = 128
$T32101 = 136
orig_dict$ = 144
nslots$2$ = 152
$T32102 = 160
metatype$ = 256
j$1$ = 264
nslots$1$ = 264
args$ = 264
may_add_weak$1$ = 272
kwds$ = 272
may_add_dict$1$ = 280
type_new PROC						; COMDAT

; 1989 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 55		 push	 r13
  0000d	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 1990 :     PyObject *name, *bases = NULL, *orig_dict, *dict = NULL;
; 1991 :     static char *kwlist[] = {"name", "bases", "dict", 0};
; 1992 :     PyObject *qualname, *slots = NULL, *tmp, *newslots;
; 1993 :     PyTypeObject *type = NULL, *base, *tmptype, *winner;
; 1994 :     PyHeapTypeObject *et;
; 1995 :     PyMemberDef *mp;
; 1996 :     Py_ssize_t i, nbases, nslots, slotoffset, add_dict, add_weak;
; 1997 :     int j, may_add_dict, may_add_weak;
; 1998 :     _Py_IDENTIFIER(__qualname__);
; 1999 :     _Py_IDENTIFIER(__slots__);
; 2000 : 
; 2001 :     assert(args != NULL && PyTuple_Check(args));
; 2002 :     assert(kwds == NULL || PyDict_Check(kwds));
; 2003 : 
; 2004 :     /* Special case: type(x) should return x->ob_type */
; 2005 :     {
; 2006 :         const Py_ssize_t nargs = PyTuple_GET_SIZE(args);

  00014	48 8b 6a 60	 mov	 rbp, QWORD PTR [rdx+96]
  00018	45 33 e4	 xor	 r12d, r12d
  0001b	33 db		 xor	 ebx, ebx
  0001d	49 8b f0	 mov	 rsi, r8
  00020	48 8b fa	 mov	 rdi, rdx
  00023	4c 8b e9	 mov	 r13, rcx
  00026	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR bases$[rsp], 0

; 2007 :         const Py_ssize_t nkwds = kwds == NULL ? 0 : PyDict_Size(kwds);

  0002f	4d 85 c0	 test	 r8, r8
  00032	75 04		 jne	 SHORT $LN116@type_new
  00034	33 c0		 xor	 eax, eax
  00036	eb 08		 jmp	 SHORT $LN117@type_new
$LN116@type_new:
  00038	49 8b c8	 mov	 rcx, r8
  0003b	e8 00 00 00 00	 call	 PyDict_Size
$LN117@type_new:

; 2008 : 
; 2009 :         if (PyType_CheckExact(metatype) && nargs == 1 && nkwds == 0) {

  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyType_Type
  00047	49 39 4d 58	 cmp	 QWORD PTR [r13+88], rcx
  0004b	75 2c		 jne	 SHORT $LN113@type_new
  0004d	48 83 fd 01	 cmp	 rbp, 1
  00051	75 26		 jne	 SHORT $LN113@type_new
  00053	48 85 c0	 test	 rax, rax
  00056	75 21		 jne	 SHORT $LN113@type_new

; 2010 :             PyObject *x = PyTuple_GET_ITEM(args, 0);

  00058	48 8b 7f 70	 mov	 rdi, QWORD PTR [rdi+112]

; 2011 :             Py_INCREF(Py_TYPE(x));

  0005c	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00060	e8 00 00 00 00	 call	 _Py_IncRef

; 2012 :             return (PyObject *) Py_TYPE(x);

  00065	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]

; 2392 : }

  00069	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00070	41 5d		 pop	 r13
  00072	41 5c		 pop	 r12
  00074	5f		 pop	 rdi
  00075	5e		 pop	 rsi
  00076	5d		 pop	 rbp
  00077	5b		 pop	 rbx
  00078	c3		 ret	 0
$LN113@type_new:

; 2013 :         }
; 2014 : 
; 2015 :         /* SF bug 475327 -- if that didn't trigger, we need 3
; 2016 :            arguments. but PyArg_ParseTupleAndKeywords below may give
; 2017 :            a msg saying type() needs exactly 3. */
; 2018 :         if (nargs + nkwds != 3) {

  00079	48 03 c5	 add	 rax, rbp
  0007c	48 83 f8 03	 cmp	 rax, 3
  00080	74 25		 je	 SHORT $LN112@type_new

; 2019 :             PyErr_SetString(PyExc_TypeError,
; 2020 :                             "type() takes 1 or 3 arguments");

  00082	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00089	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@MDBCPHPL@type?$CI?$CJ?5takes?51?5or?53?5arguments?$AA@
  00090	e8 00 00 00 00	 call	 PyErr_SetString
$LN152@type_new:

; 2021 :             return NULL;

  00095	33 c0		 xor	 eax, eax

; 2392 : }

  00097	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0009e	41 5d		 pop	 r13
  000a0	41 5c		 pop	 r12
  000a2	5f		 pop	 rdi
  000a3	5e		 pop	 rsi
  000a4	5d		 pop	 rbp
  000a5	5b		 pop	 rbx
  000a6	c3		 ret	 0
$LN112@type_new:

; 2022 :         }
; 2023 :     }
; 2024 : 
; 2025 :     /* Check arguments: (name, bases, dict) */
; 2026 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "UO!O!:type", kwlist,
; 2027 :                                      &name,
; 2028 :                                      &PyTuple_Type, &bases,
; 2029 :                                      &PyDict_Type, &orig_dict))

  000a7	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR orig_dict$[rsp]
  000af	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??type_new@@9@9
  000b6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@NCCGNLB@UO?$CBO?$CB?3type?$AA@
  000bd	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  000c2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  000c9	48 8b d6	 mov	 rdx, rsi
  000cc	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  000d1	48 8d 44 24 58	 lea	 rax, QWORD PTR bases$[rsp]
  000d6	48 8b cf	 mov	 rcx, rdi
  000d9	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000de	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyTuple_Type
  000e5	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000ea	48 8d 44 24 68	 lea	 rax, QWORD PTR name$[rsp]
  000ef	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f4	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  000f9	85 c0		 test	 eax, eax

; 2030 :         return NULL;

  000fb	74 98		 je	 SHORT $LN152@type_new

; 2031 : 
; 2032 :     /* Determine the proper metatype to deal with this: */
; 2033 :     winner = _PyType_CalculateMetaclass(metatype, bases);

  000fd	48 8b 54 24 58	 mov	 rdx, QWORD PTR bases$[rsp]
  00102	49 8b cd	 mov	 rcx, r13
  00105	e8 00 00 00 00	 call	 _PyType_CalculateMetaclass

; 2034 :     if (winner == NULL) {

  0010a	48 85 c0	 test	 rax, rax

; 2035 :         return NULL;

  0010d	74 86		 je	 SHORT $LN152@type_new

; 2036 :     }
; 2037 : 
; 2038 :     if (winner != metatype) {

  0010f	49 3b c5	 cmp	 rax, r13
  00112	74 37		 je	 SHORT $LN109@type_new

; 2039 :         if (winner->tp_new != type_new) /* Pass it to the winner */

  00114	4c 8b 88 90 01
	00 00		 mov	 r9, QWORD PTR [rax+400]
  0011b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:type_new
  00122	4c 3b c9	 cmp	 r9, rcx
  00125	74 1c		 je	 SHORT $LN108@type_new

; 2040 :             return winner->tp_new(winner, args, kwds);

  00127	4c 8b c6	 mov	 r8, rsi
  0012a	48 8b d7	 mov	 rdx, rdi
  0012d	48 8b c8	 mov	 rcx, rax
  00130	41 ff d1	 call	 r9

; 2392 : }

  00133	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0013a	41 5d		 pop	 r13
  0013c	41 5c		 pop	 r12
  0013e	5f		 pop	 rdi
  0013f	5e		 pop	 rsi
  00140	5d		 pop	 rbp
  00141	5b		 pop	 rbx
  00142	c3		 ret	 0
$LN108@type_new:

; 2041 :         metatype = winner;

  00143	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR metatype$[rsp], rax
$LN109@type_new:

; 2042 :     }
; 2043 : 
; 2044 :     /* Adjust for empty tuple bases */
; 2045 :     nbases = PyTuple_GET_SIZE(bases);

  0014b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR bases$[rsp]
  00150	4c 89 b4 24 c0
	00 00 00	 mov	 QWORD PTR [rsp+192], r14

; 2046 :     if (nbases == 0) {

  00158	bf 01 00 00 00	 mov	 edi, 1
  0015d	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00161	4c 89 bc 24 b8
	00 00 00	 mov	 QWORD PTR [rsp+184], r15
  00169	48 89 94 24 80
	00 00 00	 mov	 QWORD PTR nbases$1$[rsp], rdx
  00171	48 85 d2	 test	 rdx, rdx
  00174	75 26		 jne	 SHORT $LN107@type_new

; 2047 :         bases = PyTuple_Pack(1, &PyBaseObject_Type);

  00176	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyBaseObject_Type
  0017d	8b cf		 mov	 ecx, edi
  0017f	e8 00 00 00 00	 call	 PyTuple_Pack
  00184	48 89 44 24 58	 mov	 QWORD PTR bases$[rsp], rax

; 2048 :         if (bases == NULL)

  00189	48 85 c0	 test	 rax, rax
  0018c	0f 84 a1 01 00
	00		 je	 $LN3@type_new

; 2049 :             goto error;
; 2050 :         nbases = 1;

  00192	48 89 bc 24 80
	00 00 00	 mov	 QWORD PTR nbases$1$[rsp], rdi

; 2051 :     }
; 2052 :     else

  0019a	eb 0a		 jmp	 SHORT $LN105@type_new
$LN107@type_new:

; 2053 :         Py_INCREF(bases);

  0019c	e8 00 00 00 00	 call	 _Py_IncRef
  001a1	48 8b 44 24 58	 mov	 rax, QWORD PTR bases$[rsp]
$LN105@type_new:

; 2054 : 
; 2055 :     /* Calculate best base, and check that all bases are type objects */
; 2056 :     base = best_base(bases);

  001a6	48 8b c8	 mov	 rcx, rax
  001a9	e8 00 00 00 00	 call	 best_base
  001ae	48 8b e8	 mov	 rbp, rax
  001b1	48 89 44 24 60	 mov	 QWORD PTR base$1$[rsp], rax

; 2057 :     if (base == NULL) {

  001b6	48 85 c0	 test	 rax, rax
  001b9	0f 84 4b 01 00
	00		 je	 $LN15@type_new

; 2058 :         goto error;
; 2059 :     }
; 2060 :     if (!PyType_HasFeature(base, Py_TPFLAGS_BASETYPE)) {

  001bf	f7 80 00 01 00
	00 00 04 00 00	 test	 DWORD PTR [rax+256], 1024 ; 00000400H
  001c9	75 1c		 jne	 SHORT $LN103@type_new

; 2061 :         PyErr_Format(PyExc_TypeError,
; 2062 :                      "type '%.100s' is not an acceptable base type",
; 2063 :                      base->tp_name);

  001cb	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  001cf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  001d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@NKNOGCEG@type?5?8?$CF?4100s?8?5is?5not?5an?5acceptab@
  001dd	e8 00 00 00 00	 call	 PyErr_Format

; 2064 :         goto error;

  001e2	e9 23 01 00 00	 jmp	 $LN15@type_new
$LN103@type_new:

; 2065 :     }
; 2066 : 
; 2067 :     dict = PyDict_Copy(orig_dict);

  001e7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR orig_dict$[rsp]
  001ef	e8 00 00 00 00	 call	 PyDict_Copy
  001f4	48 8b f8	 mov	 rdi, rax
  001f7	48 89 44 24 70	 mov	 QWORD PTR dict$1$[rsp], rax

; 2068 :     if (dict == NULL)

  001fc	48 85 c0	 test	 rax, rax
  001ff	0f 84 05 01 00
	00		 je	 $LN15@type_new

; 2069 :         goto error;
; 2070 : 
; 2071 :     /* Check for a __slots__ sequence variable in dict, and count it */
; 2072 :     slots = _PyDict_GetItemId(dict, &PyId___slots__);

  00205	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0020b	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00214	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___slots__@?1??type_new@@9@9
  00219	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  0021d	48 8b cf	 mov	 rcx, rdi
  00220	48 03 d0	 add	 rdx, rax
  00223	48 89 44 24 78	 mov	 QWORD PTR tv1320[rsp], rax
  00228	e8 00 00 00 00	 call	 _PyDict_GetItemId

; 2073 :     nslots = 0;

  0022d	45 33 ff	 xor	 r15d, r15d

; 2074 :     add_dict = 0;

  00230	45 33 ed	 xor	 r13d, r13d

; 2075 :     add_weak = 0;

  00233	45 33 f6	 xor	 r14d, r14d

; 2076 :     may_add_dict = base->tp_dictoffset == 0;

  00236	48 39 9d 78 01
	00 00		 cmp	 QWORD PTR [rbp+376], rbx
  0023d	48 8b f0	 mov	 rsi, rax
  00240	41 0f 94 c4	 sete	 r12b
  00244	48 89 44 24 50	 mov	 QWORD PTR slots$1$[rsp], rax
  00249	44 89 a4 24 18
	01 00 00	 mov	 DWORD PTR may_add_dict$1$[rsp], r12d

; 2077 :     may_add_weak = base->tp_weaklistoffset == 0 && base->tp_itemsize == 0;

  00251	48 39 9d 28 01
	00 00		 cmp	 QWORD PTR [rbp+296], rbx
  00258	75 19		 jne	 SHORT $LN118@type_new
  0025a	48 39 9d 80 00
	00 00		 cmp	 QWORD PTR [rbp+128], rbx
  00261	75 10		 jne	 SHORT $LN118@type_new
  00263	b9 01 00 00 00	 mov	 ecx, 1
  00268	8b f9		 mov	 edi, ecx
  0026a	89 8c 24 10 01
	00 00		 mov	 DWORD PTR may_add_weak$1$[rsp], ecx
  00271	eb 0c		 jmp	 SHORT $LN119@type_new
$LN118@type_new:
  00273	33 ff		 xor	 edi, edi
  00275	89 bc 24 10 01
	00 00		 mov	 DWORD PTR may_add_weak$1$[rsp], edi
  0027c	8d 4f 01	 lea	 ecx, QWORD PTR [rdi+1]
$LN119@type_new:

; 2078 :     if (slots == NULL) {

  0027f	48 85 c0	 test	 rax, rax
  00282	75 17		 jne	 SHORT $LN101@type_new

; 2079 :         if (may_add_dict) {

  00284	45 85 e4	 test	 r12d, r12d
  00287	4c 0f 45 e9	 cmovne	 r13, rcx

; 2080 :             add_dict++;
; 2081 :         }
; 2082 :         if (may_add_weak) {

  0028b	85 ff		 test	 edi, edi
  0028d	0f 84 da 03 00
	00		 je	 $LN58@type_new

; 2083 :             add_weak++;

  00293	4c 8b f1	 mov	 r14, rcx

; 2084 :         }
; 2085 :     }
; 2086 :     else {

  00296	e9 d2 03 00 00	 jmp	 $LN58@type_new
$LN101@type_new:

; 2087 :         /* Have slots */
; 2088 : 
; 2089 :         /* Make it into a tuple */
; 2090 :         if (PyUnicode_Check(slots))

  0029b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0029f	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  002a9	74 0a		 je	 SHORT $LN97@type_new

; 2091 :             slots = PyTuple_Pack(1, slots);

  002ab	48 8b d6	 mov	 rdx, rsi
  002ae	e8 00 00 00 00	 call	 PyTuple_Pack

; 2092 :         else

  002b3	eb 08		 jmp	 SHORT $LN147@type_new
$LN97@type_new:

; 2093 :             slots = PySequence_Tuple(slots);

  002b5	48 8b ce	 mov	 rcx, rsi
  002b8	e8 00 00 00 00	 call	 PySequence_Tuple
$LN147@type_new:
  002bd	48 8b f0	 mov	 rsi, rax
  002c0	48 89 44 24 50	 mov	 QWORD PTR slots$1$[rsp], rax

; 2094 :         if (slots == NULL)

  002c5	48 85 c0	 test	 rax, rax
  002c8	74 31		 je	 SHORT $error$21872

; 2095 :             goto error;
; 2096 :         assert(PyTuple_Check(slots));
; 2097 : 
; 2098 :         /* Are slots allowed? */
; 2099 :         nslots = PyTuple_GET_SIZE(slots);

  002ca	4c 8b 78 60	 mov	 r15, QWORD PTR [rax+96]
  002ce	4c 89 bc 24 98
	00 00 00	 mov	 QWORD PTR nslots$2$[rsp], r15

; 2100 :         if (nslots > 0 && base->tp_itemsize != 0) {

  002d6	4d 85 ff	 test	 r15, r15
  002d9	7e 7a		 jle	 SHORT $LN94@type_new
  002db	48 39 9d 80 00
	00 00		 cmp	 QWORD PTR [rbp+128], rbx
  002e2	74 71		 je	 SHORT $LN94@type_new

; 2101 :             PyErr_Format(PyExc_TypeError,
; 2102 :                          "nonempty __slots__ "
; 2103 :                          "not supported for subtype of '%s'",
; 2104 :                          base->tp_name);

  002e4	4c 8b 45 70	 mov	 r8, QWORD PTR [rbp+112]
  002e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@HBKAGDPD@nonempty?5__slots__?5not?5supported@
$LN151@type_new:

; 2258 :             PyErr_Format(PyExc_TypeError,
; 2259 :                          "type __qualname__ must be a str, not %s",
; 2260 :                          Py_TYPE(qualname)->tp_name);

  002ef	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  002f6	e8 00 00 00 00	 call	 PyErr_Format
$error$21872:

; 2385 : 
; 2386 : error:
; 2387 :     Py_XDECREF(dict);

  002fb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dict$1$[rsp]
  00300	e8 00 00 00 00	 call	 _Py_DecRef
  00305	4c 8b 64 24 50	 mov	 r12, QWORD PTR slots$1$[rsp]
$LN15@type_new:

; 2388 :     Py_XDECREF(bases);

  0030a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR bases$[rsp]
  0030f	48 85 c9	 test	 rcx, rcx
  00312	74 05		 je	 SHORT $LN11@type_new
  00314	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@type_new:

; 2389 :     Py_XDECREF(slots);

  00319	4d 85 e4	 test	 r12, r12
  0031c	74 08		 je	 SHORT $LN7@type_new
  0031e	49 8b cc	 mov	 rcx, r12
  00321	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@type_new:

; 2390 :     Py_XDECREF(type);

  00326	48 85 db	 test	 rbx, rbx
  00329	74 08		 je	 SHORT $LN3@type_new
  0032b	48 8b cb	 mov	 rcx, rbx
  0032e	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@type_new:

; 2391 :     return NULL;

  00333	33 c0		 xor	 eax, eax
$LN146@type_new:
  00335	4c 8b b4 24 c0
	00 00 00	 mov	 r14, QWORD PTR [rsp+192]
  0033d	4c 8b bc 24 b8
	00 00 00	 mov	 r15, QWORD PTR [rsp+184]

; 2392 : }

  00345	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0034c	41 5d		 pop	 r13
  0034e	41 5c		 pop	 r12
  00350	5f		 pop	 rdi
  00351	5e		 pop	 rsi
  00352	5d		 pop	 rbp
  00353	5b		 pop	 rbx
  00354	c3		 ret	 0
$LN94@type_new:

; 2115 :                 if (!may_add_dict || add_dict) {

  00355	49 63 c4	 movsxd	 rax, r12d

; 2124 :                 if (!may_add_weak || add_weak) {

  00358	4c 63 e7	 movsxd	 r12, edi
  0035b	33 f6		 xor	 esi, esi
  0035d	4c 89 a4 24 a0
	00 00 00	 mov	 QWORD PTR $T32102[rsp], r12
  00365	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR $T32101[rsp], rax
  0036d	4d 85 ff	 test	 r15, r15
  00370	0f 8e 81 00 00
	00		 jle	 $LN136@type_new

; 2105 :             goto error;
; 2106 :         }
; 2107 : 
; 2108 :         /* Check for valid slot names and two special cases */
; 2109 :         for (i = 0; i < nslots; i++) {

  00376	48 8b 6c 24 50	 mov	 rbp, QWORD PTR slots$1$[rsp]
  0037b	48 83 c5 70	 add	 rbp, 112		; 00000070H
  0037f	90		 npad	 1
$LL93@type_new:

; 2110 :             PyObject *tmp = PyTuple_GET_ITEM(slots, i);

  00380	48 8b 7d 00	 mov	 rdi, QWORD PTR [rbp]

; 2111 :             if (!valid_identifier(tmp))

  00384	48 8b cf	 mov	 rcx, rdi
  00387	e8 00 00 00 00	 call	 valid_identifier
  0038c	85 c0		 test	 eax, eax
  0038e	0f 84 67 ff ff
	ff		 je	 $error$21872

; 2112 :                 goto error;
; 2113 :             assert(PyUnicode_Check(tmp));
; 2114 :             if (PyUnicode_CompareWithASCIIString(tmp, "__dict__") == 0) {

  00394	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08IBFKALI@__dict__?$AA@
  0039b	48 8b cf	 mov	 rcx, rdi
  0039e	e8 00 00 00 00	 call	 PyUnicode_CompareWithASCIIString
  003a3	85 c0		 test	 eax, eax
  003a5	75 1b		 jne	 SHORT $LN89@type_new

; 2115 :                 if (!may_add_dict || add_dict) {

  003a7	48 39 9c 24 88
	00 00 00	 cmp	 QWORD PTR $T32101[rsp], rbx
  003af	0f 84 02 01 00
	00		 je	 $LN127@type_new
  003b5	4d 85 ed	 test	 r13, r13
  003b8	0f 85 f9 00 00
	00		 jne	 $LN127@type_new

; 2120 :                 }
; 2121 :                 add_dict++;

  003be	44 8d 68 01	 lea	 r13d, QWORD PTR [rax+1]
$LN89@type_new:

; 2122 :             }
; 2123 :             if (PyUnicode_CompareWithASCIIString(tmp, "__weakref__") == 0) {

  003c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@OFKEODAB@__weakref__?$AA@
  003c9	48 8b cf	 mov	 rcx, rdi
  003cc	e8 00 00 00 00	 call	 PyUnicode_CompareWithASCIIString
  003d1	85 c0		 test	 eax, eax
  003d3	75 16		 jne	 SHORT $LN92@type_new

; 2124 :                 if (!may_add_weak || add_weak) {

  003d5	4d 85 e4	 test	 r12, r12
  003d8	0f 84 f1 00 00
	00		 je	 $LN128@type_new
  003de	4d 85 f6	 test	 r14, r14
  003e1	0f 85 e8 00 00
	00		 jne	 $LN128@type_new

; 2130 :                 }
; 2131 :                 add_weak++;

  003e7	44 8d 70 01	 lea	 r14d, QWORD PTR [rax+1]
$LN92@type_new:

; 2105 :             goto error;
; 2106 :         }
; 2107 : 
; 2108 :         /* Check for valid slot names and two special cases */
; 2109 :         for (i = 0; i < nslots; i++) {

  003eb	48 ff c6	 inc	 rsi
  003ee	48 83 c5 08	 add	 rbp, 8
  003f2	49 3b f7	 cmp	 rsi, r15
  003f5	7c 89		 jl	 SHORT $LL93@type_new
$LN136@type_new:

; 2132 :             }
; 2133 :         }
; 2134 : 
; 2135 :         /* Copy slots into a list, mangle names and sort them.
; 2136 :            Sorted names are needed for __class__ assignment.
; 2137 :            Convert them back to tuple at the end.
; 2138 :         */
; 2139 :         newslots = PyList_New(nslots - add_dict - add_weak);

  003f7	49 8b cf	 mov	 rcx, r15
  003fa	49 2b ce	 sub	 rcx, r14
  003fd	49 2b cd	 sub	 rcx, r13
  00400	e8 00 00 00 00	 call	 PyList_New
  00405	48 8b f0	 mov	 rsi, rax

; 2140 :         if (newslots == NULL)

  00408	48 85 c0	 test	 rax, rax
  0040b	0f 84 ea fe ff
	ff		 je	 $error$21872

; 2141 :             goto error;
; 2142 :         for (i = j = 0; i < nslots; i++) {

  00411	33 c0		 xor	 eax, eax
  00413	45 33 e4	 xor	 r12d, r12d
  00416	89 84 24 08 01
	00 00		 mov	 DWORD PTR j$1$[rsp], eax
  0041d	4d 85 ff	 test	 r15, r15
  00420	0f 8e dd 00 00
	00		 jle	 $LN80@type_new
  00426	48 8b 6c 24 50	 mov	 rbp, QWORD PTR slots$1$[rsp]
  0042b	45 33 ff	 xor	 r15d, r15d
  0042e	48 83 c5 70	 add	 rbp, 112		; 00000070H
$LL82@type_new:

; 2143 :             tmp = PyTuple_GET_ITEM(slots, i);

  00432	48 8b 7d 00	 mov	 rdi, QWORD PTR [rbp]

; 2144 :             if ((add_dict &&
; 2145 :                  PyUnicode_CompareWithASCIIString(tmp, "__dict__") == 0) ||
; 2146 :                 (add_weak &&
; 2147 :                  PyUnicode_CompareWithASCIIString(tmp, "__weakref__") == 0))

  00436	4d 85 ed	 test	 r13, r13
  00439	74 17		 je	 SHORT $LN77@type_new
  0043b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08IBFKALI@__dict__?$AA@
  00442	48 8b cf	 mov	 rcx, rdi
  00445	e8 00 00 00 00	 call	 PyUnicode_CompareWithASCIIString
  0044a	85 c0		 test	 eax, eax
  0044c	0f 84 95 00 00
	00		 je	 $LN139@type_new
$LN77@type_new:
  00452	4d 85 f6	 test	 r14, r14
  00455	74 13		 je	 SHORT $LN79@type_new
  00457	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@OFKEODAB@__weakref__?$AA@
  0045e	48 8b cf	 mov	 rcx, rdi
  00461	e8 00 00 00 00	 call	 PyUnicode_CompareWithASCIIString
  00466	85 c0		 test	 eax, eax

; 2148 :                 continue;

  00468	74 7d		 je	 SHORT $LN139@type_new
$LN79@type_new:

; 2149 :             tmp =_Py_Mangle(name, tmp);

  0046a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR name$[rsp]
  0046f	48 8b d7	 mov	 rdx, rdi
  00472	e8 00 00 00 00	 call	 _Py_Mangle
  00477	48 8b f8	 mov	 rdi, rax

; 2150 :             if (!tmp) {

  0047a	48 85 c0	 test	 rax, rax
  0047d	0f 84 f5 00 00
	00		 je	 $LN129@type_new

; 2151 :                 Py_DECREF(newslots);
; 2152 :                 goto error;
; 2153 :             }
; 2154 :             PyList_SET_ITEM(newslots, j, tmp);

  00483	48 8b 4e 70	 mov	 rcx, QWORD PTR [rsi+112]

; 2155 :             if (PyDict_GetItem(dict, tmp)) {

  00487	48 8b d0	 mov	 rdx, rax
  0048a	49 89 04 0f	 mov	 QWORD PTR [r15+rcx], rax
  0048e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dict$1$[rsp]
  00493	e8 00 00 00 00	 call	 PyDict_GetItem
  00498	48 85 c0	 test	 rax, rax
  0049b	0f 85 c1 00 00
	00		 jne	 $LN130@type_new

; 2161 :             }
; 2162 :             j++;

  004a1	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR j$1$[rsp]
  004a8	ff c0		 inc	 eax
  004aa	49 83 c7 08	 add	 r15, 8
  004ae	89 84 24 08 01
	00 00		 mov	 DWORD PTR j$1$[rsp], eax
  004b5	eb 37		 jmp	 SHORT $LN81@type_new
$LN127@type_new:

; 2116 :                     PyErr_SetString(PyExc_TypeError,
; 2117 :                         "__dict__ slot disallowed: "
; 2118 :                         "we already got one");

  004b7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  004be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@HEEOHDAA@__dict__?5slot?5disallowed?3?5we?5alr@
  004c5	e8 00 00 00 00	 call	 PyErr_SetString

; 2119 :                     goto error;

  004ca	e9 2c fe ff ff	 jmp	 $error$21872
$LN128@type_new:

; 2125 :                     PyErr_SetString(PyExc_TypeError,
; 2126 :                         "__weakref__ slot disallowed: "
; 2127 :                         "either we already got one, "
; 2128 :                         "or __itemsize__ != 0");

  004cf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  004d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EN@DKLGOPEO@__weakref__?5slot?5disallowed?3?5eit@
  004dd	e8 00 00 00 00	 call	 PyErr_SetString

; 2129 :                     goto error;

  004e2	e9 14 fe ff ff	 jmp	 $error$21872
$LN139@type_new:

; 2161 :             }
; 2162 :             j++;

  004e7	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR j$1$[rsp]
$LN81@type_new:

; 2141 :             goto error;
; 2142 :         for (i = j = 0; i < nslots; i++) {

  004ee	49 ff c4	 inc	 r12
  004f1	48 83 c5 08	 add	 rbp, 8
  004f5	4c 3b a4 24 98
	00 00 00	 cmp	 r12, QWORD PTR nslots$2$[rsp]
  004fd	0f 8c 2f ff ff
	ff		 jl	 $LL82@type_new
$LN80@type_new:

; 2163 :         }
; 2164 :         assert(j == nslots - add_dict - add_weak);
; 2165 :         nslots = j;
; 2166 :         Py_CLEAR(slots);

  00503	48 8b 7c 24 50	 mov	 rdi, QWORD PTR slots$1$[rsp]
  00508	4c 63 f8	 movsxd	 r15, eax
  0050b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKBBAMFA@?4?4?2Objects?2typeobject?4c?$AA@
  00512	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08PMCPIDCB@type_new?$AA@
  00519	41 b8 76 08 00
	00		 mov	 r8d, 2166		; 00000876H
  0051f	4c 8b cf	 mov	 r9, rdi
  00522	4c 89 bc 24 08
	01 00 00	 mov	 QWORD PTR nslots$1$[rsp], r15
  0052a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00532	e8 00 00 00 00	 call	 _PyParallel_Guard
  00537	85 c0		 test	 eax, eax
  00539	75 0d		 jne	 SHORT $LN73@type_new
  0053b	48 8b cf	 mov	 rcx, rdi
  0053e	48 89 5c 24 50	 mov	 QWORD PTR slots$1$[rsp], rbx
  00543	e8 00 00 00 00	 call	 _Py_DecRef
$LN73@type_new:

; 2167 :         if (PyList_Sort(newslots) == -1) {

  00548	48 8b ce	 mov	 rcx, rsi
  0054b	e8 00 00 00 00	 call	 PyList_Sort

; 2168 :             Py_DECREF(newslots);

  00550	48 8b ce	 mov	 rcx, rsi
  00553	83 f8 ff	 cmp	 eax, -1
  00556	75 2d		 jne	 SHORT $LN70@type_new
  00558	e8 00 00 00 00	 call	 _Py_DecRef

; 2169 :             goto error;

  0055d	e9 99 fd ff ff	 jmp	 $error$21872
$LN130@type_new:

; 2156 :                 PyErr_Format(PyExc_ValueError,
; 2157 :                              "%R in __slots__ conflicts with class variable",
; 2158 :                              tmp);

  00562	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00569	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@KNOILAEF@?$CFR?5in?5__slots__?5conflicts?5with?5c@
  00570	4c 8b c7	 mov	 r8, rdi
  00573	e8 00 00 00 00	 call	 PyErr_Format
$LN129@type_new:

; 2159 :                 Py_DECREF(newslots);

  00578	48 8b ce	 mov	 rcx, rsi
  0057b	e8 00 00 00 00	 call	 _Py_DecRef

; 2160 :                 goto error;

  00580	e9 76 fd ff ff	 jmp	 $error$21872
$LN70@type_new:

; 2170 :         }
; 2171 :         slots = PyList_AsTuple(newslots);

  00585	e8 00 00 00 00	 call	 PyList_AsTuple

; 2172 :         Py_DECREF(newslots);

  0058a	48 8b ce	 mov	 rcx, rsi
  0058d	48 89 44 24 50	 mov	 QWORD PTR slots$1$[rsp], rax
  00592	e8 00 00 00 00	 call	 _Py_DecRef

; 2173 :         if (slots == NULL)

  00597	48 8b 74 24 50	 mov	 rsi, QWORD PTR slots$1$[rsp]
  0059c	48 85 f6	 test	 rsi, rsi
  0059f	0f 84 56 fd ff
	ff		 je	 $error$21872

; 2174 :             goto error;
; 2175 : 
; 2176 :         /* Secondary bases may provide weakrefs or dict */
; 2177 :         if (nbases > 1 &&
; 2178 :             ((may_add_dict && !add_dict) ||
; 2179 :              (may_add_weak && !add_weak))) {

  005a5	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR nbases$1$[rsp]
  005ad	49 83 f8 01	 cmp	 r8, 1
  005b1	0f 8e b1 00 00
	00		 jle	 $LN143@type_new
  005b7	39 9c 24 18 01
	00 00		 cmp	 DWORD PTR may_add_dict$1$[rsp], ebx
  005be	74 05		 je	 SHORT $LN66@type_new
  005c0	4d 85 ed	 test	 r13, r13
  005c3	74 16		 je	 SHORT $LN67@type_new
$LN66@type_new:
  005c5	39 9c 24 10 01
	00 00		 cmp	 DWORD PTR may_add_weak$1$[rsp], ebx
  005cc	0f 84 96 00 00
	00		 je	 $LN143@type_new
  005d2	4d 85 f6	 test	 r14, r14
  005d5	0f 85 8d 00 00
	00		 jne	 $LN143@type_new
$LN67@type_new:
  005db	48 8b 6c 24 60	 mov	 rbp, QWORD PTR base$1$[rsp]

; 2180 :             for (i = 0; i < nbases; i++) {

  005e0	33 d2		 xor	 edx, edx
  005e2	4d 85 c0	 test	 r8, r8
  005e5	0f 8e 82 00 00
	00		 jle	 $LN58@type_new
  005eb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR bases$[rsp]
  005f0	48 8b bc 24 a0
	00 00 00	 mov	 rdi, QWORD PTR $T32102[rsp]
  005f8	4c 8b bc 24 88
	00 00 00	 mov	 r15, QWORD PTR $T32101[rsp]
  00600	48 83 c1 70	 add	 rcx, 112		; 00000070H
  00604	8d 72 01	 lea	 esi, QWORD PTR [rdx+1]
$LL65@type_new:

; 2181 :                 tmp = PyTuple_GET_ITEM(bases, i);

  00607	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 2182 :                 if (tmp == (PyObject *)base)

  0060a	48 3b c5	 cmp	 rax, rbp
  0060d	74 3e		 je	 SHORT $LN64@type_new

; 2183 :                     continue; /* Skip primary base */
; 2184 :                 assert(PyType_Check(tmp));
; 2185 :                 tmptype = (PyTypeObject *)tmp;
; 2186 :                 if (may_add_dict && !add_dict &&
; 2187 :                     tmptype->tp_dictoffset != 0)

  0060f	4d 85 ff	 test	 r15, r15
  00612	74 10		 je	 SHORT $LN61@type_new
  00614	4d 85 ed	 test	 r13, r13
  00617	75 0b		 jne	 SHORT $LN61@type_new
  00619	48 39 98 78 01
	00 00		 cmp	 QWORD PTR [rax+376], rbx
  00620	4c 0f 45 ee	 cmovne	 r13, rsi
$LN61@type_new:

; 2188 :                     add_dict++;
; 2189 :                 if (may_add_weak && !add_weak &&
; 2190 :                     tmptype->tp_weaklistoffset != 0)

  00624	48 85 ff	 test	 rdi, rdi
  00627	74 10		 je	 SHORT $LN60@type_new
  00629	4d 85 f6	 test	 r14, r14
  0062c	75 0b		 jne	 SHORT $LN60@type_new
  0062e	48 39 98 28 01
	00 00		 cmp	 QWORD PTR [rax+296], rbx
  00635	4c 0f 45 f6	 cmovne	 r14, rsi
$LN60@type_new:

; 2191 :                     add_weak++;
; 2192 :                 if (may_add_dict && !add_dict)

  00639	4d 85 ff	 test	 r15, r15
  0063c	74 05		 je	 SHORT $LN59@type_new
  0063e	4d 85 ed	 test	 r13, r13
  00641	74 0a		 je	 SHORT $LN64@type_new
$LN59@type_new:

; 2193 :                     continue;
; 2194 :                 if (may_add_weak && !add_weak)

  00643	48 85 ff	 test	 rdi, rdi
  00646	74 11		 je	 SHORT $LN137@type_new
  00648	4d 85 f6	 test	 r14, r14
  0064b	75 0c		 jne	 SHORT $LN137@type_new
$LN64@type_new:

; 2180 :             for (i = 0; i < nbases; i++) {

  0064d	48 ff c2	 inc	 rdx
  00650	48 83 c1 08	 add	 rcx, 8
  00654	49 3b d0	 cmp	 rdx, r8
  00657	7c ae		 jl	 SHORT $LL65@type_new
$LN137@type_new:
  00659	4c 8b bc 24 08
	01 00 00	 mov	 r15, QWORD PTR nslots$1$[rsp]

; 2054 : 
; 2055 :     /* Calculate best base, and check that all bases are type objects */
; 2056 :     base = best_base(bases);

  00661	48 8b 74 24 50	 mov	 rsi, QWORD PTR slots$1$[rsp]
  00666	eb 05		 jmp	 SHORT $LN58@type_new
$LN143@type_new:
  00668	48 8b 6c 24 60	 mov	 rbp, QWORD PTR base$1$[rsp]
$LN58@type_new:

; 2195 :                     continue;
; 2196 :                 /* Nothing more to check */
; 2197 :                 break;
; 2198 :             }
; 2199 :         }
; 2200 :     }
; 2201 : 
; 2202 :     /* Allocate the type object */
; 2203 :     type = (PyTypeObject *)metatype->tp_alloc(metatype, nslots);

  0066d	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR metatype$[rsp]
  00675	49 8b d7	 mov	 rdx, r15
  00678	48 8b c8	 mov	 rcx, rax
  0067b	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  00681	48 8b d8	 mov	 rbx, rax

; 2204 :     if (type == NULL)

  00684	48 85 c0	 test	 rax, rax
  00687	0f 84 6e fc ff
	ff		 je	 $error$21872

; 2205 :         goto error;
; 2206 : 
; 2207 :     /* Keep name and slots alive in the extended type object */
; 2208 :     et = (PyHeapTypeObject *)type;
; 2209 :     Py_INCREF(name);

  0068d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR name$[rsp]
  00692	e8 00 00 00 00	 call	 _Py_IncRef

; 2210 :     et->ht_name = name;

  00697	48 8b 4c 24 68	 mov	 rcx, QWORD PTR name$[rsp]

; 2211 :     et->ht_slots = slots;
; 2212 :     slots = NULL;

  0069c	33 ff		 xor	 edi, edi
  0069e	48 89 b3 70 03
	00 00		 mov	 QWORD PTR [rbx+880], rsi

; 2213 : 
; 2214 :     /* Initialize tp_flags */
; 2215 :     type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE |
; 2216 :         Py_TPFLAGS_BASETYPE;

  006a5	c7 83 00 01 00
	00 00 06 04 00	 mov	 DWORD PTR [rbx+256], 263680 ; 00040600H
  006af	48 89 8b 68 03
	00 00		 mov	 QWORD PTR [rbx+872], rcx

; 2217 :     if (base->tp_flags & Py_TPFLAGS_HAVE_GC)

  006b6	f7 85 00 01 00
	00 00 40 00 00	 test	 DWORD PTR [rbp+256], 16384 ; 00004000H
  006c0	48 89 7c 24 50	 mov	 QWORD PTR slots$1$[rsp], rdi
  006c5	74 0a		 je	 SHORT $LN56@type_new

; 2218 :         type->tp_flags |= Py_TPFLAGS_HAVE_GC;

  006c7	c7 83 00 01 00
	00 00 46 04 00	 mov	 DWORD PTR [rbx+256], 280064 ; 00044600H
$LN56@type_new:

; 2219 : 
; 2220 :     /* Initialize essential fields */
; 2221 :     type->tp_as_number = &et->as_number;

  006d1	48 8d 83 e0 01
	00 00		 lea	 rax, QWORD PTR [rbx+480]
  006d8	48 89 83 b8 00
	00 00		 mov	 QWORD PTR [rbx+184], rax

; 2222 :     type->tp_as_sequence = &et->as_sequence;

  006df	48 8d 83 08 03
	00 00		 lea	 rax, QWORD PTR [rbx+776]
  006e6	48 89 83 c0 00
	00 00		 mov	 QWORD PTR [rbx+192], rax

; 2223 :     type->tp_as_mapping = &et->as_mapping;

  006ed	48 8d 83 f0 02
	00 00		 lea	 rax, QWORD PTR [rbx+752]
  006f4	48 89 83 c8 00
	00 00		 mov	 QWORD PTR [rbx+200], rax

; 2224 :     type->tp_as_buffer = &et->as_buffer;

  006fb	48 8d 83 58 03
	00 00		 lea	 rax, QWORD PTR [rbx+856]
  00702	48 89 83 f8 00
	00 00		 mov	 QWORD PTR [rbx+248], rax

; 2225 :     type->tp_name = _PyUnicode_AsString(name);

  00709	48 8b 4c 24 68	 mov	 rcx, QWORD PTR name$[rsp]
  0070e	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  00713	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax

; 2226 :     if (!type->tp_name)

  00717	48 85 c0	 test	 rax, rax
  0071a	0f 84 db fb ff
	ff		 je	 $error$21872

; 2227 :         goto error;
; 2228 : 
; 2229 :     /* Set tp_base and tp_bases */
; 2230 :     type->tp_bases = bases;

  00720	48 8b 44 24 58	 mov	 rax, QWORD PTR bases$[rsp]

; 2231 :     bases = NULL;
; 2232 :     Py_INCREF(base);

  00725	48 8b cd	 mov	 rcx, rbp
  00728	48 89 83 a8 01
	00 00		 mov	 QWORD PTR [rbx+424], rax
  0072f	48 89 7c 24 58	 mov	 QWORD PTR bases$[rsp], rdi
  00734	e8 00 00 00 00	 call	 _Py_IncRef

; 2233 :     type->tp_base = base;
; 2234 : 
; 2235 :     /* Initialize tp_dict from passed-in dict */
; 2236 :     Py_INCREF(dict);

  00739	4c 8b 64 24 70	 mov	 r12, QWORD PTR dict$1$[rsp]
  0073e	48 89 ab 58 01
	00 00		 mov	 QWORD PTR [rbx+344], rbp
  00745	49 8b cc	 mov	 rcx, r12
  00748	e8 00 00 00 00	 call	 _Py_IncRef

; 2237 :     type->tp_dict = dict;
; 2238 : 
; 2239 :     /* Set __module__ in the dict */
; 2240 :     if (_PyDict_GetItemId(dict, &PyId___module__) == NULL) {

  0074d	48 8b 74 24 78	 mov	 rsi, QWORD PTR tv1320[rsp]
  00752	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:PyId___module__
  00757	48 03 fe	 add	 rdi, rsi
  0075a	49 8b cc	 mov	 rcx, r12
  0075d	4c 89 a3 60 01
	00 00		 mov	 QWORD PTR [rbx+352], r12
  00764	48 8b d7	 mov	 rdx, rdi
  00767	e8 00 00 00 00	 call	 _PyDict_GetItemId
  0076c	48 85 c0	 test	 rax, rax
  0076f	75 35		 jne	 SHORT $LN51@type_new

; 2241 :         tmp = PyEval_GetGlobals();

  00771	e8 00 00 00 00	 call	 PyEval_GetGlobals

; 2242 :         if (tmp != NULL) {

  00776	48 85 c0	 test	 rax, rax
  00779	74 2b		 je	 SHORT $LN51@type_new

; 2243 :             tmp = _PyDict_GetItemId(tmp, &PyId___name__);

  0077b	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId___name__
  00780	48 8b c8	 mov	 rcx, rax
  00783	48 03 d6	 add	 rdx, rsi
  00786	e8 00 00 00 00	 call	 _PyDict_GetItemId

; 2244 :             if (tmp != NULL) {

  0078b	48 85 c0	 test	 rax, rax
  0078e	74 16		 je	 SHORT $LN51@type_new

; 2245 :                 if (_PyDict_SetItemId(dict, &PyId___module__,
; 2246 :                                       tmp) < 0)

  00790	4c 8b c0	 mov	 r8, rax
  00793	48 8b d7	 mov	 rdx, rdi
  00796	49 8b cc	 mov	 rcx, r12
  00799	e8 00 00 00 00	 call	 _PyDict_SetItemId
  0079e	85 c0		 test	 eax, eax
  007a0	0f 88 55 fb ff
	ff		 js	 $error$21872
$LN51@type_new:

; 2247 :                     goto error;
; 2248 :             }
; 2249 :         }
; 2250 :     }
; 2251 : 
; 2252 :     /* Set ht_qualname to dict['__qualname__'] if available, else to
; 2253 :        __name__.  The __qualname__ accessor will look for ht_qualname.
; 2254 :     */
; 2255 :     qualname = _PyDict_GetItemId(dict, &PyId___qualname__);

  007a6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId___qualname__@?1??type_new@@9@9
  007ab	49 8b cc	 mov	 rcx, r12
  007ae	48 03 f0	 add	 rsi, rax
  007b1	48 8b d6	 mov	 rdx, rsi
  007b4	e8 00 00 00 00	 call	 _PyDict_GetItemId
  007b9	48 8b f8	 mov	 rdi, rax

; 2256 :     if (qualname != NULL) {

  007bc	48 85 c0	 test	 rax, rax
  007bf	74 26		 je	 SHORT $LN120@type_new

; 2257 :         if (!PyUnicode_Check(qualname)) {

  007c1	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  007c5	41 f7 80 00 01
	00 00 00 00 00
	10		 test	 DWORD PTR [r8+256], 268435456 ; 10000000H
  007d0	75 10		 jne	 SHORT $LN49@type_new

; 2258 :             PyErr_Format(PyExc_TypeError,
; 2259 :                          "type __qualname__ must be a str, not %s",
; 2260 :                          Py_TYPE(qualname)->tp_name);

  007d2	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  007d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@INBJKNKC@type?5__qualname__?5must?5be?5a?5str?0@

; 2261 :             goto error;

  007dd	e9 0d fb ff ff	 jmp	 $LN151@type_new
$LN49@type_new:

; 2262 :         }
; 2263 :     }
; 2264 :     et->ht_qualname = qualname ? qualname : et->ht_name;

  007e2	48 8b c8	 mov	 rcx, rax
  007e5	eb 07		 jmp	 SHORT $LN121@type_new
$LN120@type_new:
  007e7	48 8b 8b 68 03
	00 00		 mov	 rcx, QWORD PTR [rbx+872]
$LN121@type_new:
  007ee	48 89 8b 78 03
	00 00		 mov	 QWORD PTR [rbx+888], rcx

; 2265 :     Py_INCREF(et->ht_qualname);

  007f5	e8 00 00 00 00	 call	 _Py_IncRef

; 2266 :     if (qualname != NULL && PyDict_DelItem(dict, PyId___qualname__.object) < 0)

  007fa	48 85 ff	 test	 rdi, rdi
  007fd	74 14		 je	 SHORT $LN48@type_new
  007ff	48 8b 56 10	 mov	 rdx, QWORD PTR [rsi+16]
  00803	49 8b cc	 mov	 rcx, r12
  00806	e8 00 00 00 00	 call	 PyDict_DelItem
  0080b	85 c0		 test	 eax, eax
  0080d	0f 88 e8 fa ff
	ff		 js	 $error$21872
$LN48@type_new:

; 2267 :         goto error;
; 2268 : 
; 2269 :     /* Set tp_doc to a copy of dict['__doc__'], if the latter is there
; 2270 :        and is a string.  The __doc__ accessor will first look for tp_doc;
; 2271 :        if that fails, it will still look into __dict__.
; 2272 :     */
; 2273 :     {
; 2274 :         PyObject *doc = _PyDict_GetItemId(dict, &PyId___doc__);

  00813	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId___doc__
  00818	49 8b cc	 mov	 rcx, r12
  0081b	48 03 54 24 78	 add	 rdx, QWORD PTR tv1320[rsp]
  00820	e8 00 00 00 00	 call	 _PyDict_GetItemId

; 2275 :         if (doc != NULL && PyUnicode_Check(doc)) {

  00825	48 85 c0	 test	 rax, rax
  00828	74 66		 je	 SHORT $LN47@type_new
  0082a	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0082e	f7 81 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rcx+256], 268435456 ; 10000000H
  00838	74 56		 je	 SHORT $LN47@type_new

; 2276 :             Py_ssize_t len;
; 2277 :             char *doc_str;
; 2278 :             char *tp_doc;
; 2279 : 
; 2280 :             doc_str = _PyUnicode_AsString(doc);

  0083a	48 8b c8	 mov	 rcx, rax
  0083d	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  00842	48 8b f0	 mov	 rsi, rax

; 2281 :             if (doc_str == NULL)

  00845	48 85 c0	 test	 rax, rax
  00848	0f 84 ad fa ff
	ff		 je	 $error$21872

; 2282 :                 goto error;
; 2283 :             /* Silently truncate the docstring if it contains null bytes. */
; 2284 :             len = strlen(doc_str);

  0084e	48 83 c9 ff	 or	 rcx, -1
  00852	33 c0		 xor	 eax, eax
  00854	48 8b fe	 mov	 rdi, rsi
  00857	f2 ae		 repne scasb
  00859	48 f7 d1	 not	 rcx
  0085c	48 8d 69 ff	 lea	 rbp, QWORD PTR [rcx-1]

; 2285 :             tp_doc = (char *)PyObject_MALLOC(len + 1);

  00860	48 8d 4d 01	 lea	 rcx, QWORD PTR [rbp+1]
  00864	e8 00 00 00 00	 call	 PyObject_Malloc
  00869	48 8b f8	 mov	 rdi, rax

; 2286 :             if (tp_doc == NULL)

  0086c	48 85 c0	 test	 rax, rax
  0086f	0f 84 86 fa ff
	ff		 je	 $error$21872

; 2287 :                 goto error;
; 2288 :             memcpy(tp_doc, doc_str, len + 1);

  00875	4c 8d 45 01	 lea	 r8, QWORD PTR [rbp+1]
  00879	48 8b d6	 mov	 rdx, rsi
  0087c	48 8b c8	 mov	 rcx, rax
  0087f	e8 00 00 00 00	 call	 memcpy
  00884	48 8b 6c 24 60	 mov	 rbp, QWORD PTR base$1$[rsp]

; 2289 :             type->tp_doc = tp_doc;

  00889	48 89 bb 08 01
	00 00		 mov	 QWORD PTR [rbx+264], rdi
$LN47@type_new:

; 2290 :         }
; 2291 :     }
; 2292 : 
; 2293 :     /* Special-case __new__: if it's a plain function,
; 2294 :        make it a static function */
; 2295 :     tmp = _PyDict_GetItemId(dict, &PyId___new__);

  00890	be 00 00 00 00	 mov	 esi, OFFSET FLAT:PyId___new__
  00895	49 8b cc	 mov	 rcx, r12
  00898	48 03 74 24 78	 add	 rsi, QWORD PTR tv1320[rsp]
  0089d	48 8b d6	 mov	 rdx, rsi
  008a0	e8 00 00 00 00	 call	 _PyDict_GetItemId

; 2296 :     if (tmp != NULL && PyFunction_Check(tmp)) {

  008a5	48 85 c0	 test	 rax, rax
  008a8	74 3f		 je	 SHORT $LN44@type_new
  008aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyFunction_Type
  008b1	48 39 48 58	 cmp	 QWORD PTR [rax+88], rcx
  008b5	75 32		 jne	 SHORT $LN44@type_new

; 2297 :         tmp = PyStaticMethod_New(tmp);

  008b7	48 8b c8	 mov	 rcx, rax
  008ba	e8 00 00 00 00	 call	 PyStaticMethod_New
  008bf	48 8b f8	 mov	 rdi, rax

; 2298 :         if (tmp == NULL)

  008c2	48 85 c0	 test	 rax, rax
  008c5	0f 84 30 fa ff
	ff		 je	 $error$21872

; 2299 :             goto error;
; 2300 :         if (_PyDict_SetItemId(dict, &PyId___new__, tmp) < 0)

  008cb	4c 8b c0	 mov	 r8, rax
  008ce	48 8b d6	 mov	 rdx, rsi
  008d1	49 8b cc	 mov	 rcx, r12
  008d4	e8 00 00 00 00	 call	 _PyDict_SetItemId
  008d9	85 c0		 test	 eax, eax
  008db	0f 88 1a fa ff
	ff		 js	 $error$21872

; 2301 :             goto error;
; 2302 :         Py_DECREF(tmp);

  008e1	48 8b cf	 mov	 rcx, rdi
  008e4	e8 00 00 00 00	 call	 _Py_DecRef
$LN44@type_new:

; 2303 :     }
; 2304 : 
; 2305 :     /* Add descriptors for custom slots from __slots__, or for __dict__ */
; 2306 :     mp = PyHeapType_GET_MEMBERS(et);
; 2307 :     slotoffset = base->tp_basicsize;
; 2308 :     if (et->ht_slots != NULL) {

  008e9	48 83 bb 70 03
	00 00 00	 cmp	 QWORD PTR [rbx+880], 0
  008f1	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  008f5	48 8b 7d 78	 mov	 rdi, QWORD PTR [rbp+120]
  008f9	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  008fd	48 8d 34 0b	 lea	 rsi, QWORD PTR [rbx+rcx]
  00901	74 52		 je	 SHORT $LN38@type_new

; 2309 :         for (i = 0; i < nslots; i++, mp++) {

  00903	33 ed		 xor	 ebp, ebp
  00905	4d 85 ff	 test	 r15, r15
  00908	7e 46		 jle	 SHORT $LN140@type_new
  0090a	41 bc 70 00 00
	00		 mov	 r12d, 112		; 00000070H
$LL40@type_new:

; 2310 :             mp->name = _PyUnicode_AsString(
; 2311 :                 PyTuple_GET_ITEM(et->ht_slots, i));

  00910	48 8b 8b 70 03
	00 00		 mov	 rcx, QWORD PTR [rbx+880]
  00917	4a 8b 0c 21	 mov	 rcx, QWORD PTR [rcx+r12]
  0091b	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  00920	48 89 06	 mov	 QWORD PTR [rsi], rax

; 2312 :             if (mp->name == NULL)

  00923	48 85 c0	 test	 rax, rax
  00926	0f 84 cf f9 ff
	ff		 je	 $error$21872

; 2313 :                 goto error;
; 2314 :             mp->type = T_OBJECT_EX;
; 2315 :             mp->offset = slotoffset;

  0092c	48 89 7e 10	 mov	 QWORD PTR [rsi+16], rdi
  00930	48 ff c5	 inc	 rbp
  00933	c7 46 08 10 00
	00 00		 mov	 DWORD PTR [rsi+8], 16

; 2316 : 
; 2317 :             /* __dict__ and __weakref__ are already filtered out */
; 2318 :             assert(strcmp(mp->name, "__dict__") != 0);
; 2319 :             assert(strcmp(mp->name, "__weakref__") != 0);
; 2320 : 
; 2321 :             slotoffset += sizeof(PyObject *);

  0093a	48 83 c7 08	 add	 rdi, 8
  0093e	49 83 c4 08	 add	 r12, 8
  00942	48 83 c6 28	 add	 rsi, 40			; 00000028H
  00946	49 3b ef	 cmp	 rbp, r15
  00949	7c c5		 jl	 SHORT $LL40@type_new

; 2054 : 
; 2055 :     /* Calculate best base, and check that all bases are type objects */
; 2056 :     base = best_base(bases);

  0094b	4c 8b 64 24 70	 mov	 r12, QWORD PTR dict$1$[rsp]
$LN140@type_new:
  00950	48 8b 6c 24 60	 mov	 rbp, QWORD PTR base$1$[rsp]
$LN38@type_new:

; 2322 :         }
; 2323 :     }
; 2324 :     if (add_dict) {

  00955	4d 85 ed	 test	 r13, r13
  00958	74 21		 je	 SHORT $LN36@type_new

; 2325 :         if (base->tp_itemsize)

  0095a	48 83 bd 80 00
	00 00 00	 cmp	 QWORD PTR [rbp+128], 0
  00962	48 8b c7	 mov	 rax, rdi
  00965	48 c7 c1 f8 ff
	ff ff		 mov	 rcx, -8
  0096c	48 0f 45 c1	 cmovne	 rax, rcx

; 2326 :             type->tp_dictoffset = -(long)sizeof(PyObject *);
; 2327 :         else
; 2328 :             type->tp_dictoffset = slotoffset;
; 2329 :         slotoffset += sizeof(PyObject *);

  00970	48 83 c7 08	 add	 rdi, 8
  00974	48 89 83 78 01
	00 00		 mov	 QWORD PTR [rbx+376], rax
$LN36@type_new:

; 2330 :     }
; 2331 :     if (type->tp_dictoffset) {

  0097b	48 83 bb 78 01
	00 00 00	 cmp	 QWORD PTR [rbx+376], 0
  00983	74 0c		 je	 SHORT $LN33@type_new

; 2332 :         et->ht_cached_keys = _PyDict_NewKeysForClass();

  00985	e8 00 00 00 00	 call	 _PyDict_NewKeysForClass
  0098a	48 89 83 80 03
	00 00		 mov	 QWORD PTR [rbx+896], rax
$LN33@type_new:

; 2333 :     }
; 2334 :     if (add_weak) {

  00991	4d 85 f6	 test	 r14, r14
  00994	74 0b		 je	 SHORT $LN32@type_new

; 2335 :         assert(!base->tp_itemsize);
; 2336 :         type->tp_weaklistoffset = slotoffset;

  00996	48 89 bb 28 01
	00 00		 mov	 QWORD PTR [rbx+296], rdi

; 2337 :         slotoffset += sizeof(PyObject *);

  0099d	48 83 c7 08	 add	 rdi, 8
$LN32@type_new:

; 2338 :     }
; 2339 :     type->tp_basicsize = slotoffset;

  009a1	48 89 7b 78	 mov	 QWORD PTR [rbx+120], rdi

; 2340 :     type->tp_itemsize = base->tp_itemsize;

  009a5	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR [rbp+128]
  009ac	48 89 83 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rax

; 2341 :     type->tp_members = PyHeapType_GET_MEMBERS(et);

  009b3	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  009b7	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  009bb	48 8d 04 0b	 lea	 rax, QWORD PTR [rbx+rcx]
  009bf	48 89 83 48 01
	00 00		 mov	 QWORD PTR [rbx+328], rax

; 2342 : 
; 2343 :     if (type->tp_weaklistoffset && type->tp_dictoffset)

  009c6	48 8b 83 28 01
	00 00		 mov	 rax, QWORD PTR [rbx+296]
  009cd	48 85 c0	 test	 rax, rax
  009d0	74 3e		 je	 SHORT $LN150@type_new
  009d2	48 83 bb 78 01
	00 00 00	 cmp	 QWORD PTR [rbx+376], 0
  009da	74 10		 je	 SHORT $LN31@type_new

; 2344 :         type->tp_getset = subtype_getsets_full;

  009dc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:subtype_getsets_full
  009e3	48 89 83 50 01
	00 00		 mov	 QWORD PTR [rbx+336], rax
  009ea	eb 49		 jmp	 SHORT $LN26@type_new
$LN31@type_new:

; 2345 :     else if (type->tp_weaklistoffset && !type->tp_dictoffset)

  009ec	48 85 c0	 test	 rax, rax
  009ef	74 1f		 je	 SHORT $LN150@type_new
  009f1	48 83 bb 78 01
	00 00 00	 cmp	 QWORD PTR [rbx+376], 0
  009f9	75 10		 jne	 SHORT $LN29@type_new

; 2346 :         type->tp_getset = subtype_getsets_weakref_only;

  009fb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:subtype_getsets_weakref_only
  00a02	48 89 83 50 01
	00 00		 mov	 QWORD PTR [rbx+336], rax
  00a09	eb 2a		 jmp	 SHORT $LN26@type_new
$LN29@type_new:

; 2347 :     else if (!type->tp_weaklistoffset && type->tp_dictoffset)

  00a0b	48 85 c0	 test	 rax, rax
  00a0e	75 1a		 jne	 SHORT $LN27@type_new
$LN150@type_new:
  00a10	48 83 bb 78 01
	00 00 00	 cmp	 QWORD PTR [rbx+376], 0
  00a18	74 10		 je	 SHORT $LN27@type_new

; 2348 :         type->tp_getset = subtype_getsets_dict_only;

  00a1a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:subtype_getsets_dict_only
  00a21	48 89 83 50 01
	00 00		 mov	 QWORD PTR [rbx+336], rax

; 2349 :     else

  00a28	eb 0b		 jmp	 SHORT $LN26@type_new
$LN27@type_new:

; 2350 :         type->tp_getset = NULL;

  00a2a	48 c7 83 50 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rbx+336], 0
$LN26@type_new:

; 2351 : 
; 2352 :     /* Special case some slots */
; 2353 :     if (type->tp_dictoffset != 0 || nslots > 0) {

  00a35	48 83 bb 78 01
	00 00 00	 cmp	 QWORD PTR [rbx+376], 0
  00a3d	75 05		 jne	 SHORT $LN24@type_new
  00a3f	4d 85 ff	 test	 r15, r15
  00a42	7e 44		 jle	 SHORT $LN22@type_new
$LN24@type_new:

; 2354 :         if (base->tp_getattr == NULL && base->tp_getattro == NULL)

  00a44	48 83 bd 98 00
	00 00 00	 cmp	 QWORD PTR [rbp+152], 0
  00a4c	75 18		 jne	 SHORT $LN23@type_new
  00a4e	48 83 bd e8 00
	00 00 00	 cmp	 QWORD PTR [rbp+232], 0
  00a56	75 0e		 jne	 SHORT $LN23@type_new

; 2355 :             type->tp_getattro = PyObject_GenericGetAttr;

  00a58	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyObject_GenericGetAttr
  00a5f	48 89 83 e8 00
	00 00		 mov	 QWORD PTR [rbx+232], rax
$LN23@type_new:

; 2356 :         if (base->tp_setattr == NULL && base->tp_setattro == NULL)

  00a66	48 83 bd a0 00
	00 00 00	 cmp	 QWORD PTR [rbp+160], 0
  00a6e	75 18		 jne	 SHORT $LN22@type_new
  00a70	48 83 bd f0 00
	00 00 00	 cmp	 QWORD PTR [rbp+240], 0
  00a78	75 0e		 jne	 SHORT $LN22@type_new

; 2357 :             type->tp_setattro = PyObject_GenericSetAttr;

  00a7a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyObject_GenericSetAttr
  00a81	48 89 83 f0 00
	00 00		 mov	 QWORD PTR [rbx+240], rax
$LN22@type_new:

; 2358 :     }
; 2359 :     type->tp_dealloc = subtype_dealloc;

  00a88	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:subtype_dealloc
  00a8f	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax

; 2360 : 
; 2361 :     /* Enable GC unless there are really no instance variables possible */
; 2362 :     if (!(type->tp_basicsize == sizeof(PyObject) &&
; 2363 :           type->tp_itemsize == 0))

  00a96	48 83 ff 60	 cmp	 rdi, 96			; 00000060H
  00a9a	75 0a		 jne	 SHORT $LN20@type_new
  00a9c	48 83 bb 80 00
	00 00 00	 cmp	 QWORD PTR [rbx+128], 0
  00aa4	74 0a		 je	 SHORT $LN21@type_new
$LN20@type_new:

; 2364 :         type->tp_flags |= Py_TPFLAGS_HAVE_GC;

  00aa6	81 8b 00 01 00
	00 00 40 00 00	 or	 DWORD PTR [rbx+256], 16384 ; 00004000H
$LN21@type_new:

; 2365 : 
; 2366 :     /* Always override allocation strategy to use regular heap */
; 2367 :     type->tp_alloc = PyType_GenericAlloc;
; 2368 :     if (type->tp_flags & Py_TPFLAGS_HAVE_GC) {

  00ab0	f7 83 00 01 00
	00 00 40 00 00	 test	 DWORD PTR [rbx+256], 16384 ; 00004000H
  00aba	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyType_GenericAlloc
  00ac1	48 89 83 88 01
	00 00		 mov	 QWORD PTR [rbx+392], rax
  00ac8	74 2c		 je	 SHORT $LN19@type_new

; 2369 :         type->tp_free = PyObject_GC_Del;

  00aca	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyObject_GC_Del
  00ad1	48 89 83 98 01
	00 00		 mov	 QWORD PTR [rbx+408], rax

; 2370 :         type->tp_traverse = subtype_traverse;

  00ad8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:subtype_traverse
  00adf	48 89 83 10 01
	00 00		 mov	 QWORD PTR [rbx+272], rax

; 2371 :         type->tp_clear = subtype_clear;

  00ae6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:subtype_clear
  00aed	48 89 83 18 01
	00 00		 mov	 QWORD PTR [rbx+280], rax

; 2372 :     }
; 2373 :     else

  00af4	eb 0e		 jmp	 SHORT $LN18@type_new
$LN19@type_new:

; 2374 :         type->tp_free = PyObject_Del;

  00af6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyObject_Free
  00afd	48 89 83 98 01
	00 00		 mov	 QWORD PTR [rbx+408], rax
$LN18@type_new:

; 2375 : 
; 2376 :     /* Initialize the rest */
; 2377 :     if (PyType_Ready(type) < 0)

  00b04	48 8b cb	 mov	 rcx, rbx
  00b07	e8 00 00 00 00	 call	 PyType_Ready
  00b0c	85 c0		 test	 eax, eax
  00b0e	0f 88 e7 f7 ff
	ff		 js	 $error$21872

; 2378 :         goto error;
; 2379 : 
; 2380 :     /* Put the proper slots in place */
; 2381 :     fixup_slot_dispatchers(type);

  00b14	48 8b cb	 mov	 rcx, rbx
  00b17	e8 00 00 00 00	 call	 fixup_slot_dispatchers

; 2382 : 
; 2383 :     Py_DECREF(dict);

  00b1c	49 8b cc	 mov	 rcx, r12
  00b1f	e8 00 00 00 00	 call	 _Py_DecRef

; 2384 :     return (PyObject *)type;

  00b24	48 8b c3	 mov	 rax, rbx
  00b27	e9 09 f8 ff ff	 jmp	 $LN146@type_new
type_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@NDDPBGNB@invalid?5slot?5offset?$AA@	; `string'
PUBLIC	PyType_FromSpecWithBases
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyType_FromSpecWithBases DD imagerel $LN47
	DD	imagerel $LN47+85
	DD	imagerel $unwind$PyType_FromSpecWithBases
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyType_FromSpecWithBases DD imagerel $LN47+85
	DD	imagerel $LN47+339
	DD	imagerel $chain$2$PyType_FromSpecWithBases
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyType_FromSpecWithBases DD imagerel $LN47+339
	DD	imagerel $LN47+800
	DD	imagerel $chain$4$PyType_FromSpecWithBases
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyType_FromSpecWithBases DD 060021H
	DD	0cd400H
	DD	0b7400H
	DD	0a5400H
	DD	imagerel $LN47
	DD	imagerel $LN47+85
	DD	imagerel $unwind$PyType_FromSpecWithBases
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyType_FromSpecWithBases DD 061321H
	DD	0cd413H
	DD	0b740aH
	DD	0a5405H
	DD	imagerel $LN47
	DD	imagerel $LN47+85
	DD	imagerel $unwind$PyType_FromSpecWithBases
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyType_FromSpecWithBases DD 040901H
	DD	0c0055209H
	DD	030026003H
xdata	ENDS
;	COMDAT ??_C@_0BE@NDDPBGNB@invalid?5slot?5offset?$AA@
CONST	SEGMENT
??_C@_0BE@NDDPBGNB@invalid?5slot?5offset?$AA@ DB 'invalid slot offset', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\typeobject.c
CONST	ENDS
;	COMDAT PyType_FromSpecWithBases
_TEXT	SEGMENT
spec$ = 80
bases$ = 88
PyType_FromSpecWithBases PROC				; COMDAT

; 2401 : {

$LN47:
  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	41 54		 push	 r12
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00009	4c 8b e1	 mov	 r12, rcx
  0000c	48 8b da	 mov	 rbx, rdx

; 2402 :     PyHeapTypeObject *res = (PyHeapTypeObject*)PyType_GenericAlloc(&PyType_Type, 0);

  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyType_Type
  00016	33 d2		 xor	 edx, edx
  00018	e8 00 00 00 00	 call	 PyType_GenericAlloc

; 2403 :     PyTypeObject *type, *base;
; 2404 :     char *s;
; 2405 :     char *res_start = (char*)res;
; 2406 :     PyType_Slot *slot;
; 2407 :     
; 2408 :     /* Set the type name and qualname */
; 2409 :     s = strrchr(spec->name, '.');

  0001d	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
  00021	ba 2e 00 00 00	 mov	 edx, 46			; 0000002eH
  00026	48 8b f0	 mov	 rsi, rax
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strrchr
  0002f	48 8b c8	 mov	 rcx, rax

; 2410 :     if (s == NULL)

  00032	48 85 c0	 test	 rax, rax
  00035	75 06		 jne	 SHORT $LN29@PyType_Fro

; 2411 :         s = (char*)spec->name;

  00037	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]

; 2412 :     else

  0003b	eb 03		 jmp	 SHORT $LN28@PyType_Fro
$LN29@PyType_Fro:

; 2413 :         s++;

  0003d	48 ff c1	 inc	 rcx
$LN28@PyType_Fro:

; 2414 : 
; 2415 :     if (res == NULL)

  00040	48 85 f6	 test	 rsi, rsi
  00043	75 0b		 jne	 SHORT $LN27@PyType_Fro

; 2416 :         return NULL;

  00045	33 c0		 xor	 eax, eax

; 2521 : }

  00047	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004b	41 5c		 pop	 r12
  0004d	5e		 pop	 rsi
  0004e	5b		 pop	 rbx
  0004f	c3		 ret	 0
$LN27@PyType_Fro:

; 2417 :     type = &res->ht_type;
; 2418 :     /* The flags must be initialized early, before the GC traverses us */
; 2419 :     type->tp_flags = spec->flags | Py_TPFLAGS_HEAPTYPE;

  00050	41 8b 44 24 10	 mov	 eax, DWORD PTR [r12+16]
  00055	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  0005a	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi
  0005f	0f ba e8 09	 bts	 eax, 9
  00063	4c 89 6c 24 60	 mov	 QWORD PTR [rsp+96], r13
  00068	89 86 00 01 00
	00		 mov	 DWORD PTR [rsi+256], eax

; 2420 :     res->ht_name = PyUnicode_FromString(s);

  0006e	e8 00 00 00 00	 call	 PyUnicode_FromString
  00073	48 8b f8	 mov	 rdi, rax
  00076	48 89 86 68 03
	00 00		 mov	 QWORD PTR [rsi+872], rax

; 2421 :     if (!res->ht_name)

  0007d	48 85 c0	 test	 rax, rax
  00080	0f 84 ab 00 00
	00		 je	 $fail$22311

; 2422 :         goto fail;
; 2423 :     res->ht_qualname = res->ht_name;

  00086	48 89 86 78 03
	00 00		 mov	 QWORD PTR [rsi+888], rax

; 2424 :     Py_INCREF(res->ht_qualname);

  0008d	e8 00 00 00 00	 call	 _Py_PXCTX
  00092	85 c0		 test	 eax, eax
  00094	75 32		 jne	 SHORT $LN33@PyType_Fro
  00096	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000a4	4c 8b cf	 mov	 r9, rdi
  000a7	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000ad	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000b5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ba	85 c0		 test	 eax, eax
  000bc	75 06		 jne	 SHORT $LN32@PyType_Fro
  000be	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  000c2	74 04		 je	 SHORT $LN33@PyType_Fro
$LN32@PyType_Fro:
  000c4	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN33@PyType_Fro:

; 2425 :     type->tp_name = spec->name;

  000c8	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  000cc	48 89 46 70	 mov	 QWORD PTR [rsi+112], rax

; 2426 :     if (!type->tp_name)

  000d0	48 85 c0	 test	 rax, rax
  000d3	74 5c		 je	 SHORT $fail$22311

; 2427 :         goto fail;
; 2428 :     
; 2429 :     /* Adjust for empty tuple bases */
; 2430 :     if (!bases) {

  000d5	48 85 db	 test	 rbx, rbx
  000d8	75 79		 jne	 SHORT $LN24@PyType_Fro

; 2431 :         base = &PyBaseObject_Type;
; 2432 :         /* See whether Py_tp_base(s) was specified */
; 2433 :         for (slot = spec->slots; slot->slot; slot++) {

  000da	49 8b 7c 24 18	 mov	 rdi, QWORD PTR [r12+24]
  000df	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:PyBaseObject_Type
  000e6	8b 07		 mov	 eax, DWORD PTR [rdi]
  000e8	85 c0		 test	 eax, eax
  000ea	74 30		 je	 SHORT $LN43@PyType_Fro
  000ec	0f 1f 40 00	 npad	 4
$LL23@PyType_Fro:

; 2434 :             if (slot->slot == Py_tp_base)

  000f0	83 f8 30	 cmp	 eax, 48			; 00000030H
  000f3	75 06		 jne	 SHORT $LN20@PyType_Fro

; 2435 :                 base = slot->pfunc;

  000f5	48 8b 6f 08	 mov	 rbp, QWORD PTR [rdi+8]
  000f9	eb 11		 jmp	 SHORT $LN22@PyType_Fro
$LN20@PyType_Fro:

; 2436 :             else if (slot->slot == Py_tp_bases) {

  000fb	83 f8 31	 cmp	 eax, 49			; 00000031H
  000fe	75 0c		 jne	 SHORT $LN22@PyType_Fro

; 2437 :                 bases = slot->pfunc;

  00100	48 8b 5f 08	 mov	 rbx, QWORD PTR [rdi+8]

; 2438 :                 Py_INCREF(bases);

  00104	48 8b cb	 mov	 rcx, rbx
  00107	e8 00 00 00 00	 call	 _Py_IncRef
$LN22@PyType_Fro:

; 2431 :         base = &PyBaseObject_Type;
; 2432 :         /* See whether Py_tp_base(s) was specified */
; 2433 :         for (slot = spec->slots; slot->slot; slot++) {

  0010c	8b 47 10	 mov	 eax, DWORD PTR [rdi+16]
  0010f	48 83 c7 10	 add	 rdi, 16
  00113	85 c0		 test	 eax, eax
  00115	75 d9		 jne	 SHORT $LL23@PyType_Fro

; 2439 :             }
; 2440 :         }
; 2441 :         if (!bases)

  00117	48 85 db	 test	 rbx, rbx
  0011a	75 3f		 jne	 SHORT $LN15@PyType_Fro
$LN43@PyType_Fro:

; 2442 :             bases = PyTuple_Pack(1, base);

  0011c	48 8b d5	 mov	 rdx, rbp
  0011f	b9 01 00 00 00	 mov	 ecx, 1
  00124	e8 00 00 00 00	 call	 PyTuple_Pack
  00129	48 8b d8	 mov	 rbx, rax

; 2443 :         if (!bases)

  0012c	48 85 c0	 test	 rax, rax
  0012f	75 2a		 jne	 SHORT $LN15@PyType_Fro
$fail$22311:

; 2517 : 
; 2518 :  fail:
; 2519 :     Py_DECREF(res);

  00131	48 8b ce	 mov	 rcx, rsi
  00134	e8 00 00 00 00	 call	 _Py_DecRef

; 2520 :     return NULL;

  00139	33 c0		 xor	 eax, eax
$LN46@PyType_Fro:
  0013b	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00140	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00145	4c 8b 6c 24 60	 mov	 r13, QWORD PTR [rsp+96]

; 2521 : }

  0014a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0014e	41 5c		 pop	 r12
  00150	5e		 pop	 rsi
  00151	5b		 pop	 rbx
  00152	c3		 ret	 0
$LN24@PyType_Fro:

; 2444 :             goto fail;
; 2445 :     }
; 2446 :     else
; 2447 :         Py_INCREF(bases);

  00153	48 8b cb	 mov	 rcx, rbx
  00156	e8 00 00 00 00	 call	 _Py_IncRef
$LN15@PyType_Fro:

; 2448 : 
; 2449 :     /* Calculate best base, and check that all bases are type objects */
; 2450 :     base = best_base(bases);

  0015b	48 8b cb	 mov	 rcx, rbx
  0015e	e8 00 00 00 00	 call	 best_base
  00163	48 8b f8	 mov	 rdi, rax

; 2451 :     if (base == NULL) {

  00166	48 85 c0	 test	 rax, rax
  00169	74 c6		 je	 SHORT $fail$22311

; 2452 :         goto fail;
; 2453 :     }
; 2454 :     if (!PyType_HasFeature(base, Py_TPFLAGS_BASETYPE)) {

  0016b	f7 80 00 01 00
	00 00 04 00 00	 test	 DWORD PTR [rax+256], 1024 ; 00000400H
  00175	75 19		 jne	 SHORT $LN13@PyType_Fro

; 2455 :         PyErr_Format(PyExc_TypeError,
; 2456 :                      "type '%.100s' is not an acceptable base type",
; 2457 :                      base->tp_name);

  00177	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  0017b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00182	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@NKNOGCEG@type?5?8?$CF?4100s?8?5is?5not?5an?5acceptab@
  00189	e8 00 00 00 00	 call	 PyErr_Format

; 2458 :         goto fail;

  0018e	eb a1		 jmp	 SHORT $fail$22311
$LN13@PyType_Fro:

; 2459 :     }
; 2460 : 
; 2461 :     /* Initialize essential fields */
; 2462 :     type->tp_as_number = &res->as_number;

  00190	48 8d 86 e0 01
	00 00		 lea	 rax, QWORD PTR [rsi+480]

; 2463 :     type->tp_as_sequence = &res->as_sequence;
; 2464 :     type->tp_as_mapping = &res->as_mapping;
; 2465 :     type->tp_as_buffer = &res->as_buffer;
; 2466 :     /* Set tp_base and tp_bases */
; 2467 :     type->tp_bases = bases;
; 2468 :     bases = NULL;
; 2469 :     Py_INCREF(base);

  00197	48 8b cf	 mov	 rcx, rdi
  0019a	48 89 9e a8 01
	00 00		 mov	 QWORD PTR [rsi+424], rbx
  001a1	48 89 86 b8 00
	00 00		 mov	 QWORD PTR [rsi+184], rax
  001a8	48 8d 86 08 03
	00 00		 lea	 rax, QWORD PTR [rsi+776]
  001af	48 89 86 c0 00
	00 00		 mov	 QWORD PTR [rsi+192], rax
  001b6	48 8d 86 f0 02
	00 00		 lea	 rax, QWORD PTR [rsi+752]
  001bd	48 89 86 c8 00
	00 00		 mov	 QWORD PTR [rsi+200], rax
  001c4	48 8d 86 58 03
	00 00		 lea	 rax, QWORD PTR [rsi+856]
  001cb	48 89 86 f8 00
	00 00		 mov	 QWORD PTR [rsi+248], rax
  001d2	e8 00 00 00 00	 call	 _Py_IncRef

; 2470 :     type->tp_base = base;

  001d7	48 89 be 58 01
	00 00		 mov	 QWORD PTR [rsi+344], rdi

; 2471 : 
; 2472 :     type->tp_basicsize = spec->basicsize;

  001de	49 63 44 24 08	 movsxd	 rax, DWORD PTR [r12+8]
  001e3	48 89 46 78	 mov	 QWORD PTR [rsi+120], rax

; 2473 :     type->tp_itemsize = spec->itemsize;

  001e7	49 63 44 24 0c	 movsxd	 rax, DWORD PTR [r12+12]
  001ec	48 89 86 80 00
	00 00		 mov	 QWORD PTR [rsi+128], rax

; 2474 : 
; 2475 :     for (slot = spec->slots; slot->slot; slot++) {

  001f3	49 8b 5c 24 18	 mov	 rbx, QWORD PTR [r12+24]
  001f8	8b 03		 mov	 eax, DWORD PTR [rbx]
  001fa	85 c0		 test	 eax, eax
  001fc	74 75		 je	 SHORT $LN10@PyType_Fro
  001fe	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:slotoffsets
$LL12@PyType_Fro:

; 2476 :         if (slot->slot >= Py_ARRAY_LENGTH(slotoffsets)) {

  00205	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  00208	0f 83 fa 00 00
	00		 jae	 $LN38@PyType_Fro

; 2479 :         }
; 2480 :         if (slot->slot == Py_tp_base || slot->slot == Py_tp_bases)

  0020e	83 f8 30	 cmp	 eax, 48			; 00000030H
  00211	74 55		 je	 SHORT $LN11@PyType_Fro
  00213	83 f8 31	 cmp	 eax, 49			; 00000031H
  00216	74 50		 je	 SHORT $LN11@PyType_Fro

; 2481 :             /* Processed above */
; 2482 :             continue;
; 2483 :         *(void**)(res_start + slotoffsets[slot->slot]) = slot->pfunc;

  00218	48 98		 cdqe
  0021a	49 0f bf 4c 45
	00		 movsx	 rcx, WORD PTR [r13+rax*2]
  00220	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00224	48 89 04 31	 mov	 QWORD PTR [rcx+rsi], rax

; 2484 : 
; 2485 :         /* need to make a copy of the docstring slot, which usually
; 2486 :            points to a static string literal */
; 2487 :         if (slot->slot == Py_tp_doc) {

  00228	83 3b 38	 cmp	 DWORD PTR [rbx], 56	; 00000038H
  0022b	75 3b		 jne	 SHORT $LN11@PyType_Fro

; 2488 :             size_t len = strlen(slot->pfunc)+1;

  0022d	48 8b 7b 08	 mov	 rdi, QWORD PTR [rbx+8]
  00231	48 83 c9 ff	 or	 rcx, -1
  00235	33 c0		 xor	 eax, eax
  00237	f2 ae		 repne scasb
  00239	48 f7 d1	 not	 rcx
  0023c	48 8d 69 ff	 lea	 rbp, QWORD PTR [rcx-1]

; 2489 :             char *tp_doc = PyObject_MALLOC(len);

  00240	e8 00 00 00 00	 call	 PyObject_Malloc
  00245	48 8b f8	 mov	 rdi, rax

; 2490 :             if (tp_doc == NULL)

  00248	48 85 c0	 test	 rax, rax
  0024b	0f 84 e0 fe ff
	ff		 je	 $fail$22311

; 2491 :                 goto fail;
; 2492 :             memcpy(tp_doc, slot->pfunc, len);

  00251	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  00255	4c 8d 45 01	 lea	 r8, QWORD PTR [rbp+1]
  00259	48 8b c8	 mov	 rcx, rax
  0025c	e8 00 00 00 00	 call	 memcpy

; 2493 :             type->tp_doc = tp_doc;

  00261	48 89 be 08 01
	00 00		 mov	 QWORD PTR [rsi+264], rdi
$LN11@PyType_Fro:

; 2474 : 
; 2475 :     for (slot = spec->slots; slot->slot; slot++) {

  00268	8b 43 10	 mov	 eax, DWORD PTR [rbx+16]
  0026b	48 83 c3 10	 add	 rbx, 16
  0026f	85 c0		 test	 eax, eax
  00271	75 92		 jne	 SHORT $LL12@PyType_Fro
$LN10@PyType_Fro:

; 2494 :         }
; 2495 :     }
; 2496 :     if (type->tp_dictoffset) {

  00273	48 83 be 78 01
	00 00 00	 cmp	 QWORD PTR [rsi+376], 0
  0027b	74 0c		 je	 SHORT $LN4@PyType_Fro

; 2497 :         res->ht_cached_keys = _PyDict_NewKeysForClass();

  0027d	e8 00 00 00 00	 call	 _PyDict_NewKeysForClass
  00282	48 89 86 80 03
	00 00		 mov	 QWORD PTR [rsi+896], rax
$LN4@PyType_Fro:

; 2498 :     }
; 2499 :     if (type->tp_dealloc == NULL) {

  00289	48 8b 86 88 00
	00 00		 mov	 rax, QWORD PTR [rsi+136]
  00290	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:subtype_dealloc
  00297	48 83 f8 00	 cmp	 rax, 0
  0029b	48 0f 44 c1	 cmove	 rax, rcx

; 2500 :         /* It's a heap type, so needs the heap types' dealloc.
; 2501 :            subtype_dealloc will call the base type's tp_dealloc, if
; 2502 :            necessary. */
; 2503 :         type->tp_dealloc = subtype_dealloc;
; 2504 :     }
; 2505 : 
; 2506 :     if (PyType_Ready(type) < 0)

  0029f	48 8b ce	 mov	 rcx, rsi
  002a2	48 89 86 88 00
	00 00		 mov	 QWORD PTR [rsi+136], rax
  002a9	e8 00 00 00 00	 call	 PyType_Ready
  002ae	85 c0		 test	 eax, eax
  002b0	0f 88 7b fe ff
	ff		 js	 $fail$22311

; 2507 :         goto fail;
; 2508 : 
; 2509 :     /* Set type.__module__ */
; 2510 :     s = strrchr(spec->name, '.');

  002b6	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
  002ba	ba 2e 00 00 00	 mov	 edx, 46			; 0000002eH
  002bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strrchr

; 2511 :     if (s != NULL)

  002c5	48 85 c0	 test	 rax, rax
  002c8	74 36		 je	 SHORT $LN1@PyType_Fro

; 2512 :         _PyDict_SetItemId(type->tp_dict, &PyId___module__, 
; 2513 :             PyUnicode_FromStringAndSize(
; 2514 :                 spec->name, (Py_ssize_t)(s - spec->name)));

  002ca	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
  002ce	48 2b c1	 sub	 rax, rcx
  002d1	48 8b d0	 mov	 rdx, rax
  002d4	e8 00 00 00 00	 call	 PyUnicode_FromStringAndSize
  002d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002df	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId___module__
  002e4	4c 8b c0	 mov	 r8, rax
  002e7	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  002f0	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  002f4	48 8b 8e 60 01
	00 00		 mov	 rcx, QWORD PTR [rsi+352]
  002fb	e8 00 00 00 00	 call	 _PyDict_SetItemId
$LN1@PyType_Fro:

; 2515 : 
; 2516 :     return (PyObject*)res;

  00300	48 8b c6	 mov	 rax, rsi
  00303	e9 33 fe ff ff	 jmp	 $LN46@PyType_Fro
$LN38@PyType_Fro:

; 2477 :             PyErr_SetString(PyExc_RuntimeError, "invalid slot offset");

  00308	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  0030f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@NDDPBGNB@invalid?5slot?5offset?$AA@
  00316	e8 00 00 00 00	 call	 PyErr_SetString

; 2478 :             goto fail;

  0031b	e9 11 fe ff ff	 jmp	 $fail$22311
PyType_FromSpecWithBases ENDP
_TEXT	ENDS
PUBLIC	PyType_FromSpec
; Function compile flags: /Ogtpy
;	COMDAT PyType_FromSpec
_TEXT	SEGMENT
spec$ = 8
PyType_FromSpec PROC					; COMDAT

; 2526 :     return PyType_FromSpecWithBases(spec, NULL);

  00000	33 d2		 xor	 edx, edx

; 2527 : }

  00002	e9 00 00 00 00	 jmp	 PyType_FromSpecWithBases
PyType_FromSpec ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@FCBLAPIP@type?5object?5?8?$CF?450s?8?5has?5no?5attri@ ; `string'
PUBLIC	??_C@_0CM@IFFJPMHG@attribute?5name?5must?5be?5string?0?5n@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$type_getattro DD imagerel type_getattro
	DD	imagerel type_getattro+178
	DD	imagerel $unwind$type_getattro
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$type_getattro DD imagerel type_getattro+178
	DD	imagerel type_getattro+322
	DD	imagerel $chain$2$type_getattro
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$type_getattro DD imagerel type_getattro+322
	DD	imagerel type_getattro+342
	DD	imagerel $chain$3$type_getattro
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$type_getattro DD 021H
	DD	imagerel type_getattro
	DD	imagerel type_getattro+178
	DD	imagerel $unwind$type_getattro
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$type_getattro DD 020521H
	DD	083405H
	DD	imagerel type_getattro
	DD	imagerel type_getattro+178
	DD	imagerel $unwind$type_getattro
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_getattro DD 086b01H
	DD	0a746bH
	DD	095460H
	DD	0d006320aH
	DD	06002c004H
xdata	ENDS
;	COMDAT ??_C@_0CK@FCBLAPIP@type?5object?5?8?$CF?450s?8?5has?5no?5attri@
CONST	SEGMENT
??_C@_0CK@FCBLAPIP@type?5object?5?8?$CF?450s?8?5has?5no?5attri@ DB 'type '
	DB	'object ''%.50s'' has no attribute ''%U''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@IFFJPMHG@attribute?5name?5must?5be?5string?0?5n@
CONST	SEGMENT
??_C@_0CM@IFFJPMHG@attribute?5name?5must?5be?5string?0?5n@ DB 'attribute '
	DB	'name must be string, not ''%.200s''', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT type_getattro
_TEXT	SEGMENT
type$ = 64
name$ = 72
type_getattro PROC					; COMDAT

; 2601 : {

  00000	40 56		 push	 rsi
  00002	41 54		 push	 r12
  00004	41 55		 push	 r13
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2602 :     PyTypeObject *metatype = Py_TYPE(type);
; 2603 :     PyObject *meta_attribute, *attribute;
; 2604 :     descrgetfunc meta_get;
; 2605 : 
; 2606 :     if (!PyUnicode_Check(name)) {

  0000a	4c 8b 42 58	 mov	 r8, QWORD PTR [rdx+88]
  0000e	4c 8b 69 58	 mov	 r13, QWORD PTR [rcx+88]
  00012	4c 8b e2	 mov	 r12, rdx
  00015	41 f7 80 00 01
	00 00 00 00 00
	10		 test	 DWORD PTR [r8+256], 268435456 ; 10000000H
  00020	48 8b f1	 mov	 rsi, rcx
  00023	75 23		 jne	 SHORT $LN13@type_getat

; 2607 :         PyErr_Format(PyExc_TypeError,
; 2608 :                      "attribute name must be string, not '%.200s'",
; 2609 :                      name->ob_type->tp_name);

  00025	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00029	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@IFFJPMHG@attribute?5name?5must?5be?5string?0?5n@
  00037	e8 00 00 00 00	 call	 PyErr_Format
$LN19@type_getat:

; 2610 :         return NULL;

  0003c	33 c0		 xor	 eax, eax

; 2679 : }

  0003e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00042	41 5d		 pop	 r13
  00044	41 5c		 pop	 r12
  00046	5e		 pop	 rsi
  00047	c3		 ret	 0
$LN13@type_getat:

; 2611 :     }
; 2612 : 
; 2613 :     /* Initialize this type (we'll assume the metatype is initialized) */
; 2614 :     if (type->tp_dict == NULL) {

  00048	48 83 b9 60 01
	00 00 00	 cmp	 QWORD PTR [rcx+352], 0
  00050	75 09		 jne	 SHORT $LN11@type_getat

; 2615 :         if (PyType_Ready(type) < 0)

  00052	e8 00 00 00 00	 call	 PyType_Ready
  00057	85 c0		 test	 eax, eax

; 2616 :             return NULL;

  00059	78 e1		 js	 SHORT $LN19@type_getat
$LN11@type_getat:
  0005b	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp

; 2617 :     }
; 2618 : 
; 2619 :     /* No readable descriptor found yet */
; 2620 :     meta_get = NULL;
; 2621 : 
; 2622 :     /* Look for the attribute in the metatype */
; 2623 :     meta_attribute = _PyType_Lookup(metatype, name);

  00060	49 8b d4	 mov	 rdx, r12
  00063	49 8b cd	 mov	 rcx, r13
  00066	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  0006b	33 ed		 xor	 ebp, ebp
  0006d	e8 00 00 00 00	 call	 _PyType_Lookup
  00072	48 8b f8	 mov	 rdi, rax

; 2624 : 
; 2625 :     if (meta_attribute != NULL) {

  00075	48 85 c0	 test	 rax, rax
  00078	74 32		 je	 SHORT $LN10@type_getat

; 2626 :         meta_get = Py_TYPE(meta_attribute)->tp_descr_get;

  0007a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0007e	48 8b a8 68 01
	00 00		 mov	 rbp, QWORD PTR [rax+360]

; 2627 : 
; 2628 :         if (meta_get != NULL && PyDescr_IsData(meta_attribute)) {

  00085	48 85 ed	 test	 rbp, rbp
  00088	74 1a		 je	 SHORT $LN9@type_getat
  0008a	48 83 b8 70 01
	00 00 00	 cmp	 QWORD PTR [rax+368], 0
  00092	74 10		 je	 SHORT $LN9@type_getat

; 2629 :             /* Data descriptors implement tp_descr_set to intercept
; 2630 :              * writes. Assume the attribute is not overridden in
; 2631 :              * type's tp_dict (and bases): call the descriptor now.
; 2632 :              */
; 2633 :             return meta_get(meta_attribute, (PyObject *)type,
; 2634 :                             (PyObject *)metatype);

  00094	4d 8b c5	 mov	 r8, r13
  00097	48 8b d6	 mov	 rdx, rsi
  0009a	48 8b cf	 mov	 rcx, rdi
  0009d	ff d5		 call	 rbp
  0009f	e9 9e 00 00 00	 jmp	 $LN17@type_getat
$LN9@type_getat:

; 2635 :         }
; 2636 :         Py_INCREF(meta_attribute);

  000a4	48 8b cf	 mov	 rcx, rdi
  000a7	e8 00 00 00 00	 call	 _Py_IncRef
$LN10@type_getat:

; 2637 :     }
; 2638 : 
; 2639 :     /* No data descriptor found on metatype. Look in tp_dict of this
; 2640 :      * type and its bases */
; 2641 :     attribute = _PyType_Lookup(type, name);

  000ac	49 8b d4	 mov	 rdx, r12
  000af	48 8b ce	 mov	 rcx, rsi
  000b2	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  000b7	e8 00 00 00 00	 call	 _PyType_Lookup
  000bc	48 8b d8	 mov	 rbx, rax

; 2642 :     if (attribute != NULL) {

  000bf	48 85 c0	 test	 rax, rax
  000c2	74 33		 je	 SHORT $LN8@type_getat

; 2643 :         /* Implement descriptor functionality, if any */
; 2644 :         descrgetfunc local_get = Py_TYPE(attribute)->tp_descr_get;

  000c4	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000c8	48 8b a9 68 01
	00 00		 mov	 rbp, QWORD PTR [rcx+360]

; 2645 : 
; 2646 :         Py_XDECREF(meta_attribute);

  000cf	48 85 ff	 test	 rdi, rdi
  000d2	74 08		 je	 SHORT $LN6@type_getat
  000d4	48 8b cf	 mov	 rcx, rdi
  000d7	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@type_getat:

; 2647 : 
; 2648 :         if (local_get != NULL) {
; 2649 :             /* NULL 2nd argument indicates the descriptor was
; 2650 :              * found on the target object itself (or a base)  */
; 2651 :             return local_get(attribute, (PyObject *)NULL,
; 2652 :                              (PyObject *)type);

  000dc	48 8b cb	 mov	 rcx, rbx
  000df	48 85 ed	 test	 rbp, rbp
  000e2	74 09		 je	 SHORT $LN3@type_getat
  000e4	4c 8b c6	 mov	 r8, rsi
  000e7	33 d2		 xor	 edx, edx
  000e9	ff d5		 call	 rbp
  000eb	eb 50		 jmp	 SHORT $LN18@type_getat
$LN3@type_getat:

; 2653 :         }
; 2654 : 
; 2655 :         Py_INCREF(attribute);

  000ed	e8 00 00 00 00	 call	 _Py_IncRef

; 2656 :         return attribute;

  000f2	48 8b c3	 mov	 rax, rbx
  000f5	eb 46		 jmp	 SHORT $LN18@type_getat
$LN8@type_getat:

; 2657 :     }
; 2658 : 
; 2659 :     /* No attribute found in local __dict__ (or bases): use the
; 2660 :      * descriptor from the metatype, if any */
; 2661 :     if (meta_get != NULL) {

  000f7	48 85 ed	 test	 rbp, rbp
  000fa	74 1b		 je	 SHORT $LN2@type_getat

; 2662 :         PyObject *res;
; 2663 :         res = meta_get(meta_attribute, (PyObject *)type,
; 2664 :                        (PyObject *)metatype);

  000fc	4d 8b c5	 mov	 r8, r13
  000ff	48 8b d6	 mov	 rdx, rsi
  00102	48 8b cf	 mov	 rcx, rdi
  00105	ff d5		 call	 rbp

; 2665 :         Py_DECREF(meta_attribute);

  00107	48 8b cf	 mov	 rcx, rdi
  0010a	48 8b d8	 mov	 rbx, rax
  0010d	e8 00 00 00 00	 call	 _Py_DecRef

; 2666 :         return res;

  00112	48 8b c3	 mov	 rax, rbx
  00115	eb 26		 jmp	 SHORT $LN18@type_getat
$LN2@type_getat:

; 2667 :     }
; 2668 : 
; 2669 :     /* If an ordinary attribute was found on the metatype, return it now */
; 2670 :     if (meta_attribute != NULL) {

  00117	48 85 ff	 test	 rdi, rdi
  0011a	74 05		 je	 SHORT $LN1@type_getat

; 2671 :         return meta_attribute;

  0011c	48 8b c7	 mov	 rax, rdi
  0011f	eb 1c		 jmp	 SHORT $LN18@type_getat
$LN1@type_getat:

; 2672 :     }
; 2673 : 
; 2674 :     /* Give up */
; 2675 :     PyErr_Format(PyExc_AttributeError,
; 2676 :                  "type object '%.50s' has no attribute '%U'",
; 2677 :                  type->tp_name, name);

  00121	4c 8b 46 70	 mov	 r8, QWORD PTR [rsi+112]
  00125	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  0012c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@FCBLAPIP@type?5object?5?8?$CF?450s?8?5has?5no?5attri@
  00133	4d 8b cc	 mov	 r9, r12
  00136	e8 00 00 00 00	 call	 PyErr_Format

; 2678 :     return NULL;

  0013b	33 c0		 xor	 eax, eax
$LN18@type_getat:
  0013d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN17@type_getat:
  00142	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00147	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 2679 : }

  0014c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00150	41 5d		 pop	 r13
  00152	41 5c		 pop	 r12
  00154	5e		 pop	 rsi
  00155	c3		 ret	 0
type_getattro ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@KKPAOPLB@can?8t?5set?5attributes?5of?5built?9in@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$type_setattro DD imagerel type_setattro
	DD	imagerel type_setattro+95
	DD	imagerel $unwind$type_setattro
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_setattro DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0DF@KKPAOPLB@can?8t?5set?5attributes?5of?5built?9in@
CONST	SEGMENT
??_C@_0DF@KKPAOPLB@can?8t?5set?5attributes?5of?5built?9in@ DB 'can''t set'
	DB	' attributes of built-in/extension type ''%s''', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT type_setattro
_TEXT	SEGMENT
type$ = 48
name$ = 56
value$ = 64
type_setattro PROC					; COMDAT

; 2683 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2684 :     if (!(type->tp_flags & Py_TPFLAGS_HEAPTYPE)) {

  0000a	f7 81 00 01 00
	00 00 02 00 00	 test	 DWORD PTR [rcx+256], 512 ; 00000200H
  00014	48 8b fa	 mov	 rdi, rdx
  00017	48 8b d9	 mov	 rbx, rcx
  0001a	75 25		 jne	 SHORT $LN2@type_setat

; 2685 :         PyErr_Format(
; 2686 :             PyExc_TypeError,
; 2687 :             "can't set attributes of built-in/extension type '%s'",
; 2688 :             type->tp_name);

  0001c	4c 8b 41 70	 mov	 r8, QWORD PTR [rcx+112]
  00020	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@KKPAOPLB@can?8t?5set?5attributes?5of?5built?9in@
  0002e	e8 00 00 00 00	 call	 PyErr_Format
$LN5@type_setat:

; 2689 :         return -1;

  00033	83 c8 ff	 or	 eax, -1

; 2694 : }

  00036	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5f		 pop	 rdi
  00040	c3		 ret	 0
$LN2@type_setat:

; 2690 :     }
; 2691 :     if (PyObject_GenericSetAttr((PyObject *)type, name, value) < 0)

  00041	e8 00 00 00 00	 call	 PyObject_GenericSetAttr
  00046	85 c0		 test	 eax, eax

; 2692 :         return -1;

  00048	78 e9		 js	 SHORT $LN5@type_setat

; 2693 :     return update_slot(type, name);

  0004a	48 8b d7	 mov	 rdx, rdi
  0004d	48 8b cb	 mov	 rcx, rbx

; 2694 : }

  00050	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00055	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00059	5f		 pop	 rdi
  0005a	e9 00 00 00 00	 jmp	 update_slot
type_setattro ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@KMPAJIL@?$CFs?4__bases__?5must?5be?5tuple?5of?5cl@ ; `string'
PUBLIC	??_C@_0CN@FHOLHLPH@a?5__bases__?5item?5causes?5an?5inher@ ; `string'
PUBLIC	??_C@_0DI@HBHDIBPC@can?5only?5assign?5non?9empty?5tuple?5@ ; `string'
PUBLIC	??_C@_0CO@NIHOFPCP@can?5only?5assign?5tuple?5to?5?$CFs?4__ba@ ; `string'
EXTRN	PyList_Size:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$type_set_bases DD imagerel type_set_bases
	DD	imagerel type_set_bases+128
	DD	imagerel $unwind$type_set_bases
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$type_set_bases DD imagerel type_set_bases+128
	DD	imagerel type_set_bases+622
	DD	imagerel $chain$4$type_set_bases
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$type_set_bases DD imagerel type_set_bases+622
	DD	imagerel type_set_bases+657
	DD	imagerel $chain$6$type_set_bases
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$type_set_bases DD imagerel type_set_bases+657
	DD	imagerel type_set_bases+700
	DD	imagerel $chain$8$type_set_bases
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$type_set_bases DD imagerel type_set_bases+700
	DD	imagerel type_set_bases+856
	DD	imagerel $chain$10$type_set_bases
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$type_set_bases DD 0a0021H
	DD	08f400H
	DD	09e400H
	DD	010d400H
	DD	0fc400H
	DD	0e6400H
	DD	imagerel type_set_bases
	DD	imagerel type_set_bases+128
	DD	imagerel $unwind$type_set_bases
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$type_set_bases DD 020021H
	DD	0e6400H
	DD	imagerel type_set_bases
	DD	imagerel type_set_bases+128
	DD	imagerel $unwind$type_set_bases
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$type_set_bases DD 020021H
	DD	0e6400H
	DD	imagerel type_set_bases
	DD	imagerel type_set_bases+128
	DD	imagerel $unwind$type_set_bases
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$type_set_bases DD 0a9521H
	DD	08f495H
	DD	09e490H
	DD	010d488H
	DD	0fc480H
	DD	0e6405H
	DD	imagerel type_set_bases
	DD	imagerel type_set_bases+128
	DD	imagerel $unwind$type_set_bases
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_set_bases DD 040801H
	DD	070049208H
	DD	030025003H
xdata	ENDS
;	COMDAT ??_C@_0DA@KMPAJIL@?$CFs?4__bases__?5must?5be?5tuple?5of?5cl@
CONST	SEGMENT
??_C@_0DA@KMPAJIL@?$CFs?4__bases__?5must?5be?5tuple?5of?5cl@ DB '%s.__bas'
	DB	'es__ must be tuple of classes, not ''%s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@FHOLHLPH@a?5__bases__?5item?5causes?5an?5inher@
CONST	SEGMENT
??_C@_0CN@FHOLHLPH@a?5__bases__?5item?5causes?5an?5inher@ DB 'a __bases__'
	DB	' item causes an inheritance cycle', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@HBHDIBPC@can?5only?5assign?5non?9empty?5tuple?5@
CONST	SEGMENT
??_C@_0DI@HBHDIBPC@can?5only?5assign?5non?9empty?5tuple?5@ DB 'can only a'
	DB	'ssign non-empty tuple to %s.__bases__, not ()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@NIHOFPCP@can?5only?5assign?5tuple?5to?5?$CFs?4__ba@
CONST	SEGMENT
??_C@_0CO@NIHOFPCP@can?5only?5assign?5tuple?5to?5?$CFs?4__ba@ DB 'can onl'
	DB	'y assign tuple to %s.__bases__, not %s', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT type_set_bases
_TEXT	SEGMENT
cls$20710 = 48
type$ = 112
value$ = 120
context$ = 128
mro$20711 = 136
type_set_bases PROC					; COMDAT

; 484  : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	57		 push	 rdi
  00004	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 485  :     Py_ssize_t i;
; 486  :     int r = 0;
; 487  :     PyObject *ob, *temp;
; 488  :     PyTypeObject *new_base, *old_base;
; 489  :     PyObject *old_bases, *old_mro;
; 490  : 
; 491  :     if (!check_set_special_type_attr(type, value, "__bases__"))

  00008	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_09LJKDIEEK@__bases__?$AA@
  0000f	48 8b ea	 mov	 rbp, rdx
  00012	48 8b f9	 mov	 rdi, rcx
  00015	e8 00 00 00 00	 call	 check_set_special_type_attr
  0001a	85 c0		 test	 eax, eax

; 492  :         return -1;

  0001c	74 2c		 je	 SHORT $LN45@type_set_b

; 493  :     if (!PyTuple_Check(value)) {

  0001e	4c 8b 4d 58	 mov	 r9, QWORD PTR [rbp+88]
  00022	41 f7 81 00 01
	00 00 00 00 00
	04		 test	 DWORD PTR [r9+256], 67108864 ; 04000000H
  0002d	75 26		 jne	 SHORT $LN25@type_set_b

; 494  :         PyErr_Format(PyExc_TypeError,
; 495  :              "can only assign tuple to %s.__bases__, not %s",
; 496  :                  type->tp_name, Py_TYPE(value)->tp_name);

  0002f	4d 8b 49 70	 mov	 r9, QWORD PTR [r9+112]
  00033	4c 8b 47 70	 mov	 r8, QWORD PTR [rdi+112]
  00037	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@NIHOFPCP@can?5only?5assign?5tuple?5to?5?$CFs?4__ba@
  00045	e8 00 00 00 00	 call	 PyErr_Format
$LN45@type_set_b:

; 497  :         return -1;

  0004a	83 c8 ff	 or	 eax, -1

; 609  : }

  0004d	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00051	5f		 pop	 rdi
  00052	5d		 pop	 rbp
  00053	5b		 pop	 rbx
  00054	c3		 ret	 0
$LN25@type_set_b:

; 498  :     }
; 499  :     if (PyTuple_GET_SIZE(value) == 0) {

  00055	48 8b 5d 60	 mov	 rbx, QWORD PTR [rbp+96]
  00059	48 85 db	 test	 rbx, rbx
  0005c	75 22		 jne	 SHORT $LN24@type_set_b

; 500  :         PyErr_Format(PyExc_TypeError,
; 501  :              "can only assign non-empty tuple to %s.__bases__, not ()",
; 502  :                  type->tp_name);

  0005e	4c 8b 47 70	 mov	 r8, QWORD PTR [rdi+112]
  00062	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00069	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DI@HBHDIBPC@can?5only?5assign?5non?9empty?5tuple?5@
  00070	e8 00 00 00 00	 call	 PyErr_Format

; 503  :         return -1;

  00075	83 c8 ff	 or	 eax, -1

; 609  : }

  00078	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0007c	5f		 pop	 rdi
  0007d	5d		 pop	 rbp
  0007e	5b		 pop	 rbx
  0007f	c3		 ret	 0
$LN24@type_set_b:
  00080	48 89 74 24 70	 mov	 QWORD PTR [rsp+112], rsi

; 504  :     }
; 505  :     for (i = 0; i < PyTuple_GET_SIZE(value); i++) {

  00085	33 f6		 xor	 esi, esi
  00087	44 8b d6	 mov	 r10d, esi
  0008a	48 85 db	 test	 rbx, rbx
  0008d	7e 3a		 jle	 SHORT $LN21@type_set_b
  0008f	4c 8d 5d 70	 lea	 r11, QWORD PTR [rbp+112]
$LL23@type_set_b:

; 506  :         ob = PyTuple_GET_ITEM(value, i);

  00093	4d 8b 0b	 mov	 r9, QWORD PTR [r11]

; 507  :         if (!PyType_Check(ob)) {

  00096	49 8b 41 58	 mov	 rax, QWORD PTR [r9+88]
  0009a	f7 80 00 01 00
	00 00 00 00 80	 test	 DWORD PTR [rax+256], -2147483648 ; ffffffff80000000H
  000a4	0f 84 e7 01 00
	00		 je	 $LN33@type_set_b

; 512  :         }
; 513  :         if (PyType_IsSubtype((PyTypeObject*)ob, type)) {

  000aa	48 8b d7	 mov	 rdx, rdi
  000ad	49 8b c9	 mov	 rcx, r9
  000b0	e8 00 00 00 00	 call	 PyType_IsSubtype
  000b5	85 c0		 test	 eax, eax
  000b7	0f 85 b1 01 00
	00		 jne	 $LN34@type_set_b

; 504  :     }
; 505  :     for (i = 0; i < PyTuple_GET_SIZE(value); i++) {

  000bd	49 ff c2	 inc	 r10
  000c0	49 83 c3 08	 add	 r11, 8
  000c4	4c 3b d3	 cmp	 r10, rbx
  000c7	7c ca		 jl	 SHORT $LL23@type_set_b
$LN21@type_set_b:

; 517  :         }
; 518  :     }
; 519  : 
; 520  :     new_base = best_base(value);

  000c9	48 8b cd	 mov	 rcx, rbp
  000cc	e8 00 00 00 00	 call	 best_base
  000d1	48 8b d8	 mov	 rbx, rax

; 521  : 
; 522  :     if (!new_base)

  000d4	48 85 c0	 test	 rax, rax

; 523  :         return -1;

  000d7	0f 84 cf 01 00
	00		 je	 $LN44@type_set_b

; 524  : 
; 525  :     if (!compatible_for_assignment(type->tp_base, new_base, "__bases__"))

  000dd	48 8b 8f 58 01
	00 00		 mov	 rcx, QWORD PTR [rdi+344]
  000e4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_09LJKDIEEK@__bases__?$AA@
  000eb	48 8b d0	 mov	 rdx, rax
  000ee	e8 00 00 00 00	 call	 compatible_for_assignment
  000f3	85 c0		 test	 eax, eax

; 526  :         return -1;

  000f5	0f 84 b1 01 00
	00		 je	 $LN44@type_set_b

; 527  : 
; 528  :     Py_INCREF(new_base);

  000fb	4c 89 64 24 78	 mov	 QWORD PTR [rsp+120], r12
  00100	4c 89 ac 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], r13
  00108	48 8b cb	 mov	 rcx, rbx
  0010b	4c 89 74 24 48	 mov	 QWORD PTR [rsp+72], r14
  00110	4c 89 7c 24 40	 mov	 QWORD PTR [rsp+64], r15
  00115	e8 00 00 00 00	 call	 _Py_IncRef

; 529  :     Py_INCREF(value);

  0011a	48 8b cd	 mov	 rcx, rbp
  0011d	e8 00 00 00 00	 call	 _Py_IncRef

; 530  : 
; 531  :     old_bases = type->tp_bases;

  00122	4c 8b af a8 01
	00 00		 mov	 r13, QWORD PTR [rdi+424]

; 532  :     old_base = type->tp_base;

  00129	4c 8b bf 58 01
	00 00		 mov	 r15, QWORD PTR [rdi+344]

; 533  :     old_mro = type->tp_mro;

  00130	4c 8b b7 b0 01
	00 00		 mov	 r14, QWORD PTR [rdi+432]

; 534  : 
; 535  :     type->tp_bases = value;
; 536  :     type->tp_base = new_base;
; 537  : 
; 538  :     if (mro_internal(type) < 0) {

  00137	48 8b cf	 mov	 rcx, rdi
  0013a	48 89 af a8 01
	00 00		 mov	 QWORD PTR [rdi+424], rbp
  00141	48 89 9f 58 01
	00 00		 mov	 QWORD PTR [rdi+344], rbx
  00148	e8 00 00 00 00	 call	 mro_internal
  0014d	85 c0		 test	 eax, eax
  0014f	0f 88 b4 00 00
	00		 js	 $bail$20704

; 539  :         goto bail;
; 540  :     }
; 541  : 
; 542  :     temp = PyList_New(0);

  00155	33 c9		 xor	 ecx, ecx
  00157	e8 00 00 00 00	 call	 PyList_New
  0015c	48 8b d8	 mov	 rbx, rax

; 543  :     if (!temp)

  0015f	48 85 c0	 test	 rax, rax
  00162	0f 84 a1 00 00
	00		 je	 $bail$20704

; 544  :         goto bail;
; 545  : 
; 546  :     r = mro_subclasses(type, temp);

  00168	48 8b d0	 mov	 rdx, rax
  0016b	48 8b cf	 mov	 rcx, rdi
  0016e	e8 00 00 00 00	 call	 mro_subclasses

; 547  : 
; 548  :     if (r < 0) {
; 549  :         for (i = 0; i < PyList_Size(temp); i++) {

  00173	48 8b cb	 mov	 rcx, rbx
  00176	44 8b e0	 mov	 r12d, eax
  00179	85 c0		 test	 eax, eax
  0017b	0f 89 3b 01 00
	00		 jns	 $LN14@type_set_b
  00181	e8 00 00 00 00	 call	 PyList_Size
  00186	48 85 c0	 test	 rax, rax
  00189	7e 76		 jle	 SHORT $LN11@type_set_b
  0018b	0f 1f 44 00 00	 npad	 5
$LL13@type_set_b:

; 550  :             PyTypeObject* cls;
; 551  :             PyObject* mro;
; 552  :             PyArg_UnpackTuple(PyList_GET_ITEM(temp, i),
; 553  :                              "", 2, 2, &cls, &mro);

  00190	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  00194	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR mro$20711[rsp]
  0019c	41 b9 02 00 00
	00		 mov	 r9d, 2
  001a2	48 8b 0c f1	 mov	 rcx, QWORD PTR [rcx+rsi*8]
  001a6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001ab	48 8d 44 24 30	 lea	 rax, QWORD PTR cls$20710[rsp]
  001b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  001b7	45 8b c1	 mov	 r8d, r9d
  001ba	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001bf	e8 00 00 00 00	 call	 PyArg_UnpackTuple

; 554  :             Py_INCREF(mro);

  001c4	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR mro$20711[rsp]
  001cc	e8 00 00 00 00	 call	 _Py_IncRef

; 555  :             ob = cls->tp_mro;

  001d1	4c 8b 5c 24 30	 mov	 r11, QWORD PTR cls$20710[rsp]

; 556  :             cls->tp_mro = mro;

  001d6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR mro$20711[rsp]
  001de	49 8b 8b b0 01
	00 00		 mov	 rcx, QWORD PTR [r11+432]
  001e5	49 89 83 b0 01
	00 00		 mov	 QWORD PTR [r11+432], rax

; 557  :             Py_DECREF(ob);

  001ec	e8 00 00 00 00	 call	 _Py_DecRef
  001f1	48 8b cb	 mov	 rcx, rbx
  001f4	48 ff c6	 inc	 rsi
  001f7	e8 00 00 00 00	 call	 PyList_Size
  001fc	48 3b f0	 cmp	 rsi, rax
  001ff	7c 8f		 jl	 SHORT $LL13@type_set_b
$LN11@type_set_b:

; 558  :         }
; 559  :         Py_DECREF(temp);

  00201	48 8b cb	 mov	 rcx, rbx
  00204	e8 00 00 00 00	 call	 _Py_DecRef
$bail$20704:

; 596  : 
; 597  :   bail:
; 598  :     Py_DECREF(type->tp_bases);

  00209	48 8b 8f a8 01
	00 00		 mov	 rcx, QWORD PTR [rdi+424]
  00210	e8 00 00 00 00	 call	 _Py_DecRef

; 599  :     Py_DECREF(type->tp_base);

  00215	48 8b 8f 58 01
	00 00		 mov	 rcx, QWORD PTR [rdi+344]
  0021c	e8 00 00 00 00	 call	 _Py_DecRef

; 600  :     if (type->tp_mro != old_mro) {

  00221	48 8b 8f b0 01
	00 00		 mov	 rcx, QWORD PTR [rdi+432]
  00228	49 3b ce	 cmp	 rcx, r14
  0022b	74 05		 je	 SHORT $LN1@type_set_b

; 601  :         Py_DECREF(type->tp_mro);

  0022d	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@type_set_b:

; 602  :     }
; 603  : 
; 604  :     type->tp_bases = old_bases;

  00232	4c 89 af a8 01
	00 00		 mov	 QWORD PTR [rdi+424], r13

; 605  :     type->tp_base = old_base;

  00239	4c 89 bf 58 01
	00 00		 mov	 QWORD PTR [rdi+344], r15

; 606  :     type->tp_mro = old_mro;

  00240	4c 89 b7 b0 01
	00 00		 mov	 QWORD PTR [rdi+432], r14

; 607  : 
; 608  :     return -1;

  00247	83 c8 ff	 or	 eax, -1
$LN43@type_set_b:
  0024a	4c 8b 74 24 48	 mov	 r14, QWORD PTR [rsp+72]
  0024f	4c 8b ac 24 80
	00 00 00	 mov	 r13, QWORD PTR [rsp+128]
  00257	4c 8b 64 24 78	 mov	 r12, QWORD PTR [rsp+120]
  0025c	4c 8b 7c 24 40	 mov	 r15, QWORD PTR [rsp+64]
  00261	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]

; 609  : }

  00266	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0026a	5f		 pop	 rdi
  0026b	5d		 pop	 rbp
  0026c	5b		 pop	 rbx
  0026d	c3		 ret	 0
$LN34@type_set_b:

; 514  :             PyErr_SetString(PyExc_TypeError,
; 515  :                             "a __bases__ item causes an inheritance cycle");

  0026e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00275	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@FHOLHLPH@a?5__bases__?5item?5causes?5an?5inher@
  0027c	e8 00 00 00 00	 call	 PyErr_SetString
  00281	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]

; 516  :             return -1;

  00286	83 c8 ff	 or	 eax, -1

; 609  : }

  00289	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0028d	5f		 pop	 rdi
  0028e	5d		 pop	 rbp
  0028f	5b		 pop	 rbx
  00290	c3		 ret	 0
$LN33@type_set_b:

; 508  :             PyErr_Format(PyExc_TypeError,
; 509  :                          "%s.__bases__ must be tuple of classes, not '%s'",
; 510  :                          type->tp_name, Py_TYPE(ob)->tp_name);

  00291	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  00295	4c 8b 47 70	 mov	 r8, QWORD PTR [rdi+112]
  00299	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  002a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@KMPAJIL@?$CFs?4__bases__?5must?5be?5tuple?5of?5cl@
  002a7	e8 00 00 00 00	 call	 PyErr_Format
$LN44@type_set_b:

; 511  :             return -1;

  002ac	83 c8 ff	 or	 eax, -1
  002af	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]

; 609  : }

  002b4	48 83 c4 50	 add	 rsp, 80			; 00000050H
  002b8	5f		 pop	 rdi
  002b9	5d		 pop	 rbp
  002ba	5b		 pop	 rbx
  002bb	c3		 ret	 0
$LN14@type_set_b:

; 560  :         goto bail;
; 561  :     }
; 562  : 
; 563  :     Py_DECREF(temp);

  002bc	e8 00 00 00 00	 call	 _Py_DecRef

; 564  : 
; 565  :     /* any base that was in __bases__ but now isn't, we
; 566  :        need to remove |type| from its tp_subclasses.
; 567  :        conversely, any class now in __bases__ that wasn't
; 568  :        needs to have |type| added to its subclasses. */
; 569  : 
; 570  :     /* for now, sod that: just remove from all old_bases,
; 571  :        add to all new_bases */
; 572  : 
; 573  :     for (i = PyTuple_GET_SIZE(old_bases) - 1; i >= 0; i--) {

  002c1	49 8b 5d 60	 mov	 rbx, QWORD PTR [r13+96]
  002c5	48 ff cb	 dec	 rbx
  002c8	78 2a		 js	 SHORT $LN8@type_set_b

; 560  :         goto bail;
; 561  :     }
; 562  : 
; 563  :     Py_DECREF(temp);

  002ca	49 8d 74 dd 70	 lea	 rsi, QWORD PTR [r13+rbx*8+112]
  002cf	90		 npad	 1
$LL10@type_set_b:

; 574  :         ob = PyTuple_GET_ITEM(old_bases, i);

  002d0	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]

; 575  :         if (PyType_Check(ob)) {

  002d3	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  002d7	f7 80 00 01 00
	00 00 00 00 80	 test	 DWORD PTR [rax+256], -2147483648 ; ffffffff80000000H
  002e1	74 08		 je	 SHORT $LN9@type_set_b

; 576  :             remove_subclass(
; 577  :                 (PyTypeObject*)ob, type);

  002e3	48 8b d7	 mov	 rdx, rdi
  002e6	e8 00 00 00 00	 call	 remove_subclass
$LN9@type_set_b:

; 564  : 
; 565  :     /* any base that was in __bases__ but now isn't, we
; 566  :        need to remove |type| from its tp_subclasses.
; 567  :        conversely, any class now in __bases__ that wasn't
; 568  :        needs to have |type| added to its subclasses. */
; 569  : 
; 570  :     /* for now, sod that: just remove from all old_bases,
; 571  :        add to all new_bases */
; 572  : 
; 573  :     for (i = PyTuple_GET_SIZE(old_bases) - 1; i >= 0; i--) {

  002eb	48 83 ee 08	 sub	 rsi, 8
  002ef	48 ff cb	 dec	 rbx
  002f2	79 dc		 jns	 SHORT $LL10@type_set_b
$LN8@type_set_b:

; 578  :         }
; 579  :     }
; 580  : 
; 581  :     for (i = PyTuple_GET_SIZE(value) - 1; i >= 0; i--) {

  002f4	48 8b 75 60	 mov	 rsi, QWORD PTR [rbp+96]
  002f8	48 ff ce	 dec	 rsi
  002fb	78 33		 js	 SHORT $LN4@type_set_b
  002fd	48 8d 6c f5 70	 lea	 rbp, QWORD PTR [rbp+rsi*8+112]
  00302	83 cb ff	 or	 ebx, -1
$LL6@type_set_b:

; 582  :         ob = PyTuple_GET_ITEM(value, i);

  00305	48 8b 4d 00	 mov	 rcx, QWORD PTR [rbp]

; 583  :         if (PyType_Check(ob)) {

  00309	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0030d	f7 80 00 01 00
	00 00 00 00 80	 test	 DWORD PTR [rax+256], -2147483648 ; ffffffff80000000H
  00317	74 0e		 je	 SHORT $LN5@type_set_b

; 584  :             if (add_subclass((PyTypeObject*)ob, type) < 0)

  00319	48 8b d7	 mov	 rdx, rdi
  0031c	e8 00 00 00 00	 call	 add_subclass
  00321	85 c0		 test	 eax, eax
  00323	44 0f 48 e3	 cmovs	 r12d, ebx
$LN5@type_set_b:

; 578  :         }
; 579  :     }
; 580  : 
; 581  :     for (i = PyTuple_GET_SIZE(value) - 1; i >= 0; i--) {

  00327	48 83 ed 08	 sub	 rbp, 8
  0032b	48 ff ce	 dec	 rsi
  0032e	79 d5		 jns	 SHORT $LL6@type_set_b
$LN4@type_set_b:

; 585  :                 r = -1;
; 586  :         }
; 587  :     }
; 588  : 
; 589  :     update_all_slots(type);

  00330	48 8b cf	 mov	 rcx, rdi
  00333	e8 00 00 00 00	 call	 update_all_slots

; 590  : 
; 591  :     Py_DECREF(old_bases);

  00338	49 8b cd	 mov	 rcx, r13
  0033b	e8 00 00 00 00	 call	 _Py_DecRef

; 592  :     Py_DECREF(old_base);

  00340	49 8b cf	 mov	 rcx, r15
  00343	e8 00 00 00 00	 call	 _Py_DecRef

; 593  :     Py_DECREF(old_mro);

  00348	49 8b ce	 mov	 rcx, r14
  0034b	e8 00 00 00 00	 call	 _Py_DecRef

; 594  : 
; 595  :     return r;

  00350	41 8b c4	 mov	 eax, r12d
  00353	e9 f2 fe ff ff	 jmp	 $LN43@type_set_b
type_set_bases ENDP
_TEXT	ENDS
END
