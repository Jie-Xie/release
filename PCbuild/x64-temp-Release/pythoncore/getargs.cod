; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
EXTRN	__imp_free:PROC
EXTRN	_PxMem_Free:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\getargs.c
pdata	SEGMENT
$pdata$cleanup_ptr DD imagerel cleanup_ptr
	DD	imagerel cleanup_ptr+53
	DD	imagerel $unwind$cleanup_ptr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cleanup_ptr DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT cleanup_ptr
_TEXT	SEGMENT
self$ = 48
ptr$ = 56
cleanup_ptr PROC					; COMDAT

; 145  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b da	 mov	 rbx, rdx

; 146  :     if (ptr) {

  00009	48 85 d2	 test	 rdx, rdx
  0000c	74 1f		 je	 SHORT $LN6@cleanup_pt

; 147  :         PyMem_FREE(ptr);

  0000e	e8 00 00 00 00	 call	 _Py_PXCTX
  00013	48 8b cb	 mov	 rcx, rbx
  00016	85 c0		 test	 eax, eax
  00018	74 0d		 je	 SHORT $LN4@cleanup_pt
  0001a	e8 00 00 00 00	 call	 _PxMem_Free

; 148  :     }
; 149  :     return 0;

  0001f	33 c0		 xor	 eax, eax

; 150  : }

  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5b		 pop	 rbx
  00026	c3		 ret	 0
$LN4@cleanup_pt:

; 147  :         PyMem_FREE(ptr);

  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN6@cleanup_pt:

; 148  :     }
; 149  :     return 0;

  0002d	33 c0		 xor	 eax, eax

; 150  : }

  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5b		 pop	 rbx
  00034	c3		 ret	 0
cleanup_ptr ENDP
_TEXT	ENDS
EXTRN	PyBuffer_Release:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$cleanup_buffer DD imagerel cleanup_buffer
	DD	imagerel cleanup_buffer+24
	DD	imagerel $unwind$cleanup_buffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cleanup_buffer DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT cleanup_buffer
_TEXT	SEGMENT
self$ = 48
ptr$ = 56
cleanup_buffer PROC					; COMDAT

; 154  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 155  :     Py_buffer *buf = (Py_buffer *)ptr;
; 156  :     if (buf) {

  00004	48 85 d2	 test	 rdx, rdx
  00007	74 08		 je	 SHORT $LN4@cleanup_bu

; 157  :         PyBuffer_Release(buf);

  00009	48 8b ca	 mov	 rcx, rdx
  0000c	e8 00 00 00 00	 call	 PyBuffer_Release
$LN4@cleanup_bu:

; 158  :     }
; 159  :     return 0;

  00011	33 c0		 xor	 eax, eax

; 160  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
cleanup_buffer ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT addcleanup
_TEXT	SEGMENT
ptr$ = 8
freelist$ = 16
destructor$ = 24
addcleanup PROC						; COMDAT

; 165  :     int index;
; 166  : 
; 167  :     index = freelist->first_available;

  00000	4c 63 0a	 movsxd	 r9, DWORD PTR [rdx]

; 168  :     freelist->first_available += 1;
; 169  : 
; 170  :     freelist->entries[index].item = ptr;

  00003	4d 8b d1	 mov	 r10, r9
  00006	41 8d 41 01	 lea	 eax, DWORD PTR [r9+1]
  0000a	4d 03 d2	 add	 r10, r10
  0000d	89 02		 mov	 DWORD PTR [rdx], eax
  0000f	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00013	4a 89 0c d0	 mov	 QWORD PTR [rax+r10*8], rcx

; 171  :     freelist->entries[index].destructor = destructor;

  00017	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0001b	4e 89 44 d0 08	 mov	 QWORD PTR [rax+r10*8+8], r8

; 172  : 
; 173  :     return 0;

  00020	33 c0		 xor	 eax, eax

; 174  : }

  00022	c3		 ret	 0
addcleanup ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$cleanreturn DD imagerel cleanreturn
	DD	imagerel cleanreturn+19
	DD	imagerel $unwind$cleanreturn
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$cleanreturn DD imagerel cleanreturn+19
	DD	imagerel cleanreturn+30
	DD	imagerel $chain$0$cleanreturn
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$cleanreturn DD imagerel cleanreturn+30
	DD	imagerel cleanreturn+77
	DD	imagerel $chain$1$cleanreturn
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$cleanreturn DD imagerel cleanreturn+77
	DD	imagerel cleanreturn+82
	DD	imagerel $chain$2$cleanreturn
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$cleanreturn DD imagerel cleanreturn+82
	DD	imagerel cleanreturn+132
	DD	imagerel $chain$3$cleanreturn
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$cleanreturn DD 021H
	DD	imagerel cleanreturn
	DD	imagerel cleanreturn+19
	DD	imagerel $unwind$cleanreturn
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$cleanreturn DD 021H
	DD	imagerel cleanreturn+19
	DD	imagerel cleanreturn+30
	DD	imagerel $chain$0$cleanreturn
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$cleanreturn DD 020521H
	DD	066405H
	DD	imagerel cleanreturn+19
	DD	imagerel cleanreturn+30
	DD	imagerel $chain$0$cleanreturn
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$cleanreturn DD 020521H
	DD	077405H
	DD	imagerel cleanreturn
	DD	imagerel cleanreturn+19
	DD	imagerel $unwind$cleanreturn
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cleanreturn DD 040a01H
	DD	08340aH
	DD	05006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT cleanreturn
_TEXT	SEGMENT
retval$ = 48
freelist$ = 56
cleanreturn PROC					; COMDAT

; 178  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	8b e9		 mov	 ebp, ecx

; 179  :     int index;
; 180  : 
; 181  :     if (retval == 0) {

  0000f	85 c9		 test	 ecx, ecx
  00011	75 3f		 jne	 SHORT $LN1@cleanretur

; 182  :       /* A failure occurred, therefore execute all of the cleanup
; 183  :          functions.
; 184  :       */
; 185  :       for (index = 0; index < freelist->first_available; ++index) {

  00013	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00018	33 ff		 xor	 edi, edi
  0001a	39 3a		 cmp	 DWORD PTR [rdx], edi
  0001c	7e 2f		 jle	 SHORT $LN11@cleanretur
  0001e	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00023	8b f7		 mov	 esi, edi
  00025	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL3@cleanretur:

; 186  :           freelist->entries[index].destructor(NULL,
; 187  :                                               freelist->entries[index].item);

  00030	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00034	33 c9		 xor	 ecx, ecx
  00036	48 8b 14 30	 mov	 rdx, QWORD PTR [rax+rsi]
  0003a	ff 54 30 08	 call	 QWORD PTR [rax+rsi+8]
  0003e	ff c7		 inc	 edi
  00040	48 83 c6 10	 add	 rsi, 16
  00044	3b 3b		 cmp	 edi, DWORD PTR [rbx]
  00046	7c e8		 jl	 SHORT $LL3@cleanretur
  00048	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
$LN11@cleanretur:
  0004d	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
$LN1@cleanretur:

; 188  :       }
; 189  :     }
; 190  :     PyMem_FREE(freelist->entries);

  00052	e8 00 00 00 00	 call	 _Py_PXCTX
  00057	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0005b	85 c0		 test	 eax, eax
  0005d	74 12		 je	 SHORT $LN7@cleanretur
  0005f	e8 00 00 00 00	 call	 _PxMem_Free

; 191  :     return retval;

  00064	8b c5		 mov	 eax, ebp

; 192  : }

  00066	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0006b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006f	5d		 pop	 rbp
  00070	c3		 ret	 0
$LN7@cleanretur:

; 188  :       }
; 189  :     }
; 190  :     PyMem_FREE(freelist->entries);

  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 192  : }

  00077	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0007c	8b c5		 mov	 eax, ebp
  0007e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00082	5d		 pop	 rbp
  00083	c3		 ret	 0
cleanreturn ENDP
_TEXT	ENDS
PUBLIC	??_C@_07PLGIGANP@?5?$CF?4256s?$AA@		; `string'
PUBLIC	??_C@_08MNCFOIFH@argument?$AA@			; `string'
PUBLIC	??_C@_09LKNIBBFP@?0?5item?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_0M@CLHFBAMN@argument?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_09ONCPLENA@?$CF?4200s?$CI?$CJ?5?$AA@	; `string'
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyOS_snprintf:PROC
EXTRN	PyErr_Occurred:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$seterror DD imagerel seterror
	DD	imagerel seterror+387
	DD	imagerel $unwind$seterror
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$seterror DD 0b1d01H
	DD	049741dH
	DD	048641dH
	DD	047541dH
	DD	046341dH
	DD	044011dH
	DD	0c016H
xdata	ENDS
;	COMDAT ??_C@_07PLGIGANP@?5?$CF?4256s?$AA@
CONST	SEGMENT
??_C@_07PLGIGANP@?5?$CF?4256s?$AA@ DB ' %.256s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MNCFOIFH@argument?$AA@
CONST	SEGMENT
??_C@_08MNCFOIFH@argument?$AA@ DB 'argument', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LKNIBBFP@?0?5item?5?$CFd?$AA@
CONST	SEGMENT
??_C@_09LKNIBBFP@?0?5item?5?$CFd?$AA@ DB ', item %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CLHFBAMN@argument?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0M@CLHFBAMN@argument?5?$CFd?$AA@ DB 'argument %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09ONCPLENA@?$CF?4200s?$CI?$CJ?5?$AA@
CONST	SEGMENT
??_C@_09ONCPLENA@?$CF?4200s?$CI?$CJ?5?$AA@ DB '%.200s() ', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT seterror
_TEXT	SEGMENT
buf$ = 32
iarg$ = 560
msg$ = 568
levels$ = 576
fname$ = 584
message$ = 592
seterror PROC						; COMDAT

; 355  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 81 ec 20 02
	00 00		 sub	 rsp, 544		; 00000220H
  0001d	49 8b f9	 mov	 rdi, r9
  00020	49 8b e8	 mov	 rbp, r8
  00023	4c 8b e2	 mov	 r12, rdx
  00026	8b f1		 mov	 esi, ecx

; 356  :     char buf[512];
; 357  :     int i;
; 358  :     char *p = buf;

  00028	48 8d 5c 24 20	 lea	 rbx, QWORD PTR buf$[rsp]

; 359  : 
; 360  :     if (PyErr_Occurred())

  0002d	e8 00 00 00 00	 call	 PyErr_Occurred
  00032	48 85 c0	 test	 rax, rax
  00035	0f 85 2a 01 00
	00		 jne	 $LN9@seterror

; 361  :         return;
; 362  :     else if (message == NULL) {

  0003b	48 8b 94 24 50
	02 00 00	 mov	 rdx, QWORD PTR message$[rsp]
  00043	48 85 d2	 test	 rdx, rdx
  00046	0f 85 0d 01 00
	00		 jne	 $LN6@seterror

; 363  :         if (fname != NULL) {

  0004c	48 85 ff	 test	 rdi, rdi
  0004f	74 2e		 je	 SHORT $LN5@seterror

; 364  :             PyOS_snprintf(p, sizeof(buf), "%.200s() ", fname);

  00051	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_09ONCPLENA@?$CF?4200s?$CI?$CJ?5?$AA@
  00058	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  0005d	4c 8b cf	 mov	 r9, rdi
  00060	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  00065	e8 00 00 00 00	 call	 PyOS_snprintf

; 365  :             p += strlen(p);

  0006a	48 83 c9 ff	 or	 rcx, -1
  0006e	48 8d 7c 24 20	 lea	 rdi, QWORD PTR buf$[rsp]
  00073	33 c0		 xor	 eax, eax
  00075	f2 ae		 repne scasb
  00077	48 f7 d1	 not	 rcx
  0007a	48 8d 5c 0c 1f	 lea	 rbx, QWORD PTR buf$[rsp+rcx-1]
$LN5@seterror:

; 366  :         }
; 367  :         if (iarg != 0) {
; 368  :             PyOS_snprintf(p, sizeof(buf) - (p - buf),
; 369  :                           "argument %d", iarg);

  0007f	48 8d 94 24 20
	02 00 00	 lea	 rdx, QWORD PTR buf$[rsp+512]
  00087	48 8b cb	 mov	 rcx, rbx
  0008a	48 2b d3	 sub	 rdx, rbx
  0008d	85 f6		 test	 esi, esi
  0008f	0f 84 82 00 00
	00		 je	 $LN4@seterror
  00095	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0M@CLHFBAMN@argument?5?$CFd?$AA@
  0009c	44 8b ce	 mov	 r9d, esi
  0009f	e8 00 00 00 00	 call	 PyOS_snprintf

; 370  :             i = 0;
; 371  :             p += strlen(p);

  000a4	48 83 c9 ff	 or	 rcx, -1
  000a8	33 c0		 xor	 eax, eax
  000aa	48 8b fb	 mov	 rdi, rbx
  000ad	33 f6		 xor	 esi, esi
  000af	f2 ae		 repne scasb
  000b1	48 f7 d1	 not	 rcx
  000b4	48 ff c9	 dec	 rcx
  000b7	48 03 d9	 add	 rbx, rcx

; 372  :             while (levels[i] > 0 && i < 32 && (int)(p-buf) < 220) {

  000ba	39 45 00	 cmp	 DWORD PTR [rbp], eax
  000bd	7e 78		 jle	 SHORT $LN1@seterror
  000bf	90		 npad	 1
$LL3@seterror:
  000c0	48 83 fe 20	 cmp	 rsi, 32			; 00000020H
  000c4	7d 71		 jge	 SHORT $LN1@seterror
  000c6	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  000cb	8b c3		 mov	 eax, ebx
  000cd	2b c1		 sub	 eax, ecx
  000cf	3d dc 00 00 00	 cmp	 eax, 220		; 000000dcH
  000d4	7d 61		 jge	 SHORT $LN1@seterror

; 373  :                 PyOS_snprintf(p, sizeof(buf) - (p - buf),
; 374  :                               ", item %d", levels[i]-1);

  000d6	44 8b 4c b5 00	 mov	 r9d, DWORD PTR [rbp+rsi*4]
  000db	48 8d 94 24 20
	02 00 00	 lea	 rdx, QWORD PTR buf$[rsp+512]
  000e3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_09LKNIBBFP@?0?5item?5?$CFd?$AA@
  000ea	48 2b d3	 sub	 rdx, rbx
  000ed	48 8b cb	 mov	 rcx, rbx
  000f0	41 ff c9	 dec	 r9d
  000f3	e8 00 00 00 00	 call	 PyOS_snprintf

; 375  :                 p += strlen(p);

  000f8	48 83 c9 ff	 or	 rcx, -1
  000fc	33 c0		 xor	 eax, eax
  000fe	48 8b fb	 mov	 rdi, rbx

; 376  :                 i++;

  00101	48 ff c6	 inc	 rsi
  00104	f2 ae		 repne scasb
  00106	48 f7 d1	 not	 rcx
  00109	48 ff c9	 dec	 rcx
  0010c	48 03 d9	 add	 rbx, rcx
  0010f	39 44 b5 00	 cmp	 DWORD PTR [rbp+rsi*4], eax
  00113	7f ab		 jg	 SHORT $LL3@seterror

; 377  :             }
; 378  :         }
; 379  :         else {

  00115	eb 20		 jmp	 SHORT $LN1@seterror
$LN4@seterror:

; 380  :             PyOS_snprintf(p, sizeof(buf) - (p - buf), "argument");

  00117	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_08MNCFOIFH@argument?$AA@
  0011e	e8 00 00 00 00	 call	 PyOS_snprintf

; 381  :             p += strlen(p);

  00123	48 83 c9 ff	 or	 rcx, -1
  00127	33 c0		 xor	 eax, eax
  00129	48 8b fb	 mov	 rdi, rbx
  0012c	f2 ae		 repne scasb
  0012e	48 f7 d1	 not	 rcx
  00131	48 ff c9	 dec	 rcx
  00134	48 03 d9	 add	 rbx, rcx
$LN1@seterror:

; 382  :         }
; 383  :         PyOS_snprintf(p, sizeof(buf) - (p - buf), " %.256s", msg);

  00137	48 8d 94 24 20
	02 00 00	 lea	 rdx, QWORD PTR buf$[rsp+512]
  0013f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_07PLGIGANP@?5?$CF?4256s?$AA@
  00146	4d 8b cc	 mov	 r9, r12
  00149	48 2b d3	 sub	 rdx, rbx
  0014c	48 8b cb	 mov	 rcx, rbx
  0014f	e8 00 00 00 00	 call	 PyOS_snprintf

; 384  :         message = buf;

  00154	48 8d 54 24 20	 lea	 rdx, QWORD PTR buf$[rsp]
$LN6@seterror:

; 385  :     }
; 386  :     PyErr_SetString(PyExc_TypeError, message);

  00159	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00160	e8 00 00 00 00	 call	 PyErr_SetString
$LN9@seterror:

; 387  : }

  00165	4c 8d 9c 24 20
	02 00 00	 lea	 r11, QWORD PTR [rsp+544]
  0016d	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00171	49 8b 6b 18	 mov	 rbp, QWORD PTR [r11+24]
  00175	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  00179	49 8b 7b 28	 mov	 rdi, QWORD PTR [r11+40]
  0017d	49 8b e3	 mov	 rsp, r11
  00180	41 5c		 pop	 r12
  00182	c3		 ret	 0
seterror ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@COBEPABP@must?5be?5?$CFd?9item?5sequence?0?5not?5?$CF?4@ ; `string'
PUBLIC	??_C@_0CB@NKOGLILG@expected?5?$CFd?5arguments?0?5not?5?$CF?450s@ ; `string'
PUBLIC	??_C@_04OHJIHAFH@None?$AA@			; `string'
PUBLIC	??_C@_0BD@LNNDNBCF@is?5not?5retrievable?$AA@	; `string'
PUBLIC	??_C@_0BO@DOGODLPL@expected?5?$CFd?5arguments?0?5not?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CG@PJDNHDOE@must?5be?5sequence?5of?5length?5?$CFd?0?5n@ ; `string'
EXTRN	_Py_NoneStruct:BYTE
EXTRN	__imp_strncpy:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	PySequence_GetItem:PROC
EXTRN	PySequence_Size:PROC
EXTRN	PySequence_Check:PROC
EXTRN	_Py_ctype_table:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$converttuple DD imagerel converttuple
	DD	imagerel converttuple+272
	DD	imagerel $unwind$converttuple
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$converttuple DD imagerel converttuple+272
	DD	imagerel converttuple+493
	DD	imagerel $chain$2$converttuple
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$converttuple DD imagerel converttuple+493
	DD	imagerel converttuple+548
	DD	imagerel $chain$4$converttuple
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$converttuple DD imagerel converttuple+548
	DD	imagerel converttuple+611
	DD	imagerel $chain$5$converttuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$converttuple DD 021H
	DD	imagerel converttuple
	DD	imagerel converttuple+272
	DD	imagerel $unwind$converttuple
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$converttuple DD 060021H
	DD	0af400H
	DD	0bd400H
	DD	0125400H
	DD	imagerel converttuple
	DD	imagerel converttuple+272
	DD	imagerel $unwind$converttuple
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$converttuple DD 061221H
	DD	0af412H
	DD	0bd40dH
	DD	0125408H
	DD	imagerel converttuple
	DD	imagerel converttuple+272
	DD	imagerel $unwind$converttuple
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$converttuple DD 061a01H
	DD	0e016b21aH
	DD	07012c014H
	DD	030106011H
xdata	ENDS
;	COMDAT ??_C@_0CE@COBEPABP@must?5be?5?$CFd?9item?5sequence?0?5not?5?$CF?4@
CONST	SEGMENT
??_C@_0CE@COBEPABP@must?5be?5?$CFd?9item?5sequence?0?5not?5?$CF?4@ DB 'mu'
	DB	'st be %d-item sequence, not %.50s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NKOGLILG@expected?5?$CFd?5arguments?0?5not?5?$CF?450s@
CONST	SEGMENT
??_C@_0CB@NKOGLILG@expected?5?$CFd?5arguments?0?5not?5?$CF?450s@ DB 'expe'
	DB	'cted %d arguments, not %.50s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHJIHAFH@None?$AA@
CONST	SEGMENT
??_C@_04OHJIHAFH@None?$AA@ DB 'None', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LNNDNBCF@is?5not?5retrievable?$AA@
CONST	SEGMENT
??_C@_0BD@LNNDNBCF@is?5not?5retrievable?$AA@ DB 'is not retrievable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DOGODLPL@expected?5?$CFd?5arguments?0?5not?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@DOGODLPL@expected?5?$CFd?5arguments?0?5not?5?$CFd?$AA@ DB 'expe'
	DB	'cted %d arguments, not %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PJDNHDOE@must?5be?5sequence?5of?5length?5?$CFd?0?5n@
CONST	SEGMENT
??_C@_0CG@PJDNHDOE@must?5be?5sequence?5of?5length?5?$CFd?0?5n@ DB 'must b'
	DB	'e sequence of length %d, not %d', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT converttuple
_TEXT	SEGMENT
format$ = 64
arg$ = 144
p_format$ = 152
p_va$ = 160
flags$ = 168
levels$ = 176
msgbuf$ = 184
bufsize$ = 192
toplevel$ = 200
freelist$ = 208
converttuple PROC					; COMDAT

; 412  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	53		 push	 rbx
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	41 54		 push	 r12
  00014	41 56		 push	 r14
  00016	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 413  :     int level = 0;
; 414  :     int n = 0;
; 415  :     const char *format = *p_format;

  0001a	4c 8b 1a	 mov	 r11, QWORD PTR [rdx]
  0001d	33 f6		 xor	 esi, esi
  0001f	4c 8b f1	 mov	 r14, rcx
  00022	45 8b e1	 mov	 r12d, r9d
  00025	48 8b fa	 mov	 rdi, rdx
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  0002f	4c 89 5c 24 40	 mov	 QWORD PTR format$[rsp], r11
  00034	44 8b d6	 mov	 r10d, esi
  00037	8b de		 mov	 ebx, esi
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL24@converttup:

; 416  :     int i;
; 417  : 
; 418  :     for (;;) {
; 419  :         int c = *format++;

  00040	41 0f be 03	 movsx	 eax, BYTE PTR [r11]
  00044	49 ff c3	 inc	 r11
  00047	4c 89 5c 24 40	 mov	 QWORD PTR format$[rsp], r11

; 420  :         if (c == '(') {

  0004c	83 f8 28	 cmp	 eax, 40			; 00000028H
  0004f	75 0c		 jne	 SHORT $LN22@converttup

; 421  :             if (level == 0)

  00051	45 85 d2	 test	 r10d, r10d
  00054	75 02		 jne	 SHORT $LN21@converttup

; 422  :                 n++;

  00056	ff c3		 inc	 ebx
$LN21@converttup:

; 423  :             level++;

  00058	41 ff c2	 inc	 r10d
  0005b	eb e3		 jmp	 SHORT $LL24@converttup
$LN22@converttup:

; 424  :         }
; 425  :         else if (c == ')') {

  0005d	83 f8 29	 cmp	 eax, 41			; 00000029H
  00060	75 0a		 jne	 SHORT $LN19@converttup

; 426  :             if (level == 0)

  00062	45 85 d2	 test	 r10d, r10d
  00065	74 25		 je	 SHORT $LN31@converttup

; 427  :                 break;
; 428  :             level--;

  00067	41 ff ca	 dec	 r10d
  0006a	eb d4		 jmp	 SHORT $LL24@converttup
$LN19@converttup:

; 429  :         }
; 430  :         else if (c == ':' || c == ';' || c == '\0')

  0006c	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  0006f	74 1b		 je	 SHORT $LN31@converttup
  00071	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  00074	74 16		 je	 SHORT $LN31@converttup
  00076	85 c0		 test	 eax, eax
  00078	74 12		 je	 SHORT $LN31@converttup

; 431  :             break;
; 432  :         else if (level == 0 && Py_ISALPHA(Py_CHARMASK(c)))

  0007a	45 85 d2	 test	 r10d, r10d
  0007d	75 c1		 jne	 SHORT $LL24@converttup
  0007f	0f b6 c0	 movzx	 eax, al
  00082	f6 04 81 03	 test	 BYTE PTR [rcx+rax*4], 3
  00086	74 b8		 je	 SHORT $LL24@converttup

; 433  :             n++;

  00088	ff c3		 inc	 ebx

; 434  :     }

  0008a	eb b4		 jmp	 SHORT $LL24@converttup
$LN31@converttup:

; 435  : 
; 436  :     if (!PySequence_Check(arg) || PyBytes_Check(arg)) {

  0008c	49 8b ce	 mov	 rcx, r14
  0008f	e8 00 00 00 00	 call	 PySequence_Check
  00094	85 c0		 test	 eax, eax
  00096	0f 84 88 01 00
	00		 je	 $LN11@converttup
  0009c	49 8b 46 58	 mov	 rax, QWORD PTR [r14+88]
  000a0	f7 80 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rax+256], 134217728 ; 08000000H
  000aa	0f 85 74 01 00
	00		 jne	 $LN11@converttup

; 443  :         return msgbuf;
; 444  :     }
; 445  : 
; 446  :     if ((i = PySequence_Size(arg)) != n) {

  000b0	49 8b ce	 mov	 rcx, r14
  000b3	e8 00 00 00 00	 call	 PySequence_Size
  000b8	3b c3		 cmp	 eax, ebx
  000ba	74 51		 je	 SHORT $LN10@converttup

; 447  :         levels[0] = 0;

  000bc	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR levels$[rsp]

; 448  :         PyOS_snprintf(msgbuf, bufsize,
; 449  :                       toplevel ? "expected %d arguments, not %d" :
; 450  :                      "must be sequence of length %d, not %d",
; 451  :                   n, i);

  000c4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CG@PJDNHDOE@must?5be?5sequence?5of?5length?5?$CFd?0?5n@
  000cb	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000cf	89 31		 mov	 DWORD PTR [rcx], esi
  000d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@DOGODLPL@expected?5?$CFd?5arguments?0?5not?5?$CFd?$AA@
$LN40@converttup:
  000d8	39 b4 24 c8 00
	00 00		 cmp	 DWORD PTR toplevel$[rsp], esi
  000df	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR bufsize$[rsp]
  000e7	44 8b cb	 mov	 r9d, ebx
  000ea	48 8b 9c 24 b8
	00 00 00	 mov	 rbx, QWORD PTR msgbuf$[rsp]
  000f2	4c 0f 45 c1	 cmovne	 r8, rcx
  000f6	48 8b cb	 mov	 rcx, rbx
  000f9	e8 00 00 00 00	 call	 PyOS_snprintf

; 452  :         return msgbuf;

  000fe	48 8b c3	 mov	 rax, rbx

; 479  : }

  00101	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00105	41 5e		 pop	 r14
  00107	41 5c		 pop	 r12
  00109	5f		 pop	 rdi
  0010a	5e		 pop	 rsi
  0010b	5b		 pop	 rbx
  0010c	c3		 ret	 0
$LN10@converttup:

; 453  :     }
; 454  : 
; 455  :     format = *p_format;

  0010d	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00110	48 89 ac 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rbp
  00118	4c 89 6c 24 58	 mov	 QWORD PTR [rsp+88], r13
  0011d	4c 89 7c 24 50	 mov	 QWORD PTR [rsp+80], r15

; 456  :     for (i = 0; i < n; i++) {

  00122	8b fe		 mov	 edi, esi
  00124	48 89 44 24 40	 mov	 QWORD PTR format$[rsp], rax
  00129	85 db		 test	 ebx, ebx
  0012b	0f 8e 91 00 00
	00		 jle	 $LN7@converttup
  00131	4c 8b bc 24 c0
	00 00 00	 mov	 r15, QWORD PTR bufsize$[rsp]
  00139	4c 8b ac 24 b8
	00 00 00	 mov	 r13, QWORD PTR msgbuf$[rsp]
  00141	48 8b ac 24 b0
	00 00 00	 mov	 rbp, QWORD PTR levels$[rsp]
  00149	0f 1f 80 00 00
	00 00		 npad	 7
$LL9@converttup:

; 457  :         char *msg;
; 458  :         PyObject *item;
; 459  :         item = PySequence_GetItem(arg, i);

  00150	48 63 d7	 movsxd	 rdx, edi
  00153	49 8b ce	 mov	 rcx, r14
  00156	e8 00 00 00 00	 call	 PySequence_GetItem
  0015b	48 8b f0	 mov	 rsi, rax

; 460  :         if (item == NULL) {

  0015e	48 85 c0	 test	 rax, rax
  00161	0f 84 91 00 00
	00		 je	 $LN33@converttup

; 466  :         }
; 467  :         msg = convertitem(item, &format, p_va, flags, levels+1,
; 468  :                           msgbuf, bufsize, freelist);

  00167	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR freelist$[rsp]
  0016f	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR p_va$[rsp]
  00177	48 8d 4d 04	 lea	 rcx, QWORD PTR [rbp+4]
  0017b	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00180	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15
  00185	48 8d 54 24 40	 lea	 rdx, QWORD PTR format$[rsp]
  0018a	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  0018f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00194	45 8b cc	 mov	 r9d, r12d
  00197	48 8b ce	 mov	 rcx, rsi
  0019a	e8 00 00 00 00	 call	 convertitem

; 469  :         /* PySequence_GetItem calls tp->sq_item, which INCREFs */
; 470  :         Py_XDECREF(item);

  0019f	48 8b ce	 mov	 rcx, rsi
  001a2	4c 8b e0	 mov	 r12, rax
  001a5	e8 00 00 00 00	 call	 _Py_DecRef

; 471  :         if (msg != NULL) {

  001aa	4d 85 e4	 test	 r12, r12
  001ad	75 3e		 jne	 SHORT $LN34@converttup

; 456  :     for (i = 0; i < n; i++) {

  001af	44 8b a4 24 a8
	00 00 00	 mov	 r12d, DWORD PTR flags$[rsp]
  001b7	ff c7		 inc	 edi
  001b9	3b fb		 cmp	 edi, ebx
  001bb	7c 93		 jl	 SHORT $LL9@converttup

; 471  :         if (msg != NULL) {

  001bd	48 8b 44 24 40	 mov	 rax, QWORD PTR format$[rsp]
$LN7@converttup:

; 474  :         }
; 475  :     }
; 476  : 
; 477  :     *p_format = format;

  001c2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR p_format$[rsp]
  001ca	48 89 01	 mov	 QWORD PTR [rcx], rax

; 478  :     return NULL;

  001cd	33 c0		 xor	 eax, eax
$LN38@converttup:
  001cf	4c 8b 6c 24 58	 mov	 r13, QWORD PTR [rsp+88]
  001d4	48 8b ac 24 90
	00 00 00	 mov	 rbp, QWORD PTR [rsp+144]
  001dc	4c 8b 7c 24 50	 mov	 r15, QWORD PTR [rsp+80]

; 479  : }

  001e1	48 83 c4 60	 add	 rsp, 96			; 00000060H
  001e5	41 5e		 pop	 r14
  001e7	41 5c		 pop	 r12
  001e9	5f		 pop	 rdi
  001ea	5e		 pop	 rsi
  001eb	5b		 pop	 rbx
  001ec	c3		 ret	 0
$LN34@converttup:

; 472  :             levels[0] = i+1;

  001ed	8d 47 01	 lea	 eax, DWORD PTR [rdi+1]
  001f0	89 45 00	 mov	 DWORD PTR [rbp], eax

; 473  :             return msg;

  001f3	49 8b c4	 mov	 rax, r12
  001f6	eb d7		 jmp	 SHORT $LN38@converttup
$LN33@converttup:

; 461  :             PyErr_Clear();

  001f8	e8 00 00 00 00	 call	 PyErr_Clear

; 462  :             levels[0] = i+1;

  001fd	44 8d 5f 01	 lea	 r11d, DWORD PTR [rdi+1]

; 463  :             levels[1] = 0;
; 464  :             strncpy(msgbuf, "is not retrievable", bufsize);

  00201	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@LNNDNBCF@is?5not?5retrievable?$AA@
  00208	4d 8b c7	 mov	 r8, r15
  0020b	49 8b cd	 mov	 rcx, r13
  0020e	44 89 5d 00	 mov	 DWORD PTR [rbp], r11d
  00212	c7 45 04 00 00
	00 00		 mov	 DWORD PTR [rbp+4], 0
  00219	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 465  :             return msgbuf;

  0021f	49 8b c5	 mov	 rax, r13
  00222	eb ab		 jmp	 SHORT $LN38@converttup
$LN11@converttup:

; 437  :         levels[0] = 0;

  00224	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR levels$[rsp]
  0022c	89 30		 mov	 DWORD PTR [rax], esi

; 438  :         PyOS_snprintf(msgbuf, bufsize,
; 439  :                       toplevel ? "expected %d arguments, not %.50s" :
; 440  :                       "must be %d-item sequence, not %.50s",
; 441  :                   n,
; 442  :                   arg == Py_None ? "None" : arg->ob_type->tp_name);

  0022e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00235	4c 3b f0	 cmp	 r14, rax
  00238	75 09		 jne	 SHORT $LN27@converttup
  0023a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04OHJIHAFH@None?$AA@
  00241	eb 08		 jmp	 SHORT $LN28@converttup
$LN27@converttup:
  00243	49 8b 46 58	 mov	 rax, QWORD PTR [r14+88]
  00247	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
$LN28@converttup:
  0024b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CB@NKOGLILG@expected?5?$CFd?5arguments?0?5not?5?$CF?450s@
  00252	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CE@COBEPABP@must?5be?5?$CFd?9item?5sequence?0?5not?5?$CF?4@
  00259	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0025e	e9 75 fe ff ff	 jmp	 $LN40@converttup
converttuple ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@NNKBDMMC@must?5be?5?$CF?450s?0?5not?5?$CF?450s?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$converterr DD imagerel converterr
	DD	imagerel converterr+76
	DD	imagerel $unwind$converterr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$converterr DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0BJ@NNKBDMMC@must?5be?5?$CF?450s?0?5not?5?$CF?450s?$AA@
CONST	SEGMENT
??_C@_0BJ@NNKBDMMC@must?5be?5?$CF?450s?0?5not?5?$CF?450s?$AA@ DB 'must be'
	DB	' %.50s, not %.50s', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT converterr
_TEXT	SEGMENT
expected$ = 64
arg$ = 72
msgbuf$ = 80
bufsize$ = 88
converterr PROC						; COMDAT

; 515  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 516  :     assert(expected != NULL);
; 517  :     assert(arg != NULL);
; 518  :     PyOS_snprintf(msgbuf, bufsize,
; 519  :                   "must be %.50s, not %.50s", expected,
; 520  :                   arg == Py_None ? "None" : arg->ob_type->tp_name);

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0000d	4d 8b d1	 mov	 r10, r9
  00010	49 8b d8	 mov	 rbx, r8
  00013	48 3b d0	 cmp	 rdx, rax
  00016	75 09		 jne	 SHORT $LN3@converterr
  00018	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04OHJIHAFH@None?$AA@
  0001f	eb 08		 jmp	 SHORT $LN4@converterr
$LN3@converterr:
  00021	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00025	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
$LN4@converterr:
  00029	4c 8b c9	 mov	 r9, rcx
  0002c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BJ@NNKBDMMC@must?5be?5?$CF?450s?0?5not?5?$CF?450s?$AA@
  00033	49 8b d2	 mov	 rdx, r10
  00036	48 8b cb	 mov	 rcx, rbx
  00039	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0003e	e8 00 00 00 00	 call	 PyOS_snprintf

; 521  :     return msgbuf;

  00043	48 8b c3	 mov	 rax, rbx

; 522  : }

  00046	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004a	5b		 pop	 rbx
  0004b	c3		 ret	 0
converterr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@BFHGIJMM@integer?5argument?5expected?0?5got?5f@ ; `string'
EXTRN	PyType_IsSubtype:PROC
EXTRN	PyFloat_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_argument_error DD imagerel float_argument_error
	DD	imagerel float_argument_error+63
	DD	imagerel $unwind$float_argument_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_argument_error DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CF@BFHGIJMM@integer?5argument?5expected?0?5got?5f@
CONST	SEGMENT
??_C@_0CF@BFHGIJMM@integer?5argument?5expected?0?5got?5f@ DB 'integer arg'
	DB	'ument expected, got float', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT float_argument_error
_TEXT	SEGMENT
arg$ = 48
float_argument_error PROC				; COMDAT

; 530  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 531  :     if (PyFloat_Check(arg)) {

  00004	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00008	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  0000f	48 3b ca	 cmp	 rcx, rdx
  00012	74 0e		 je	 SHORT $LN2@float_argu
  00014	e8 00 00 00 00	 call	 PyType_IsSubtype
  00019	85 c0		 test	 eax, eax
  0001b	75 05		 jne	 SHORT $LN2@float_argu

; 535  :     }
; 536  :     else
; 537  :         return 0;
; 538  : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
$LN2@float_argu:

; 532  :         PyErr_SetString(PyExc_TypeError,
; 533  :                         "integer argument expected, got float" );

  00022	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@BFHGIJMM@integer?5argument?5expected?0?5got?5f@
  00030	e8 00 00 00 00	 call	 PyErr_SetString

; 534  :         return 1;

  00035	b8 01 00 00 00	 mov	 eax, 1

; 535  :     }
; 536  :     else
; 537  :         return 0;
; 538  : }

  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
float_argument_error ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@KHDHJHGE@contiguous?5buffer?$AA@	; `string'
PUBLIC	??_C@_0BA@PDPPHHIG@bytes?5or?5buffer?$AA@	; `string'
EXTRN	PyBuffer_IsContiguous:PROC
EXTRN	PyObject_GetBuffer:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$getbuffer DD imagerel getbuffer
	DD	imagerel getbuffer+111
	DD	imagerel $unwind$getbuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getbuffer DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0BC@KHDHJHGE@contiguous?5buffer?$AA@
CONST	SEGMENT
??_C@_0BC@KHDHJHGE@contiguous?5buffer?$AA@ DB 'contiguous buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PDPPHHIG@bytes?5or?5buffer?$AA@
CONST	SEGMENT
??_C@_0BA@PDPPHHIG@bytes?5or?5buffer?$AA@ DB 'bytes or buffer', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT getbuffer
_TEXT	SEGMENT
arg$ = 48
view$ = 56
errmsg$ = 64
getbuffer PROC						; COMDAT

; 1280 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b d8	 mov	 rbx, r8

; 1281 :     if (PyObject_GetBuffer(arg, view, PyBUF_SIMPLE) != 0) {

  0000d	45 33 c0	 xor	 r8d, r8d
  00010	48 8b fa	 mov	 rdi, rdx
  00013	e8 00 00 00 00	 call	 PyObject_GetBuffer
  00018	85 c0		 test	 eax, eax
  0001a	74 18		 je	 SHORT $LN2@getbuffer

; 1282 :         *errmsg = "bytes or buffer";

  0001c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BA@PDPPHHIG@bytes?5or?5buffer?$AA@
  00023	48 89 03	 mov	 QWORD PTR [rbx], rax

; 1283 :         return -1;

  00026	83 c8 ff	 or	 eax, -1

; 1291 : }

  00029	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5f		 pop	 rdi
  00033	c3		 ret	 0
$LN2@getbuffer:

; 1284 :     }
; 1285 :     if (!PyBuffer_IsContiguous(view, 'C')) {

  00034	b2 43		 mov	 dl, 67			; 00000043H
  00036	48 8b cf	 mov	 rcx, rdi
  00039	e8 00 00 00 00	 call	 PyBuffer_IsContiguous
  0003e	85 c0		 test	 eax, eax
  00040	75 20		 jne	 SHORT $LN1@getbuffer

; 1286 :         PyBuffer_Release(view);

  00042	48 8b cf	 mov	 rcx, rdi
  00045	e8 00 00 00 00	 call	 PyBuffer_Release

; 1287 :         *errmsg = "contiguous buffer";

  0004a	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:??_C@_0BC@KHDHJHGE@contiguous?5buffer?$AA@

; 1288 :         return -1;

  00051	83 c8 ff	 or	 eax, -1
  00054	4c 89 1b	 mov	 QWORD PTR [rbx], r11

; 1291 : }

  00057	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5f		 pop	 rdi
  00061	c3		 ret	 0
$LN1@getbuffer:

; 1289 :     }
; 1290 :     return 0;

  00062	33 c0		 xor	 eax, eax

; 1291 : }

  00064	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00069	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006d	5f		 pop	 rdi
  0006e	c3		 ret	 0
getbuffer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@IHJGJBNK@keyword?5arguments?5must?5be?5string@ ; `string'
PUBLIC	??_C@_0BE@GAIPICFM@?4?4?2Python?2getargs?4c?$AA@ ; `string'
PUBLIC	PyArg_ValidateKeywordArguments
EXTRN	_PyDict_HasOnlyStringKeys:PROC
EXTRN	_PyErr_BadInternalCall:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyArg_ValidateKeywordArguments DD imagerel $LN5
	DD	imagerel $LN5+89
	DD	imagerel $unwind$PyArg_ValidateKeywordArguments
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyArg_ValidateKeywordArguments DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CC@IHJGJBNK@keyword?5arguments?5must?5be?5string@
CONST	SEGMENT
??_C@_0CC@IHJGJBNK@keyword?5arguments?5must?5be?5string@ DB 'keyword argu'
	DB	'ments must be strings', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GAIPICFM@?4?4?2Python?2getargs?4c?$AA@
CONST	SEGMENT
??_C@_0BE@GAIPICFM@?4?4?2Python?2getargs?4c?$AA@ DB '..\Python\getargs.c', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyArg_ValidateKeywordArguments
_TEXT	SEGMENT
kwargs$ = 48
PyArg_ValidateKeywordArguments PROC			; COMDAT

; 1398 : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1399 :     if (!PyDict_Check(kwargs)) {

  00004	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00008	f7 80 00 01 00
	00 00 00 00 20	 test	 DWORD PTR [rax+256], 536870912 ; 20000000H
  00012	75 18		 jne	 SHORT $LN2@PyArg_Vali

; 1400 :         PyErr_BadInternalCall();

  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@GAIPICFM@?4?4?2Python?2getargs?4c?$AA@
  0001b	ba 78 05 00 00	 mov	 edx, 1400		; 00000578H
  00020	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1401 :         return 0;

  00025	33 c0		 xor	 eax, eax

; 1409 : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
$LN2@PyArg_Vali:

; 1402 :     }
; 1403 :     if (!_PyDict_HasOnlyStringKeys(kwargs)) {

  0002c	e8 00 00 00 00	 call	 _PyDict_HasOnlyStringKeys
  00031	85 c0		 test	 eax, eax
  00033	75 1a		 jne	 SHORT $LN1@PyArg_Vali

; 1404 :         PyErr_SetString(PyExc_TypeError,
; 1405 :                         "keyword arguments must be strings");

  00035	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@IHJGJBNK@keyword?5arguments?5must?5be?5string@
  00043	e8 00 00 00 00	 call	 PyErr_SetString

; 1406 :         return 0;

  00048	33 c0		 xor	 eax, eax

; 1409 : }

  0004a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004e	c3		 ret	 0
$LN1@PyArg_Vali:

; 1407 :     }
; 1408 :     return 1;

  0004f	b8 01 00 00 00	 mov	 eax, 1

; 1409 : }

  00054	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00058	c3		 ret	 0
PyArg_ValidateKeywordArguments ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@IMALOFOA@impossible?$DMbad?5format?5char?$DO?$AA@ ; `string'
PUBLIC	??_C@_0CH@NJHPCPND@Unmatched?5right?5paren?5in?5format?5@ ; `string'
PUBLIC	??_C@_0CG@JJFFKGEA@Unmatched?5left?5paren?5in?5format?5s@ ; `string'
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$skipitem DD imagerel skipitem
	DD	imagerel skipitem+479
	DD	imagerel $unwind$skipitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$skipitem DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BM@IMALOFOA@impossible?$DMbad?5format?5char?$DO?$AA@
CONST	SEGMENT
??_C@_0BM@IMALOFOA@impossible?$DMbad?5format?5char?$DO?$AA@ DB 'impossibl'
	DB	'e<bad format char>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@NJHPCPND@Unmatched?5right?5paren?5in?5format?5@
CONST	SEGMENT
??_C@_0CH@NJHPCPND@Unmatched?5right?5paren?5in?5format?5@ DB 'Unmatched r'
	DB	'ight paren in format string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@JJFFKGEA@Unmatched?5left?5paren?5in?5format?5s@
CONST	SEGMENT
??_C@_0CG@JJFFKGEA@Unmatched?5left?5paren?5in?5format?5s@ DB 'Unmatched l'
	DB	'eft paren in format string', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT skipitem
_TEXT	SEGMENT
format$ = 48
p_format$ = 48
p_va$ = 56
flags$ = 64
skipitem PROC						; COMDAT

; 1609 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1610 :     const char *format = *p_format;

  0000f	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  00012	48 8b da	 mov	 rbx, rdx
  00015	41 8b f8	 mov	 edi, r8d
  00018	4c 89 4c 24 30	 mov	 QWORD PTR format$[rsp], r9

; 1611 :     char c = *format++;

  0001d	41 0f be 11	 movsx	 edx, BYTE PTR [r9]
  00021	49 ff c1	 inc	 r9

; 1612 : 
; 1613 :     switch (c) {

  00024	8d 42 d8	 lea	 eax, DWORD PTR [rdx-40]
  00027	48 8b f1	 mov	 rsi, rcx
  0002a	4c 89 4c 24 30	 mov	 QWORD PTR format$[rsp], r9
  0002f	83 f8 52	 cmp	 eax, 82			; 00000052H
  00032	0f 87 21 01 00
	00		 ja	 $err$21847
  00038	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  0003f	48 98		 cdqe
  00041	41 0f b6 84 00
	00 00 00 00	 movzx	 eax, BYTE PTR $LN33@skipitem[r8+rax]
  0004a	41 8b 8c 80 00
	00 00 00	 mov	 ecx, DWORD PTR $LN34@skipitem[r8+rax*4]
  00052	49 03 c8	 add	 rcx, r8
  00055	ff e1		 jmp	 rcx
$LN24@skipitem:

; 1614 : 
; 1615 :     /*
; 1616 :      * codes that take a single data pointer as an argument
; 1617 :      * (the type of the pointer is irrelevant)
; 1618 :      */
; 1619 : 
; 1620 :     case 'b': /* byte -- very short int */
; 1621 :     case 'B': /* byte as bitfield */
; 1622 :     case 'h': /* short int */
; 1623 :     case 'H': /* short int as bitfield */
; 1624 :     case 'i': /* int */
; 1625 :     case 'I': /* int sized bitfield */
; 1626 :     case 'l': /* long int */
; 1627 :     case 'k': /* long int sized bitfield */
; 1628 : #ifdef HAVE_LONG_LONG
; 1629 :     case 'L': /* PY_LONG_LONG */
; 1630 :     case 'K': /* PY_LONG_LONG sized bitfield */
; 1631 : #endif
; 1632 :     case 'n': /* Py_ssize_t */
; 1633 :     case 'f': /* float */
; 1634 :     case 'd': /* double */
; 1635 :     case 'D': /* complex double */
; 1636 :     case 'c': /* char */
; 1637 :     case 'C': /* unicode char */
; 1638 :     case 'p': /* boolean predicate */
; 1639 :     case 'S': /* string object */
; 1640 :     case 'Y': /* string object */
; 1641 :     case 'U': /* unicode string object */
; 1642 :         {
; 1643 :             (void) va_arg(*p_va, void *);

  00057	48 83 03 08	 add	 QWORD PTR [rbx], 8

; 1721 : 
; 1722 :     }
; 1723 : 
; 1724 :     *p_format = format;

  0005b	4c 89 0e	 mov	 QWORD PTR [rsi], r9

; 1725 :     return NULL;

  0005e	33 c0		 xor	 eax, eax

; 1726 : }

  00060	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00065	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0006a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006e	5f		 pop	 rdi
  0006f	c3		 ret	 0
$LN23@skipitem:

; 1644 :             break;
; 1645 :         }
; 1646 : 
; 1647 :     /* string codes */
; 1648 : 
; 1649 :     case 'e': /* string with encoding */
; 1650 :         {
; 1651 :             (void) va_arg(*p_va, const char *);

  00070	48 83 03 08	 add	 QWORD PTR [rbx], 8

; 1652 :             if (!(*format == 's' || *format == 't'))

  00074	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00078	3c 73		 cmp	 al, 115			; 00000073H
  0007a	74 08		 je	 SHORT $LN22@skipitem
  0007c	3c 74		 cmp	 al, 116			; 00000074H
  0007e	0f 85 d5 00 00
	00		 jne	 $err$21847
$LN22@skipitem:

; 1653 :                 /* after 'e', only 's' and 't' is allowed */
; 1654 :                 goto err;
; 1655 :             format++;

  00084	49 ff c1	 inc	 r9
  00087	4c 89 4c 24 30	 mov	 QWORD PTR format$[rsp], r9
$LN21@skipitem:

; 1656 :             /* explicit fallthrough to string cases */
; 1657 :         }
; 1658 : 
; 1659 :     case 's': /* string */
; 1660 :     case 'z': /* string or None */
; 1661 :     case 'y': /* bytes */
; 1662 :     case 'u': /* unicode string */
; 1663 :     case 'Z': /* unicode string or None */
; 1664 :     case 'w': /* buffer, read-write */
; 1665 :         {
; 1666 :             (void) va_arg(*p_va, char **);

  0008c	48 83 03 08	 add	 QWORD PTR [rbx], 8

; 1667 :             if (*format == '#') {

  00090	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00094	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00097	80 f9 23	 cmp	 cl, 35			; 00000023H
  0009a	75 1f		 jne	 SHORT $LN20@skipitem

; 1668 :                 if (flags & FLAG_SIZE_T)
; 1669 :                     (void) va_arg(*p_va, Py_ssize_t *);

  0009c	48 83 c0 08	 add	 rax, 8
  000a0	48 89 03	 mov	 QWORD PTR [rbx], rax
$LN30@skipitem:

; 1709 :                     return msg;
; 1710 :             }
; 1711 :             format++;

  000a3	49 ff c1	 inc	 r9
$LN25@skipitem:

; 1721 : 
; 1722 :     }
; 1723 : 
; 1724 :     *p_format = format;

  000a6	4c 89 0e	 mov	 QWORD PTR [rsi], r9

; 1725 :     return NULL;

  000a9	33 c0		 xor	 eax, eax

; 1726 : }

  000ab	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000b0	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000b5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b9	5f		 pop	 rdi
  000ba	c3		 ret	 0
$LN20@skipitem:

; 1670 :                 else
; 1671 :                     (void) va_arg(*p_va, int *);
; 1672 :                 format++;
; 1673 :             } else if ((c == 's' || c == 'z' || c == 'y') && *format == '*') {

  000bb	80 fa 73	 cmp	 dl, 115			; 00000073H
  000be	74 0a		 je	 SHORT $LN15@skipitem
  000c0	80 fa 7a	 cmp	 dl, 122			; 0000007aH
  000c3	74 05		 je	 SHORT $LN15@skipitem
  000c5	80 fa 79	 cmp	 dl, 121			; 00000079H
  000c8	75 dc		 jne	 SHORT $LN25@skipitem
$LN15@skipitem:
  000ca	80 f9 2a	 cmp	 cl, 42			; 0000002aH
  000cd	75 d7		 jne	 SHORT $LN25@skipitem

; 1674 :                 format++;
; 1675 :             }
; 1676 :             break;

  000cf	eb d2		 jmp	 SHORT $LN30@skipitem
$LN14@skipitem:

; 1677 :         }
; 1678 : 
; 1679 :     case 'O': /* object */
; 1680 :         {
; 1681 :             if (*format == '!') {

  000d1	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  000d5	3c 21		 cmp	 al, 33			; 00000021H
  000d7	75 09		 jne	 SHORT $LN13@skipitem

; 1682 :                 format++;

  000d9	49 ff c1	 inc	 r9

; 1683 :                 (void) va_arg(*p_va, PyTypeObject*);
; 1684 :                 (void) va_arg(*p_va, PyObject **);

  000dc	48 83 03 10	 add	 QWORD PTR [rbx], 16
  000e0	eb c4		 jmp	 SHORT $LN25@skipitem
$LN13@skipitem:

; 1685 :             }
; 1686 :             else if (*format == '&') {

  000e2	3c 26		 cmp	 al, 38			; 00000026H
  000e4	0f 85 6d ff ff
	ff		 jne	 $LN24@skipitem

; 1687 :                 typedef int (*converter)(PyObject *, void *);
; 1688 :                 (void) va_arg(*p_va, converter);
; 1689 :                 (void) va_arg(*p_va, void *);

  000ea	48 83 03 10	 add	 QWORD PTR [rbx], 16

; 1690 :                 format++;
; 1691 :             }
; 1692 :             else {

  000ee	eb b3		 jmp	 SHORT $LN30@skipitem
$LN29@skipitem:

; 1693 :                 (void) va_arg(*p_va, PyObject **);
; 1694 :             }
; 1695 :             break;
; 1696 :         }
; 1697 : 
; 1698 :     case '(':           /* bypass tuple, not handled at all previously */
; 1699 :         {
; 1700 :             char *msg;
; 1701 :             for (;;) {
; 1702 :                 if (*format==')')

  000f0	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  000f4	3c 29		 cmp	 al, 41			; 00000029H
  000f6	74 ab		 je	 SHORT $LN30@skipitem
$LL8@skipitem:

; 1703 :                     break;
; 1704 :                 if (IS_END_OF_FORMAT(*format))

  000f8	84 c0		 test	 al, al
  000fa	74 2f		 je	 SHORT $LN4@skipitem
  000fc	3c 3b		 cmp	 al, 59			; 0000003bH
  000fe	74 2b		 je	 SHORT $LN4@skipitem
  00100	3c 3a		 cmp	 al, 58			; 0000003aH
  00102	74 27		 je	 SHORT $LN4@skipitem

; 1707 :                 msg = skipitem(&format, p_va, flags);

  00104	48 8d 4c 24 30	 lea	 rcx, QWORD PTR format$[rsp]
  00109	44 8b c7	 mov	 r8d, edi
  0010c	48 8b d3	 mov	 rdx, rbx
  0010f	e8 00 00 00 00	 call	 skipitem

; 1708 :                 if (msg)

  00114	48 85 c0	 test	 rax, rax
  00117	75 47		 jne	 SHORT $LN27@skipitem

; 1693 :                 (void) va_arg(*p_va, PyObject **);
; 1694 :             }
; 1695 :             break;
; 1696 :         }
; 1697 : 
; 1698 :     case '(':           /* bypass tuple, not handled at all previously */
; 1699 :         {
; 1700 :             char *msg;
; 1701 :             for (;;) {
; 1702 :                 if (*format==')')

  00119	4c 8b 4c 24 30	 mov	 r9, QWORD PTR format$[rsp]
  0011e	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00122	3c 29		 cmp	 al, 41			; 00000029H
  00124	75 d2		 jne	 SHORT $LL8@skipitem
  00126	e9 78 ff ff ff	 jmp	 $LN30@skipitem
$LN4@skipitem:

; 1705 :                     return "Unmatched left paren in format "
; 1706 :                            "string";

  0012b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CG@JJFFKGEA@Unmatched?5left?5paren?5in?5format?5s@

; 1726 : }

  00132	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00137	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0013c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00140	5f		 pop	 rdi
  00141	c3		 ret	 0
$LN2@skipitem:

; 1712 :             break;
; 1713 :         }
; 1714 : 
; 1715 :     case ')':
; 1716 :         return "Unmatched right paren in format string";

  00142	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CH@NJHPCPND@Unmatched?5right?5paren?5in?5format?5@

; 1726 : }

  00149	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0014e	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00153	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00157	5f		 pop	 rdi
  00158	c3		 ret	 0
$err$21847:

; 1717 : 
; 1718 :     default:
; 1719 : err:
; 1720 :         return "impossible<bad format char>";

  00159	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@IMALOFOA@impossible?$DMbad?5format?5char?$DO?$AA@
$LN27@skipitem:

; 1726 : }

  00160	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00165	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0016a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0016e	5f		 pop	 rdi
  0016f	c3		 ret	 0
$LN34@skipitem:
  00170	00 00 00 00	 DD	 $LN29@skipitem
  00174	00 00 00 00	 DD	 $LN2@skipitem
  00178	00 00 00 00	 DD	 $LN24@skipitem
  0017c	00 00 00 00	 DD	 $LN14@skipitem
  00180	00 00 00 00	 DD	 $LN21@skipitem
  00184	00 00 00 00	 DD	 $LN23@skipitem
  00188	00 00 00 00	 DD	 $err$21847
$LN33@skipitem:
  0018c	00		 DB	 0
  0018d	01		 DB	 1
  0018e	06		 DB	 6
  0018f	06		 DB	 6
  00190	06		 DB	 6
  00191	06		 DB	 6
  00192	06		 DB	 6
  00193	06		 DB	 6
  00194	06		 DB	 6
  00195	06		 DB	 6
  00196	06		 DB	 6
  00197	06		 DB	 6
  00198	06		 DB	 6
  00199	06		 DB	 6
  0019a	06		 DB	 6
  0019b	06		 DB	 6
  0019c	06		 DB	 6
  0019d	06		 DB	 6
  0019e	06		 DB	 6
  0019f	06		 DB	 6
  001a0	06		 DB	 6
  001a1	06		 DB	 6
  001a2	06		 DB	 6
  001a3	06		 DB	 6
  001a4	06		 DB	 6
  001a5	06		 DB	 6
  001a6	02		 DB	 2
  001a7	02		 DB	 2
  001a8	02		 DB	 2
  001a9	06		 DB	 6
  001aa	06		 DB	 6
  001ab	06		 DB	 6
  001ac	02		 DB	 2
  001ad	02		 DB	 2
  001ae	06		 DB	 6
  001af	02		 DB	 2
  001b0	02		 DB	 2
  001b1	06		 DB	 6
  001b2	06		 DB	 6
  001b3	03		 DB	 3
  001b4	06		 DB	 6
  001b5	06		 DB	 6
  001b6	06		 DB	 6
  001b7	02		 DB	 2
  001b8	06		 DB	 6
  001b9	02		 DB	 2
  001ba	06		 DB	 6
  001bb	06		 DB	 6
  001bc	06		 DB	 6
  001bd	02		 DB	 2
  001be	04		 DB	 4
  001bf	06		 DB	 6
  001c0	06		 DB	 6
  001c1	06		 DB	 6
  001c2	06		 DB	 6
  001c3	06		 DB	 6
  001c4	06		 DB	 6
  001c5	06		 DB	 6
  001c6	02		 DB	 2
  001c7	02		 DB	 2
  001c8	02		 DB	 2
  001c9	05		 DB	 5
  001ca	02		 DB	 2
  001cb	06		 DB	 6
  001cc	02		 DB	 2
  001cd	02		 DB	 2
  001ce	06		 DB	 6
  001cf	02		 DB	 2
  001d0	02		 DB	 2
  001d1	06		 DB	 6
  001d2	02		 DB	 2
  001d3	06		 DB	 6
  001d4	02		 DB	 2
  001d5	06		 DB	 6
  001d6	06		 DB	 6
  001d7	04		 DB	 4
  001d8	06		 DB	 6
  001d9	04		 DB	 4
  001da	06		 DB	 6
  001db	04		 DB	 4
  001dc	06		 DB	 6
  001dd	04		 DB	 4
  001de	04		 DB	 4
skipitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_08KFLHMPAE@at?5most?5?$AA@		; `string'
PUBLIC	??_C@_0DH@OGLEKFEB@unpacked?5tuple?5should?5have?5?$CFs?$CFzd@ ; `string'
PUBLIC	??_C@_0CF@FMANCKCI@?$CFs?5expected?5?$CFs?$CFzd?5arguments?0?5got@ ; `string'
PUBLIC	??_C@_09HJOCAFJB@at?5least?5?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0DB@DAGMFCDN@PyArg_UnpackTuple?$CI?$CJ?5argument?5lis@ ; `string'
PUBLIC	PyArg_UnpackTuple
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_SystemError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyArg_UnpackTuple DD imagerel $LN17
	DD	imagerel $LN17+321
	DD	imagerel $unwind$PyArg_UnpackTuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyArg_UnpackTuple DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_08KFLHMPAE@at?5most?5?$AA@
CONST	SEGMENT
??_C@_08KFLHMPAE@at?5most?5?$AA@ DB 'at most ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@OGLEKFEB@unpacked?5tuple?5should?5have?5?$CFs?$CFzd@
CONST	SEGMENT
??_C@_0DH@OGLEKFEB@unpacked?5tuple?5should?5have?5?$CFs?$CFzd@ DB 'unpack'
	DB	'ed tuple should have %s%zd elements, but has %zd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@FMANCKCI@?$CFs?5expected?5?$CFs?$CFzd?5arguments?0?5got@
CONST	SEGMENT
??_C@_0CF@FMANCKCI@?$CFs?5expected?5?$CFs?$CFzd?5arguments?0?5got@ DB '%s'
	DB	' expected %s%zd arguments, got %zd', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09HJOCAFJB@at?5least?5?$AA@
CONST	SEGMENT
??_C@_09HJOCAFJB@at?5least?5?$AA@ DB 'at least ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@DAGMFCDN@PyArg_UnpackTuple?$CI?$CJ?5argument?5lis@
CONST	SEGMENT
??_C@_0DB@DAGMFCDN@PyArg_UnpackTuple?$CI?$CJ?5argument?5lis@ DB 'PyArg_Un'
	DB	'packTuple() argument list is not a tuple', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyArg_UnpackTuple
_TEXT	SEGMENT
args$ = 64
name$ = 72
min$ = 80
max$ = 88
PyArg_UnpackTuple PROC					; COMDAT

; 1731 : {

$LN17:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1732 :     Py_ssize_t i, l;
; 1733 :     PyObject **o;
; 1734 :     va_list vargs;
; 1735 : 
; 1736 : #ifdef HAVE_STDARG_PROTOTYPES
; 1737 :     va_start(vargs, max);
; 1738 : #else
; 1739 :     va_start(vargs);
; 1740 : #endif
; 1741 : 
; 1742 :     assert(min >= 0);
; 1743 :     assert(min <= max);
; 1744 :     if (!PyTuple_Check(args)) {

  00009	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000d	4d 8b d1	 mov	 r10, r9
  00010	4c 8d 5c 24 60	 lea	 r11, QWORD PTR max$[rsp+8]
  00015	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  0001f	75 1a		 jne	 SHORT $LN10@PyArg_Unpa

; 1745 :         va_end(vargs);
; 1746 :         PyErr_SetString(PyExc_SystemError,
; 1747 :             "PyArg_UnpackTuple() argument list is not a tuple");

  00021	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@DAGMFCDN@PyArg_UnpackTuple?$CI?$CJ?5argument?5lis@
  0002f	e8 00 00 00 00	 call	 PyErr_SetString

; 1748 :         return 0;

  00034	33 c0		 xor	 eax, eax

; 1787 : }

  00036	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003a	c3		 ret	 0
$LN10@PyArg_Unpa:

; 1749 :     }
; 1750 :     l = PyTuple_GET_SIZE(args);

  0003b	4c 8b 49 60	 mov	 r9, QWORD PTR [rcx+96]

; 1751 :     if (l < min) {

  0003f	4d 3b c8	 cmp	 r9, r8
  00042	7d 70		 jge	 SHORT $LN9@PyArg_Unpa

; 1752 :         if (name != NULL)
; 1753 :             PyErr_Format(
; 1754 :                 PyExc_TypeError,
; 1755 :                 "%s expected %s%zd arguments, got %zd",
; 1756 :                 name, (min == max ? "" : "at least "), min, l);

  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0004b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_09HJOCAFJB@at?5least?5?$AA@
  00052	48 85 d2	 test	 rdx, rdx
  00055	74 31		 je	 SHORT $LN8@PyArg_Unpa
  00057	4d 3b c2	 cmp	 r8, r10
  0005a	4c 89 4c 24 28	 mov	 QWORD PTR [rsp+40], r9
  0005f	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  00064	48 0f 44 c1	 cmove	 rax, rcx
  00068	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0006f	4c 8b c2	 mov	 r8, rdx
  00072	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@FMANCKCI@?$CFs?5expected?5?$CFs?$CFzd?5arguments?0?5got@
  00079	4c 8b c8	 mov	 r9, rax
  0007c	e8 00 00 00 00	 call	 PyErr_Format

; 1763 :         va_end(vargs);
; 1764 :         return 0;

  00081	33 c0		 xor	 eax, eax

; 1787 : }

  00083	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00087	c3		 ret	 0
$LN8@PyArg_Unpa:

; 1757 :         else
; 1758 :             PyErr_Format(
; 1759 :                 PyExc_TypeError,
; 1760 :                 "unpacked tuple should have %s%zd elements,"
; 1761 :                 " but has %zd",
; 1762 :                 (min == max ? "" : "at least "), min, l);

  00088	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0008d	4d 8b c8	 mov	 r9, r8
$LN16@PyArg_Unpa:
  00090	4d 3b c2	 cmp	 r8, r10
  00093	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DH@OGLEKFEB@unpacked?5tuple?5should?5have?5?$CFs?$CFzd@
  0009a	48 0f 44 c1	 cmove	 rax, rcx
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000a5	4c 8b c0	 mov	 r8, rax
  000a8	e8 00 00 00 00	 call	 PyErr_Format

; 1763 :         va_end(vargs);
; 1764 :         return 0;

  000ad	33 c0		 xor	 eax, eax

; 1787 : }

  000af	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b3	c3		 ret	 0
$LN9@PyArg_Unpa:

; 1765 :     }
; 1766 :     if (l > max) {

  000b4	4d 3b ca	 cmp	 r9, r10
  000b7	7e 4e		 jle	 SHORT $LN6@PyArg_Unpa

; 1767 :         if (name != NULL)
; 1768 :             PyErr_Format(
; 1769 :                 PyExc_TypeError,
; 1770 :                 "%s expected %s%zd arguments, got %zd",
; 1771 :                 name, (min == max ? "" : "at most "), max, l);

  000b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000c0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08KFLHMPAE@at?5most?5?$AA@
  000c7	48 85 d2	 test	 rdx, rdx
  000ca	74 31		 je	 SHORT $LN5@PyArg_Unpa
  000cc	4d 3b c2	 cmp	 r8, r10
  000cf	4c 89 4c 24 28	 mov	 QWORD PTR [rsp+40], r9
  000d4	4c 8b c2	 mov	 r8, rdx
  000d7	48 0f 44 c1	 cmove	 rax, rcx
  000db	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@FMANCKCI@?$CFs?5expected?5?$CFs?$CFzd?5arguments?0?5got@
  000e9	4c 8b c8	 mov	 r9, rax
  000ec	4c 89 54 24 20	 mov	 QWORD PTR [rsp+32], r10
  000f1	e8 00 00 00 00	 call	 PyErr_Format
  000f6	33 c0		 xor	 eax, eax

; 1787 : }

  000f8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000fc	c3		 ret	 0
$LN5@PyArg_Unpa:

; 1772 :         else
; 1773 :             PyErr_Format(
; 1774 :                 PyExc_TypeError,
; 1775 :                 "unpacked tuple should have %s%zd elements,"
; 1776 :                 " but has %zd",
; 1777 :                 (min == max ? "" : "at most "), max, l);

  000fd	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00102	4d 8b ca	 mov	 r9, r10

; 1778 :         va_end(vargs);
; 1779 :         return 0;

  00105	eb 89		 jmp	 SHORT $LN16@PyArg_Unpa
$LN6@PyArg_Unpa:

; 1780 :     }
; 1781 :     for (i = 0; i < l; i++) {

  00107	4d 85 c9	 test	 r9, r9
  0010a	7e 2b		 jle	 SHORT $LN1@PyArg_Unpa
  0010c	49 8d 53 f8	 lea	 rdx, QWORD PTR [r11-8]
  00110	4c 8d 41 70	 lea	 r8, QWORD PTR [rcx+112]
  00114	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL3@PyArg_Unpa:

; 1782 :         o = va_arg(vargs, PyObject **);
; 1783 :         *o = PyTuple_GET_ITEM(args, i);

  00120	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00123	48 8b 4a 08	 mov	 rcx, QWORD PTR [rdx+8]
  00127	48 83 c2 08	 add	 rdx, 8
  0012b	49 83 c0 08	 add	 r8, 8
  0012f	49 ff c9	 dec	 r9
  00132	48 89 01	 mov	 QWORD PTR [rcx], rax
  00135	75 e9		 jne	 SHORT $LL3@PyArg_Unpa
$LN1@PyArg_Unpa:

; 1784 :     }
; 1785 :     va_end(vargs);
; 1786 :     return 1;

  00137	b8 01 00 00 00	 mov	 eax, 1

; 1787 : }

  0013c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00140	c3		 ret	 0
PyArg_UnpackTuple ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@MFKGCFAF@?$CFs?5does?5not?5take?5keyword?5argumen@ ; `string'
PUBLIC	_PyArg_NoKeywords
EXTRN	PyDict_Size:PROC
EXTRN	PyDict_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyArg_NoKeywords DD imagerel $LN8
	DD	imagerel $LN8+112
	DD	imagerel $unwind$_PyArg_NoKeywords
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyArg_NoKeywords DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CD@MFKGCFAF@?$CFs?5does?5not?5take?5keyword?5argumen@
CONST	SEGMENT
??_C@_0CD@MFKGCFAF@?$CFs?5does?5not?5take?5keyword?5argumen@ DB '%s does '
	DB	'not take keyword arguments', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyArg_NoKeywords
_TEXT	SEGMENT
funcname$ = 48
kw$ = 56
_PyArg_NoKeywords PROC					; COMDAT

; 1797 : {

$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1798 :     if (kw == NULL)

  00009	48 85 d2	 test	 rdx, rdx
  0000c	75 0b		 jne	 SHORT $LN3@PyArg_NoKe
$LN7@PyArg_NoKe:

; 1799 :         return 1;

  0000e	b8 01 00 00 00	 mov	 eax, 1

; 1810 : }

  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5b		 pop	 rbx
  00018	c3		 ret	 0
$LN3@PyArg_NoKe:

; 1800 :     if (!PyDict_CheckExact(kw)) {

  00019	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  00020	48 39 42 58	 cmp	 QWORD PTR [rdx+88], rax
  00024	74 1f		 je	 SHORT $LN2@PyArg_NoKe
  00026	48 39 42 38	 cmp	 QWORD PTR [rdx+56], rax
  0002a	74 19		 je	 SHORT $LN2@PyArg_NoKe

; 1801 :         PyErr_BadInternalCall();

  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@GAIPICFM@?4?4?2Python?2getargs?4c?$AA@
  00033	ba 09 07 00 00	 mov	 edx, 1801		; 00000709H
  00038	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1809 :     return 0;

  0003d	33 c0		 xor	 eax, eax

; 1810 : }

  0003f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00043	5b		 pop	 rbx
  00044	c3		 ret	 0
$LN2@PyArg_NoKe:

; 1802 :         return 0;
; 1803 :     }
; 1804 :     if (PyDict_Size(kw) == 0)

  00045	48 8b ca	 mov	 rcx, rdx
  00048	e8 00 00 00 00	 call	 PyDict_Size
  0004d	48 85 c0	 test	 rax, rax

; 1805 :         return 1;

  00050	74 bc		 je	 SHORT $LN7@PyArg_NoKe

; 1806 : 
; 1807 :     PyErr_Format(PyExc_TypeError, "%s does not take keyword arguments",
; 1808 :                     funcname);

  00052	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00059	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@MFKGCFAF@?$CFs?5does?5not?5take?5keyword?5argumen@
  00060	4c 8b c3	 mov	 r8, rbx
  00063	e8 00 00 00 00	 call	 PyErr_Format

; 1809 :     return 0;

  00068	33 c0		 xor	 eax, eax

; 1810 : }

  0006a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006e	5b		 pop	 rbx
  0006f	c3		 ret	 0
_PyArg_NoKeywords ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@PPCDLMDC@read?9only?5pinned?5buffer?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$convertbuffer DD imagerel convertbuffer
	DD	imagerel convertbuffer+121
	DD	imagerel $unwind$convertbuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$convertbuffer DD 045601H
	DD	0103456H
	DD	07002d206H
xdata	ENDS
;	COMDAT ??_C@_0BI@PPCDLMDC@read?9only?5pinned?5buffer?$AA@
CONST	SEGMENT
??_C@_0BI@PPCDLMDC@read?9only?5pinned?5buffer?$AA@ DB 'read-only pinned b'
	DB	'uffer', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT convertbuffer
_TEXT	SEGMENT
view$ = 32
arg$ = 128
p$ = 136
errmsg$ = 144
convertbuffer PROC					; COMDAT

; 1258 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 1259 :     PyBufferProcs *pb = Py_TYPE(arg)->tp_as_buffer;

  00006	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	4c 8b 88 f8 00
	00 00		 mov	 r9, QWORD PTR [rax+248]

; 1260 :     Py_ssize_t count;
; 1261 :     Py_buffer view;
; 1262 : 
; 1263 :     *errmsg = NULL;

  00014	33 c0		 xor	 eax, eax
  00016	49 89 00	 mov	 QWORD PTR [r8], rax

; 1264 :     *p = NULL;

  00019	48 89 02	 mov	 QWORD PTR [rdx], rax

; 1265 :     if (pb != NULL && pb->bf_releasebuffer != NULL) {

  0001c	4d 85 c9	 test	 r9, r9
  0001f	74 1a		 je	 SHORT $LN2@convertbuf
  00021	49 39 41 08	 cmp	 QWORD PTR [r9+8], rax
  00025	74 14		 je	 SHORT $LN2@convertbuf

; 1266 :         *errmsg = "read-only pinned buffer";

  00027	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BI@PPCDLMDC@read?9only?5pinned?5buffer?$AA@
  0002e	49 89 00	 mov	 QWORD PTR [r8], rax
$LN5@convertbuf:

; 1267 :         return -1;

  00031	48 83 c8 ff	 or	 rax, -1

; 1276 : }

  00035	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00039	5f		 pop	 rdi
  0003a	c3		 ret	 0
$LN2@convertbuf:

; 1268 :     }
; 1269 : 
; 1270 :     if (getbuffer(arg, &view, errmsg) < 0)

  0003b	48 8d 54 24 20	 lea	 rdx, QWORD PTR view$[rsp]
  00040	e8 00 00 00 00	 call	 getbuffer
  00045	85 c0		 test	 eax, eax

; 1271 :         return -1;

  00047	78 e8		 js	 SHORT $LN5@convertbuf

; 1272 :     count = view.len;
; 1273 :     *p = view.buf;

  00049	48 8b 4c 24 20	 mov	 rcx, QWORD PTR view$[rsp]
  0004e	48 89 9c 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbx
  00056	48 8b 5c 24 30	 mov	 rbx, QWORD PTR view$[rsp+16]
  0005b	48 89 0f	 mov	 QWORD PTR [rdi], rcx

; 1274 :     PyBuffer_Release(&view);

  0005e	48 8d 4c 24 20	 lea	 rcx, QWORD PTR view$[rsp]
  00063	e8 00 00 00 00	 call	 PyBuffer_Release

; 1275 :     return count;

  00068	48 8b c3	 mov	 rax, rbx
  0006b	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]

; 1276 : }

  00073	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00077	5f		 pop	 rdi
  00078	c3		 ret	 0
convertbuffer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@NOEFPHII@read?9write?5buffer?$AA@	; `string'
PUBLIC	??_C@_0CE@FHIKGACL@invalid?5use?5of?5?8w?8?5format?5charac@ ; `string'
PUBLIC	??_C@_0O@DMBJEJOF@?$CIunspecified?$CJ?$AA@	; `string'
PUBLIC	??_C@_09FCJHKOIN@bytearray?$AA@			; `string'
PUBLIC	??_C@_05FBJAGGIG@bytes?$AA@			; `string'
PUBLIC	??_C@_0CE@BAFKKLBH@?$CIunknown?5parser?5marker?5combinati@ ; `string'
PUBLIC	??_C@_0CC@PNMABHGD@encoded?5string?5without?5NULL?5byte@ ; `string'
PUBLIC	??_C@_0BC@CNIENJCI@?$CIbuffer?5overflow?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BF@FDDEBFPN@?$CIbuffer_len?5is?5NULL?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CB@OMNKEOOG@?$CIencoder?5failed?5to?5return?5bytes?$CJ@ ; `string'
PUBLIC	??_C@_0BC@ECLEOFDF@?$CIencoding?5failed?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CB@CBNPKI@string?5or?5unicode?5or?5text?5buffer@ ; `string'
PUBLIC	??_C@_0BG@KEABMDON@?$CIAsCharBuffer?5failed?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BB@MCHFDCHO@?$CIbuffer?5is?5NULL?$CJ?$AA@ ; `string'
PUBLIC	??_C@_03OJMAPEGJ@str?$AA@			; `string'
PUBLIC	??_C@_0M@ECJNJCHF@str?5or?5None?$AA@		; `string'
PUBLIC	??_C@_0BM@CLLMJED@str?5without?5null?5characters?$AA@ ; `string'
PUBLIC	??_C@_0CE@NNHOCDLF@str?5without?5null?5characters?5or?5N@ ; `string'
PUBLIC	??_C@_0BM@PBNPKOPA@size?5does?5not?5fit?5in?5an?5int?$AA@ ; `string'
PUBLIC	??_C@_0BL@MCHPFBGL@?$CIunicode?5conversion?5error?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BJ@KKHLFOBF@bytes?5without?5null?5bytes?$AA@ ; `string'
PUBLIC	??_C@_0BC@IHGAANNF@?$CIcleanup?5problem?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BE@GCGDJOP@a?5unicode?5character?$AA@	; `string'
PUBLIC	??_C@_0BK@GGDPHBGA@a?5byte?5string?5of?5length?51?$AA@ ; `string'
PUBLIC	??_C@_0L@FHEGIPAD@integer?$DMK?$DO?$AA@		; `string'
PUBLIC	??_C@_0L@GPALMJOD@integer?$DMk?$DO?$AA@		; `string'
PUBLIC	??_C@_0CE@OIJKLPAI@signed?5integer?5is?5less?5than?5mini@ ; `string'
PUBLIC	??_C@_0CH@OOIIJIN@signed?5integer?5is?5greater?5than?5m@ ; `string'
PUBLIC	??_C@_0CN@GGCBHAGN@signed?5short?5integer?5is?5greater?5@ ; `string'
PUBLIC	??_C@_0CK@KINDOECN@signed?5short?5integer?5is?5less?5tha@ ; `string'
PUBLIC	??_C@_0CO@JGCPDOOF@unsigned?5byte?5integer?5is?5greater@ ; `string'
PUBLIC	??_C@_0CL@KDPALKGI@unsigned?5byte?5integer?5is?5less?5th@ ; `string'
EXTRN	PyErr_NoMemory:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_PxMem_Malloc:PROC
EXTRN	PyUnicode_AsEncodedString:PROC
EXTRN	PyUnicode_FromObject:PROC
EXTRN	PyObject_AsCharBuffer:PROC
EXTRN	PyUnicode_GetDefaultEncoding:PROC
EXTRN	Py_UNICODE_strlen:PROC
EXTRN	PyUnicode_AsUnicodeAndSize:PROC
EXTRN	PyUnicode_AsUTF8AndSize:PROC
EXTRN	PyBuffer_FillInfo:PROC
EXTRN	PyObject_IsTrue:PROC
EXTRN	_PyUnicode_Ready:PROC
EXTRN	_PyByteArray_empty_string:BYTE
EXTRN	PyByteArray_Size:PROC
EXTRN	PyByteArray_Type:BYTE
EXTRN	PyBytes_Size:PROC
EXTRN	PyComplex_AsCComplex:PROC
EXTRN	PyFloat_AsDouble:PROC
EXTRN	PyLong_AsUnsignedLongLongMask:PROC
EXTRN	PyLong_AsLongLong:PROC
EXTRN	PyLong_AsSsize_t:PROC
EXTRN	PyNumber_Index:PROC
EXTRN	PyLong_AsUnsignedLongMask:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	PyLong_AsLong:PROC
EXTRN	_fltused:DWORD
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$convertsimple DD imagerel convertsimple
	DD	imagerel convertsimple+4505
	DD	imagerel $unwind$convertsimple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$convertsimple DD 0e2f01H
	DD	07682fH
	DD	0197427H
	DD	0186427H
	DD	0163427H
	DD	0f01df227H
	DD	0d019e01bH
	DD	05015c017H
xdata	ENDS
;	COMDAT ??_C@_0BC@NOEFPHII@read?9write?5buffer?$AA@
CONST	SEGMENT
??_C@_0BC@NOEFPHII@read?9write?5buffer?$AA@ DB 'read-write buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FHIKGACL@invalid?5use?5of?5?8w?8?5format?5charac@
CONST	SEGMENT
??_C@_0CE@FHIKGACL@invalid?5use?5of?5?8w?8?5format?5charac@ DB 'invalid u'
	DB	'se of ''w'' format character', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DMBJEJOF@?$CIunspecified?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@DMBJEJOF@?$CIunspecified?$CJ?$AA@ DB '(unspecified)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FCJHKOIN@bytearray?$AA@
CONST	SEGMENT
??_C@_09FCJHKOIN@bytearray?$AA@ DB 'bytearray', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05FBJAGGIG@bytes?$AA@
CONST	SEGMENT
??_C@_05FBJAGGIG@bytes?$AA@ DB 'bytes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@BAFKKLBH@?$CIunknown?5parser?5marker?5combinati@
CONST	SEGMENT
??_C@_0CE@BAFKKLBH@?$CIunknown?5parser?5marker?5combinati@ DB '(unknown p'
	DB	'arser marker combination)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PNMABHGD@encoded?5string?5without?5NULL?5byte@
CONST	SEGMENT
??_C@_0CC@PNMABHGD@encoded?5string?5without?5NULL?5byte@ DB 'encoded stri'
	DB	'ng without NULL bytes', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CNIENJCI@?$CIbuffer?5overflow?$CJ?$AA@
CONST	SEGMENT
??_C@_0BC@CNIENJCI@?$CIbuffer?5overflow?$CJ?$AA@ DB '(buffer overflow)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FDDEBFPN@?$CIbuffer_len?5is?5NULL?$CJ?$AA@
CONST	SEGMENT
??_C@_0BF@FDDEBFPN@?$CIbuffer_len?5is?5NULL?$CJ?$AA@ DB '(buffer_len is N'
	DB	'ULL)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OMNKEOOG@?$CIencoder?5failed?5to?5return?5bytes?$CJ@
CONST	SEGMENT
??_C@_0CB@OMNKEOOG@?$CIencoder?5failed?5to?5return?5bytes?$CJ@ DB '(encod'
	DB	'er failed to return bytes)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@ECLEOFDF@?$CIencoding?5failed?$CJ?$AA@
CONST	SEGMENT
??_C@_0BC@ECLEOFDF@?$CIencoding?5failed?$CJ?$AA@ DB '(encoding failed)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CBNPKI@string?5or?5unicode?5or?5text?5buffer@
CONST	SEGMENT
??_C@_0CB@CBNPKI@string?5or?5unicode?5or?5text?5buffer@ DB 'string or uni'
	DB	'code or text buffer', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KEABMDON@?$CIAsCharBuffer?5failed?$CJ?$AA@
CONST	SEGMENT
??_C@_0BG@KEABMDON@?$CIAsCharBuffer?5failed?$CJ?$AA@ DB '(AsCharBuffer fa'
	DB	'iled)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MCHFDCHO@?$CIbuffer?5is?5NULL?$CJ?$AA@
CONST	SEGMENT
??_C@_0BB@MCHFDCHO@?$CIbuffer?5is?5NULL?$CJ?$AA@ DB '(buffer is NULL)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OJMAPEGJ@str?$AA@
CONST	SEGMENT
??_C@_03OJMAPEGJ@str?$AA@ DB 'str', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ECJNJCHF@str?5or?5None?$AA@
CONST	SEGMENT
??_C@_0M@ECJNJCHF@str?5or?5None?$AA@ DB 'str or None', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CLLMJED@str?5without?5null?5characters?$AA@
CONST	SEGMENT
??_C@_0BM@CLLMJED@str?5without?5null?5characters?$AA@ DB 'str without nul'
	DB	'l characters', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NNHOCDLF@str?5without?5null?5characters?5or?5N@
CONST	SEGMENT
??_C@_0CE@NNHOCDLF@str?5without?5null?5characters?5or?5N@ DB 'str without'
	DB	' null characters or None', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PBNPKOPA@size?5does?5not?5fit?5in?5an?5int?$AA@
CONST	SEGMENT
??_C@_0BM@PBNPKOPA@size?5does?5not?5fit?5in?5an?5int?$AA@ DB 'size does n'
	DB	'ot fit in an int', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MCHPFBGL@?$CIunicode?5conversion?5error?$CJ?$AA@
CONST	SEGMENT
??_C@_0BL@MCHPFBGL@?$CIunicode?5conversion?5error?$CJ?$AA@ DB '(unicode c'
	DB	'onversion error)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KKHLFOBF@bytes?5without?5null?5bytes?$AA@
CONST	SEGMENT
??_C@_0BJ@KKHLFOBF@bytes?5without?5null?5bytes?$AA@ DB 'bytes without nul'
	DB	'l bytes', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IHGAANNF@?$CIcleanup?5problem?$CJ?$AA@
CONST	SEGMENT
??_C@_0BC@IHGAANNF@?$CIcleanup?5problem?$CJ?$AA@ DB '(cleanup problem)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GCGDJOP@a?5unicode?5character?$AA@
CONST	SEGMENT
??_C@_0BE@GCGDJOP@a?5unicode?5character?$AA@ DB 'a unicode character', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GGDPHBGA@a?5byte?5string?5of?5length?51?$AA@
CONST	SEGMENT
??_C@_0BK@GGDPHBGA@a?5byte?5string?5of?5length?51?$AA@ DB 'a byte string '
	DB	'of length 1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FHEGIPAD@integer?$DMK?$DO?$AA@
CONST	SEGMENT
??_C@_0L@FHEGIPAD@integer?$DMK?$DO?$AA@ DB 'integer<K>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GPALMJOD@integer?$DMk?$DO?$AA@
CONST	SEGMENT
??_C@_0L@GPALMJOD@integer?$DMk?$DO?$AA@ DB 'integer<k>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OIJKLPAI@signed?5integer?5is?5less?5than?5mini@
CONST	SEGMENT
??_C@_0CE@OIJKLPAI@signed?5integer?5is?5less?5than?5mini@ DB 'signed inte'
	DB	'ger is less than minimum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@OOIIJIN@signed?5integer?5is?5greater?5than?5m@
CONST	SEGMENT
??_C@_0CH@OOIIJIN@signed?5integer?5is?5greater?5than?5m@ DB 'signed integ'
	DB	'er is greater than maximum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@GGCBHAGN@signed?5short?5integer?5is?5greater?5@
CONST	SEGMENT
??_C@_0CN@GGCBHAGN@signed?5short?5integer?5is?5greater?5@ DB 'signed shor'
	DB	't integer is greater than maximum', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KINDOECN@signed?5short?5integer?5is?5less?5tha@
CONST	SEGMENT
??_C@_0CK@KINDOECN@signed?5short?5integer?5is?5less?5tha@ DB 'signed shor'
	DB	't integer is less than minimum', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@JGCPDOOF@unsigned?5byte?5integer?5is?5greater@
CONST	SEGMENT
??_C@_0CO@JGCPDOOF@unsigned?5byte?5integer?5is?5greater@ DB 'unsigned byt'
	DB	'e integer is greater than maximum', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KDPALKGI@unsigned?5byte?5integer?5is?5less?5th@
CONST	SEGMENT
??_C@_0CL@KDPALKGI@unsigned?5byte?5integer?5is?5less?5th@ DB 'unsigned by'
	DB	'te integer is less than minimum', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT convertsimple
_TEXT	SEGMENT
size$21258 = 48
buffer$1$ = 56
q$1$ = 56
ptr$21259 = 64
len$21235 = 64
buf$21027 = 64
q$1$ = 72
q2$1$ = 72
len$21145 = 72
q2$1$ = 80
u$1$ = 80
p$1$ = 80
len$21248 = 80
len$21170 = 80
buf$21152 = 80
buf$21094 = 80
len$21089 = 80
$T22513 = 88
arg$ = 176
p_format$ = 184
p_va$ = 192
flags$ = 200
msgbuf$ = 208
bufsize$ = 216
freelist$ = 224
convertsimple PROC					; COMDAT

; 552  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00014	55		 push	 rbp
  00015	41 54		 push	 r12
  00017	41 55		 push	 r13
  00019	41 56		 push	 r14
  0001b	41 57		 push	 r15
  0001d	48 8b ec	 mov	 rbp, rsp
  00020	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 553  :     /* For # codes */
; 554  : #define FETCH_SIZE      int *q=NULL;Py_ssize_t *q2=NULL;\
; 555  :     if (flags & FLAG_SIZE_T) q2=va_arg(*p_va, Py_ssize_t*); \
; 556  :     else q=va_arg(*p_va, int*);
; 557  : #define STORE_SIZE(s)   \
; 558  :     if (flags & FLAG_SIZE_T) \
; 559  :         *q2=s; \
; 560  :     else { \
; 561  :         if (INT_MAX < s) { \
; 562  :             PyErr_SetString(PyExc_OverflowError, \
; 563  :                 "size does not fit in an int"); \
; 564  :             return converterr("", arg, msgbuf, bufsize); \
; 565  :         } \
; 566  :         *q=s; \
; 567  :     }
; 568  : #define BUFFER_LEN      ((flags & FLAG_SIZE_T) ? *q2:*q)
; 569  : #define RETURN_ERR_OCCURRED return msgbuf
; 570  : 
; 571  :     const char *format = *p_format;

  00027	4c 8b 22	 mov	 r12, QWORD PTR [rdx]
  0002a	0f 29 74 24 70	 movaps	 XMMWORD PTR [rsp+112], xmm6
  0002f	45 8b f9	 mov	 r15d, r9d

; 572  :     char c = *format++;

  00032	45 0f be 2c 24	 movsx	 r13d, BYTE PTR [r12]
  00037	49 ff c4	 inc	 r12
  0003a	49 8b f8	 mov	 rdi, r8

; 573  :     char *sarg;
; 574  : 
; 575  :     switch (c) {

  0003d	41 8d 45 be	 lea	 eax, DWORD PTR [r13-66]
  00041	48 8b d9	 mov	 rbx, rcx
  00044	83 f8 38	 cmp	 eax, 56			; 00000038H
  00047	0f 87 69 10 00
	00		 ja	 $LN1@convertsim
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00054	48 98		 cdqe
  00056	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN245@convertsim[rcx+rax]
  0005e	8b 94 81 00 00
	00 00		 mov	 edx, DWORD PTR $LN246@convertsim[rcx+rax*4]
  00065	48 03 d1	 add	 rdx, rcx
  00068	ff e2		 jmp	 rdx
$LN206@convertsim:

; 576  : 
; 577  :     case 'b': { /* unsigned byte -- very short int */
; 578  :         char *p = va_arg(*p_va, char *);

  0006a	49 83 00 08	 add	 QWORD PTR [r8], 8
  0006e	49 8b 00	 mov	 rax, QWORD PTR [r8]

; 579  :         long ival;
; 580  :         if (float_argument_error(arg))

  00071	48 8b cb	 mov	 rcx, rbx
  00074	48 8b 78 f8	 mov	 rdi, QWORD PTR [rax-8]
  00078	e8 00 00 00 00	 call	 float_argument_error
  0007d	85 c0		 test	 eax, eax

; 581  :             RETURN_ERR_OCCURRED;

  0007f	75 17		 jne	 SHORT $LN262@convertsim

; 582  :         ival = PyLong_AsLong(arg);

  00081	48 8b cb	 mov	 rcx, rbx
  00084	e8 00 00 00 00	 call	 PyLong_AsLong

; 583  :         if (ival == -1 && PyErr_Occurred())

  00089	83 f8 ff	 cmp	 eax, -1
  0008c	75 13		 jne	 SHORT $LN204@convertsim
  0008e	e8 00 00 00 00	 call	 PyErr_Occurred
  00093	48 85 c0	 test	 rax, rax
  00096	74 0d		 je	 SHORT $LN243@convertsim
$LN262@convertsim:

; 584  :             RETURN_ERR_OCCURRED;

  00098	48 8b 45 50	 mov	 rax, QWORD PTR msgbuf$[rbp-128]
  0009c	e9 2c 10 00 00	 jmp	 $LN209@convertsim
$LN204@convertsim:

; 585  :         else if (ival < 0) {

  000a1	85 c0		 test	 eax, eax
  000a3	79 1c		 jns	 SHORT $LN202@convertsim
$LN243@convertsim:

; 586  :             PyErr_SetString(PyExc_OverflowError,
; 587  :                             "unsigned byte integer is less than minimum");

  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@KDPALKGI@unsigned?5byte?5integer?5is?5less?5th@
$LN263@convertsim:
  000ac	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000b3	e8 00 00 00 00	 call	 PyErr_SetString

; 588  :             RETURN_ERR_OCCURRED;

  000b8	48 8b 45 50	 mov	 rax, QWORD PTR msgbuf$[rbp-128]
  000bc	e9 0c 10 00 00	 jmp	 $LN209@convertsim
$LN202@convertsim:

; 589  :         }
; 590  :         else if (ival > UCHAR_MAX) {

  000c1	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000c6	0f 8e 39 04 00
	00		 jle	 $LN200@convertsim

; 591  :             PyErr_SetString(PyExc_OverflowError,
; 592  :                             "unsigned byte integer is greater than maximum");

  000cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@JGCPDOOF@unsigned?5byte?5integer?5is?5greater@

; 593  :             RETURN_ERR_OCCURRED;

  000d3	eb d7		 jmp	 SHORT $LN263@convertsim
$LN198@convertsim:

; 594  :         }
; 595  :         else
; 596  :             *p = (unsigned char) ival;
; 597  :         break;
; 598  :     }
; 599  : 
; 600  :     case 'B': {/* byte sized bitfield - both signed and unsigned
; 601  :                   values allowed */
; 602  :         char *p = va_arg(*p_va, char *);

  000d5	49 83 00 08	 add	 QWORD PTR [r8], 8
  000d9	49 8b 00	 mov	 rax, QWORD PTR [r8]

; 603  :         long ival;
; 604  :         if (float_argument_error(arg))

  000dc	48 8b cb	 mov	 rcx, rbx
  000df	48 8b 70 f8	 mov	 rsi, QWORD PTR [rax-8]
  000e3	e8 00 00 00 00	 call	 float_argument_error
  000e8	85 c0		 test	 eax, eax

; 605  :             RETURN_ERR_OCCURRED;

  000ea	75 ac		 jne	 SHORT $LN262@convertsim

; 606  :         ival = PyLong_AsUnsignedLongMask(arg);

  000ec	48 8b cb	 mov	 rcx, rbx
  000ef	e8 00 00 00 00	 call	 PyLong_AsUnsignedLongMask
  000f4	8b f8		 mov	 edi, eax

; 607  :         if (ival == -1 && PyErr_Occurred())

  000f6	83 f8 ff	 cmp	 eax, -1
  000f9	75 0a		 jne	 SHORT $LN196@convertsim
  000fb	e8 00 00 00 00	 call	 PyErr_Occurred
  00100	48 85 c0	 test	 rax, rax

; 608  :             RETURN_ERR_OCCURRED;

  00103	75 93		 jne	 SHORT $LN262@convertsim
$LN196@convertsim:

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  00105	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  00109	40 88 3e	 mov	 BYTE PTR [rsi], dil
  0010c	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  0010f	33 c0		 xor	 eax, eax
  00111	e9 b7 0f 00 00	 jmp	 $LN209@convertsim
$LN194@convertsim:

; 609  :         else
; 610  :             *p = (unsigned char) ival;
; 611  :         break;
; 612  :     }
; 613  : 
; 614  :     case 'h': {/* signed short int */
; 615  :         short *p = va_arg(*p_va, short *);

  00116	49 83 00 08	 add	 QWORD PTR [r8], 8
  0011a	49 8b 00	 mov	 rax, QWORD PTR [r8]

; 616  :         long ival;
; 617  :         if (float_argument_error(arg))

  0011d	48 8b cb	 mov	 rcx, rbx
  00120	48 8b 70 f8	 mov	 rsi, QWORD PTR [rax-8]
  00124	e8 00 00 00 00	 call	 float_argument_error
  00129	85 c0		 test	 eax, eax

; 618  :             RETURN_ERR_OCCURRED;

  0012b	0f 85 67 ff ff
	ff		 jne	 $LN262@convertsim

; 619  :         ival = PyLong_AsLong(arg);

  00131	48 8b cb	 mov	 rcx, rbx
  00134	e8 00 00 00 00	 call	 PyLong_AsLong
  00139	8b f8		 mov	 edi, eax

; 620  :         if (ival == -1 && PyErr_Occurred())

  0013b	83 f8 ff	 cmp	 eax, -1

; 621  :             RETURN_ERR_OCCURRED;

  0013e	74 61		 je	 SHORT $LN265@convertsim

; 622  :         else if (ival < SHRT_MIN) {

  00140	3d 00 80 ff ff	 cmp	 eax, -32768		; ffffffffffff8000H
  00145	7d 0c		 jge	 SHORT $LN190@convertsim

; 623  :             PyErr_SetString(PyExc_OverflowError,
; 624  :                             "signed short integer is less than minimum");

  00147	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@KINDOECN@signed?5short?5integer?5is?5less?5tha@

; 625  :             RETURN_ERR_OCCURRED;

  0014e	e9 59 ff ff ff	 jmp	 $LN263@convertsim
$LN190@convertsim:

; 626  :         }
; 627  :         else if (ival > SHRT_MAX) {

  00153	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00158	7e 0c		 jle	 SHORT $LN188@convertsim

; 628  :             PyErr_SetString(PyExc_OverflowError,
; 629  :                             "signed short integer is greater than maximum");

  0015a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@GGCBHAGN@signed?5short?5integer?5is?5greater?5@

; 630  :             RETURN_ERR_OCCURRED;

  00161	e9 46 ff ff ff	 jmp	 $LN263@convertsim
$LN188@convertsim:

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  00166	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  0016a	66 89 3e	 mov	 WORD PTR [rsi], di
  0016d	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  00170	33 c0		 xor	 eax, eax
  00172	e9 56 0f 00 00	 jmp	 $LN209@convertsim
$LN186@convertsim:

; 631  :         }
; 632  :         else
; 633  :             *p = (short) ival;
; 634  :         break;
; 635  :     }
; 636  : 
; 637  :     case 'H': { /* short int sized bitfield, both signed and
; 638  :                    unsigned allowed */
; 639  :         unsigned short *p = va_arg(*p_va, unsigned short *);

  00177	49 83 00 08	 add	 QWORD PTR [r8], 8
  0017b	49 8b 00	 mov	 rax, QWORD PTR [r8]

; 640  :         long ival;
; 641  :         if (float_argument_error(arg))

  0017e	48 8b cb	 mov	 rcx, rbx
  00181	48 8b 70 f8	 mov	 rsi, QWORD PTR [rax-8]
  00185	e8 00 00 00 00	 call	 float_argument_error
  0018a	85 c0		 test	 eax, eax

; 642  :             RETURN_ERR_OCCURRED;

  0018c	0f 85 06 ff ff
	ff		 jne	 $LN262@convertsim

; 643  :         ival = PyLong_AsUnsignedLongMask(arg);

  00192	48 8b cb	 mov	 rcx, rbx
  00195	e8 00 00 00 00	 call	 PyLong_AsUnsignedLongMask
  0019a	8b f8		 mov	 edi, eax

; 644  :         if (ival == -1 && PyErr_Occurred())

  0019c	83 f8 ff	 cmp	 eax, -1
  0019f	75 c5		 jne	 SHORT $LN188@convertsim
$LN265@convertsim:
  001a1	e8 00 00 00 00	 call	 PyErr_Occurred
  001a6	48 85 c0	 test	 rax, rax
  001a9	74 bb		 je	 SHORT $LN188@convertsim

; 588  :             RETURN_ERR_OCCURRED;

  001ab	48 8b 45 50	 mov	 rax, QWORD PTR msgbuf$[rbp-128]
  001af	e9 19 0f 00 00	 jmp	 $LN209@convertsim
$LN182@convertsim:

; 645  :             RETURN_ERR_OCCURRED;
; 646  :         else
; 647  :             *p = (unsigned short) ival;
; 648  :         break;
; 649  :     }
; 650  : 
; 651  :     case 'i': {/* signed int */
; 652  :         int *p = va_arg(*p_va, int *);

  001b4	49 83 00 08	 add	 QWORD PTR [r8], 8
  001b8	49 8b 00	 mov	 rax, QWORD PTR [r8]

; 653  :         long ival;
; 654  :         if (float_argument_error(arg))

  001bb	48 8b cb	 mov	 rcx, rbx
  001be	48 8b 70 f8	 mov	 rsi, QWORD PTR [rax-8]
  001c2	e8 00 00 00 00	 call	 float_argument_error
  001c7	85 c0		 test	 eax, eax

; 655  :             RETURN_ERR_OCCURRED;

  001c9	0f 85 c9 fe ff
	ff		 jne	 $LN262@convertsim

; 656  :         ival = PyLong_AsLong(arg);

  001cf	48 8b cb	 mov	 rcx, rbx
  001d2	e8 00 00 00 00	 call	 PyLong_AsLong
  001d7	8b f8		 mov	 edi, eax

; 657  :         if (ival == -1 && PyErr_Occurred())

  001d9	83 f8 ff	 cmp	 eax, -1

; 658  :             RETURN_ERR_OCCURRED;

  001dc	74 60		 je	 SHORT $LN266@convertsim

; 659  :         else if (ival > INT_MAX) {

  001de	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  001e3	7e 0c		 jle	 SHORT $LN178@convertsim

; 660  :             PyErr_SetString(PyExc_OverflowError,
; 661  :                             "signed integer is greater than maximum");

  001e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@OOIIJIN@signed?5integer?5is?5greater?5than?5m@

; 662  :             RETURN_ERR_OCCURRED;

  001ec	e9 bb fe ff ff	 jmp	 $LN263@convertsim
$LN178@convertsim:

; 663  :         }
; 664  :         else if (ival < INT_MIN) {

  001f1	3d 00 00 00 80	 cmp	 eax, -2147483648	; ffffffff80000000H
  001f6	7d 0c		 jge	 SHORT $LN176@convertsim

; 665  :             PyErr_SetString(PyExc_OverflowError,
; 666  :                             "signed integer is less than minimum");

  001f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@OIJKLPAI@signed?5integer?5is?5less?5than?5mini@

; 667  :             RETURN_ERR_OCCURRED;

  001ff	e9 a8 fe ff ff	 jmp	 $LN263@convertsim
$LN176@convertsim:

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  00204	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  00208	89 3e		 mov	 DWORD PTR [rsi], edi
  0020a	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  0020d	33 c0		 xor	 eax, eax
  0020f	e9 b9 0e 00 00	 jmp	 $LN209@convertsim
$LN174@convertsim:

; 668  :         }
; 669  :         else
; 670  :             *p = ival;
; 671  :         break;
; 672  :     }
; 673  : 
; 674  :     case 'I': { /* int sized bitfield, both signed and
; 675  :                    unsigned allowed */
; 676  :         unsigned int *p = va_arg(*p_va, unsigned int *);

  00214	49 83 00 08	 add	 QWORD PTR [r8], 8
  00218	49 8b 00	 mov	 rax, QWORD PTR [r8]

; 677  :         unsigned int ival;
; 678  :         if (float_argument_error(arg))

  0021b	48 8b cb	 mov	 rcx, rbx
  0021e	48 8b 70 f8	 mov	 rsi, QWORD PTR [rax-8]
  00222	e8 00 00 00 00	 call	 float_argument_error
  00227	85 c0		 test	 eax, eax

; 679  :             RETURN_ERR_OCCURRED;

  00229	0f 85 69 fe ff
	ff		 jne	 $LN262@convertsim

; 680  :         ival = (unsigned int)PyLong_AsUnsignedLongMask(arg);

  0022f	48 8b cb	 mov	 rcx, rbx
  00232	e8 00 00 00 00	 call	 PyLong_AsUnsignedLongMask
  00237	8b f8		 mov	 edi, eax

; 681  :         if (ival == (unsigned int)-1 && PyErr_Occurred())

  00239	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  0023c	75 c6		 jne	 SHORT $LN176@convertsim
$LN266@convertsim:
  0023e	e8 00 00 00 00	 call	 PyErr_Occurred
  00243	48 85 c0	 test	 rax, rax
  00246	74 bc		 je	 SHORT $LN176@convertsim

; 588  :             RETURN_ERR_OCCURRED;

  00248	48 8b 45 50	 mov	 rax, QWORD PTR msgbuf$[rbp-128]
  0024c	e9 7c 0e 00 00	 jmp	 $LN209@convertsim
$LN170@convertsim:

; 682  :             RETURN_ERR_OCCURRED;
; 683  :         else
; 684  :             *p = ival;
; 685  :         break;
; 686  :     }
; 687  : 
; 688  :     case 'n': /* Py_ssize_t */
; 689  :     {
; 690  :         PyObject *iobj;
; 691  :         Py_ssize_t *p = va_arg(*p_va, Py_ssize_t *);

  00251	49 83 00 08	 add	 QWORD PTR [r8], 8
  00255	49 8b 00	 mov	 rax, QWORD PTR [r8]

; 692  :         Py_ssize_t ival = -1;
; 693  :         if (float_argument_error(arg))

  00258	48 8b cb	 mov	 rcx, rbx
  0025b	48 8b 70 f8	 mov	 rsi, QWORD PTR [rax-8]
  0025f	48 83 cf ff	 or	 rdi, -1
  00263	e8 00 00 00 00	 call	 float_argument_error
  00268	85 c0		 test	 eax, eax

; 694  :             RETURN_ERR_OCCURRED;

  0026a	0f 85 28 fe ff
	ff		 jne	 $LN262@convertsim

; 695  :         iobj = PyNumber_Index(arg);

  00270	48 8b cb	 mov	 rcx, rbx
  00273	e8 00 00 00 00	 call	 PyNumber_Index
  00278	48 8b d8	 mov	 rbx, rax

; 696  :         if (iobj != NULL) {

  0027b	48 85 c0	 test	 rax, rax
  0027e	74 19		 je	 SHORT $LN244@convertsim

; 697  :             ival = PyLong_AsSsize_t(iobj);

  00280	48 8b c8	 mov	 rcx, rax
  00283	e8 00 00 00 00	 call	 PyLong_AsSsize_t

; 698  :             Py_DECREF(iobj);

  00288	48 8b cb	 mov	 rcx, rbx
  0028b	48 8b f8	 mov	 rdi, rax
  0028e	e8 00 00 00 00	 call	 _Py_DecRef

; 699  :         }
; 700  :         if (ival == -1 && PyErr_Occurred())

  00293	48 83 ff ff	 cmp	 rdi, -1
  00297	75 0e		 jne	 SHORT $LN167@convertsim
$LN244@convertsim:
  00299	e8 00 00 00 00	 call	 PyErr_Occurred
  0029e	48 85 c0	 test	 rax, rax

; 701  :             RETURN_ERR_OCCURRED;

  002a1	0f 85 f1 fd ff
	ff		 jne	 $LN262@convertsim
$LN167@convertsim:

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  002a7	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  002ab	48 89 3e	 mov	 QWORD PTR [rsi], rdi
  002ae	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  002b1	33 c0		 xor	 eax, eax
  002b3	e9 15 0e 00 00	 jmp	 $LN209@convertsim
$LN166@convertsim:

; 702  :         *p = ival;
; 703  :         break;
; 704  :     }
; 705  :     case 'l': {/* long int */
; 706  :         long *p = va_arg(*p_va, long *);

  002b8	49 83 00 08	 add	 QWORD PTR [r8], 8
  002bc	49 8b 00	 mov	 rax, QWORD PTR [r8]

; 707  :         long ival;
; 708  :         if (float_argument_error(arg))

  002bf	48 8b cb	 mov	 rcx, rbx
  002c2	48 8b 70 f8	 mov	 rsi, QWORD PTR [rax-8]
  002c6	e8 00 00 00 00	 call	 float_argument_error
  002cb	85 c0		 test	 eax, eax

; 709  :             RETURN_ERR_OCCURRED;

  002cd	0f 85 c5 fd ff
	ff		 jne	 $LN262@convertsim

; 710  :         ival = PyLong_AsLong(arg);

  002d3	48 8b cb	 mov	 rcx, rbx
  002d6	e8 00 00 00 00	 call	 PyLong_AsLong
  002db	8b f8		 mov	 edi, eax

; 711  :         if (ival == -1 && PyErr_Occurred())

  002dd	83 f8 ff	 cmp	 eax, -1
  002e0	0f 85 1e ff ff
	ff		 jne	 $LN176@convertsim
  002e6	e8 00 00 00 00	 call	 PyErr_Occurred
  002eb	48 85 c0	 test	 rax, rax
  002ee	0f 84 10 ff ff
	ff		 je	 $LN176@convertsim

; 588  :             RETURN_ERR_OCCURRED;

  002f4	48 8b 45 50	 mov	 rax, QWORD PTR msgbuf$[rbp-128]
  002f8	e9 d0 0d 00 00	 jmp	 $LN209@convertsim
$LN162@convertsim:

; 712  :             RETURN_ERR_OCCURRED;
; 713  :         else
; 714  :             *p = ival;
; 715  :         break;
; 716  :     }
; 717  : 
; 718  :     case 'k': { /* long sized bitfield */
; 719  :         unsigned long *p = va_arg(*p_va, unsigned long *);

  002fd	49 83 00 08	 add	 QWORD PTR [r8], 8
  00301	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00304	48 8b 78 f8	 mov	 rdi, QWORD PTR [rax-8]

; 720  :         unsigned long ival;
; 721  :         if (PyLong_Check(arg))

  00308	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0030c	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00316	74 18		 je	 SHORT $LN161@convertsim

; 722  :             ival = PyLong_AsUnsignedLongMask(arg);

  00318	48 8b cb	 mov	 rcx, rbx
  0031b	e8 00 00 00 00	 call	 PyLong_AsUnsignedLongMask

; 813  :         *p = PyUnicode_READ(kind, data, 0);

  00320	89 07		 mov	 DWORD PTR [rdi], eax
$LN2@convertsim:

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  00322	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  00326	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  00329	33 c0		 xor	 eax, eax
  0032b	e9 9d 0d 00 00	 jmp	 $LN209@convertsim
$LN161@convertsim:

; 723  :         else
; 724  :             return converterr("integer<k>", arg, msgbuf, bufsize);

  00330	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@GPALMJOD@integer?$DMk?$DO?$AA@
  00337	e9 81 0d 00 00	 jmp	 $LN249@convertsim
$LN159@convertsim:

; 725  :         *p = ival;
; 726  :         break;
; 727  :     }
; 728  : 
; 729  : #ifdef HAVE_LONG_LONG
; 730  :     case 'L': {/* PY_LONG_LONG */
; 731  :         PY_LONG_LONG *p = va_arg( *p_va, PY_LONG_LONG * );

  0033c	49 83 00 08	 add	 QWORD PTR [r8], 8
  00340	49 8b 00	 mov	 rax, QWORD PTR [r8]

; 732  :         PY_LONG_LONG ival;
; 733  :         if (float_argument_error(arg))

  00343	48 8b cb	 mov	 rcx, rbx
  00346	48 8b 70 f8	 mov	 rsi, QWORD PTR [rax-8]
  0034a	e8 00 00 00 00	 call	 float_argument_error
  0034f	85 c0		 test	 eax, eax

; 734  :             RETURN_ERR_OCCURRED;

  00351	0f 85 41 fd ff
	ff		 jne	 $LN262@convertsim

; 735  :         ival = PyLong_AsLongLong(arg);

  00357	48 8b cb	 mov	 rcx, rbx
  0035a	e8 00 00 00 00	 call	 PyLong_AsLongLong
  0035f	48 8b f8	 mov	 rdi, rax

; 736  :         if (ival == (PY_LONG_LONG)-1 && PyErr_Occurred())

  00362	48 83 f8 ff	 cmp	 rax, -1
  00366	0f 85 3b ff ff
	ff		 jne	 $LN167@convertsim
  0036c	e8 00 00 00 00	 call	 PyErr_Occurred
  00371	48 85 c0	 test	 rax, rax
  00374	0f 84 2d ff ff
	ff		 je	 $LN167@convertsim

; 588  :             RETURN_ERR_OCCURRED;

  0037a	48 8b 45 50	 mov	 rax, QWORD PTR msgbuf$[rbp-128]
  0037e	e9 4a 0d 00 00	 jmp	 $LN209@convertsim
$LN155@convertsim:

; 737  :             RETURN_ERR_OCCURRED;
; 738  :         else
; 739  :             *p = ival;
; 740  :         break;
; 741  :     }
; 742  : 
; 743  :     case 'K': { /* long long sized bitfield */
; 744  :         unsigned PY_LONG_LONG *p = va_arg(*p_va, unsigned PY_LONG_LONG *);

  00383	49 83 00 08	 add	 QWORD PTR [r8], 8
  00387	49 8b 00	 mov	 rax, QWORD PTR [r8]
  0038a	48 8b 78 f8	 mov	 rdi, QWORD PTR [rax-8]

; 745  :         unsigned PY_LONG_LONG ival;
; 746  :         if (PyLong_Check(arg))

  0038e	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00392	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  0039c	74 19		 je	 SHORT $LN154@convertsim

; 747  :             ival = PyLong_AsUnsignedLongLongMask(arg);

  0039e	48 8b cb	 mov	 rcx, rbx
  003a1	e8 00 00 00 00	 call	 PyLong_AsUnsignedLongLongMask

; 750  :         *p = ival;

  003a6	48 89 07	 mov	 QWORD PTR [rdi], rax

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  003a9	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  003ad	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  003b0	33 c0		 xor	 eax, eax
  003b2	e9 16 0d 00 00	 jmp	 $LN209@convertsim
$LN154@convertsim:

; 748  :         else
; 749  :             return converterr("integer<K>", arg, msgbuf, bufsize);

  003b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@FHEGIPAD@integer?$DMK?$DO?$AA@
  003be	e9 fa 0c 00 00	 jmp	 $LN249@convertsim
$LN152@convertsim:

; 751  :         break;
; 752  :     }
; 753  : #endif
; 754  : 
; 755  :     case 'f': {/* float */
; 756  :         float *p = va_arg(*p_va, float *);

  003c3	49 83 00 08	 add	 QWORD PTR [r8], 8
  003c7	49 8b 00	 mov	 rax, QWORD PTR [r8]

; 757  :         double dval = PyFloat_AsDouble(arg);

  003ca	48 8b cb	 mov	 rcx, rbx
  003cd	48 8b 78 f8	 mov	 rdi, QWORD PTR [rax-8]
  003d1	e8 00 00 00 00	 call	 PyFloat_AsDouble
  003d6	66 0f 28 f0	 movapd	 xmm6, xmm0

; 758  :         if (PyErr_Occurred())

  003da	e8 00 00 00 00	 call	 PyErr_Occurred
  003df	48 85 c0	 test	 rax, rax

; 759  :             RETURN_ERR_OCCURRED;

  003e2	0f 85 b0 fc ff
	ff		 jne	 $LN262@convertsim

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  003e8	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  003ec	f2 0f 5a c6	 cvtsd2ss xmm0, xmm6
  003f0	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  003f3	33 c0		 xor	 eax, eax
  003f5	f3 0f 11 07	 movss	 DWORD PTR [rdi], xmm0
  003f9	e9 cf 0c 00 00	 jmp	 $LN209@convertsim
$LN149@convertsim:

; 760  :         else
; 761  :             *p = (float) dval;
; 762  :         break;
; 763  :     }
; 764  : 
; 765  :     case 'd': {/* double */
; 766  :         double *p = va_arg(*p_va, double *);

  003fe	49 83 00 08	 add	 QWORD PTR [r8], 8
  00402	49 8b 00	 mov	 rax, QWORD PTR [r8]

; 767  :         double dval = PyFloat_AsDouble(arg);

  00405	48 8b cb	 mov	 rcx, rbx
  00408	48 8b 78 f8	 mov	 rdi, QWORD PTR [rax-8]
  0040c	e8 00 00 00 00	 call	 PyFloat_AsDouble
  00411	66 0f 28 f0	 movapd	 xmm6, xmm0

; 768  :         if (PyErr_Occurred())

  00415	e8 00 00 00 00	 call	 PyErr_Occurred
  0041a	48 85 c0	 test	 rax, rax

; 769  :             RETURN_ERR_OCCURRED;

  0041d	0f 85 75 fc ff
	ff		 jne	 $LN262@convertsim

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  00423	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  00427	f2 0f 11 37	 movsdx	 QWORD PTR [rdi], xmm6
  0042b	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  0042e	33 c0		 xor	 eax, eax
  00430	e9 98 0c 00 00	 jmp	 $LN209@convertsim
$LN146@convertsim:

; 770  :         else
; 771  :             *p = dval;
; 772  :         break;
; 773  :     }
; 774  : 
; 775  :     case 'D': {/* complex double */
; 776  :         Py_complex *p = va_arg(*p_va, Py_complex *);

  00435	49 83 00 08	 add	 QWORD PTR [r8], 8
  00439	49 8b 00	 mov	 rax, QWORD PTR [r8]

; 777  :         Py_complex cval;
; 778  :         cval = PyComplex_AsCComplex(arg);

  0043c	48 8d 4d d8	 lea	 rcx, QWORD PTR $T22513[rbp-128]
  00440	48 8b 78 f8	 mov	 rdi, QWORD PTR [rax-8]
  00444	48 8b d3	 mov	 rdx, rbx
  00447	e8 00 00 00 00	 call	 PyComplex_AsCComplex
  0044c	48 8b 18	 mov	 rbx, QWORD PTR [rax]
  0044f	48 8b 70 08	 mov	 rsi, QWORD PTR [rax+8]

; 779  :         if (PyErr_Occurred())

  00453	e8 00 00 00 00	 call	 PyErr_Occurred
  00458	48 85 c0	 test	 rax, rax

; 780  :             RETURN_ERR_OCCURRED;

  0045b	0f 85 37 fc ff
	ff		 jne	 $LN262@convertsim

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  00461	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  00465	48 89 1f	 mov	 QWORD PTR [rdi], rbx
  00468	48 89 77 08	 mov	 QWORD PTR [rdi+8], rsi
  0046c	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  0046f	33 c0		 xor	 eax, eax
  00471	e9 57 0c 00 00	 jmp	 $LN209@convertsim
$LN143@convertsim:

; 781  :         else
; 782  :             *p = cval;
; 783  :         break;
; 784  :     }
; 785  : 
; 786  :     case 'c': {/* char */
; 787  :         char *p = va_arg(*p_va, char *);

  00476	49 83 00 08	 add	 QWORD PTR [r8], 8
  0047a	49 8b 00	 mov	 rax, QWORD PTR [r8]
  0047d	48 8b 78 f8	 mov	 rdi, QWORD PTR [rax-8]

; 788  :         if (PyBytes_Check(arg) && PyBytes_Size(arg) == 1)

  00481	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00485	f7 80 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rax+256], 134217728 ; 08000000H
  0048f	74 22		 je	 SHORT $LN142@convertsim
  00491	48 8b cb	 mov	 rcx, rbx
  00494	e8 00 00 00 00	 call	 PyBytes_Size
  00499	48 83 f8 01	 cmp	 rax, 1
  0049d	75 14		 jne	 SHORT $LN142@convertsim

; 789  :             *p = PyBytes_AS_STRING(arg)[0];

  0049f	0f b6 43 78	 movzx	 eax, BYTE PTR [rbx+120]
  004a3	88 07		 mov	 BYTE PTR [rdi], al

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  004a5	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  004a9	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  004ac	33 c0		 xor	 eax, eax
  004ae	e9 1a 0c 00 00	 jmp	 $LN209@convertsim
$LN142@convertsim:

; 790  :         else if (PyByteArray_Check(arg) && PyByteArray_Size(arg) == 1)

  004b3	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  004b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  004be	48 3b ca	 cmp	 rcx, rdx
  004c1	74 09		 je	 SHORT $LN139@convertsim
  004c3	e8 00 00 00 00	 call	 PyType_IsSubtype
  004c8	85 c0		 test	 eax, eax
  004ca	74 49		 je	 SHORT $LN140@convertsim
$LN139@convertsim:
  004cc	48 8b cb	 mov	 rcx, rbx
  004cf	e8 00 00 00 00	 call	 PyByteArray_Size
  004d4	48 83 f8 01	 cmp	 rax, 1
  004d8	75 3b		 jne	 SHORT $LN140@convertsim

; 791  :             *p = PyByteArray_AS_STRING(arg)[0];

  004da	48 83 7b 60 00	 cmp	 QWORD PTR [rbx+96], 0
  004df	74 1a		 je	 SHORT $LN211@convertsim
  004e1	48 8b 83 80 00
	00 00		 mov	 rax, QWORD PTR [rbx+128]
  004e8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  004eb	88 07		 mov	 BYTE PTR [rdi], al

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  004ed	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  004f1	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  004f4	33 c0		 xor	 eax, eax
  004f6	e9 d2 0b 00 00	 jmp	 $LN209@convertsim
$LN211@convertsim:

; 791  :             *p = PyByteArray_AS_STRING(arg)[0];

  004fb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00502	0f b6 00	 movzx	 eax, BYTE PTR [rax]
$LN200@convertsim:
  00505	88 07		 mov	 BYTE PTR [rdi], al

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  00507	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  0050b	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  0050e	33 c0		 xor	 eax, eax
  00510	e9 b8 0b 00 00	 jmp	 $LN209@convertsim
$LN140@convertsim:

; 792  :         else
; 793  :             return converterr("a byte string of length 1", arg, msgbuf, bufsize);

  00515	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@GGDPHBGA@a?5byte?5string?5of?5length?51?$AA@
  0051c	e9 9c 0b 00 00	 jmp	 $LN249@convertsim
$LN137@convertsim:

; 794  :         break;
; 795  :     }
; 796  : 
; 797  :     case 'C': {/* unicode char */
; 798  :         int *p = va_arg(*p_va, int *);

  00521	49 83 00 08	 add	 QWORD PTR [r8], 8
  00525	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00528	48 8b 78 f8	 mov	 rdi, QWORD PTR [rax-8]

; 799  :         int kind;
; 800  :         void *data;
; 801  : 
; 802  :         if (!PyUnicode_Check(arg))

  0052c	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00530	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  0053a	75 0c		 jne	 SHORT $LN136@convertsim
$LN256@convertsim:

; 803  :             return converterr("a unicode character", arg, msgbuf, bufsize);

  0053c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@GCGDJOP@a?5unicode?5character?$AA@
  00543	e9 75 0b 00 00	 jmp	 $LN249@convertsim
$LN136@convertsim:

; 804  : 
; 805  :         if (PyUnicode_READY(arg))

  00548	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  0054c	75 10		 jne	 SHORT $LN135@convertsim
  0054e	48 8b cb	 mov	 rcx, rbx
  00551	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00556	85 c0		 test	 eax, eax

; 806  :             RETURN_ERR_OCCURRED;

  00558	0f 85 3a fb ff
	ff		 jne	 $LN262@convertsim
$LN135@convertsim:

; 807  : 
; 808  :         if (PyUnicode_GET_LENGTH(arg) != 1)

  0055e	48 83 7b 60 01	 cmp	 QWORD PTR [rbx+96], 1

; 809  :             return converterr("a unicode character", arg, msgbuf, bufsize);

  00563	75 d7		 jne	 SHORT $LN256@convertsim

; 810  : 
; 811  :         kind = PyUnicode_KIND(arg);

  00565	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00568	8b c8		 mov	 ecx, eax
  0056a	c1 e9 02	 shr	 ecx, 2
  0056d	83 e1 07	 and	 ecx, 7

; 812  :         data = PyUnicode_DATA(arg);

  00570	a8 20		 test	 al, 32			; 00000020H
  00572	74 13		 je	 SHORT $LN217@convertsim
  00574	a8 40		 test	 al, 64			; 00000040H
  00576	74 06		 je	 SHORT $LN215@convertsim
  00578	48 83 eb 80	 sub	 rbx, -128		; ffffffffffffff80H
  0057c	eb 10		 jmp	 SHORT $LN218@convertsim
$LN215@convertsim:
  0057e	48 81 c3 a0 00
	00 00		 add	 rbx, 160		; 000000a0H
  00585	eb 07		 jmp	 SHORT $LN218@convertsim
$LN217@convertsim:
  00587	48 8b 9b a0 00
	00 00		 mov	 rbx, QWORD PTR [rbx+160]
$LN218@convertsim:

; 813  :         *p = PyUnicode_READ(kind, data, 0);

  0058e	83 f9 01	 cmp	 ecx, 1
  00591	75 13		 jne	 SHORT $LN221@convertsim
  00593	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00596	89 07		 mov	 DWORD PTR [rdi], eax

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  00598	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  0059c	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  0059f	33 c0		 xor	 eax, eax
  005a1	e9 27 0b 00 00	 jmp	 $LN209@convertsim
$LN221@convertsim:

; 813  :         *p = PyUnicode_READ(kind, data, 0);

  005a6	83 f9 02	 cmp	 ecx, 2
  005a9	75 13		 jne	 SHORT $LN219@convertsim
  005ab	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  005ae	89 07		 mov	 DWORD PTR [rdi], eax

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  005b0	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  005b4	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  005b7	33 c0		 xor	 eax, eax
  005b9	e9 0f 0b 00 00	 jmp	 $LN209@convertsim
$LN219@convertsim:

; 813  :         *p = PyUnicode_READ(kind, data, 0);

  005be	8b 03		 mov	 eax, DWORD PTR [rbx]
  005c0	89 07		 mov	 DWORD PTR [rdi], eax

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  005c2	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  005c6	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  005c9	33 c0		 xor	 eax, eax
  005cb	e9 fd 0a 00 00	 jmp	 $LN209@convertsim
$LN133@convertsim:

; 814  :         break;
; 815  :     }
; 816  : 
; 817  :     case 'p': {/* boolean *p*redicate */
; 818  :         int *p = va_arg(*p_va, int *);

  005d0	49 83 00 08	 add	 QWORD PTR [r8], 8
  005d4	49 8b 00	 mov	 rax, QWORD PTR [r8]

; 819  :         int val = PyObject_IsTrue(arg);

  005d7	48 8b cb	 mov	 rcx, rbx
  005da	48 8b 78 f8	 mov	 rdi, QWORD PTR [rax-8]
  005de	e8 00 00 00 00	 call	 PyObject_IsTrue

; 820  :         if (val > 0)

  005e3	85 c0		 test	 eax, eax
  005e5	7e 17		 jle	 SHORT $LN250@convertsim

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  005e7	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  005eb	41 bd 01 00 00
	00		 mov	 r13d, 1
  005f1	44 89 2f	 mov	 DWORD PTR [rdi], r13d
  005f4	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  005f7	33 c0		 xor	 eax, eax
  005f9	e9 cf 0a 00 00	 jmp	 $LN209@convertsim
$LN250@convertsim:

; 821  :             *p = 1;
; 822  :         else if (val == 0)

  005fe	0f 85 94 fa ff
	ff		 jne	 $LN262@convertsim

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  00604	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  00608	33 f6		 xor	 esi, esi
  0060a	89 37		 mov	 DWORD PTR [rdi], esi
  0060c	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  0060f	33 c0		 xor	 eax, eax
  00611	e9 b7 0a 00 00	 jmp	 $LN209@convertsim
$LN128@convertsim:

; 823  :             *p = 0;
; 824  :         else
; 825  :             RETURN_ERR_OCCURRED;
; 826  :         break;
; 827  :     }
; 828  : 
; 829  :     /* XXX WAAAAH!  's', 'y', 'z', 'u', 'Z', 'e', 'w' codes all
; 830  :        need to be cleaned up! */
; 831  : 
; 832  :     case 'y': {/* any buffer-like object, but not PyUnicode */
; 833  :         void **p = (void **)va_arg(*p_va, char **);

  00616	49 83 00 08	 add	 QWORD PTR [r8], 8

; 834  :         char *buf;
; 835  :         Py_ssize_t count;
; 836  :         if (*format == '*') {

  0061a	41 80 3c 24 2a	 cmp	 BYTE PTR [r12], 42	; 0000002aH
  0061f	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00622	48 8b 70 f8	 mov	 rsi, QWORD PTR [rax-8]

; 837  :             if (getbuffer(arg, (Py_buffer*)p, &buf) < 0)

  00626	4c 8d 45 c0	 lea	 r8, QWORD PTR buf$21027[rbp-128]
  0062a	48 8b cb	 mov	 rcx, rbx
  0062d	48 8b d6	 mov	 rdx, rsi
  00630	75 3c		 jne	 SHORT $LN127@convertsim
  00632	e8 00 00 00 00	 call	 getbuffer
  00637	85 c0		 test	 eax, eax
  00639	79 09		 jns	 SHORT $LN126@convertsim
$LN257@convertsim:

; 838  :                 return converterr(buf, arg, msgbuf, bufsize);

  0063b	48 8b 4d c0	 mov	 rcx, QWORD PTR buf$21027[rbp-128]
  0063f	e9 79 0a 00 00	 jmp	 $LN249@convertsim
$LN126@convertsim:

; 839  :             format++;
; 840  :             if (addcleanup(p, freelist, cleanup_buffer)) {

  00644	48 8b 55 60	 mov	 rdx, QWORD PTR freelist$[rbp-128]
  00648	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cleanup_buffer
  0064f	48 8b ce	 mov	 rcx, rsi
  00652	49 ff c4	 inc	 r12
  00655	e8 00 00 00 00	 call	 addcleanup
  0065a	85 c0		 test	 eax, eax
  0065c	0f 84 c0 fc ff
	ff		 je	 $LN2@convertsim

; 841  :                 return converterr(
; 842  :                     "(cleanup problem)",
; 843  :                     arg, msgbuf, bufsize);

  00662	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@IHGAANNF@?$CIcleanup?5problem?$CJ?$AA@
  00669	e9 4f 0a 00 00	 jmp	 $LN249@convertsim
$LN127@convertsim:

; 844  :             }
; 845  :             break;
; 846  :         }
; 847  :         count = convertbuffer(arg, p, &buf);

  0066e	e8 00 00 00 00	 call	 convertbuffer
  00673	4c 8b d8	 mov	 r11, rax

; 848  :         if (count < 0)

  00676	48 85 c0	 test	 rax, rax

; 849  :             return converterr(buf, arg, msgbuf, bufsize);

  00679	78 c0		 js	 SHORT $LN257@convertsim

; 850  :         if (*format == '#') {

  0067b	41 80 3c 24 23	 cmp	 BYTE PTR [r12], 35	; 00000023H
  00680	75 55		 jne	 SHORT $LN123@convertsim

; 851  :             FETCH_SIZE;

  00682	48 83 07 08	 add	 QWORD PTR [rdi], 8
  00686	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00689	33 f6		 xor	 esi, esi
  0068b	41 83 e7 02	 and	 r15d, 2
  0068f	8b ce		 mov	 ecx, esi
  00691	74 06		 je	 SHORT $LN122@convertsim
  00693	48 8b 48 f8	 mov	 rcx, QWORD PTR [rax-8]
  00697	eb 04		 jmp	 SHORT $LN121@convertsim
$LN122@convertsim:
  00699	48 8b 70 f8	 mov	 rsi, QWORD PTR [rax-8]
$LN121@convertsim:

; 852  :             STORE_SIZE(count);

  0069d	45 85 ff	 test	 r15d, r15d
  006a0	74 14		 je	 SHORT $LN120@convertsim

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  006a2	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  006a6	49 ff c4	 inc	 r12
  006a9	4c 89 19	 mov	 QWORD PTR [rcx], r11
  006ac	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  006af	33 c0		 xor	 eax, eax
  006b1	e9 17 0a 00 00	 jmp	 $LN209@convertsim
$LN120@convertsim:

; 852  :             STORE_SIZE(count);

  006b6	49 81 fb ff ff
	ff 7f		 cmp	 r11, 2147483647		; 7fffffffH
  006bd	0f 8f cd 01 00
	00		 jg	 $LN258@convertsim
  006c3	44 89 1e	 mov	 DWORD PTR [rsi], r11d
$LN119@convertsim:

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  006c6	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  006ca	49 ff c4	 inc	 r12
  006cd	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  006d0	33 c0		 xor	 eax, eax
  006d2	e9 f6 09 00 00	 jmp	 $LN209@convertsim
$LN123@convertsim:

; 853  :             format++;
; 854  :         } else {
; 855  :             if (strlen(*p) != count)

  006d7	48 8b 3e	 mov	 rdi, QWORD PTR [rsi]
  006da	48 83 c9 ff	 or	 rcx, -1
  006de	33 c0		 xor	 eax, eax
  006e0	f2 ae		 repne scasb
  006e2	48 f7 d1	 not	 rcx
  006e5	48 ff c9	 dec	 rcx
  006e8	49 3b cb	 cmp	 rcx, r11
  006eb	0f 84 31 fc ff
	ff		 je	 $LN2@convertsim

; 856  :                 return converterr(
; 857  :                     "bytes without null bytes",
; 858  :                     arg, msgbuf, bufsize);

  006f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@KKHLFOBF@bytes?5without?5null?5bytes?$AA@
  006f8	e9 c0 09 00 00	 jmp	 $LN249@convertsim
$LN115@convertsim:

; 859  :         }
; 860  :         break;
; 861  :     }
; 862  : 
; 863  :     case 's': /* text string */
; 864  :     case 'z': /* text string or None */
; 865  :     {
; 866  :         if (*format == '*') {

  006fd	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]

; 867  :             /* "s*" or "z*" */
; 868  :             Py_buffer *p = (Py_buffer *)va_arg(*p_va, Py_buffer *);

  00702	49 83 00 08	 add	 QWORD PTR [r8], 8
  00706	3c 2a		 cmp	 al, 42			; 0000002aH
  00708	0f 85 c8 00 00
	00		 jne	 $LN114@convertsim
  0070e	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00711	48 8b 78 f8	 mov	 rdi, QWORD PTR [rax-8]

; 869  : 
; 870  :             if (c == 'z' && arg == Py_None)

  00715	41 80 fd 7a	 cmp	 r13b, 122		; 0000007aH
  00719	75 54		 jne	 SHORT $LN113@convertsim
  0071b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00722	48 3b d8	 cmp	 rbx, rax
  00725	75 48		 jne	 SHORT $LN113@convertsim

; 871  :                 PyBuffer_FillInfo(p, NULL, NULL, 0, 1, 0);

  00727	33 f6		 xor	 esi, esi
  00729	41 bd 01 00 00
	00		 mov	 r13d, 1
  0072f	45 33 c9	 xor	 r9d, r9d
  00732	45 33 c0	 xor	 r8d, r8d
  00735	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00739	33 d2		 xor	 edx, edx
  0073b	44 89 6c 24 20	 mov	 DWORD PTR [rsp+32], r13d
$LN252@convertsim:
  00740	48 8b cf	 mov	 rcx, rdi
  00743	e8 00 00 00 00	 call	 PyBuffer_FillInfo
$LN108@convertsim:

; 884  :             }
; 885  :             if (addcleanup(p, freelist, cleanup_buffer)) {

  00748	48 8b 55 60	 mov	 rdx, QWORD PTR freelist$[rbp-128]
  0074c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cleanup_buffer
  00753	48 8b cf	 mov	 rcx, rdi
  00756	e8 00 00 00 00	 call	 addcleanup
  0075b	85 c0		 test	 eax, eax
  0075d	0f 84 63 ff ff
	ff		 je	 $LN119@convertsim

; 886  :                 return converterr(
; 887  :                     "(cleanup problem)",
; 888  :                     arg, msgbuf, bufsize);

  00763	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@IHGAANNF@?$CIcleanup?5problem?$CJ?$AA@
  0076a	e9 4e 09 00 00	 jmp	 $LN249@convertsim
$LN113@convertsim:

; 872  :             else if (PyUnicode_Check(arg)) {

  0076f	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 873  :                 Py_ssize_t len;
; 874  :                 sarg = PyUnicode_AsUTF8AndSize(arg, &len);

  00773	48 8b cb	 mov	 rcx, rbx
  00776	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00780	74 37		 je	 SHORT $LN111@convertsim
  00782	48 8d 55 d0	 lea	 rdx, QWORD PTR len$21089[rbp-128]
  00786	e8 00 00 00 00	 call	 PyUnicode_AsUTF8AndSize

; 875  :                 if (sarg == NULL)
; 876  :                     return converterr(CONV_UNICODE,
; 877  :                                       arg, msgbuf, bufsize);

  0078b	48 8b d3	 mov	 rdx, rbx
  0078e	48 85 c0	 test	 rax, rax
  00791	75 0c		 jne	 SHORT $LN110@convertsim
  00793	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@MCHPFBGL@?$CIunicode?5conversion?5error?$CJ?$AA@
  0079a	e9 21 09 00 00	 jmp	 $LN251@convertsim
$LN110@convertsim:

; 878  :                 PyBuffer_FillInfo(p, arg, sarg, len, 1, 0);

  0079f	4c 8b 4d d0	 mov	 r9, QWORD PTR len$21089[rbp-128]
  007a3	33 f6		 xor	 esi, esi
  007a5	41 bd 01 00 00
	00		 mov	 r13d, 1
  007ab	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  007af	44 89 6c 24 20	 mov	 DWORD PTR [rsp+32], r13d
  007b4	4c 8b c0	 mov	 r8, rax

; 879  :             }
; 880  :             else { /* any buffer-like object */

  007b7	eb 87		 jmp	 SHORT $LN252@convertsim
$LN111@convertsim:

; 881  :                 char *buf;
; 882  :                 if (getbuffer(arg, p, &buf) < 0)

  007b9	4c 8d 45 d0	 lea	 r8, QWORD PTR buf$21094[rbp-128]
  007bd	48 8b d7	 mov	 rdx, rdi
  007c0	e8 00 00 00 00	 call	 getbuffer
  007c5	85 c0		 test	 eax, eax
  007c7	0f 89 7b ff ff
	ff		 jns	 $LN108@convertsim
$LN259@convertsim:

; 883  :                     return converterr(buf, arg, msgbuf, bufsize);

  007cd	48 8b 4d d0	 mov	 rcx, QWORD PTR buf$21094[rbp-128]
  007d1	e9 e7 08 00 00	 jmp	 $LN249@convertsim
$LN114@convertsim:

; 889  :             }
; 890  :             format++;
; 891  :         } else if (*format == '#') { /* any buffer-like object */

  007d6	3c 23		 cmp	 al, 35			; 00000023H
  007d8	0f 85 15 01 00
	00		 jne	 $LN105@convertsim

; 892  :             /* "s#" or "z#" */
; 893  :             void **p = (void **)va_arg(*p_va, char **);

  007de	49 8b 10	 mov	 rdx, QWORD PTR [r8]

; 894  :             FETCH_SIZE;

  007e1	33 f6		 xor	 esi, esi
  007e3	41 83 e7 02	 and	 r15d, 2
  007e7	48 8b 4a f8	 mov	 rcx, QWORD PTR [rdx-8]
  007eb	48 8d 42 08	 lea	 rax, QWORD PTR [rdx+8]
  007ef	44 8b f6	 mov	 r14d, esi
  007f2	48 89 4d d0	 mov	 QWORD PTR p$1$[rbp-128], rcx
  007f6	49 89 00	 mov	 QWORD PTR [r8], rax
  007f9	74 08		 je	 SHORT $LN104@convertsim
  007fb	4c 8b 70 f8	 mov	 r14, QWORD PTR [rax-8]
  007ff	8b fe		 mov	 edi, esi
  00801	eb 04		 jmp	 SHORT $LN103@convertsim
$LN104@convertsim:
  00803	48 8b 78 f8	 mov	 rdi, QWORD PTR [rax-8]
$LN103@convertsim:

; 895  : 
; 896  :             if (c == 'z' && arg == Py_None) {

  00807	41 80 fd 7a	 cmp	 r13b, 122		; 0000007aH
  0080b	75 3b		 jne	 SHORT $LN102@convertsim
  0080d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00814	48 3b d8	 cmp	 rbx, rax
  00817	75 2f		 jne	 SHORT $LN102@convertsim

; 897  :                 *p = NULL;

  00819	48 89 31	 mov	 QWORD PTR [rcx], rsi

; 898  :                 STORE_SIZE(0);

  0081c	45 85 ff	 test	 r15d, r15d
  0081f	74 14		 je	 SHORT $LN101@convertsim

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  00821	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  00825	49 ff c4	 inc	 r12
  00828	49 89 36	 mov	 QWORD PTR [r14], rsi
  0082b	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  0082e	33 c0		 xor	 eax, eax
  00830	e9 98 08 00 00	 jmp	 $LN209@convertsim
$LN101@convertsim:

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  00835	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  00839	49 ff c4	 inc	 r12
  0083c	89 37		 mov	 DWORD PTR [rdi], esi
  0083e	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  00841	33 c0		 xor	 eax, eax
  00843	e9 85 08 00 00	 jmp	 $LN209@convertsim
$LN102@convertsim:

; 899  :             }
; 900  :             else if (PyUnicode_Check(arg)) {

  00848	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0084c	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00856	74 57		 je	 SHORT $LN97@convertsim

; 901  :                 Py_ssize_t len;
; 902  :                 sarg = PyUnicode_AsUTF8AndSize(arg, &len);

  00858	48 8d 55 c8	 lea	 rdx, QWORD PTR len$21145[rbp-128]
  0085c	48 8b cb	 mov	 rcx, rbx
  0085f	e8 00 00 00 00	 call	 PyUnicode_AsUTF8AndSize
  00864	4c 8b d8	 mov	 r11, rax

; 903  :                 if (sarg == NULL)

  00867	48 85 c0	 test	 rax, rax
  0086a	75 0c		 jne	 SHORT $LN96@convertsim
$LN260@convertsim:

; 904  :                     return converterr(CONV_UNICODE,
; 905  :                                       arg, msgbuf, bufsize);

  0086c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@MCHPFBGL@?$CIunicode?5conversion?5error?$CJ?$AA@
  00873	e9 45 08 00 00	 jmp	 $LN249@convertsim
$LN96@convertsim:

; 906  :                 *p = sarg;

  00878	48 8b 45 d0	 mov	 rax, QWORD PTR p$1$[rbp-128]
  0087c	4c 89 18	 mov	 QWORD PTR [rax], r11

; 907  :                 STORE_SIZE(len);

  0087f	48 8b 45 c8	 mov	 rax, QWORD PTR len$21145[rbp-128]
  00883	45 85 ff	 test	 r15d, r15d
  00886	75 44		 jne	 SHORT $LN253@convertsim
$LN95@convertsim:
  00888	48 3d ff ff ff
	7f		 cmp	 rax, 2147483647		; 7fffffffH
  0088e	7e 50		 jle	 SHORT $LN88@convertsim
$LN258@convertsim:
  00890	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00897	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@PBNPKOPA@size?5does?5not?5fit?5in?5an?5int?$AA@
  0089e	e8 00 00 00 00	 call	 PyErr_SetString
  008a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  008aa	e9 0e 08 00 00	 jmp	 $LN249@convertsim
$LN97@convertsim:

; 908  :             }
; 909  :             else { /* any buffer-like object */
; 910  :                 /* XXX Really? */
; 911  :                 char *buf;
; 912  :                 Py_ssize_t count = convertbuffer(arg, p, &buf);

  008af	48 8b d1	 mov	 rdx, rcx
  008b2	4c 8d 45 d0	 lea	 r8, QWORD PTR buf$21152[rbp-128]
  008b6	48 8b cb	 mov	 rcx, rbx
  008b9	e8 00 00 00 00	 call	 convertbuffer

; 913  :                 if (count < 0)

  008be	48 85 c0	 test	 rax, rax

; 914  :                     return converterr(buf, arg, msgbuf, bufsize);

  008c1	0f 88 06 ff ff
	ff		 js	 $LN259@convertsim

; 915  :                 STORE_SIZE(count);

  008c7	45 85 ff	 test	 r15d, r15d
  008ca	74 bc		 je	 SHORT $LN95@convertsim
$LN253@convertsim:
  008cc	49 89 06	 mov	 QWORD PTR [r14], rax

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  008cf	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  008d3	49 ff c4	 inc	 r12
  008d6	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  008d9	33 c0		 xor	 eax, eax
  008db	e9 ed 07 00 00	 jmp	 $LN209@convertsim
$LN88@convertsim:

; 915  :                 STORE_SIZE(count);

  008e0	89 07		 mov	 DWORD PTR [rdi], eax

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  008e2	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  008e6	49 ff c4	 inc	 r12
  008e9	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  008ec	33 c0		 xor	 eax, eax
  008ee	e9 da 07 00 00	 jmp	 $LN209@convertsim
$LN105@convertsim:

; 916  :             }
; 917  :             format++;
; 918  :         } else {
; 919  :             /* "s" or "z" */
; 920  :             char **p = va_arg(*p_va, char **);

  008f3	49 8b 00	 mov	 rax, QWORD PTR [r8]
  008f6	48 8b 78 f8	 mov	 rdi, QWORD PTR [rax-8]

; 921  :             Py_ssize_t len;
; 922  :             sarg = NULL;
; 923  : 
; 924  :             if (c == 'z' && arg == Py_None)

  008fa	41 80 fd 7a	 cmp	 r13b, 122		; 0000007aH
  008fe	75 1f		 jne	 SHORT $LN86@convertsim
  00900	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00907	48 3b d8	 cmp	 rbx, rax
  0090a	75 13		 jne	 SHORT $LN86@convertsim

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  0090c	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  00910	33 f6		 xor	 esi, esi
  00912	48 89 37	 mov	 QWORD PTR [rdi], rsi
  00915	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  00918	33 c0		 xor	 eax, eax
  0091a	e9 ae 07 00 00	 jmp	 $LN209@convertsim
$LN86@convertsim:

; 925  :                 *p = NULL;
; 926  :             else if (PyUnicode_Check(arg)) {

  0091f	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00923	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  0092d	74 51		 je	 SHORT $LN84@convertsim

; 927  :                 sarg = PyUnicode_AsUTF8AndSize(arg, &len);

  0092f	48 8d 55 d0	 lea	 rdx, QWORD PTR len$21170[rbp-128]
  00933	48 8b cb	 mov	 rcx, rbx
  00936	e8 00 00 00 00	 call	 PyUnicode_AsUTF8AndSize
  0093b	4c 8b d8	 mov	 r11, rax

; 928  :                 if (sarg == NULL)

  0093e	48 85 c0	 test	 rax, rax

; 929  :                     return converterr(CONV_UNICODE,
; 930  :                                       arg, msgbuf, bufsize);

  00941	0f 84 25 ff ff
	ff		 je	 $LN260@convertsim

; 931  :                 *p = sarg;

  00947	48 89 07	 mov	 QWORD PTR [rdi], rax

; 936  :             if (*p != NULL && sarg != NULL && (Py_ssize_t) strlen(*p) != len)

  0094a	48 83 c9 ff	 or	 rcx, -1
  0094e	33 c0		 xor	 eax, eax
  00950	49 8b fb	 mov	 rdi, r11
  00953	f2 ae		 repne scasb
  00955	48 f7 d1	 not	 rcx
  00958	48 ff c9	 dec	 rcx
  0095b	48 3b 4d d0	 cmp	 rcx, QWORD PTR len$21170[rbp-128]
  0095f	0f 84 bd f9 ff
	ff		 je	 $LN2@convertsim

; 937  :                 return converterr(
; 938  :                     c == 'z' ? "str without null characters or None"
; 939  :                              : "str without null characters",
; 940  :                     arg, msgbuf, bufsize);

  00965	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CE@NNHOCDLF@str?5without?5null?5characters?5or?5N@
  0096c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@CLLMJED@str?5without?5null?5characters?$AA@
  00973	41 80 fd 7a	 cmp	 r13b, 122		; 0000007aH
  00977	48 0f 44 c8	 cmove	 rcx, rax
  0097b	e9 3d 07 00 00	 jmp	 $LN249@convertsim
$LN84@convertsim:

; 932  :             }
; 933  :             else
; 934  :                 return converterr(c == 'z' ? "str or None" : "str",
; 935  :                                   arg, msgbuf, bufsize);

  00980	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0M@ECJNJCHF@str?5or?5None?$AA@
  00987	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03OJMAPEGJ@str?$AA@
  0098e	41 80 fd 7a	 cmp	 r13b, 122		; 0000007aH
  00992	48 0f 44 c8	 cmove	 rcx, rax
  00996	e9 22 07 00 00	 jmp	 $LN249@convertsim
$LN80@convertsim:

; 941  :         }
; 942  :         break;
; 943  :     }
; 944  : 
; 945  :     case 'u': /* raw unicode buffer (Py_UNICODE *) */
; 946  :     case 'Z': /* raw unicode buffer or None */
; 947  :     {
; 948  :         Py_UNICODE **p = va_arg(*p_va, Py_UNICODE **);

  0099b	49 83 00 08	 add	 QWORD PTR [r8], 8

; 949  : 
; 950  :         if (*format == '#') { /* any buffer-like object */

  0099f	41 80 3c 24 23	 cmp	 BYTE PTR [r12], 35	; 00000023H
  009a4	49 8b 00	 mov	 rax, QWORD PTR [r8]
  009a7	4c 8b 70 f8	 mov	 r14, QWORD PTR [rax-8]
  009ab	0f 85 e6 00 00
	00		 jne	 $LN79@convertsim

; 951  :             /* "s#" or "Z#" */
; 952  :             FETCH_SIZE;

  009b1	33 f6		 xor	 esi, esi
  009b3	48 83 c0 08	 add	 rax, 8
  009b7	41 83 e7 02	 and	 r15d, 2
  009bb	8b d6		 mov	 edx, esi
  009bd	8b ce		 mov	 ecx, esi
  009bf	49 89 00	 mov	 QWORD PTR [r8], rax
  009c2	48 89 55 b8	 mov	 QWORD PTR q$1$[rbp-128], rdx
  009c6	48 89 4d c8	 mov	 QWORD PTR q2$1$[rbp-128], rcx
  009ca	74 0a		 je	 SHORT $LN78@convertsim
  009cc	48 8b 48 f8	 mov	 rcx, QWORD PTR [rax-8]
  009d0	48 89 4d c8	 mov	 QWORD PTR q2$1$[rbp-128], rcx
  009d4	eb 08		 jmp	 SHORT $LN77@convertsim
$LN78@convertsim:
  009d6	48 8b 50 f8	 mov	 rdx, QWORD PTR [rax-8]
  009da	48 89 55 b8	 mov	 QWORD PTR q$1$[rbp-128], rdx
$LN77@convertsim:

; 953  : 
; 954  :             if (c == 'Z' && arg == Py_None) {

  009de	41 80 fd 5a	 cmp	 r13b, 90		; 0000005aH
  009e2	75 3b		 jne	 SHORT $LN76@convertsim
  009e4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  009eb	48 3b d8	 cmp	 rbx, rax
  009ee	75 2f		 jne	 SHORT $LN76@convertsim

; 955  :                 *p = NULL;

  009f0	49 89 36	 mov	 QWORD PTR [r14], rsi

; 956  :                 STORE_SIZE(0);

  009f3	45 85 ff	 test	 r15d, r15d
  009f6	74 14		 je	 SHORT $LN75@convertsim

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  009f8	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  009fc	49 ff c4	 inc	 r12
  009ff	48 89 31	 mov	 QWORD PTR [rcx], rsi
  00a02	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  00a05	33 c0		 xor	 eax, eax
  00a07	e9 c1 06 00 00	 jmp	 $LN209@convertsim
$LN75@convertsim:

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  00a0c	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  00a10	49 ff c4	 inc	 r12
  00a13	89 32		 mov	 DWORD PTR [rdx], esi
  00a15	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  00a18	33 c0		 xor	 eax, eax
  00a1a	e9 ae 06 00 00	 jmp	 $LN209@convertsim
$LN76@convertsim:

; 957  :             }
; 958  :             else if (PyUnicode_Check(arg)) {

  00a1f	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00a23	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00a2d	74 5c		 je	 SHORT $LN71@convertsim

; 959  :                 Py_ssize_t len;
; 960  :                 *p = PyUnicode_AsUnicodeAndSize(arg, &len);

  00a2f	48 8d 55 c0	 lea	 rdx, QWORD PTR len$21235[rbp-128]
  00a33	48 8b cb	 mov	 rcx, rbx
  00a36	e8 00 00 00 00	 call	 PyUnicode_AsUnicodeAndSize
  00a3b	49 89 06	 mov	 QWORD PTR [r14], rax

; 961  :                 if (*p == NULL)

  00a3e	48 85 c0	 test	 rax, rax

; 962  :                     RETURN_ERR_OCCURRED;

  00a41	0f 84 51 f6 ff
	ff		 je	 $LN262@convertsim

; 963  :                 STORE_SIZE(len);

  00a47	48 8b 45 c0	 mov	 rax, QWORD PTR len$21235[rbp-128]
  00a4b	45 85 ff	 test	 r15d, r15d
  00a4e	74 18		 je	 SHORT $LN69@convertsim
  00a50	48 8b 4d c8	 mov	 rcx, QWORD PTR q2$1$[rbp-128]

; 967  :             format++;

  00a54	49 ff c4	 inc	 r12
  00a57	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  00a5a	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  00a5e	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  00a61	33 c0		 xor	 eax, eax
  00a63	e9 65 06 00 00	 jmp	 $LN209@convertsim
$LN69@convertsim:

; 963  :                 STORE_SIZE(len);

  00a68	48 3d ff ff ff
	7f		 cmp	 rax, 2147483647		; 7fffffffH
  00a6e	0f 8f 1c fe ff
	ff		 jg	 $LN258@convertsim
  00a74	48 8b 4d b8	 mov	 rcx, QWORD PTR q$1$[rbp-128]

; 967  :             format++;

  00a78	49 ff c4	 inc	 r12
  00a7b	89 01		 mov	 DWORD PTR [rcx], eax

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  00a7d	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  00a81	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  00a84	33 c0		 xor	 eax, eax
  00a86	e9 42 06 00 00	 jmp	 $LN209@convertsim
$LN71@convertsim:

; 964  :             }
; 965  :             else
; 966  :                 return converterr("str or None", arg, msgbuf, bufsize);

  00a8b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@ECJNJCHF@str?5or?5None?$AA@
  00a92	e9 26 06 00 00	 jmp	 $LN249@convertsim
$LN79@convertsim:

; 968  :         } else {
; 969  :             /* "s" or "Z" */
; 970  :             if (c == 'Z' && arg == Py_None)

  00a97	41 80 fd 5a	 cmp	 r13b, 90		; 0000005aH
  00a9b	75 1f		 jne	 SHORT $LN64@convertsim
  00a9d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00aa4	48 3b d8	 cmp	 rbx, rax
  00aa7	75 13		 jne	 SHORT $LN64@convertsim

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  00aa9	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  00aad	33 f6		 xor	 esi, esi
  00aaf	49 89 36	 mov	 QWORD PTR [r14], rsi
  00ab2	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  00ab5	33 c0		 xor	 eax, eax
  00ab7	e9 11 06 00 00	 jmp	 $LN209@convertsim
$LN64@convertsim:

; 971  :                 *p = NULL;
; 972  :             else if (PyUnicode_Check(arg)) {

  00abc	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00ac0	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00aca	74 36		 je	 SHORT $LN62@convertsim

; 973  :                 Py_ssize_t len;
; 974  :                 *p = PyUnicode_AsUnicodeAndSize(arg, &len);

  00acc	48 8d 55 d0	 lea	 rdx, QWORD PTR len$21248[rbp-128]
  00ad0	48 8b cb	 mov	 rcx, rbx
  00ad3	e8 00 00 00 00	 call	 PyUnicode_AsUnicodeAndSize
  00ad8	49 89 06	 mov	 QWORD PTR [r14], rax

; 975  :                 if (*p == NULL)

  00adb	48 85 c0	 test	 rax, rax

; 976  :                     RETURN_ERR_OCCURRED;

  00ade	0f 84 b4 f5 ff
	ff		 je	 $LN262@convertsim

; 977  :                 if (Py_UNICODE_strlen(*p) != len)

  00ae4	48 8b c8	 mov	 rcx, rax
  00ae7	e8 00 00 00 00	 call	 Py_UNICODE_strlen
  00aec	48 3b 45 d0	 cmp	 rax, QWORD PTR len$21248[rbp-128]
  00af0	0f 84 2c f8 ff
	ff		 je	 $LN2@convertsim

; 978  :                     return converterr(
; 979  :                         "str without null characters or None",
; 980  :                         arg, msgbuf, bufsize);

  00af6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@NNHOCDLF@str?5without?5null?5characters?5or?5N@
  00afd	e9 bb 05 00 00	 jmp	 $LN249@convertsim
$LN62@convertsim:

; 981  :             } else
; 982  :                 return converterr(c == 'Z' ? "str or None" : "str",
; 983  :                                   arg, msgbuf, bufsize);

  00b02	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0M@ECJNJCHF@str?5or?5None?$AA@
  00b09	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03OJMAPEGJ@str?$AA@
  00b10	41 80 fd 5a	 cmp	 r13b, 90		; 0000005aH
  00b14	48 0f 44 c8	 cmove	 rcx, rax
  00b18	e9 a0 05 00 00	 jmp	 $LN249@convertsim
$LN58@convertsim:

; 984  :         }
; 985  :         break;
; 986  :     }
; 987  : 
; 988  :     case 'e': {/* encoded string */
; 989  :         char **buffer;
; 990  :         const char *encoding;
; 991  :         PyObject *s;
; 992  :         int recode_strings;
; 993  :         Py_ssize_t size;
; 994  :         const char *ptr;
; 995  : 
; 996  :         /* Get 'e' parameter: the encoding name */
; 997  :         encoding = (const char *)va_arg(*p_va, const char *);

  00b1d	49 83 00 08	 add	 QWORD PTR [r8], 8
  00b21	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00b24	4c 8b 70 f8	 mov	 r14, QWORD PTR [rax-8]

; 998  :         if (encoding == NULL)

  00b28	4d 85 f6	 test	 r14, r14
  00b2b	75 08		 jne	 SHORT $LN57@convertsim

; 999  :             encoding = PyUnicode_GetDefaultEncoding();

  00b2d	e8 00 00 00 00	 call	 PyUnicode_GetDefaultEncoding
  00b32	4c 8b f0	 mov	 r14, rax
$LN57@convertsim:

; 1000 : 
; 1001 :         /* Get output buffer parameter:
; 1002 :            's' (recode all objects via Unicode) or
; 1003 :            't' (only recode non-string objects)
; 1004 :         */
; 1005 :         if (*format == 's')

  00b35	41 0f b6 0c 24	 movzx	 ecx, BYTE PTR [r12]
  00b3a	33 f6		 xor	 esi, esi
  00b3c	44 8d 6e 01	 lea	 r13d, QWORD PTR [rsi+1]
  00b40	80 f9 73	 cmp	 cl, 115			; 00000073H
  00b43	75 05		 jne	 SHORT $LN56@convertsim

; 1006 :             recode_strings = 1;

  00b45	41 8b cd	 mov	 ecx, r13d
  00b48	eb 0b		 jmp	 SHORT $LN53@convertsim
$LN56@convertsim:

; 1007 :         else if (*format == 't')

  00b4a	80 f9 74	 cmp	 cl, 116			; 00000074H
  00b4d	0f 85 66 03 00
	00		 jne	 $LN54@convertsim

; 1008 :             recode_strings = 0;

  00b53	8b ce		 mov	 ecx, esi
$LN53@convertsim:

; 1013 :         buffer = (char **)va_arg(*p_va, char **);

  00b55	48 83 07 08	 add	 QWORD PTR [rdi], 8
  00b59	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 1014 :         format++;

  00b5c	49 ff c4	 inc	 r12
  00b5f	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00b63	48 89 45 b8	 mov	 QWORD PTR buffer$1$[rbp-128], rax

; 1015 :         if (buffer == NULL)

  00b67	48 85 c0	 test	 rax, rax
  00b6a	75 0c		 jne	 SHORT $LN52@convertsim

; 1016 :             return converterr("(buffer is NULL)",
; 1017 :                               arg, msgbuf, bufsize);

  00b6c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@MCHFDCHO@?$CIbuffer?5is?5NULL?$CJ?$AA@
  00b73	e9 45 05 00 00	 jmp	 $LN249@convertsim
$LN52@convertsim:

; 1018 : 
; 1019 :         /* Encode object */
; 1020 :         if (!recode_strings &&
; 1021 :             (PyBytes_Check(arg) || PyByteArray_Check(arg))) {

  00b78	85 c9		 test	 ecx, ecx
  00b7a	75 5d		 jne	 SHORT $LN51@convertsim
  00b7c	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00b80	f7 81 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rcx+256], 134217728 ; 08000000H
  00b8a	75 15		 jne	 SHORT $LN49@convertsim
  00b8c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00b93	48 3b ca	 cmp	 rcx, rdx
  00b96	74 09		 je	 SHORT $LN49@convertsim
  00b98	e8 00 00 00 00	 call	 PyType_IsSubtype
  00b9d	85 c0		 test	 eax, eax
  00b9f	74 38		 je	 SHORT $LN51@convertsim
$LN49@convertsim:

; 1022 :             s = arg;
; 1023 :             Py_INCREF(s);

  00ba1	48 8b cb	 mov	 rcx, rbx
  00ba4	4c 8b f3	 mov	 r14, rbx
  00ba7	e8 00 00 00 00	 call	 _Py_IncRef

; 1024 :             if (PyObject_AsCharBuffer(s, &ptr, &size) < 0)

  00bac	4c 8d 45 b0	 lea	 r8, QWORD PTR size$21258[rbp-128]
  00bb0	48 8d 55 c0	 lea	 rdx, QWORD PTR ptr$21259[rbp-128]
  00bb4	48 8b cb	 mov	 rcx, rbx
  00bb7	e8 00 00 00 00	 call	 PyObject_AsCharBuffer
  00bbc	85 c0		 test	 eax, eax
  00bbe	79 0c		 jns	 SHORT $LN247@convertsim

; 1025 :                 return converterr("(AsCharBuffer failed)",
; 1026 :                                   arg, msgbuf, bufsize);

  00bc0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@KEABMDON@?$CIAsCharBuffer?5failed?$CJ?$AA@
  00bc7	e9 f1 04 00 00	 jmp	 $LN249@convertsim
$LN247@convertsim:

; 1054 :             if (ptr == NULL)

  00bcc	48 8b 55 b0	 mov	 rdx, QWORD PTR size$21258[rbp-128]
  00bd0	4c 8b 4d c0	 mov	 r9, QWORD PTR ptr$21259[rbp-128]
  00bd4	e9 8a 00 00 00	 jmp	 $LN43@convertsim
$LN51@convertsim:

; 1027 :         }
; 1028 :         else {
; 1029 :             PyObject *u;
; 1030 : 
; 1031 :             /* Convert object to Unicode */
; 1032 :             u = PyUnicode_FromObject(arg);

  00bd9	48 8b cb	 mov	 rcx, rbx
  00bdc	e8 00 00 00 00	 call	 PyUnicode_FromObject
  00be1	48 89 45 d0	 mov	 QWORD PTR u$1$[rbp-128], rax

; 1033 :             if (u == NULL)

  00be5	48 85 c0	 test	 rax, rax
  00be8	75 0c		 jne	 SHORT $LN46@convertsim

; 1034 :                 return converterr(
; 1035 :                     "string or unicode or text buffer",
; 1036 :                     arg, msgbuf, bufsize);

  00bea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CB@CBNPKI@string?5or?5unicode?5or?5text?5buffer@
  00bf1	e9 c7 04 00 00	 jmp	 $LN249@convertsim
$LN46@convertsim:

; 1037 : 
; 1038 :             /* Encode object; use default error handling */
; 1039 :             s = PyUnicode_AsEncodedString(u,
; 1040 :                                           encoding,
; 1041 :                                           NULL);

  00bf6	45 33 c0	 xor	 r8d, r8d
  00bf9	49 8b d6	 mov	 rdx, r14
  00bfc	48 8b c8	 mov	 rcx, rax
  00bff	e8 00 00 00 00	 call	 PyUnicode_AsEncodedString

; 1042 :             Py_DECREF(u);

  00c04	48 8b 4d d0	 mov	 rcx, QWORD PTR u$1$[rbp-128]
  00c08	4c 8b f0	 mov	 r14, rax
  00c0b	e8 00 00 00 00	 call	 _Py_DecRef

; 1043 :             if (s == NULL)

  00c10	4d 85 f6	 test	 r14, r14
  00c13	75 0c		 jne	 SHORT $LN45@convertsim

; 1044 :                 return converterr("(encoding failed)",
; 1045 :                                   arg, msgbuf, bufsize);

  00c15	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@ECLEOFDF@?$CIencoding?5failed?$CJ?$AA@
  00c1c	e9 9c 04 00 00	 jmp	 $LN249@convertsim
$LN45@convertsim:

; 1046 :             if (!PyBytes_Check(s)) {

  00c21	49 8b 46 58	 mov	 rax, QWORD PTR [r14+88]
  00c25	f7 80 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rax+256], 134217728 ; 08000000H
  00c2f	75 14		 jne	 SHORT $LN44@convertsim

; 1047 :                 Py_DECREF(s);

  00c31	49 8b ce	 mov	 rcx, r14
  00c34	e8 00 00 00 00	 call	 _Py_DecRef

; 1048 :                 return converterr(
; 1049 :                     "(encoder failed to return bytes)",
; 1050 :                     arg, msgbuf, bufsize);

  00c39	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CB@OMNKEOOG@?$CIencoder?5failed?5to?5return?5bytes?$CJ@
  00c40	e9 78 04 00 00	 jmp	 $LN249@convertsim
$LN44@convertsim:

; 1051 :             }
; 1052 :             size = PyBytes_GET_SIZE(s);

  00c45	49 8b 56 60	 mov	 rdx, QWORD PTR [r14+96]

; 1053 :             ptr = PyBytes_AS_STRING(s);

  00c49	49 8d 46 78	 lea	 rax, QWORD PTR [r14+120]

; 1054 :             if (ptr == NULL)

  00c4d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00c54	48 85 c0	 test	 rax, rax
  00c57	48 89 55 b0	 mov	 QWORD PTR size$21258[rbp-128], rdx
  00c5b	4c 0f 45 c8	 cmovne	 r9, rax
  00c5f	4c 89 4d c0	 mov	 QWORD PTR ptr$21259[rbp-128], r9
$LN43@convertsim:

; 1055 :                 ptr = "";
; 1056 :         }
; 1057 : 
; 1058 :         /* Write output; output is guaranteed to be 0-terminated */
; 1059 :         if (*format == '#') {

  00c63	41 80 3c 24 23	 cmp	 BYTE PTR [r12], 35	; 00000023H
  00c68	0f 85 84 01 00
	00		 jne	 $LN42@convertsim

; 1060 :             /* Using buffer length parameter '#':
; 1061 : 
; 1062 :                - if *buffer is NULL, a new buffer of the
; 1063 :                needed size is allocated and the data
; 1064 :                copied into it; *buffer is updated to point
; 1065 :                to the new buffer; the caller is
; 1066 :                responsible for PyMem_Free()ing it after
; 1067 :                usage
; 1068 : 
; 1069 :                - if *buffer is not NULL, the data is
; 1070 :                copied to *buffer; *buffer_len has to be
; 1071 :                set to the size of the buffer on input;
; 1072 :                buffer overflow is signalled with an error;
; 1073 :                buffer has to provide enough room for the
; 1074 :                encoded string plus the trailing 0-byte
; 1075 : 
; 1076 :                - in both cases, *buffer_len is updated to
; 1077 :                the size of the buffer /excluding/ the
; 1078 :                trailing 0-byte
; 1079 : 
; 1080 :             */
; 1081 :             FETCH_SIZE;

  00c6e	48 83 07 08	 add	 QWORD PTR [rdi], 8
  00c72	41 83 e7 02	 and	 r15d, 2
  00c76	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00c79	48 8b ce	 mov	 rcx, rsi
  00c7c	48 89 75 c8	 mov	 QWORD PTR q$1$[rbp-128], rsi
  00c80	48 89 4d d0	 mov	 QWORD PTR q2$1$[rbp-128], rcx
  00c84	74 0d		 je	 SHORT $LN41@convertsim
  00c86	48 8b 48 f8	 mov	 rcx, QWORD PTR [rax-8]
  00c8a	48 8b fe	 mov	 rdi, rsi
  00c8d	48 89 4d d0	 mov	 QWORD PTR q2$1$[rbp-128], rcx
  00c91	eb 08		 jmp	 SHORT $LN40@convertsim
$LN41@convertsim:
  00c93	48 8b 78 f8	 mov	 rdi, QWORD PTR [rax-8]
  00c97	48 89 7d c8	 mov	 QWORD PTR q$1$[rbp-128], rdi
$LN40@convertsim:

; 1082 : 
; 1083 :             format++;

  00c9b	49 ff c4	 inc	 r12

; 1084 :             if (q == NULL && q2 == NULL) {

  00c9e	48 85 ff	 test	 rdi, rdi
  00ca1	75 19		 jne	 SHORT $LN39@convertsim
  00ca3	48 85 c9	 test	 rcx, rcx
  00ca6	75 14		 jne	 SHORT $LN39@convertsim

; 1085 :                 Py_DECREF(s);

  00ca8	49 8b ce	 mov	 rcx, r14
  00cab	e8 00 00 00 00	 call	 _Py_DecRef

; 1086 :                 return converterr(
; 1087 :                     "(buffer_len is NULL)",
; 1088 :                     arg, msgbuf, bufsize);

  00cb0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@FDDEBFPN@?$CIbuffer_len?5is?5NULL?$CJ?$AA@
  00cb7	e9 01 04 00 00	 jmp	 $LN249@convertsim
$LN39@convertsim:

; 1089 :             }
; 1090 :             if (*buffer == NULL) {

  00cbc	48 8b 45 b8	 mov	 rax, QWORD PTR buffer$1$[rbp-128]
  00cc0	48 39 30	 cmp	 QWORD PTR [rax], rsi
  00cc3	0f 85 db 00 00
	00		 jne	 $LN38@convertsim

; 1091 :                 *buffer = PyMem_NEW(char, size + 1);

  00cc9	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]
  00ccd	48 bf ff ff ff
	ff ff ff ff 7f	 mov	 rdi, 9223372036854775807 ; 7fffffffffffffffH
  00cd7	48 3b c7	 cmp	 rax, rdi
  00cda	77 36		 ja	 SHORT $LN226@convertsim
  00cdc	e8 00 00 00 00	 call	 _Py_PXCTX
  00ce1	85 c0		 test	 eax, eax
  00ce3	74 0e		 je	 SHORT $LN227@convertsim
  00ce5	48 8b 4d b0	 mov	 rcx, QWORD PTR size$21258[rbp-128]
  00ce9	48 ff c1	 inc	 rcx
  00cec	e8 00 00 00 00	 call	 _PxMem_Malloc
  00cf1	eb 1c		 jmp	 SHORT $LN254@convertsim
$LN227@convertsim:
  00cf3	48 8b 45 b0	 mov	 rax, QWORD PTR size$21258[rbp-128]
  00cf7	48 ff c0	 inc	 rax
  00cfa	48 3b c7	 cmp	 rax, rdi
  00cfd	77 13		 ja	 SHORT $LN226@convertsim
  00cff	48 85 c0	 test	 rax, rax
  00d02	4c 0f 45 e8	 cmovne	 r13, rax
  00d06	49 8b cd	 mov	 rcx, r13
  00d09	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN254@convertsim:
  00d0f	48 8b f0	 mov	 rsi, rax
$LN226@convertsim:
  00d12	48 8b 45 b8	 mov	 rax, QWORD PTR buffer$1$[rbp-128]
  00d16	48 89 30	 mov	 QWORD PTR [rax], rsi

; 1092 :                 if (*buffer == NULL) {

  00d19	48 85 f6	 test	 rsi, rsi
  00d1c	75 16		 jne	 SHORT $LN37@convertsim
$LN267@convertsim:

; 1093 :                     Py_DECREF(s);

  00d1e	49 8b ce	 mov	 rcx, r14
  00d21	e8 00 00 00 00	 call	 _Py_DecRef

; 1094 :                     PyErr_NoMemory();

  00d26	e8 00 00 00 00	 call	 PyErr_NoMemory
  00d2b	48 8b 45 50	 mov	 rax, QWORD PTR msgbuf$[rbp-128]
  00d2f	e9 99 03 00 00	 jmp	 $LN209@convertsim
$LN37@convertsim:

; 1095 :                     RETURN_ERR_OCCURRED;
; 1096 :                 }
; 1097 :                 if (addcleanup(*buffer, freelist, cleanup_ptr)) {

  00d34	48 8b 55 60	 mov	 rdx, QWORD PTR freelist$[rbp-128]
  00d38	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cleanup_ptr
  00d3f	48 8b ce	 mov	 rcx, rsi
  00d42	e8 00 00 00 00	 call	 addcleanup
  00d47	85 c0		 test	 eax, eax
  00d49	74 14		 je	 SHORT $LN248@convertsim
$LN261@convertsim:

; 1098 :                     Py_DECREF(s);

  00d4b	49 8b ce	 mov	 rcx, r14
  00d4e	e8 00 00 00 00	 call	 _Py_DecRef

; 1099 :                     return converterr(
; 1100 :                         "(cleanup problem)",
; 1101 :                         arg, msgbuf, bufsize);

  00d53	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@IHGAANNF@?$CIcleanup?5problem?$CJ?$AA@
  00d5a	e9 5e 03 00 00	 jmp	 $LN249@convertsim
$LN248@convertsim:

; 1106 :                     return converterr(
; 1107 :                         "(buffer overflow)",
; 1108 :                         arg, msgbuf, bufsize);

  00d5f	48 8b 55 b0	 mov	 rdx, QWORD PTR size$21258[rbp-128]
  00d63	4c 8b 4d c0	 mov	 r9, QWORD PTR ptr$21259[rbp-128]
  00d67	48 8b 7d c8	 mov	 rdi, QWORD PTR q$1$[rbp-128]
$LN34@convertsim:

; 1109 :                 }
; 1110 :             }
; 1111 :             memcpy(*buffer, ptr, size+1);

  00d6b	48 8b 45 b8	 mov	 rax, QWORD PTR buffer$1$[rbp-128]
  00d6f	4c 8d 42 01	 lea	 r8, QWORD PTR [rdx+1]
  00d73	49 8b d1	 mov	 rdx, r9
  00d76	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00d79	e8 00 00 00 00	 call	 memcpy

; 1112 :             STORE_SIZE(size);

  00d7e	48 8b 45 b0	 mov	 rax, QWORD PTR size$21258[rbp-128]
  00d82	45 85 ff	 test	 r15d, r15d
  00d85	74 47		 je	 SHORT $LN33@convertsim
  00d87	48 8b 4d d0	 mov	 rcx, QWORD PTR q2$1$[rbp-128]
  00d8b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1145 :         }
; 1146 :         Py_DECREF(s);

  00d8e	49 8b ce	 mov	 rcx, r14
  00d91	e8 00 00 00 00	 call	 _Py_DecRef

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  00d96	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  00d9a	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  00d9d	33 c0		 xor	 eax, eax
  00d9f	e9 29 03 00 00	 jmp	 $LN209@convertsim
$LN38@convertsim:

; 1102 :                 }
; 1103 :             } else {
; 1104 :                 if (size + 1 > BUFFER_LEN) {

  00da4	45 85 ff	 test	 r15d, r15d
  00da7	74 05		 je	 SHORT $LN231@convertsim
  00da9	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00dac	eb 03		 jmp	 SHORT $LN232@convertsim
$LN231@convertsim:
  00dae	48 63 0f	 movsxd	 rcx, DWORD PTR [rdi]
$LN232@convertsim:
  00db1	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]
  00db5	48 3b c1	 cmp	 rax, rcx
  00db8	7e b1		 jle	 SHORT $LN34@convertsim

; 1105 :                     Py_DECREF(s);

  00dba	49 8b ce	 mov	 rcx, r14
  00dbd	e8 00 00 00 00	 call	 _Py_DecRef

; 1106 :                     return converterr(
; 1107 :                         "(buffer overflow)",
; 1108 :                         arg, msgbuf, bufsize);

  00dc2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@CNIENJCI@?$CIbuffer?5overflow?$CJ?$AA@
  00dc9	e9 ef 02 00 00	 jmp	 $LN249@convertsim
$LN33@convertsim:

; 1112 :             STORE_SIZE(size);

  00dce	48 3d ff ff ff
	7f		 cmp	 rax, 2147483647		; 7fffffffH
  00dd4	0f 8f b6 fa ff
	ff		 jg	 $LN258@convertsim

; 1145 :         }
; 1146 :         Py_DECREF(s);

  00dda	49 8b ce	 mov	 rcx, r14
  00ddd	89 07		 mov	 DWORD PTR [rdi], eax
  00ddf	e8 00 00 00 00	 call	 _Py_DecRef

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  00de4	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  00de8	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  00deb	33 c0		 xor	 eax, eax
  00ded	e9 db 02 00 00	 jmp	 $LN209@convertsim
$LN42@convertsim:

; 1113 :         } else {
; 1114 :             /* Using a 0-terminated buffer:
; 1115 : 
; 1116 :                - the encoded string has to be 0-terminated
; 1117 :                for this variant to work; if it is not, an
; 1118 :                error raised
; 1119 : 
; 1120 :                - a new buffer of the needed size is
; 1121 :                allocated and the data copied into it;
; 1122 :                *buffer is updated to point to the new
; 1123 :                buffer; the caller is responsible for
; 1124 :                PyMem_Free()ing it after usage
; 1125 : 
; 1126 :             */
; 1127 :             if ((Py_ssize_t)strlen(ptr) != size) {

  00df2	48 83 c9 ff	 or	 rcx, -1
  00df6	33 c0		 xor	 eax, eax
  00df8	49 8b f9	 mov	 rdi, r9
  00dfb	f2 ae		 repne scasb
  00dfd	48 f7 d1	 not	 rcx
  00e00	48 ff c9	 dec	 rcx
  00e03	48 3b ca	 cmp	 rcx, rdx
  00e06	74 14		 je	 SHORT $LN29@convertsim

; 1128 :                 Py_DECREF(s);

  00e08	49 8b ce	 mov	 rcx, r14
  00e0b	e8 00 00 00 00	 call	 _Py_DecRef

; 1129 :                 return converterr(
; 1130 :                     "encoded string without NULL bytes",
; 1131 :                     arg, msgbuf, bufsize);

  00e10	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@PNMABHGD@encoded?5string?5without?5NULL?5byte@
  00e17	e9 a1 02 00 00	 jmp	 $LN249@convertsim
$LN29@convertsim:

; 1132 :             }
; 1133 :             *buffer = PyMem_NEW(char, size + 1);

  00e1c	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]
  00e20	48 bf ff ff ff
	ff ff ff ff 7f	 mov	 rdi, 9223372036854775807 ; 7fffffffffffffffH
  00e2a	48 3b c7	 cmp	 rax, rdi
  00e2d	77 36		 ja	 SHORT $LN236@convertsim
  00e2f	e8 00 00 00 00	 call	 _Py_PXCTX
  00e34	85 c0		 test	 eax, eax
  00e36	74 0e		 je	 SHORT $LN237@convertsim
  00e38	48 8b 4d b0	 mov	 rcx, QWORD PTR size$21258[rbp-128]
  00e3c	48 ff c1	 inc	 rcx
  00e3f	e8 00 00 00 00	 call	 _PxMem_Malloc
  00e44	eb 1c		 jmp	 SHORT $LN255@convertsim
$LN237@convertsim:
  00e46	48 8b 45 b0	 mov	 rax, QWORD PTR size$21258[rbp-128]
  00e4a	48 ff c0	 inc	 rax
  00e4d	48 3b c7	 cmp	 rax, rdi
  00e50	77 13		 ja	 SHORT $LN236@convertsim
  00e52	48 85 c0	 test	 rax, rax
  00e55	4c 0f 45 e8	 cmovne	 r13, rax
  00e59	49 8b cd	 mov	 rcx, r13
  00e5c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN255@convertsim:
  00e62	48 8b f0	 mov	 rsi, rax
$LN236@convertsim:
  00e65	48 8b 7d b8	 mov	 rdi, QWORD PTR buffer$1$[rbp-128]
  00e69	48 89 37	 mov	 QWORD PTR [rdi], rsi

; 1134 :             if (*buffer == NULL) {

  00e6c	48 85 f6	 test	 rsi, rsi

; 1135 :                 Py_DECREF(s);
; 1136 :                 PyErr_NoMemory();
; 1137 :                 RETURN_ERR_OCCURRED;

  00e6f	0f 84 a9 fe ff
	ff		 je	 $LN267@convertsim

; 1138 :             }
; 1139 :             if (addcleanup(*buffer, freelist, cleanup_ptr)) {

  00e75	48 8b 55 60	 mov	 rdx, QWORD PTR freelist$[rbp-128]
  00e79	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cleanup_ptr
  00e80	48 8b ce	 mov	 rcx, rsi
  00e83	e8 00 00 00 00	 call	 addcleanup
  00e88	85 c0		 test	 eax, eax

; 1140 :                 Py_DECREF(s);
; 1141 :                 return converterr("(cleanup problem)",
; 1142 :                                 arg, msgbuf, bufsize);

  00e8a	0f 85 bb fe ff
	ff		 jne	 $LN261@convertsim

; 1143 :             }
; 1144 :             memcpy(*buffer, ptr, size+1);

  00e90	4c 8b 45 b0	 mov	 r8, QWORD PTR size$21258[rbp-128]
  00e94	48 8b 55 c0	 mov	 rdx, QWORD PTR ptr$21259[rbp-128]
  00e98	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00e9b	49 ff c0	 inc	 r8
  00e9e	e8 00 00 00 00	 call	 memcpy

; 1145 :         }
; 1146 :         Py_DECREF(s);

  00ea3	49 8b ce	 mov	 rcx, r14
  00ea6	e8 00 00 00 00	 call	 _Py_DecRef

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  00eab	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  00eaf	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  00eb2	33 c0		 xor	 eax, eax
  00eb4	e9 14 02 00 00	 jmp	 $LN209@convertsim
$LN54@convertsim:

; 1009 :         else
; 1010 :             return converterr(
; 1011 :                 "(unknown parser marker combination)",
; 1012 :                 arg, msgbuf, bufsize);

  00eb9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@BAFKKLBH@?$CIunknown?5parser?5marker?5combinati@
  00ec0	e9 f8 01 00 00	 jmp	 $LN249@convertsim
$LN26@convertsim:

; 1147 :         break;
; 1148 :     }
; 1149 : 
; 1150 :     case 'S': { /* PyBytes object */
; 1151 :         PyObject **p = va_arg(*p_va, PyObject **);

  00ec5	49 83 00 08	 add	 QWORD PTR [r8], 8

; 1152 :         if (PyBytes_Check(arg))

  00ec9	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00ecd	49 8b 08	 mov	 rcx, QWORD PTR [r8]
  00ed0	f7 80 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rax+256], 134217728 ; 08000000H
  00eda	74 15		 je	 SHORT $LN25@convertsim

; 1153 :             *p = arg;

  00edc	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]
  00ee0	48 89 18	 mov	 QWORD PTR [rax], rbx

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  00ee3	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  00ee7	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  00eea	33 c0		 xor	 eax, eax
  00eec	e9 dc 01 00 00	 jmp	 $LN209@convertsim
$LN25@convertsim:

; 1154 :         else
; 1155 :             return converterr("bytes", arg, msgbuf, bufsize);

  00ef1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05FBJAGGIG@bytes?$AA@
  00ef8	e9 c0 01 00 00	 jmp	 $LN249@convertsim
$LN23@convertsim:

; 1156 :         break;
; 1157 :     }
; 1158 : 
; 1159 :     case 'Y': { /* PyByteArray object */
; 1160 :         PyObject **p = va_arg(*p_va, PyObject **);

  00efd	49 83 00 08	 add	 QWORD PTR [r8], 8
  00f01	49 8b 00	 mov	 rax, QWORD PTR [r8]

; 1161 :         if (PyByteArray_Check(arg))

  00f04	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00f08	48 8b 78 f8	 mov	 rdi, QWORD PTR [rax-8]
  00f0c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00f13	48 3b ca	 cmp	 rcx, rdx
  00f16	74 15		 je	 SHORT $LN21@convertsim
  00f18	e8 00 00 00 00	 call	 PyType_IsSubtype
  00f1d	85 c0		 test	 eax, eax
  00f1f	75 0c		 jne	 SHORT $LN21@convertsim

; 1162 :             *p = arg;
; 1163 :         else
; 1164 :             return converterr("bytearray", arg, msgbuf, bufsize);

  00f21	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09FCJHKOIN@bytearray?$AA@
  00f28	e9 90 01 00 00	 jmp	 $LN249@convertsim
$LN21@convertsim:

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  00f2d	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  00f31	48 89 1f	 mov	 QWORD PTR [rdi], rbx
  00f34	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  00f37	33 c0		 xor	 eax, eax
  00f39	e9 8f 01 00 00	 jmp	 $LN209@convertsim
$LN19@convertsim:

; 1165 :         break;
; 1166 :     }
; 1167 : 
; 1168 :     case 'U': { /* PyUnicode object */
; 1169 :         PyObject **p = va_arg(*p_va, PyObject **);

  00f3e	49 83 00 08	 add	 QWORD PTR [r8], 8
  00f42	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00f45	48 8b 78 f8	 mov	 rdi, QWORD PTR [rax-8]

; 1170 :         if (PyUnicode_Check(arg)) {

  00f49	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00f4d	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00f57	74 1c		 je	 SHORT $LN18@convertsim

; 1171 :             if (PyUnicode_READY(arg) == -1)

  00f59	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  00f5d	75 ce		 jne	 SHORT $LN21@convertsim
  00f5f	48 8b cb	 mov	 rcx, rbx
  00f62	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00f67	83 f8 ff	 cmp	 eax, -1
  00f6a	75 c1		 jne	 SHORT $LN21@convertsim

; 588  :             RETURN_ERR_OCCURRED;

  00f6c	48 8b 45 50	 mov	 rax, QWORD PTR msgbuf$[rbp-128]
  00f70	e9 58 01 00 00	 jmp	 $LN209@convertsim
$LN18@convertsim:

; 1172 :                 RETURN_ERR_OCCURRED;
; 1173 :             *p = arg;
; 1174 :         }
; 1175 :         else
; 1176 :             return converterr("str", arg, msgbuf, bufsize);

  00f75	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03OJMAPEGJ@str?$AA@
  00f7c	e9 3c 01 00 00	 jmp	 $LN249@convertsim
$LN15@convertsim:

; 1177 :         break;
; 1178 :     }
; 1179 : 
; 1180 :     case 'O': { /* object */
; 1181 :         PyTypeObject *type;
; 1182 :         PyObject **p;
; 1183 :         if (*format == '!') {

  00f81	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]

; 1184 :             type = va_arg(*p_va, PyTypeObject*);

  00f86	49 83 00 08	 add	 QWORD PTR [r8], 8
  00f8a	3c 21		 cmp	 al, 33			; 00000021H
  00f8c	75 32		 jne	 SHORT $LN14@convertsim
  00f8e	49 8b 00	 mov	 rax, QWORD PTR [r8]

; 1185 :             p = va_arg(*p_va, PyObject **);
; 1186 :             format++;

  00f91	49 ff c4	 inc	 r12
  00f94	48 8b 70 f8	 mov	 rsi, QWORD PTR [rax-8]
  00f98	48 83 c0 08	 add	 rax, 8
  00f9c	49 89 00	 mov	 QWORD PTR [r8], rax

; 1187 :             if (PyType_IsSubtype(arg->ob_type, type))

  00f9f	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00fa3	48 8b 78 f8	 mov	 rdi, QWORD PTR [rax-8]
  00fa7	48 8b d6	 mov	 rdx, rsi
  00faa	e8 00 00 00 00	 call	 PyType_IsSubtype
  00faf	85 c0		 test	 eax, eax

; 1191 : 
; 1192 :         }
; 1193 :         else if (*format == '&') {

  00fb1	0f 85 76 ff ff
	ff		 jne	 $LN21@convertsim

; 1188 :                 *p = arg;
; 1189 :             else
; 1190 :                 return converterr(type->tp_name, arg, msgbuf, bufsize);

  00fb7	48 8b 4e 70	 mov	 rcx, QWORD PTR [rsi+112]
  00fbb	e9 fd 00 00 00	 jmp	 $LN249@convertsim
$LN14@convertsim:

; 1191 : 
; 1192 :         }
; 1193 :         else if (*format == '&') {

  00fc0	3c 26		 cmp	 al, 38			; 00000026H

; 1194 :             typedef int (*converter)(PyObject *, void *);
; 1195 :             converter convert = va_arg(*p_va, converter);

  00fc2	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00fc5	75 59		 jne	 SHORT $LN10@convertsim
  00fc7	48 8b 70 f8	 mov	 rsi, QWORD PTR [rax-8]

; 1196 :             void *addr = va_arg(*p_va, void *);

  00fcb	48 83 c0 08	 add	 rax, 8

; 1197 :             int res;
; 1198 :             format++;
; 1199 :             if (! (res = (*convert)(arg, addr)))

  00fcf	48 8b cb	 mov	 rcx, rbx
  00fd2	49 89 00	 mov	 QWORD PTR [r8], rax
  00fd5	48 8b 78 f8	 mov	 rdi, QWORD PTR [rax-8]
  00fd9	49 ff c4	 inc	 r12
  00fdc	48 8b d7	 mov	 rdx, rdi
  00fdf	ff d6		 call	 rsi
  00fe1	85 c0		 test	 eax, eax
  00fe3	75 0c		 jne	 SHORT $LN9@convertsim

; 1200 :                 return converterr("(unspecified)",
; 1201 :                                   arg, msgbuf, bufsize);

  00fe5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@DMBJEJOF@?$CIunspecified?$CJ?$AA@
  00fec	e9 cc 00 00 00	 jmp	 $LN249@convertsim
$LN9@convertsim:

; 1202 :             if (res == Py_CLEANUP_SUPPORTED &&
; 1203 :                 addcleanup(addr, freelist, convert) == -1)

  00ff1	3d 00 00 02 00	 cmp	 eax, 131072		; 00020000H
  00ff6	0f 85 26 f3 ff
	ff		 jne	 $LN2@convertsim
  00ffc	48 8b 55 60	 mov	 rdx, QWORD PTR freelist$[rbp-128]
  01000	4c 8b c6	 mov	 r8, rsi
  01003	48 8b cf	 mov	 rcx, rdi
  01006	e8 00 00 00 00	 call	 addcleanup
  0100b	83 f8 ff	 cmp	 eax, -1
  0100e	0f 85 0e f3 ff
	ff		 jne	 $LN2@convertsim

; 1204 :                 return converterr("(cleanup problem)",
; 1205 :                                 arg, msgbuf, bufsize);

  01014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@IHGAANNF@?$CIcleanup?5problem?$CJ?$AA@
  0101b	e9 9d 00 00 00	 jmp	 $LN249@convertsim
$LN10@convertsim:

; 1206 :         }
; 1207 :         else {
; 1208 :             p = va_arg(*p_va, PyObject **);

  01020	48 8b 48 f8	 mov	 rcx, QWORD PTR [rax-8]

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  01024	48 8b 45 38	 mov	 rax, QWORD PTR p_format$[rbp-128]
  01028	48 89 19	 mov	 QWORD PTR [rcx], rbx
  0102b	4c 89 20	 mov	 QWORD PTR [rax], r12

; 1248 :     return NULL;

  0102e	33 c0		 xor	 eax, eax
  01030	e9 98 00 00 00	 jmp	 $LN209@convertsim
$LN6@convertsim:

; 1209 :             *p = arg;
; 1210 :         }
; 1211 :         break;
; 1212 :     }
; 1213 : 
; 1214 : 
; 1215 :     case 'w': { /* "w*": memory buffer, read-write access */
; 1216 :         void **p = va_arg(*p_va, void **);

  01035	49 83 00 08	 add	 QWORD PTR [r8], 8

; 1217 : 
; 1218 :         if (*format != '*')

  01039	41 80 3c 24 2a	 cmp	 BYTE PTR [r12], 42	; 0000002aH
  0103e	49 8b 00	 mov	 rax, QWORD PTR [r8]
  01041	48 8b 78 f8	 mov	 rdi, QWORD PTR [rax-8]
  01045	74 09		 je	 SHORT $LN5@convertsim

; 1219 :             return converterr(
; 1220 :                 "invalid use of 'w' format character",
; 1221 :                 arg, msgbuf, bufsize);

  01047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@FHIKGACL@invalid?5use?5of?5?8w?8?5format?5charac@
  0104e	eb 6d		 jmp	 SHORT $LN249@convertsim
$LN5@convertsim:

; 1222 :         format++;
; 1223 : 
; 1224 :         /* Caller is interested in Py_buffer, and the object
; 1225 :            supports it directly. */
; 1226 :         if (PyObject_GetBuffer(arg, (Py_buffer*)p, PyBUF_WRITABLE) < 0) {

  01050	41 b8 01 00 00
	00		 mov	 r8d, 1
  01056	48 8b d7	 mov	 rdx, rdi
  01059	48 8b cb	 mov	 rcx, rbx
  0105c	49 ff c4	 inc	 r12
  0105f	e8 00 00 00 00	 call	 PyObject_GetBuffer
  01064	85 c0		 test	 eax, eax
  01066	79 0e		 jns	 SHORT $LN4@convertsim

; 1227 :             PyErr_Clear();

  01068	e8 00 00 00 00	 call	 PyErr_Clear

; 1228 :             return converterr("read-write buffer", arg, msgbuf, bufsize);

  0106d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@NOEFPHII@read?9write?5buffer?$AA@
  01074	eb 47		 jmp	 SHORT $LN249@convertsim
$LN4@convertsim:

; 1229 :         }
; 1230 :         if (!PyBuffer_IsContiguous((Py_buffer*)p, 'C')) {

  01076	b2 43		 mov	 dl, 67			; 00000043H
  01078	48 8b cf	 mov	 rcx, rdi
  0107b	e8 00 00 00 00	 call	 PyBuffer_IsContiguous

; 1231 :             PyBuffer_Release((Py_buffer*)p);

  01080	48 8b cf	 mov	 rcx, rdi
  01083	85 c0		 test	 eax, eax
  01085	75 0e		 jne	 SHORT $LN3@convertsim
  01087	e8 00 00 00 00	 call	 PyBuffer_Release

; 1232 :             return converterr("contiguous buffer", arg, msgbuf, bufsize);

  0108c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@KHDHJHGE@contiguous?5buffer?$AA@
  01093	eb 28		 jmp	 SHORT $LN249@convertsim
$LN3@convertsim:

; 1233 :         }
; 1234 :         if (addcleanup(p, freelist, cleanup_buffer)) {

  01095	48 8b 55 60	 mov	 rdx, QWORD PTR freelist$[rbp-128]
  01099	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cleanup_buffer
  010a0	e8 00 00 00 00	 call	 addcleanup
  010a5	85 c0		 test	 eax, eax
  010a7	0f 84 75 f2 ff
	ff		 je	 $LN2@convertsim

; 1235 :             return converterr(
; 1236 :                 "(cleanup problem)",
; 1237 :                 arg, msgbuf, bufsize);

  010ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@IHGAANNF@?$CIcleanup?5problem?$CJ?$AA@
  010b4	eb 07		 jmp	 SHORT $LN249@convertsim
$LN1@convertsim:

; 1238 :         }
; 1239 :         break;
; 1240 :     }
; 1241 : 
; 1242 :     default:
; 1243 :         return converterr("impossible<bad format char>", arg, msgbuf, bufsize);

  010b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@IMALOFOA@impossible?$DMbad?5format?5char?$DO?$AA@
$LN249@convertsim:
  010bd	48 8b d3	 mov	 rdx, rbx
$LN251@convertsim:
  010c0	4c 8b 4d 58	 mov	 r9, QWORD PTR bufsize$[rbp-128]
  010c4	4c 8b 45 50	 mov	 r8, QWORD PTR msgbuf$[rbp-128]
  010c8	e8 00 00 00 00	 call	 converterr
$LN209@convertsim:

; 1249 : 
; 1250 : #undef FETCH_SIZE
; 1251 : #undef STORE_SIZE
; 1252 : #undef BUFFER_LEN
; 1253 : #undef RETURN_ERR_OCCURRED
; 1254 : }

  010cd	0f 28 74 24 70	 movaps	 xmm6, XMMWORD PTR [rsp+112]
  010d2	4c 8d 9c 24 80
	00 00 00	 lea	 r11, QWORD PTR [rsp+128]
  010da	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  010de	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  010e2	49 8b 7b 48	 mov	 rdi, QWORD PTR [r11+72]
  010e6	49 8b e3	 mov	 rsp, r11
  010e9	41 5f		 pop	 r15
  010eb	41 5e		 pop	 r14
  010ed	41 5d		 pop	 r13
  010ef	41 5c		 pop	 r12
  010f1	5d		 pop	 rbp
  010f2	c3		 ret	 0
  010f3	90		 npad	 1
$LN246@convertsim:
  010f4	00 00 00 00	 DD	 $LN198@convertsim
  010f8	00 00 00 00	 DD	 $LN137@convertsim
  010fc	00 00 00 00	 DD	 $LN146@convertsim
  01100	00 00 00 00	 DD	 $LN186@convertsim
  01104	00 00 00 00	 DD	 $LN174@convertsim
  01108	00 00 00 00	 DD	 $LN155@convertsim
  0110c	00 00 00 00	 DD	 $LN159@convertsim
  01110	00 00 00 00	 DD	 $LN15@convertsim
  01114	00 00 00 00	 DD	 $LN26@convertsim
  01118	00 00 00 00	 DD	 $LN19@convertsim
  0111c	00 00 00 00	 DD	 $LN23@convertsim
  01120	00 00 00 00	 DD	 $LN80@convertsim
  01124	00 00 00 00	 DD	 $LN206@convertsim
  01128	00 00 00 00	 DD	 $LN143@convertsim
  0112c	00 00 00 00	 DD	 $LN149@convertsim
  01130	00 00 00 00	 DD	 $LN58@convertsim
  01134	00 00 00 00	 DD	 $LN152@convertsim
  01138	00 00 00 00	 DD	 $LN194@convertsim
  0113c	00 00 00 00	 DD	 $LN182@convertsim
  01140	00 00 00 00	 DD	 $LN162@convertsim
  01144	00 00 00 00	 DD	 $LN166@convertsim
  01148	00 00 00 00	 DD	 $LN170@convertsim
  0114c	00 00 00 00	 DD	 $LN133@convertsim
  01150	00 00 00 00	 DD	 $LN115@convertsim
  01154	00 00 00 00	 DD	 $LN6@convertsim
  01158	00 00 00 00	 DD	 $LN128@convertsim
  0115c	00 00 00 00	 DD	 $LN1@convertsim
$LN245@convertsim:
  01160	00		 DB	 0
  01161	01		 DB	 1
  01162	02		 DB	 2
  01163	1a		 DB	 26
  01164	1a		 DB	 26
  01165	1a		 DB	 26
  01166	03		 DB	 3
  01167	04		 DB	 4
  01168	1a		 DB	 26
  01169	05		 DB	 5
  0116a	06		 DB	 6
  0116b	1a		 DB	 26
  0116c	1a		 DB	 26
  0116d	07		 DB	 7
  0116e	1a		 DB	 26
  0116f	1a		 DB	 26
  01170	1a		 DB	 26
  01171	08		 DB	 8
  01172	1a		 DB	 26
  01173	09		 DB	 9
  01174	1a		 DB	 26
  01175	1a		 DB	 26
  01176	1a		 DB	 26
  01177	0a		 DB	 10
  01178	0b		 DB	 11
  01179	1a		 DB	 26
  0117a	1a		 DB	 26
  0117b	1a		 DB	 26
  0117c	1a		 DB	 26
  0117d	1a		 DB	 26
  0117e	1a		 DB	 26
  0117f	1a		 DB	 26
  01180	0c		 DB	 12
  01181	0d		 DB	 13
  01182	0e		 DB	 14
  01183	0f		 DB	 15
  01184	10		 DB	 16
  01185	1a		 DB	 26
  01186	11		 DB	 17
  01187	12		 DB	 18
  01188	1a		 DB	 26
  01189	13		 DB	 19
  0118a	14		 DB	 20
  0118b	1a		 DB	 26
  0118c	15		 DB	 21
  0118d	1a		 DB	 26
  0118e	16		 DB	 22
  0118f	1a		 DB	 26
  01190	1a		 DB	 26
  01191	17		 DB	 23
  01192	1a		 DB	 26
  01193	0b		 DB	 11
  01194	1a		 DB	 26
  01195	18		 DB	 24
  01196	1a		 DB	 26
  01197	19		 DB	 25
  01198	17		 DB	 23
convertsimple ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$convertitem DD imagerel convertitem
	DD	imagerel convertitem+212
	DD	imagerel $unwind$convertitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$convertitem DD 020801H
	DD	030049208H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT convertitem
_TEXT	SEGMENT
arg$ = 96
format$ = 104
p_format$ = 104
p_va$ = 112
flags$ = 120
levels$ = 128
msgbuf$ = 136
bufsize$ = 144
freelist$ = 152
convertitem PROC					; COMDAT

; 487  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 488  :     char *msg;
; 489  :     const char *format = *p_format;

  00008	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0000b	48 8b da	 mov	 rbx, rdx

; 493  :         msg = converttuple(arg, &format, p_va, flags, levels, msgbuf,
; 494  :                            bufsize, 0, freelist);

  0000e	49 8d 53 10	 lea	 rdx, QWORD PTR [r11+16]
  00012	80 38 28	 cmp	 BYTE PTR [rax], 40	; 00000028H
  00015	49 89 43 10	 mov	 QWORD PTR [r11+16], rax
  00019	75 5d		 jne	 SHORT $LN5@convertite

; 490  : 
; 491  :     if (*format == '(' /* ')' */) {
; 492  :         format++;

  0001b	48 ff c0	 inc	 rax
  0001e	49 89 43 10	 mov	 QWORD PTR [r11+16], rax

; 493  :         msg = converttuple(arg, &format, p_va, flags, levels, msgbuf,
; 494  :                            bufsize, 0, freelist);

  00022	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR freelist$[rsp]
  0002a	49 89 43 e8	 mov	 QWORD PTR [r11-24], rax
  0002e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR bufsize$[rsp]
  00036	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR [rsp+56], 0
  0003e	49 89 43 d8	 mov	 QWORD PTR [r11-40], rax
  00042	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  0004a	49 89 43 d0	 mov	 QWORD PTR [r11-48], rax
  0004e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR levels$[rsp]
  00056	49 89 43 c8	 mov	 QWORD PTR [r11-56], rax
  0005a	e8 00 00 00 00	 call	 converttuple
  0005f	4c 8b d8	 mov	 r11, rax

; 495  :         if (msg == NULL)

  00062	48 85 c0	 test	 rax, rax
  00065	75 67		 jne	 SHORT $LN1@convertite

; 496  :             format++;

  00067	48 8b 4c 24 68	 mov	 rcx, QWORD PTR format$[rsp]
  0006c	48 ff c1	 inc	 rcx

; 505  :         *p_format = format;

  0006f	48 89 0b	 mov	 QWORD PTR [rbx], rcx

; 507  : }

  00072	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00076	5b		 pop	 rbx
  00077	c3		 ret	 0
$LN5@convertite:

; 497  :     }
; 498  :     else {
; 499  :         msg = convertsimple(arg, &format, p_va, flags,
; 500  :                             msgbuf, bufsize, freelist);

  00078	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR freelist$[rsp]
  00080	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00085	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR bufsize$[rsp]
  0008d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00092	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  0009a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009f	e8 00 00 00 00	 call	 convertsimple
  000a4	4c 8b d8	 mov	 r11, rax

; 501  :         if (msg != NULL)

  000a7	48 85 c0	 test	 rax, rax
  000aa	74 17		 je	 SHORT $LN10@convertite

; 502  :             levels[0] = 0;

  000ac	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR levels$[rsp]
  000b4	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 506  :     return msg;

  000ba	49 8b c3	 mov	 rax, r11

; 507  : }

  000bd	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000c1	5b		 pop	 rbx
  000c2	c3		 ret	 0
$LN10@convertite:

; 503  :     }
; 504  :     if (msg == NULL)

  000c3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR format$[rsp]

; 506  :     return msg;

  000c8	49 8b c3	 mov	 rax, r11
  000cb	48 89 0b	 mov	 QWORD PTR [rbx], rcx
$LN1@convertite:

; 507  : }

  000ce	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000d2	5b		 pop	 rbx
  000d3	c3		 ret	 0
convertitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@LEGLBJFG@keywords?5must?5be?5strings?$AA@ ; `string'
PUBLIC	??_C@_0DG@ENKIDNFE@?8?$CFU?8?5is?5an?5invalid?5keyword?5argum@ ; `string'
PUBLIC	??_C@_0DL@LMLCHELD@More?5keyword?5list?5entries?5?$CI?$CFd?$CJ?5t@ ; `string'
PUBLIC	??_C@_0CK@HKBBODMD@Required?5argument?5?8?$CFs?8?5?$CIpos?5?$CFd?$CJ?5@ ; `string'
PUBLIC	??_C@_08JAIPINJA@?$CFs?3?5?8?$CFs?8?$AA@	; `string'
PUBLIC	??_C@_0EL@FLEHBPOJ@more?5argument?5specifiers?5than?5ke@ ; `string'
PUBLIC	??_C@_0CK@MOOGIOLD@Invalid?5format?5string?5?$CI$?5specifi@ ; `string'
PUBLIC	??_C@_0DF@BPFKLMMD@Function?5takes?5?$CFs?5?$CFd?5positional?5@ ; `string'
PUBLIC	??_C@_07JLAGAGFH@exactly?$AA@			; `string'
PUBLIC	??_C@_07IGBEEPOP@at?5most?$AA@			; `string'
PUBLIC	??_C@_0CK@JJANEEBE@Invalid?5format?5string?5?$CI?$HM?5specifi@ ; `string'
PUBLIC	??_C@_0DA@GILDFAFF@Argument?5given?5by?5name?5?$CI?8?$CFs?8?$CJ?5an@ ; `string'
PUBLIC	??_C@_0CD@FHABLJPP@Invalid?5format?5string?5?$CI$?5before?5@ ; `string'
PUBLIC	??_C@_0CM@DGNOJHNI@?$CFs?$CFs?5takes?5at?5most?5?$CFd?5argument?$CFs@ ; `string'
PUBLIC	??_C@_08HFFPPCHF@function?$AA@			; `string'
PUBLIC	??_C@_02HCKGKOFO@?$CI?$CJ?$AA@			; `string'
PUBLIC	??_C@_01LKDEMHDF@s?$AA@				; `string'
EXTRN	PyUnicode_AsUTF8:PROC
EXTRN	PyDict_Next:PROC
EXTRN	PyDict_GetItemString:PROC
EXTRN	PyExc_RuntimeError:QWORD
EXTRN	__imp_strchr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$vgetargskeywords DD imagerel vgetargskeywords
	DD	imagerel vgetargskeywords+1560
	DD	imagerel $unwind$vgetargskeywords
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vgetargskeywords DD 0a2f01H
	DD	061012fH
	DD	0e01ef020H
	DD	0c01ad01cH
	DD	060177018H
	DD	050153016H
xdata	ENDS
;	COMDAT ??_C@_0BJ@LEGLBJFG@keywords?5must?5be?5strings?$AA@
CONST	SEGMENT
??_C@_0BJ@LEGLBJFG@keywords?5must?5be?5strings?$AA@ DB 'keywords must be '
	DB	'strings', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@ENKIDNFE@?8?$CFU?8?5is?5an?5invalid?5keyword?5argum@
CONST	SEGMENT
??_C@_0DG@ENKIDNFE@?8?$CFU?8?5is?5an?5invalid?5keyword?5argum@ DB '''%U'''
	DB	' is an invalid keyword argument for this function', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@LMLCHELD@More?5keyword?5list?5entries?5?$CI?$CFd?$CJ?5t@
CONST	SEGMENT
??_C@_0DL@LMLCHELD@More?5keyword?5list?5entries?5?$CI?$CFd?$CJ?5t@ DB 'Mo'
	DB	're keyword list entries (%d) than format specifiers (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@HKBBODMD@Required?5argument?5?8?$CFs?8?5?$CIpos?5?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_0CK@HKBBODMD@Required?5argument?5?8?$CFs?8?5?$CIpos?5?$CFd?$CJ?5@ DB 'R'
	DB	'equired argument ''%s'' (pos %d) not found', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JAIPINJA@?$CFs?3?5?8?$CFs?8?$AA@
CONST	SEGMENT
??_C@_08JAIPINJA@?$CFs?3?5?8?$CFs?8?$AA@ DB '%s: ''%s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@FLEHBPOJ@more?5argument?5specifiers?5than?5ke@
CONST	SEGMENT
??_C@_0EL@FLEHBPOJ@more?5argument?5specifiers?5than?5ke@ DB 'more argumen'
	DB	't specifiers than keyword list entries (remaining format:''%s'
	DB	''')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@MOOGIOLD@Invalid?5format?5string?5?$CI$?5specifi@
CONST	SEGMENT
??_C@_0CK@MOOGIOLD@Invalid?5format?5string?5?$CI$?5specifi@ DB 'Invalid f'
	DB	'ormat string ($ specified twice)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@BPFKLMMD@Function?5takes?5?$CFs?5?$CFd?5positional?5@
CONST	SEGMENT
??_C@_0DF@BPFKLMMD@Function?5takes?5?$CFs?5?$CFd?5positional?5@ DB 'Funct'
	DB	'ion takes %s %d positional arguments (%d given)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07JLAGAGFH@exactly?$AA@
CONST	SEGMENT
??_C@_07JLAGAGFH@exactly?$AA@ DB 'exactly', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IGBEEPOP@at?5most?$AA@
CONST	SEGMENT
??_C@_07IGBEEPOP@at?5most?$AA@ DB 'at most', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@JJANEEBE@Invalid?5format?5string?5?$CI?$HM?5specifi@
CONST	SEGMENT
??_C@_0CK@JJANEEBE@Invalid?5format?5string?5?$CI?$HM?5specifi@ DB 'Invali'
	DB	'd format string (| specified twice)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@GILDFAFF@Argument?5given?5by?5name?5?$CI?8?$CFs?8?$CJ?5an@
CONST	SEGMENT
??_C@_0DA@GILDFAFF@Argument?5given?5by?5name?5?$CI?8?$CFs?8?$CJ?5an@ DB 'A'
	DB	'rgument given by name (''%s'') and position (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FHABLJPP@Invalid?5format?5string?5?$CI$?5before?5@
CONST	SEGMENT
??_C@_0CD@FHABLJPP@Invalid?5format?5string?5?$CI$?5before?5@ DB 'Invalid '
	DB	'format string ($ before |)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@DGNOJHNI@?$CFs?$CFs?5takes?5at?5most?5?$CFd?5argument?$CFs@
CONST	SEGMENT
??_C@_0CM@DGNOJHNI@?$CFs?$CFs?5takes?5at?5most?5?$CFd?5argument?$CFs@ DB '%'
	DB	's%s takes at most %d argument%s (%d given)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HFFPPCHF@function?$AA@
CONST	SEGMENT
??_C@_08HFFPPCHF@function?$AA@ DB 'function', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_02HCKGKOFO@?$CI?$CJ?$AA@ DB '()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01LKDEMHDF@s?$AA@
CONST	SEGMENT
??_C@_01LKDEMHDF@s?$AA@ DB 's', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT vgetargskeywords
_TEXT	SEGMENT
min$1$ = 64
freelist$ = 72
nargs$1$ = 88
max$1$ = 92
custom_msg$1$ = 96
value$21791 = 96
fname$1$ = 104
pos$21792 = 104
tv589 = 112
levels$ = 128
msgbuf$ = 256
args$ = 848
keywords$ = 856
format$ = 864
key$21790 = 872
kwlist$ = 872
p_va$ = 880
flags$ = 888
vgetargskeywords PROC					; COMDAT

; 1416 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	53		 push	 rbx
  00016	56		 push	 rsi
  00017	57		 push	 rdi
  00018	41 54		 push	 r12
  0001a	41 55		 push	 r13
  0001c	41 56		 push	 r14
  0001e	41 57		 push	 r15
  00020	48 8d ac 24 f8
	fd ff ff	 lea	 rbp, QWORD PTR [rsp-520]
  00028	48 81 ec 08 03
	00 00		 sub	 rsp, 776		; 00000308H

; 1417 :     char msgbuf[512];
; 1418 :     int levels[32];
; 1419 :     const char *fname, *msg, *custom_msg, *keyword;
; 1420 :     int min = INT_MAX;
; 1421 :     int max = INT_MAX;
; 1422 :     int i, len, nargs, nkeywords;
; 1423 :     PyObject *current_arg;
; 1424 :     freelist_t freelist = {0, NULL};

  0002f	45 33 ed	 xor	 r13d, r13d
  00032	49 8b d8	 mov	 rbx, r8
  00035	4c 8b e2	 mov	 r12, rdx
  00038	41 b8 ff ff ff
	7f		 mov	 r8d, 2147483647		; 7fffffffH

; 1425 : 
; 1426 :     assert(args != NULL && PyTuple_Check(args));
; 1427 :     assert(keywords == NULL || PyDict_Check(keywords));
; 1428 :     assert(format != NULL);
; 1429 :     assert(kwlist != NULL);
; 1430 :     assert(p_va != NULL);
; 1431 : 
; 1432 :     /* grab the function name or custom error msg first (mutually exclusive) */
; 1433 :     fname = strchr(format, ':');

  0003e	41 8d 55 3a	 lea	 edx, QWORD PTR [r13+58]
  00042	48 8b cb	 mov	 rcx, rbx
  00045	4d 8b f9	 mov	 r15, r9
  00048	c7 44 24 40 ff
	ff ff 7f	 mov	 DWORD PTR min$1$[rsp], 2147483647 ; 7fffffffH
  00050	44 89 6c 24 48	 mov	 DWORD PTR freelist$[rsp], r13d
  00055	44 89 44 24 5c	 mov	 DWORD PTR max$1$[rsp], r8d
  0005a	4c 89 6c 24 50	 mov	 QWORD PTR freelist$[rsp+8], r13
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr
  00065	48 8b f8	 mov	 rdi, rax
  00068	48 89 44 24 68	 mov	 QWORD PTR fname$1$[rsp], rax

; 1434 :     if (fname) {

  0006d	48 85 c0	 test	 rax, rax
  00070	74 0f		 je	 SHORT $LN42@vgetargske

; 1435 :         fname++;

  00072	48 ff c7	 inc	 rdi

; 1436 :         custom_msg = NULL;

  00075	4c 89 6c 24 60	 mov	 QWORD PTR custom_msg$1$[rsp], r13
  0007a	48 89 7c 24 68	 mov	 QWORD PTR fname$1$[rsp], rdi

; 1437 :     }
; 1438 :     else {

  0007f	eb 20		 jmp	 SHORT $LN40@vgetargske
$LN42@vgetargske:

; 1439 :         custom_msg = strchr(format,';');

  00081	ba 3b 00 00 00	 mov	 edx, 59			; 0000003bH
  00086	48 8b cb	 mov	 rcx, rbx
  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr
  0008f	48 89 44 24 60	 mov	 QWORD PTR custom_msg$1$[rsp], rax

; 1440 :         if (custom_msg)

  00094	48 85 c0	 test	 rax, rax
  00097	74 08		 je	 SHORT $LN40@vgetargske

; 1441 :             custom_msg++;

  00099	48 ff c0	 inc	 rax
  0009c	48 89 44 24 60	 mov	 QWORD PTR custom_msg$1$[rsp], rax
$LN40@vgetargske:

; 1442 :     }
; 1443 : 
; 1444 :     /* scan kwlist and get greatest possible nbr of args */
; 1445 :     for (len=0; kwlist[len]; len++)

  000a1	45 8b f5	 mov	 r14d, r13d
  000a4	4d 39 2f	 cmp	 QWORD PTR [r15], r13
  000a7	74 13		 je	 SHORT $LN37@vgetargske
  000a9	49 8b cf	 mov	 rcx, r15
  000ac	0f 1f 40 00	 npad	 4
$LL39@vgetargske:
  000b0	48 83 c1 08	 add	 rcx, 8
  000b4	41 ff c6	 inc	 r14d
  000b7	4c 39 29	 cmp	 QWORD PTR [rcx], r13
  000ba	75 f4		 jne	 SHORT $LL39@vgetargske
$LN37@vgetargske:

; 1446 :         continue;
; 1447 : 
; 1448 :     freelist.entries = PyMem_NEW(freelistentry_t, len);

  000bc	49 63 f6	 movsxd	 rsi, r14d
  000bf	48 b8 ff ff ff
	ff ff ff ff 07	 mov	 rax, 576460752303423487	; 07ffffffffffffffH
  000c9	48 3b f0	 cmp	 rsi, rax
  000cc	76 11		 jbe	 SHORT $LN51@vgetargske
$LN91@vgetargske:
  000ce	4c 89 6c 24 50	 mov	 QWORD PTR freelist$[rsp+8], r13

; 1450 :         PyErr_NoMemory();

  000d3	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1451 :         return 0;

  000d8	33 c0		 xor	 eax, eax
  000da	e9 0e 05 00 00	 jmp	 $LN43@vgetargske
$LN51@vgetargske:

; 1446 :         continue;
; 1447 : 
; 1448 :     freelist.entries = PyMem_NEW(freelistentry_t, len);

  000df	e8 00 00 00 00	 call	 _Py_PXCTX
  000e4	85 c0		 test	 eax, eax
  000e6	74 0e		 je	 SHORT $LN49@vgetargske
  000e8	48 8b ce	 mov	 rcx, rsi
  000eb	48 c1 e1 04	 shl	 rcx, 4
  000ef	e8 00 00 00 00	 call	 _PxMem_Malloc
  000f4	eb 28		 jmp	 SHORT $LN90@vgetargske
$LN49@vgetargske:
  000f6	48 8b c6	 mov	 rax, rsi
  000f9	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00103	48 c1 e0 04	 shl	 rax, 4
  00107	48 3b c1	 cmp	 rax, rcx
  0010a	77 c2		 ja	 SHORT $LN91@vgetargske
  0010c	48 85 c0	 test	 rax, rax
  0010f	b9 01 00 00 00	 mov	 ecx, 1
  00114	48 0f 45 c8	 cmovne	 rcx, rax
  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN90@vgetargske:
  0011e	48 89 44 24 50	 mov	 QWORD PTR freelist$[rsp+8], rax

; 1449 :     if (freelist.entries == NULL) {

  00123	48 85 c0	 test	 rax, rax
  00126	75 0c		 jne	 SHORT $LN36@vgetargske

; 1450 :         PyErr_NoMemory();

  00128	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1451 :         return 0;

  0012d	33 c0		 xor	 eax, eax
  0012f	e9 b9 04 00 00	 jmp	 $LN43@vgetargske
$LN36@vgetargske:

; 1452 :     }
; 1453 : 
; 1454 :     nargs = PyTuple_GET_SIZE(args);

  00134	4c 8b 9d 50 02
	00 00		 mov	 r11, QWORD PTR args$[rbp-256]
  0013b	45 8b 4b 60	 mov	 r9d, DWORD PTR [r11+96]
  0013f	44 89 4c 24 58	 mov	 DWORD PTR nargs$1$[rsp], r9d

; 1455 :     nkeywords = (keywords == NULL) ? 0 : PyDict_Size(keywords);

  00144	4d 85 e4	 test	 r12, r12
  00147	74 17		 je	 SHORT $LN54@vgetargske
  00149	49 8b cc	 mov	 rcx, r12
  0014c	e8 00 00 00 00	 call	 PyDict_Size
  00151	44 8b 4c 24 58	 mov	 r9d, DWORD PTR nargs$1$[rsp]
  00156	4c 8b 9d 50 02
	00 00		 mov	 r11, QWORD PTR args$[rbp-256]
  0015d	4c 8b e8	 mov	 r13, rax
$LN54@vgetargske:

; 1456 :     if (nargs + nkeywords > len) {

  00160	43 8d 4c 0d 00	 lea	 ecx, DWORD PTR [r13+r9]
  00165	41 3b ce	 cmp	 ecx, r14d
  00168	7e 5a		 jle	 SHORT $LN35@vgetargske

; 1457 :         PyErr_Format(PyExc_TypeError,
; 1458 :                      "%s%s takes at most %d argument%s (%d given)",
; 1459 :                      (fname == NULL) ? "function" : fname,
; 1460 :                      (fname == NULL) ? "" : "()",
; 1461 :                      len,
; 1462 :                      (len == 1) ? "" : "s",
; 1463 :                      nargs + nkeywords);

  0016a	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  0016e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00175	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0017c	41 83 fe 01	 cmp	 r14d, 1
  00180	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_01LKDEMHDF@s?$AA@
  00187	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  0018e	48 0f 44 c2	 cmove	 rax, rdx
  00192	48 85 ff	 test	 rdi, rdi
  00195	4c 0f 44 ca	 cmove	 r9, rdx
  00199	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08HFFPPCHF@function?$AA@
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	48 0f 44 fa	 cmove	 rdi, rdx
  001a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@DGNOJHNI@?$CFs?$CFs?5takes?5at?5most?5?$CFd?5argument?$CFs@
  001b0	44 89 74 24 20	 mov	 DWORD PTR [rsp+32], r14d
  001b5	4c 8b c7	 mov	 r8, rdi
  001b8	e8 00 00 00 00	 call	 PyErr_Format
$LN65@vgetargske:

; 1464 :         return cleanreturn(0, &freelist);

  001bd	33 c9		 xor	 ecx, ecx
  001bf	e9 1f 04 00 00	 jmp	 $LN92@vgetargske
$LN35@vgetargske:

; 1465 :     }
; 1466 : 
; 1467 :     /* convert tuple args and keyword args in same loop, using kwlist to drive process */
; 1468 :     for (i = 0; i < len; i++) {

  001c4	33 ff		 xor	 edi, edi
  001c6	45 33 e4	 xor	 r12d, r12d
  001c9	45 85 f6	 test	 r14d, r14d
  001cc	0f 8e 82 02 00
	00		 jle	 $LN32@vgetargske
  001d2	44 8b 54 24 40	 mov	 r10d, DWORD PTR min$1$[rsp]
  001d7	49 8b cf	 mov	 rcx, r15
  001da	4d 2b df	 sub	 r11, r15
  001dd	48 89 4c 24 70	 mov	 QWORD PTR tv589[rsp], rcx
  001e2	4c 89 9d 50 02
	00 00		 mov	 QWORD PTR args$[rbp-256], r11
  001e9	0f 1f 80 00 00
	00 00		 npad	 7
$LL34@vgetargske:

; 1469 :         keyword = kwlist[i];
; 1470 :         if (*format == '|') {

  001f0	80 3b 7c	 cmp	 BYTE PTR [rbx], 124	; 0000007cH
  001f3	4c 8b 39	 mov	 r15, QWORD PTR [rcx]
  001f6	75 40		 jne	 SHORT $LN89@vgetargske

; 1471 :             if (min != INT_MAX) {

  001f8	41 81 fa ff ff
	ff 7f		 cmp	 r10d, 2147483647	; 7fffffffH
  001ff	0f 85 b6 01 00
	00		 jne	 $LN59@vgetargske

; 1478 :             format++;
; 1479 : 
; 1480 :             if (max != INT_MAX) {

  00205	8b 54 24 5c	 mov	 edx, DWORD PTR max$1$[rsp]
  00209	48 ff c3	 inc	 rbx
  0020c	8b c7		 mov	 eax, edi
  0020e	89 44 24 40	 mov	 DWORD PTR min$1$[rsp], eax
  00212	48 89 9d 60 02
	00 00		 mov	 QWORD PTR format$[rbp-256], rbx
  00219	41 3b d2	 cmp	 edx, r10d
  0021c	74 22		 je	 SHORT $LN29@vgetargske

; 1481 :                 PyErr_SetString(PyExc_RuntimeError,
; 1482 :                                 "Invalid format string ($ before |)");

  0021e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00225	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@FHABLJPP@Invalid?5format?5string?5?$CI$?5before?5@
  0022c	e8 00 00 00 00	 call	 PyErr_SetString

; 1483 :                 return cleanreturn(0, &freelist);

  00231	33 c9		 xor	 ecx, ecx
  00233	e9 ab 03 00 00	 jmp	 $LN92@vgetargske
$LN89@vgetargske:

; 1475 :             }
; 1476 : 
; 1477 :             min = i;

  00238	8b 44 24 40	 mov	 eax, DWORD PTR min$1$[rsp]
  0023c	8b 54 24 5c	 mov	 edx, DWORD PTR max$1$[rsp]
$LN29@vgetargske:

; 1484 :             }
; 1485 :         }
; 1486 :         if (*format == '$') {

  00240	80 3b 24	 cmp	 BYTE PTR [rbx], 36	; 00000024H
  00243	75 23		 jne	 SHORT $LN26@vgetargske

; 1487 :             if (max != INT_MAX) {

  00245	81 fa ff ff ff
	7f		 cmp	 edx, 2147483647		; 7fffffffH
  0024b	0f 85 bd 01 00
	00		 jne	 $LN61@vgetargske

; 1491 :             }
; 1492 : 
; 1493 :             max = i;
; 1494 :             format++;

  00251	48 ff c3	 inc	 rbx
  00254	89 7c 24 5c	 mov	 DWORD PTR max$1$[rsp], edi
  00258	48 89 9d 60 02
	00 00		 mov	 QWORD PTR format$[rbp-256], rbx

; 1495 : 
; 1496 :             if (max < nargs) {

  0025f	41 3b f9	 cmp	 edi, r9d
  00262	0f 8c 6d 01 00
	00		 jl	 $LN62@vgetargske
$LN26@vgetargske:

; 1503 :             }
; 1504 :         }
; 1505 :         if (IS_END_OF_FORMAT(*format)) {

  00268	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  0026b	84 c0		 test	 al, al
  0026d	0f 84 6e 02 00
	00		 je	 $LN24@vgetargske
  00273	3c 3b		 cmp	 al, 59			; 0000003bH
  00275	0f 84 66 02 00
	00		 je	 $LN24@vgetargske
  0027b	3c 3a		 cmp	 al, 58			; 0000003aH
  0027d	0f 84 5e 02 00
	00		 je	 $LN24@vgetargske

; 1510 :         }
; 1511 :         current_arg = NULL;
; 1512 :         if (nkeywords) {

  00283	45 85 ed	 test	 r13d, r13d
  00286	74 61		 je	 SHORT $LN19@vgetargske

; 1513 :             current_arg = PyDict_GetItemString(keywords, keyword);

  00288	48 8b 8d 58 02
	00 00		 mov	 rcx, QWORD PTR keywords$[rbp-256]
  0028f	49 8b d7	 mov	 rdx, r15
  00292	e8 00 00 00 00	 call	 PyDict_GetItemString

; 1514 :         }
; 1515 :         if (current_arg) {

  00297	48 85 c0	 test	 rax, rax
  0029a	74 2e		 je	 SHORT $LN22@vgetargske

; 1516 :             --nkeywords;
; 1517 :             if (i < nargs) {

  0029c	48 63 54 24 58	 movsxd	 rdx, DWORD PTR nargs$1$[rsp]
  002a1	41 ff cd	 dec	 r13d
  002a4	4c 3b e2	 cmp	 r12, rdx
  002a7	7d 4d		 jge	 SHORT $LN17@vgetargske

; 1518 :                 /* arg present in tuple and in dict */
; 1519 :                 PyErr_Format(PyExc_TypeError,
; 1520 :                              "Argument given by name ('%s') "
; 1521 :                              "and position (%d)",
; 1522 :                              keyword, i+1);

  002a9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  002b0	44 8d 4f 01	 lea	 r9d, DWORD PTR [rdi+1]
  002b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@GILDFAFF@Argument?5given?5by?5name?5?$CI?8?$CFs?8?$CJ?5an@
  002bb	4d 8b c7	 mov	 r8, r15
  002be	e8 00 00 00 00	 call	 PyErr_Format

; 1523 :                 return cleanreturn(0, &freelist);

  002c3	33 c9		 xor	 ecx, ecx
  002c5	e9 19 03 00 00	 jmp	 $LN92@vgetargske
$LN22@vgetargske:

; 1524 :             }
; 1525 :         }
; 1526 :         else if (nkeywords && PyErr_Occurred())

  002ca	e8 00 00 00 00	 call	 PyErr_Occurred
  002cf	48 85 c0	 test	 rax, rax
  002d2	0f 85 e5 fe ff
	ff		 jne	 $LN65@vgetargske
  002d8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv589[rsp]
  002dd	44 8b 4c 24 58	 mov	 r9d, DWORD PTR nargs$1$[rsp]
  002e2	4c 8b 9d 50 02
	00 00		 mov	 r11, QWORD PTR args$[rbp-256]
$LN19@vgetargske:

; 1527 :             return cleanreturn(0, &freelist);
; 1528 :         else if (i < nargs)

  002e9	49 63 c1	 movsxd	 rax, r9d
  002ec	4c 3b e0	 cmp	 r12, rax
  002ef	7d 5c		 jge	 SHORT $LN16@vgetargske

; 1529 :             current_arg = PyTuple_GET_ITEM(args, i);

  002f1	49 8b 44 0b 70	 mov	 rax, QWORD PTR [r11+rcx+112]
$LN17@vgetargske:

; 1530 : 
; 1531 :         if (current_arg) {

  002f6	48 85 c0	 test	 rax, rax
  002f9	74 52		 je	 SHORT $LN16@vgetargske

; 1532 :             msg = convertitem(current_arg, &format, p_va, flags,
; 1533 :                 levels, msgbuf, sizeof(msgbuf), &freelist);

  002fb	44 8b 8d 78 02
	00 00		 mov	 r9d, DWORD PTR flags$[rbp-256]
  00302	4c 8b 85 70 02
	00 00		 mov	 r8, QWORD PTR p_va$[rbp-256]
  00309	48 8d 4c 24 48	 lea	 rcx, QWORD PTR freelist$[rsp]
  0030e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00313	48 8d 4d 00	 lea	 rcx, QWORD PTR msgbuf$[rbp-256]
  00317	48 c7 44 24 30
	00 02 00 00	 mov	 QWORD PTR [rsp+48], 512	; 00000200H
  00320	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00325	48 8d 4d 80	 lea	 rcx, QWORD PTR levels$[rbp-256]
  00329	48 8d 95 60 02
	00 00		 lea	 rdx, QWORD PTR format$[rbp-256]
  00330	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00335	48 8b c8	 mov	 rcx, rax
  00338	e8 00 00 00 00	 call	 convertitem

; 1534 :             if (msg) {

  0033d	48 85 c0	 test	 rax, rax
  00340	0f 85 e2 00 00
	00		 jne	 $LN66@vgetargske

; 1537 :             }
; 1538 :             continue;

  00346	44 8b 54 24 40	 mov	 r10d, DWORD PTR min$1$[rsp]
  0034b	eb 3a		 jmp	 SHORT $LN33@vgetargske
$LN16@vgetargske:

; 1539 :         }
; 1540 : 
; 1541 :         if (i < min) {

  0034d	44 8b 54 24 40	 mov	 r10d, DWORD PTR min$1$[rsp]
  00352	41 3b fa	 cmp	 edi, r10d
  00355	0f 8c 65 01 00
	00		 jl	 $LN67@vgetargske

; 1546 :         }
; 1547 :         /* current code reports success when all required args
; 1548 :          * fulfilled and no keyword args left, with no further
; 1549 :          * validation. XXX Maybe skip this in debug build ?
; 1550 :          */
; 1551 :         if (!nkeywords)

  0035b	45 85 ed	 test	 r13d, r13d
  0035e	0f 84 7a 02 00
	00		 je	 $LN8@vgetargske

; 1552 :             return cleanreturn(1, &freelist);
; 1553 : 
; 1554 :         /* We are into optional args, skip thru to any remaining
; 1555 :          * keyword args */
; 1556 :         msg = skipitem(&format, p_va, flags);

  00364	44 8b 85 78 02
	00 00		 mov	 r8d, DWORD PTR flags$[rbp-256]
  0036b	48 8b 95 70 02
	00 00		 mov	 rdx, QWORD PTR p_va$[rbp-256]
  00372	48 8d 8d 60 02
	00 00		 lea	 rcx, QWORD PTR format$[rbp-256]
  00379	e8 00 00 00 00	 call	 skipitem

; 1557 :         if (msg) {

  0037e	48 85 c0	 test	 rax, rax
  00381	0f 85 15 01 00
	00		 jne	 $LN69@vgetargske
$LN33@vgetargske:

; 1465 :     }
; 1466 : 
; 1467 :     /* convert tuple args and keyword args in same loop, using kwlist to drive process */
; 1468 :     for (i = 0; i < len; i++) {

  00387	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv589[rsp]
  0038c	48 8b 9d 60 02
	00 00		 mov	 rbx, QWORD PTR format$[rbp-256]
  00393	49 ff c4	 inc	 r12
  00396	48 83 c1 08	 add	 rcx, 8
  0039a	ff c7		 inc	 edi
  0039c	48 89 4c 24 70	 mov	 QWORD PTR tv589[rsp], rcx
  003a1	4c 3b e6	 cmp	 r12, rsi
  003a4	0f 8d a3 00 00
	00		 jge	 $LN88@vgetargske
  003aa	44 8b 4c 24 58	 mov	 r9d, DWORD PTR nargs$1$[rsp]
  003af	4c 8b 9d 50 02
	00 00		 mov	 r11, QWORD PTR args$[rbp-256]
  003b6	e9 35 fe ff ff	 jmp	 $LL34@vgetargske
$LN59@vgetargske:

; 1472 :                 PyErr_SetString(PyExc_RuntimeError,
; 1473 :                                 "Invalid format string (| specified twice)");

  003bb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  003c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@JJANEEBE@Invalid?5format?5string?5?$CI?$HM?5specifi@
  003c9	e8 00 00 00 00	 call	 PyErr_SetString

; 1474 :                 return cleanreturn(0, &freelist);

  003ce	33 c9		 xor	 ecx, ecx
  003d0	e9 0e 02 00 00	 jmp	 $LN92@vgetargske
$LN62@vgetargske:

; 1497 :                 PyErr_Format(PyExc_TypeError,
; 1498 :                              "Function takes %s %d positional arguments"
; 1499 :                              " (%d given)",
; 1500 :                              (min != INT_MAX) ? "at most" : "exactly",
; 1501 :                              max, nargs);

  003d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07IGBEEPOP@at?5most?$AA@
  003dc	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  003e1	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  003e6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_07JLAGAGFH@exactly?$AA@
  003ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@BPFKLMMD@Function?5takes?5?$CFs?5?$CFd?5positional?5@
  003f4	44 8b cf	 mov	 r9d, edi
  003f7	4c 0f 45 c1	 cmovne	 r8, rcx
  003fb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00402	e8 00 00 00 00	 call	 PyErr_Format

; 1502 :                 return cleanreturn(0, &freelist);

  00407	33 c9		 xor	 ecx, ecx
  00409	e9 d5 01 00 00	 jmp	 $LN92@vgetargske
$LN61@vgetargske:

; 1488 :                 PyErr_SetString(PyExc_RuntimeError,
; 1489 :                                 "Invalid format string ($ specified twice)");

  0040e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00415	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@MOOGIOLD@Invalid?5format?5string?5?$CI$?5specifi@
  0041c	e8 00 00 00 00	 call	 PyErr_SetString

; 1490 :                 return cleanreturn(0, &freelist);

  00421	33 c9		 xor	 ecx, ecx
  00423	e9 bb 01 00 00	 jmp	 $LN92@vgetargske
$LN66@vgetargske:

; 1535 :                 seterror(i+1, msg, levels, fname, custom_msg);

  00428	48 8b 54 24 60	 mov	 rdx, QWORD PTR custom_msg$1$[rsp]
  0042d	4c 8b 4c 24 68	 mov	 r9, QWORD PTR fname$1$[rsp]
  00432	8d 4f 01	 lea	 ecx, DWORD PTR [rdi+1]
  00435	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0043a	4c 8d 45 80	 lea	 r8, QWORD PTR levels$[rbp-256]
  0043e	48 8b d0	 mov	 rdx, rax
  00441	e8 00 00 00 00	 call	 seterror

; 1536 :                 return cleanreturn(0, &freelist);

  00446	33 c9		 xor	 ecx, ecx
  00448	e9 96 01 00 00	 jmp	 $LN92@vgetargske
$LN88@vgetargske:

; 1588 :                         match = 1;
; 1589 :                         break;
; 1590 :                     }
; 1591 :                 }
; 1592 :             }
; 1593 :             if (!match) {

  0044d	4c 8b bd 68 02
	00 00		 mov	 r15, QWORD PTR kwlist$[rbp-256]
$LN32@vgetargske:

; 1561 :         }
; 1562 :     }
; 1563 : 
; 1564 :     if (!IS_END_OF_FORMAT(*format) && (*format != '|') && (*format != '$')) {

  00454	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00457	84 c0		 test	 al, al
  00459	0f 84 a2 00 00
	00		 je	 $LN11@vgetargske
  0045f	3c 3b		 cmp	 al, 59			; 0000003bH
  00461	0f 84 9a 00 00
	00		 je	 $LN11@vgetargske
  00467	3c 3a		 cmp	 al, 58			; 0000003aH
  00469	0f 84 92 00 00
	00		 je	 $LN11@vgetargske
  0046f	3c 7c		 cmp	 al, 124			; 0000007cH
  00471	0f 84 8a 00 00
	00		 je	 $LN11@vgetargske
  00477	3c 24		 cmp	 al, 36			; 00000024H
  00479	0f 84 82 00 00
	00		 je	 $LN11@vgetargske

; 1565 :         PyErr_Format(PyExc_RuntimeError,
; 1566 :             "more argument specifiers than keyword list entries "
; 1567 :             "(remaining format:'%s')", format);

  0047f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00486	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EL@FLEHBPOJ@more?5argument?5specifiers?5than?5ke@
  0048d	4c 8b c3	 mov	 r8, rbx
  00490	e8 00 00 00 00	 call	 PyErr_Format

; 1568 :         return cleanreturn(0, &freelist);

  00495	33 c9		 xor	 ecx, ecx
  00497	e9 47 01 00 00	 jmp	 $LN92@vgetargske
$LN69@vgetargske:

; 1558 :             PyErr_Format(PyExc_RuntimeError, "%s: '%s'", msg,
; 1559 :                          format);

  0049c	4c 8b 8d 60 02
	00 00		 mov	 r9, QWORD PTR format$[rbp-256]
  004a3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  004aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08JAIPINJA@?$CFs?3?5?8?$CFs?8?$AA@
  004b1	4c 8b c0	 mov	 r8, rax
  004b4	e8 00 00 00 00	 call	 PyErr_Format

; 1560 :             return cleanreturn(0, &freelist);

  004b9	33 c9		 xor	 ecx, ecx
  004bb	e9 23 01 00 00	 jmp	 $LN92@vgetargske
$LN67@vgetargske:

; 1542 :             PyErr_Format(PyExc_TypeError, "Required argument "
; 1543 :                          "'%s' (pos %d) not found",
; 1544 :                          keyword, i+1);

  004c0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  004c7	44 8d 4f 01	 lea	 r9d, DWORD PTR [rdi+1]
  004cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@HKBBODMD@Required?5argument?5?8?$CFs?8?5?$CIpos?5?$CFd?$CJ?5@
  004d2	4d 8b c7	 mov	 r8, r15
  004d5	e8 00 00 00 00	 call	 PyErr_Format

; 1545 :             return cleanreturn(0, &freelist);

  004da	33 c9		 xor	 ecx, ecx
  004dc	e9 02 01 00 00	 jmp	 $LN92@vgetargske
$LN24@vgetargske:

; 1506 :             PyErr_Format(PyExc_RuntimeError,
; 1507 :                          "More keyword list entries (%d) than "
; 1508 :                          "format specifiers (%d)", len, i);

  004e1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  004e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DL@LMLCHELD@More?5keyword?5list?5entries?5?$CI?$CFd?$CJ?5t@
  004ef	44 8b cf	 mov	 r9d, edi
  004f2	45 8b c6	 mov	 r8d, r14d
  004f5	e8 00 00 00 00	 call	 PyErr_Format

; 1509 :             return cleanreturn(0, &freelist);

  004fa	33 c9		 xor	 ecx, ecx
  004fc	e9 e2 00 00 00	 jmp	 $LN92@vgetargske
$LN11@vgetargske:

; 1569 :     }
; 1570 : 
; 1571 :     /* make sure there are no extraneous keyword arguments */
; 1572 :     if (nkeywords > 0) {

  00501	45 85 ed	 test	 r13d, r13d
  00504	0f 8e d4 00 00
	00		 jle	 $LN8@vgetargske

; 1573 :         PyObject *key, *value;
; 1574 :         Py_ssize_t pos = 0;
; 1575 :         while (PyDict_Next(keywords, &pos, &key, &value)) {

  0050a	48 8b 9d 58 02
	00 00		 mov	 rbx, QWORD PTR keywords$[rbp-256]
  00511	4c 8d 4c 24 60	 lea	 r9, QWORD PTR value$21791[rsp]
  00516	4c 8d 85 68 02
	00 00		 lea	 r8, QWORD PTR key$21790[rbp-256]
  0051d	48 8d 54 24 68	 lea	 rdx, QWORD PTR pos$21792[rsp]
  00522	48 8b cb	 mov	 rcx, rbx
  00525	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR pos$21792[rsp], 0
  0052e	e8 00 00 00 00	 call	 PyDict_Next
  00533	85 c0		 test	 eax, eax
  00535	0f 84 a3 00 00
	00		 je	 $LN8@vgetargske
  0053b	0f 1f 44 00 00	 npad	 5
$LL9@vgetargske:

; 1576 :             int match = 0;
; 1577 :             char *ks;
; 1578 :             if (!PyUnicode_Check(key)) {

  00540	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR key$21790[rbp-256]
  00547	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0054b	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00555	0f 84 a6 00 00
	00		 je	 $LN71@vgetargske

; 1582 :             }
; 1583 :             /* check that _PyUnicode_AsString() result is not NULL */
; 1584 :             ks = _PyUnicode_AsString(key);

  0055b	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  00560	4c 8b d8	 mov	 r11, rax

; 1585 :             if (ks != NULL) {

  00563	48 85 c0	 test	 rax, rax
  00566	74 37		 je	 SHORT $LN72@vgetargske

; 1586 :                 for (i = 0; i < len; i++) {

  00568	45 33 c9	 xor	 r9d, r9d
  0056b	45 85 f6	 test	 r14d, r14d
  0056e	7e 2f		 jle	 SHORT $LN72@vgetargske
$LL5@vgetargske:

; 1587 :                     if (!strcmp(ks, kwlist[i])) {

  00570	4f 8b 04 cf	 mov	 r8, QWORD PTR [r15+r9*8]
  00574	49 8b cb	 mov	 rcx, r11
  00577	4d 2b c3	 sub	 r8, r11
  0057a	66 0f 1f 44 00
	00		 npad	 6
$LL80@vgetargske:
  00580	0f b6 11	 movzx	 edx, BYTE PTR [rcx]
  00583	42 0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+r8]
  00588	2b d0		 sub	 edx, eax
  0058a	75 07		 jne	 SHORT $LN81@vgetargske
  0058c	48 ff c1	 inc	 rcx
  0058f	85 c0		 test	 eax, eax
  00591	75 ed		 jne	 SHORT $LL80@vgetargske
$LN81@vgetargske:
  00593	85 d2		 test	 edx, edx
  00595	74 26		 je	 SHORT $LN70@vgetargske

; 1586 :                 for (i = 0; i < len; i++) {

  00597	49 ff c1	 inc	 r9
  0059a	4c 3b ce	 cmp	 r9, rsi
  0059d	7c d1		 jl	 SHORT $LL5@vgetargske
$LN72@vgetargske:

; 1594 :                 PyErr_Format(PyExc_TypeError,
; 1595 :                              "'%U' is an invalid keyword "
; 1596 :                              "argument for this function",
; 1597 :                              key);

  0059f	4c 8b 85 68 02
	00 00		 mov	 r8, QWORD PTR key$21790[rbp-256]
  005a6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  005ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@ENKIDNFE@?8?$CFU?8?5is?5an?5invalid?5keyword?5argum@
  005b4	e8 00 00 00 00	 call	 PyErr_Format

; 1598 :                 return cleanreturn(0, &freelist);

  005b9	33 c9		 xor	 ecx, ecx
  005bb	eb 26		 jmp	 SHORT $LN92@vgetargske
$LN70@vgetargske:

; 1573 :         PyObject *key, *value;
; 1574 :         Py_ssize_t pos = 0;
; 1575 :         while (PyDict_Next(keywords, &pos, &key, &value)) {

  005bd	4c 8d 4c 24 60	 lea	 r9, QWORD PTR value$21791[rsp]
  005c2	4c 8d 85 68 02
	00 00		 lea	 r8, QWORD PTR key$21790[rbp-256]
  005c9	48 8d 54 24 68	 lea	 rdx, QWORD PTR pos$21792[rsp]
  005ce	48 8b cb	 mov	 rcx, rbx
  005d1	e8 00 00 00 00	 call	 PyDict_Next
  005d6	85 c0		 test	 eax, eax
  005d8	0f 85 62 ff ff
	ff		 jne	 $LL9@vgetargske
$LN8@vgetargske:

; 1599 :             }
; 1600 :         }
; 1601 :     }
; 1602 : 
; 1603 :     return cleanreturn(1, &freelist);

  005de	b9 01 00 00 00	 mov	 ecx, 1
$LN92@vgetargske:
  005e3	48 8d 54 24 48	 lea	 rdx, QWORD PTR freelist$[rsp]
  005e8	e8 00 00 00 00	 call	 cleanreturn
$LN43@vgetargske:

; 1604 : }

  005ed	48 81 c4 08 03
	00 00		 add	 rsp, 776		; 00000308H
  005f4	41 5f		 pop	 r15
  005f6	41 5e		 pop	 r14
  005f8	41 5d		 pop	 r13
  005fa	41 5c		 pop	 r12
  005fc	5f		 pop	 rdi
  005fd	5e		 pop	 rsi
  005fe	5b		 pop	 rbx
  005ff	5d		 pop	 rbp
  00600	c3		 ret	 0
$LN71@vgetargske:

; 1579 :                 PyErr_SetString(PyExc_TypeError,
; 1580 :                                 "keywords must be strings");

  00601	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00608	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@LEGLBJFG@keywords?5must?5be?5strings?$AA@
  0060f	e8 00 00 00 00	 call	 PyErr_SetString

; 1581 :                 return cleanreturn(0, &freelist);

  00614	33 c9		 xor	 ecx, ecx
  00616	eb cb		 jmp	 SHORT $LN92@vgetargske
vgetargskeywords ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@DKJKMDMF@?$CF?4150s?$CFs?5takes?5?$CFs?5?$CFd?5argument?$CFs?5@ ; `string'
PUBLIC	??_C@_08FNDBFMB@at?5least?$AA@			; `string'
PUBLIC	??_C@_0BK@OELPODI@bad?5format?5string?3?5?$CF?4200s?$AA@ ; `string'
PUBLIC	??_C@_0DF@JGNAFJFF@new?5style?5getargs?5format?5but?5arg@ ; `string'
PUBLIC	??_C@_0CL@DEDHDHFB@old?5style?5getargs?5format?5uses?5ne@ ; `string'
PUBLIC	??_C@_0CF@DGFDACBP@?$CF?4200s?$CFs?5takes?5at?5least?5one?5argu@ ; `string'
PUBLIC	??_C@_0BM@CMEPCPDC@?$CF?4200s?$CFs?5takes?5no?5arguments?$AA@ ; `string'
PUBLIC	??_C@_0BO@LCKPDGLB@missing?5?8?$CJ?8?5in?5getargs?5format?$AA@ ; `string'
PUBLIC	??_C@_0DI@OGOCGHBO@too?5many?5tuple?5nesting?5levels?5in@ ; `string'
PUBLIC	??_C@_0BN@FODOOFID@excess?5?8?$CJ?8?5in?5getargs?5format?$AA@ ; `string'
EXTRN	Py_FatalError:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$vgetargs1 DD imagerel vgetargs1
	DD	imagerel vgetargs1+1224
	DD	imagerel $unwind$vgetargs1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vgetargs1 DD 0b2401H
	DD	0463424H
	DD	03e0124H
	DD	0e013f015H
	DD	0c00fd011H
	DD	0600c700dH
	DD	0500bH
xdata	ENDS
;	COMDAT ??_C@_0CM@DKJKMDMF@?$CF?4150s?$CFs?5takes?5?$CFs?5?$CFd?5argument?$CFs?5@
CONST	SEGMENT
??_C@_0CM@DKJKMDMF@?$CF?4150s?$CFs?5takes?5?$CFs?5?$CFd?5argument?$CFs?5@ DB '%'
	DB	'.150s%s takes %s %d argument%s (%ld given)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08FNDBFMB@at?5least?$AA@
CONST	SEGMENT
??_C@_08FNDBFMB@at?5least?$AA@ DB 'at least', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OELPODI@bad?5format?5string?3?5?$CF?4200s?$AA@
CONST	SEGMENT
??_C@_0BK@OELPODI@bad?5format?5string?3?5?$CF?4200s?$AA@ DB 'bad format s'
	DB	'tring: %.200s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@JGNAFJFF@new?5style?5getargs?5format?5but?5arg@
CONST	SEGMENT
??_C@_0DF@JGNAFJFF@new?5style?5getargs?5format?5but?5arg@ DB 'new style g'
	DB	'etargs format but argument is not a tuple', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DEDHDHFB@old?5style?5getargs?5format?5uses?5ne@
CONST	SEGMENT
??_C@_0CL@DEDHDHFB@old?5style?5getargs?5format?5uses?5ne@ DB 'old style g'
	DB	'etargs format uses new features', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGFDACBP@?$CF?4200s?$CFs?5takes?5at?5least?5one?5argu@
CONST	SEGMENT
??_C@_0CF@DGFDACBP@?$CF?4200s?$CFs?5takes?5at?5least?5one?5argu@ DB '%.20'
	DB	'0s%s takes at least one argument', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CMEPCPDC@?$CF?4200s?$CFs?5takes?5no?5arguments?$AA@
CONST	SEGMENT
??_C@_0BM@CMEPCPDC@?$CF?4200s?$CFs?5takes?5no?5arguments?$AA@ DB '%.200s%'
	DB	's takes no arguments', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LCKPDGLB@missing?5?8?$CJ?8?5in?5getargs?5format?$AA@
CONST	SEGMENT
??_C@_0BO@LCKPDGLB@missing?5?8?$CJ?8?5in?5getargs?5format?$AA@ DB 'missin'
	DB	'g '')'' in getargs format', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@OGOCGHBO@too?5many?5tuple?5nesting?5levels?5in@
CONST	SEGMENT
??_C@_0DI@OGOCGHBO@too?5many?5tuple?5nesting?5levels?5in@ DB 'too many tu'
	DB	'ple nesting levels in argument format string', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FODOOFID@excess?5?8?$CJ?8?5in?5getargs?5format?$AA@
CONST	SEGMENT
??_C@_0BN@FODOOFID@excess?5?8?$CJ?8?5in?5getargs?5format?$AA@ DB 'excess '
	DB	''')'' in getargs format', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT vgetargs1
_TEXT	SEGMENT
freelist$ = 64
fname$1$ = 80
message$1$ = 88
compat$1$ = 96
formatsave$1$ = 104
levels$ = 112
msgbuf$ = 240
args$ = 560
format$ = 568
p_va$ = 576
flags$ = 584
vgetargs1 PROC						; COMDAT

; 197  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	41 54		 push	 r12
  0000f	41 55		 push	 r13
  00011	41 56		 push	 r14
  00013	41 57		 push	 r15
  00015	48 8d ac 24 10
	ff ff ff	 lea	 rbp, QWORD PTR [rsp-240]
  0001d	48 81 ec f0 01
	00 00		 sub	 rsp, 496		; 000001f0H

; 198  :     char msgbuf[256];
; 199  :     int levels[32];
; 200  :     const char *fname = NULL;

  00024	45 33 e4	 xor	 r12d, r12d

; 201  :     const char *message = NULL;
; 202  :     int min = -1;
; 203  :     int max = 0;
; 204  :     int level = 0;
; 205  :     int endfmt = 0;
; 206  :     const char *formatsave = format;
; 207  :     Py_ssize_t i, len;
; 208  :     char *msg;
; 209  :     freelist_t freelist = {0, NULL};
; 210  :     int compat = flags & FLAG_COMPAT;

  00027	41 8b c1	 mov	 eax, r9d
  0002a	41 83 ce ff	 or	 r14d, -1
  0002e	83 e0 01	 and	 eax, 1

; 211  : 
; 212  :     assert(compat || (args != (PyObject*)NULL));
; 213  :     flags = flags & ~FLAG_COMPAT;

  00031	41 83 e1 fe	 and	 r9d, -2
  00035	48 8b f2	 mov	 rsi, rdx
  00038	4c 8b f9	 mov	 r15, rcx
  0003b	4c 89 64 24 50	 mov	 QWORD PTR fname$1$[rsp], r12
  00040	4c 89 64 24 58	 mov	 QWORD PTR message$1$[rsp], r12
  00045	44 89 8d 48 01
	00 00		 mov	 DWORD PTR flags$[rbp-256], r9d
  0004c	41 8b fc	 mov	 edi, r12d
  0004f	41 8b dc	 mov	 ebx, r12d
  00052	4c 8b ea	 mov	 r13, rdx
  00055	48 89 54 24 68	 mov	 QWORD PTR formatsave$1$[rsp], rdx
  0005a	44 89 64 24 40	 mov	 DWORD PTR freelist$[rsp], r12d
  0005f	4c 89 64 24 48	 mov	 QWORD PTR freelist$[rsp+8], r12
  00064	89 44 24 60	 mov	 DWORD PTR compat$1$[rsp], eax
$LN67@vgetargs1:
  00068	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_ctype_table
  0006f	90		 npad	 1
$LL43@vgetargs1:

; 214  : 
; 215  :     while (endfmt == 0) {
; 216  :         int c = *format++;

  00070	0f be 16	 movsx	 edx, BYTE PTR [rsi]
  00073	48 ff c6	 inc	 rsi

; 217  :         switch (c) {

  00076	8b ca		 mov	 ecx, edx
  00078	85 d2		 test	 edx, edx
  0007a	74 79		 je	 SHORT $LN66@vgetargs1
  0007c	83 e9 28	 sub	 ecx, 40			; 00000028H
  0007f	74 51		 je	 SHORT $LN39@vgetargs1
  00081	ff c9		 dec	 ecx
  00083	74 37		 je	 SHORT $LN36@vgetargs1
  00085	83 e9 11	 sub	 ecx, 17
  00088	0f 84 ae 00 00
	00		 je	 $LN32@vgetargs1
  0008e	ff c9		 dec	 ecx
  00090	74 5e		 je	 SHORT $LN31@vgetargs1

; 243  :         default:
; 244  :             if (level == 0) {

  00092	85 db		 test	 ebx, ebx
  00094	75 da		 jne	 SHORT $LL43@vgetargs1

; 245  :                 if (c == 'O')

  00096	83 fa 4f	 cmp	 edx, 79			; 0000004fH
  00099	75 04		 jne	 SHORT $LN28@vgetargs1

; 246  :                     max++;

  0009b	ff c7		 inc	 edi
  0009d	eb d1		 jmp	 SHORT $LL43@vgetargs1
$LN28@vgetargs1:

; 247  :                 else if (Py_ISALPHA(Py_CHARMASK(c))) {

  0009f	0f b6 c2	 movzx	 eax, dl
  000a2	41 f6 04 80 03	 test	 BYTE PTR [r8+rax*4], 3
  000a7	74 09		 je	 SHORT $LN26@vgetargs1

; 248  :                     if (c != 'e') /* skip encoded */

  000a9	83 fa 65	 cmp	 edx, 101		; 00000065H
  000ac	74 c2		 je	 SHORT $LL43@vgetargs1

; 249  :                         max++;

  000ae	ff c7		 inc	 edi

; 250  :                 } else if (c == '|')

  000b0	eb be		 jmp	 SHORT $LL43@vgetargs1
$LN26@vgetargs1:
  000b2	83 fa 7c	 cmp	 edx, 124		; 0000007cH
  000b5	75 b9		 jne	 SHORT $LL43@vgetargs1

; 251  :                     min = max;

  000b7	44 8b f7	 mov	 r14d, edi

; 252  :             }
; 253  :             break;

  000ba	eb b4		 jmp	 SHORT $LL43@vgetargs1
$LN36@vgetargs1:

; 225  :             break;
; 226  :         case ')':
; 227  :             if (level == 0)

  000bc	85 db		 test	 ebx, ebx
  000be	75 0e		 jne	 SHORT $LN35@vgetargs1

; 228  :                 Py_FatalError("excess ')' in getargs format");

  000c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@FODOOFID@excess?5?8?$CJ?8?5in?5getargs?5format?$AA@
  000c7	e8 00 00 00 00	 call	 Py_FatalError

; 229  :             else

  000cc	eb 9a		 jmp	 SHORT $LN67@vgetargs1
$LN35@vgetargs1:

; 230  :                 level--;

  000ce	ff cb		 dec	 ebx

; 231  :             break;

  000d0	eb 9e		 jmp	 SHORT $LL43@vgetargs1
$LN39@vgetargs1:

; 218  :         case '(':
; 219  :             if (level == 0)

  000d2	85 db		 test	 ebx, ebx
  000d4	75 02		 jne	 SHORT $LN38@vgetargs1

; 220  :                 max++;

  000d6	ff c7		 inc	 edi
$LN38@vgetargs1:

; 221  :             level++;

  000d8	ff c3		 inc	 ebx

; 222  :             if (level >= 30)

  000da	83 fb 1e	 cmp	 ebx, 30
  000dd	7c 91		 jl	 SHORT $LL43@vgetargs1

; 223  :                 Py_FatalError("too many tuple nesting levels "
; 224  :                               "in argument format string");

  000df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DI@OGOCGHBO@too?5many?5tuple?5nesting?5levels?5in@
  000e6	e8 00 00 00 00	 call	 Py_FatalError
  000eb	e9 78 ff ff ff	 jmp	 $LN67@vgetargs1
$LN31@vgetargs1:

; 237  :             endfmt = 1;
; 238  :             break;
; 239  :         case ';':
; 240  :             message = format;

  000f0	48 89 74 24 58	 mov	 QWORD PTR message$1$[rsp], rsi
$LN66@vgetargs1:

; 241  :             endfmt = 1;
; 242  :             break;

  000f5	49 8b f4	 mov	 rsi, r12
$LN33@vgetargs1:

; 254  :         }
; 255  :     }
; 256  : 
; 257  :     if (level != 0)

  000f8	85 db		 test	 ebx, ebx
  000fa	74 0c		 je	 SHORT $LN22@vgetargs1

; 258  :         Py_FatalError(/* '(' */ "missing ')' in getargs format");

  000fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@LCKPDGLB@missing?5?8?$CJ?8?5in?5getargs?5format?$AA@
  00103	e8 00 00 00 00	 call	 Py_FatalError
$LN22@vgetargs1:

; 259  : 
; 260  :     if (min < 0)

  00108	45 85 f6	 test	 r14d, r14d

; 261  :         min = max;
; 262  : 
; 263  :     format = formatsave;

  0010b	49 8b dd	 mov	 rbx, r13

; 264  : 
; 265  :     freelist.entries = PyMem_NEW(freelistentry_t, max);

  0010e	48 b8 ff ff ff
	ff ff ff ff 07	 mov	 rax, 576460752303423487	; 07ffffffffffffffH
  00118	4c 63 ef	 movsxd	 r13, edi
  0011b	44 0f 48 f7	 cmovs	 r14d, edi
  0011f	48 89 9d 38 01
	00 00		 mov	 QWORD PTR format$[rbp-256], rbx
  00126	4c 3b e8	 cmp	 r13, rax
  00129	76 18		 jbe	 SHORT $LN52@vgetargs1
$LN69@vgetargs1:
  0012b	4c 89 64 24 48	 mov	 QWORD PTR freelist$[rsp+8], r12

; 267  :         PyErr_NoMemory();

  00130	e8 00 00 00 00	 call	 PyErr_NoMemory

; 268  :         return 0;

  00135	33 c0		 xor	 eax, eax
  00137	e9 71 03 00 00	 jmp	 $LN44@vgetargs1
$LN32@vgetargs1:

; 232  :         case '\0':
; 233  :             endfmt = 1;
; 234  :             break;
; 235  :         case ':':
; 236  :             fname = format;

  0013c	48 89 74 24 50	 mov	 QWORD PTR fname$1$[rsp], rsi
  00141	eb b5		 jmp	 SHORT $LN33@vgetargs1
$LN52@vgetargs1:

; 264  : 
; 265  :     freelist.entries = PyMem_NEW(freelistentry_t, max);

  00143	e8 00 00 00 00	 call	 _Py_PXCTX
  00148	85 c0		 test	 eax, eax
  0014a	74 0e		 je	 SHORT $LN50@vgetargs1
  0014c	49 8b cd	 mov	 rcx, r13
  0014f	48 c1 e1 04	 shl	 rcx, 4
  00153	e8 00 00 00 00	 call	 _PxMem_Malloc
  00158	eb 28		 jmp	 SHORT $LN68@vgetargs1
$LN50@vgetargs1:
  0015a	49 8b c5	 mov	 rax, r13
  0015d	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00167	48 c1 e0 04	 shl	 rax, 4
  0016b	48 3b c1	 cmp	 rax, rcx
  0016e	77 bb		 ja	 SHORT $LN69@vgetargs1
  00170	48 85 c0	 test	 rax, rax
  00173	b9 01 00 00 00	 mov	 ecx, 1
  00178	48 0f 45 c8	 cmovne	 rcx, rax
  0017c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN68@vgetargs1:
  00182	48 89 44 24 48	 mov	 QWORD PTR freelist$[rsp+8], rax

; 266  :     if (freelist.entries == NULL) {

  00187	48 85 c0	 test	 rax, rax
  0018a	75 0c		 jne	 SHORT $LN20@vgetargs1

; 267  :         PyErr_NoMemory();

  0018c	e8 00 00 00 00	 call	 PyErr_NoMemory

; 268  :         return 0;

  00191	33 c0		 xor	 eax, eax
  00193	e9 15 03 00 00	 jmp	 $LN44@vgetargs1
$LN20@vgetargs1:

; 269  :     }
; 270  : 
; 271  :     if (compat) {

  00198	44 39 64 24 60	 cmp	 DWORD PTR compat$1$[rsp], r12d
  0019d	0f 84 27 01 00
	00		 je	 $LN12@vgetargs1

; 272  :         if (max == 0) {

  001a3	85 ff		 test	 edi, edi
  001a5	75 48		 jne	 SHORT $LN18@vgetargs1

; 273  :             if (args == NULL)

  001a7	4d 85 ff	 test	 r15, r15
  001aa	75 08		 jne	 SHORT $LN17@vgetargs1

; 274  :                 return 1;

  001ac	8d 47 01	 lea	 eax, QWORD PTR [rdi+1]
  001af	e9 f9 02 00 00	 jmp	 $LN44@vgetargs1
$LN17@vgetargs1:

; 275  :             PyErr_Format(PyExc_TypeError,
; 276  :                          "%.200s%s takes no arguments",
; 277  :                          fname==NULL ? "function" : fname,
; 278  :                          fname==NULL ? "" : "()");

  001b4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  001bb	48 85 f6	 test	 rsi, rsi
  001be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  001c5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  001cc	4c 0f 44 ca	 cmove	 r9, rdx
  001d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08HFFPPCHF@function?$AA@
  001d7	48 0f 44 f2	 cmove	 rsi, rdx
  001db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@CMEPCPDC@?$CF?4200s?$CFs?5takes?5no?5arguments?$AA@
  001e2	4c 8b c6	 mov	 r8, rsi
  001e5	e8 00 00 00 00	 call	 PyErr_Format

; 279  :             return cleanreturn(0, &freelist);

  001ea	e9 b2 02 00 00	 jmp	 $LN7@vgetargs1
$LN18@vgetargs1:

; 280  :         }
; 281  :         else if (min == 1 && max == 1) {

  001ef	41 83 fe 01	 cmp	 r14d, 1
  001f3	0f 85 be 00 00
	00		 jne	 $LN15@vgetargs1
  001f9	41 3b fe	 cmp	 edi, r14d
  001fc	0f 85 b5 00 00
	00		 jne	 $LN15@vgetargs1

; 282  :             if (args == NULL) {

  00202	4d 85 ff	 test	 r15, r15
  00205	75 3b		 jne	 SHORT $LN14@vgetargs1

; 283  :                 PyErr_Format(PyExc_TypeError,
; 284  :                              "%.200s%s takes at least one argument",
; 285  :                              fname==NULL ? "function" : fname,
; 286  :                              fname==NULL ? "" : "()");

  00207	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0020e	48 85 f6	 test	 rsi, rsi
  00211	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00218	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  0021f	4c 0f 44 ca	 cmove	 r9, rdx
  00223	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08HFFPPCHF@function?$AA@
  0022a	48 0f 44 f2	 cmove	 rsi, rdx
  0022e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@DGFDACBP@?$CF?4200s?$CFs?5takes?5at?5least?5one?5argu@
  00235	4c 8b c6	 mov	 r8, rsi
  00238	e8 00 00 00 00	 call	 PyErr_Format

; 287  :                 return cleanreturn(0, &freelist);

  0023d	e9 5f 02 00 00	 jmp	 $LN7@vgetargs1
$LN14@vgetargs1:

; 288  :             }
; 289  :             msg = convertitem(args, &format, p_va, flags, levels,
; 290  :                               msgbuf, sizeof(msgbuf), &freelist);

  00242	44 8b 8d 48 01
	00 00		 mov	 r9d, DWORD PTR flags$[rbp-256]
  00249	4c 8b 85 40 01
	00 00		 mov	 r8, QWORD PTR p_va$[rbp-256]
  00250	48 8d 44 24 40	 lea	 rax, QWORD PTR freelist$[rsp]
  00255	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0025a	48 8d 45 f0	 lea	 rax, QWORD PTR msgbuf$[rbp-256]
  0025e	48 c7 44 24 30
	00 01 00 00	 mov	 QWORD PTR [rsp+48], 256	; 00000100H
  00267	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0026c	48 8d 44 24 70	 lea	 rax, QWORD PTR levels$[rsp]
  00271	48 8d 95 38 01
	00 00		 lea	 rdx, QWORD PTR format$[rbp-256]
  00278	49 8b cf	 mov	 rcx, r15
  0027b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00280	e8 00 00 00 00	 call	 convertitem

; 291  :             if (msg == NULL)

  00285	48 85 c0	 test	 rax, rax
  00288	75 0a		 jne	 SHORT $LN13@vgetargs1
$LN1@vgetargs1:

; 292  :                 return cleanreturn(1, &freelist);

  0028a	b9 01 00 00 00	 mov	 ecx, 1
  0028f	e9 0f 02 00 00	 jmp	 $LN70@vgetargs1
$LN13@vgetargs1:

; 293  :             seterror(levels[0], msg, levels+1, fname, message);

  00294	48 8b 54 24 58	 mov	 rdx, QWORD PTR message$1$[rsp]
  00299	8b 4c 24 70	 mov	 ecx, DWORD PTR levels$[rsp]
  0029d	4c 8d 44 24 74	 lea	 r8, QWORD PTR levels$[rsp+4]
  002a2	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  002a7	4c 8b ce	 mov	 r9, rsi
  002aa	48 8b d0	 mov	 rdx, rax
  002ad	e8 00 00 00 00	 call	 seterror

; 294  :             return cleanreturn(0, &freelist);

  002b2	e9 ea 01 00 00	 jmp	 $LN7@vgetargs1
$LN15@vgetargs1:

; 295  :         }
; 296  :         else {
; 297  :             PyErr_SetString(PyExc_SystemError,
; 298  :                 "old style getargs format uses new features");

  002b7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  002be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@DEDHDHFB@old?5style?5getargs?5format?5uses?5ne@

; 299  :             return cleanreturn(0, &freelist);

  002c5	e9 d2 01 00 00	 jmp	 $LN71@vgetargs1
$LN12@vgetargs1:

; 300  :         }
; 301  :     }
; 302  : 
; 303  :     if (!PyTuple_Check(args)) {

  002ca	49 8b 47 58	 mov	 rax, QWORD PTR [r15+88]
  002ce	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  002d8	75 13		 jne	 SHORT $LN11@vgetargs1

; 304  :         PyErr_SetString(PyExc_SystemError,
; 305  :             "new style getargs format but argument is not a tuple");

  002da	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  002e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@JGNAFJFF@new?5style?5getargs?5format?5but?5arg@

; 306  :         return cleanreturn(0, &freelist);

  002e8	e9 af 01 00 00	 jmp	 $LN71@vgetargs1
$LN11@vgetargs1:

; 307  :     }
; 308  : 
; 309  :     len = PyTuple_GET_SIZE(args);

  002ed	49 8b 77 60	 mov	 rsi, QWORD PTR [r15+96]

; 310  : 
; 311  :     if (len < min || max < len) {

  002f1	49 63 c6	 movsxd	 rax, r14d
  002f4	48 3b f0	 cmp	 rsi, rax
  002f7	0f 8c 06 01 00
	00		 jl	 $LN9@vgetargs1
  002fd	4c 3b ee	 cmp	 r13, rsi
  00300	0f 8c fd 00 00
	00		 jl	 $LN9@vgetargs1

; 325  :     }
; 326  : 
; 327  :     for (i = 0; i < len; i++) {

  00306	48 85 f6	 test	 rsi, rsi
  00309	7e 77		 jle	 SHORT $LN4@vgetargs1
  0030b	44 8b ad 48 01
	00 00		 mov	 r13d, DWORD PTR flags$[rbp-256]
  00312	4c 8b b5 40 01
	00 00		 mov	 r14, QWORD PTR p_va$[rbp-256]
  00319	49 8d 7f 70	 lea	 rdi, QWORD PTR [r15+112]
  0031d	0f 1f 00	 npad	 3
$LL6@vgetargs1:

; 328  :         if (*format == '|')

  00320	80 3b 7c	 cmp	 BYTE PTR [rbx], 124	; 0000007cH
  00323	75 0a		 jne	 SHORT $LN3@vgetargs1

; 329  :             format++;

  00325	48 ff c3	 inc	 rbx
  00328	48 89 9d 38 01
	00 00		 mov	 QWORD PTR format$[rbp-256], rbx
$LN3@vgetargs1:

; 330  :         msg = convertitem(PyTuple_GET_ITEM(args, i), &format, p_va,
; 331  :                           flags, levels, msgbuf,
; 332  :                           sizeof(msgbuf), &freelist);

  0032f	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00332	48 8d 44 24 40	 lea	 rax, QWORD PTR freelist$[rsp]
  00337	48 8d 95 38 01
	00 00		 lea	 rdx, QWORD PTR format$[rbp-256]
  0033e	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00343	48 8d 45 f0	 lea	 rax, QWORD PTR msgbuf$[rbp-256]
  00347	48 c7 44 24 30
	00 01 00 00	 mov	 QWORD PTR [rsp+48], 256	; 00000100H
  00350	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00355	48 8d 44 24 70	 lea	 rax, QWORD PTR levels$[rsp]
  0035a	45 8b cd	 mov	 r9d, r13d
  0035d	4d 8b c6	 mov	 r8, r14
  00360	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00365	e8 00 00 00 00	 call	 convertitem

; 333  :         if (msg) {

  0036a	48 85 c0	 test	 rax, rax
  0036d	75 73		 jne	 SHORT $LN58@vgetargs1

; 325  :     }
; 326  : 
; 327  :     for (i = 0; i < len; i++) {

  0036f	48 8b 9d 38 01
	00 00		 mov	 rbx, QWORD PTR format$[rbp-256]
  00376	49 ff c4	 inc	 r12
  00379	48 83 c7 08	 add	 rdi, 8
  0037d	4c 3b e6	 cmp	 r12, rsi
  00380	7c 9e		 jl	 SHORT $LL6@vgetargs1
$LN4@vgetargs1:

; 336  :         }
; 337  :     }
; 338  : 
; 339  :     if (*format != '\0' && !Py_ISALPHA(Py_CHARMASK(*format)) &&
; 340  :         *format != '(' &&
; 341  :         *format != '|' && *format != ':' && *format != ';') {

  00382	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  00385	84 c9		 test	 cl, cl
  00387	0f 84 fd fe ff
	ff		 je	 $LN1@vgetargs1
  0038d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_ctype_table
  00394	0f b6 c1	 movzx	 eax, cl
  00397	f6 04 82 03	 test	 BYTE PTR [rdx+rax*4], 3
  0039b	0f 85 e9 fe ff
	ff		 jne	 $LN1@vgetargs1
  003a1	80 f9 28	 cmp	 cl, 40			; 00000028H
  003a4	0f 84 e0 fe ff
	ff		 je	 $LN1@vgetargs1
  003aa	80 f9 7c	 cmp	 cl, 124			; 0000007cH
  003ad	0f 84 d7 fe ff
	ff		 je	 $LN1@vgetargs1
  003b3	80 f9 3a	 cmp	 cl, 58			; 0000003aH
  003b6	0f 84 ce fe ff
	ff		 je	 $LN1@vgetargs1
  003bc	80 f9 3b	 cmp	 cl, 59			; 0000003bH
  003bf	0f 84 c5 fe ff
	ff		 je	 $LN1@vgetargs1

; 342  :         PyErr_Format(PyExc_SystemError,
; 343  :                      "bad format string: %.200s", formatsave);

  003c5	4c 8b 44 24 68	 mov	 r8, QWORD PTR formatsave$1$[rsp]
  003ca	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  003d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@OELPODI@bad?5format?5string?3?5?$CF?4200s?$AA@
  003d8	e8 00 00 00 00	 call	 PyErr_Format

; 344  :         return cleanreturn(0, &freelist);

  003dd	e9 bf 00 00 00	 jmp	 $LN7@vgetargs1
$LN58@vgetargs1:

; 334  :             seterror(i+1, msg, levels, fname, msg);

  003e2	4c 8b 4c 24 50	 mov	 r9, QWORD PTR fname$1$[rsp]
  003e7	41 8d 4c 24 01	 lea	 ecx, DWORD PTR [r12+1]
  003ec	4c 8d 44 24 70	 lea	 r8, QWORD PTR levels$[rsp]
  003f1	48 8b d0	 mov	 rdx, rax
  003f4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003f9	e8 00 00 00 00	 call	 seterror

; 335  :             return cleanreturn(0, &freelist);

  003fe	e9 9e 00 00 00	 jmp	 $LN7@vgetargs1
$LN9@vgetargs1:

; 312  :         if (message == NULL)

  00403	48 8b 54 24 58	 mov	 rdx, QWORD PTR message$1$[rsp]
  00408	48 85 d2	 test	 rdx, rdx
  0040b	0f 85 84 00 00
	00		 jne	 $LN8@vgetargs1

; 313  :             PyErr_Format(PyExc_TypeError,
; 314  :                          "%.150s%s takes %s %d argument%s (%ld given)",
; 315  :                          fname==NULL ? "function" : fname,
; 316  :                          fname==NULL ? "" : "()",
; 317  :                          min==max ? "exactly"
; 318  :                          : len < min ? "at least" : "at most",
; 319  :                          len < min ? min : max,
; 320  :                          (len < min ? min : max) == 1 ? "" : "s",
; 321  :                          Py_SAFE_DOWNCAST(len, Py_ssize_t, long));

  00411	44 3b f7	 cmp	 r14d, edi
  00414	75 09		 jne	 SHORT $LN54@vgetargs1
  00416	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07JLAGAGFH@exactly?$AA@
  0041d	eb 15		 jmp	 SHORT $LN55@vgetargs1
$LN54@vgetargs1:
  0041f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08FNDBFMB@at?5least?$AA@
  00426	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07IGBEEPOP@at?5most?$AA@
  0042d	48 3b f0	 cmp	 rsi, rax
  00430	48 0f 4c ca	 cmovl	 rcx, rdx
$LN55@vgetargs1:
  00434	4c 8b 44 24 50	 mov	 r8, QWORD PTR fname$1$[rsp]
  00439	48 3b f0	 cmp	 rsi, rax
  0043c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00443	41 0f 4c fe	 cmovl	 edi, r14d
  00447	89 74 24 38	 mov	 DWORD PTR [rsp+56], esi
  0044b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_01LKDEMHDF@s?$AA@
  00452	83 ff 01	 cmp	 edi, 1
  00455	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  0045c	48 0f 44 c2	 cmove	 rax, rdx
  00460	4d 85 c0	 test	 r8, r8
  00463	4c 0f 44 ca	 cmove	 r9, rdx
  00467	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0046c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08HFFPPCHF@function?$AA@
  00473	4c 0f 44 c2	 cmove	 r8, rdx
  00477	89 7c 24 28	 mov	 DWORD PTR [rsp+40], edi
  0047b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00480	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00487	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@DKJKMDMF@?$CF?4150s?$CFs?5takes?5?$CFs?5?$CFd?5argument?$CFs?5@
  0048e	e8 00 00 00 00	 call	 PyErr_Format

; 322  :         else

  00493	eb 0c		 jmp	 SHORT $LN7@vgetargs1
$LN8@vgetargs1:

; 323  :             PyErr_SetString(PyExc_TypeError, message);

  00495	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
$LN71@vgetargs1:
  0049c	e8 00 00 00 00	 call	 PyErr_SetString
$LN7@vgetargs1:

; 324  :         return cleanreturn(0, &freelist);

  004a1	33 c9		 xor	 ecx, ecx
$LN70@vgetargs1:
  004a3	48 8d 54 24 40	 lea	 rdx, QWORD PTR freelist$[rsp]
  004a8	e8 00 00 00 00	 call	 cleanreturn
$LN44@vgetargs1:

; 345  :     }
; 346  : 
; 347  :     return cleanreturn(1, &freelist);
; 348  : }

  004ad	48 8b 9c 24 30
	02 00 00	 mov	 rbx, QWORD PTR [rsp+560]
  004b5	48 81 c4 f0 01
	00 00		 add	 rsp, 496		; 000001f0H
  004bc	41 5f		 pop	 r15
  004be	41 5e		 pop	 r14
  004c0	41 5d		 pop	 r13
  004c2	41 5c		 pop	 r12
  004c4	5f		 pop	 rdi
  004c5	5e		 pop	 rsi
  004c6	5d		 pop	 rbp
  004c7	c3		 ret	 0
vgetargs1 ENDP
_TEXT	ENDS
PUBLIC	PyArg_ParseTupleAndKeywords
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyArg_ParseTupleAndKeywords DD imagerel $LN6
	DD	imagerel $LN6+123
	DD	imagerel $unwind$PyArg_ParseTupleAndKeywords
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyArg_ParseTupleAndKeywords DD 010901H
	DD	08209H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyArg_ParseTupleAndKeywords
_TEXT	SEGMENT
va$ = 48
args$ = 80
keywords$ = 88
format$ = 96
kwlist$ = 104
PyArg_ParseTupleAndKeywords PROC			; COMDAT

; 1302 : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1303 :     int retval;
; 1304 :     va_list va;
; 1305 : 
; 1306 :     if ((args == NULL || !PyTuple_Check(args)) ||
; 1307 :         (keywords != NULL && !PyDict_Check(keywords)) ||
; 1308 :         format == NULL ||
; 1309 :         kwlist == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	74 55		 je	 SHORT $LN2@PyArg_Pars
  0000e	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00012	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  0001c	74 45		 je	 SHORT $LN2@PyArg_Pars
  0001e	48 85 d2	 test	 rdx, rdx
  00021	74 10		 je	 SHORT $LN1@PyArg_Pars
  00023	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00027	f7 80 00 01 00
	00 00 00 00 20	 test	 DWORD PTR [rax+256], 536870912 ; 20000000H
  00031	74 30		 je	 SHORT $LN2@PyArg_Pars
$LN1@PyArg_Pars:
  00033	4d 85 c0	 test	 r8, r8
  00036	74 2b		 je	 SHORT $LN2@PyArg_Pars
  00038	4d 85 c9	 test	 r9, r9
  0003b	74 26		 je	 SHORT $LN2@PyArg_Pars

; 1313 :     }
; 1314 : 
; 1315 :     va_start(va, kwlist);

  0003d	48 8d 44 24 70	 lea	 rax, QWORD PTR kwlist$[rsp+8]

; 1316 :     retval = vgetargskeywords(args, keywords, format, kwlist, &va, 0);

  00042	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0004a	48 89 44 24 30	 mov	 QWORD PTR va$[rsp], rax
  0004f	48 8d 44 24 30	 lea	 rax, QWORD PTR va$[rsp]
  00054	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00059	e8 00 00 00 00	 call	 vgetargskeywords

; 1317 :     va_end(va);
; 1318 :     return retval;
; 1319 : }

  0005e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00062	c3		 ret	 0
$LN2@PyArg_Pars:

; 1310 :     {
; 1311 :         PyErr_BadInternalCall();

  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@GAIPICFM@?4?4?2Python?2getargs?4c?$AA@
  0006a	ba 1f 05 00 00	 mov	 edx, 1311		; 0000051fH
  0006f	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1312 :         return 0;

  00074	33 c0		 xor	 eax, eax

; 1317 :     va_end(va);
; 1318 :     return retval;
; 1319 : }

  00076	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0007a	c3		 ret	 0
PyArg_ParseTupleAndKeywords ENDP
_TEXT	ENDS
PUBLIC	_PyArg_ParseTupleAndKeywords_SizeT
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyArg_ParseTupleAndKeywords_SizeT DD imagerel $LN6
	DD	imagerel $LN6+123
	DD	imagerel $unwind$_PyArg_ParseTupleAndKeywords_SizeT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyArg_ParseTupleAndKeywords_SizeT DD 010901H
	DD	08209H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyArg_ParseTupleAndKeywords_SizeT
_TEXT	SEGMENT
va$ = 48
args$ = 80
keywords$ = 88
format$ = 96
kwlist$ = 104
_PyArg_ParseTupleAndKeywords_SizeT PROC			; COMDAT

; 1326 : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1327 :     int retval;
; 1328 :     va_list va;
; 1329 : 
; 1330 :     if ((args == NULL || !PyTuple_Check(args)) ||
; 1331 :         (keywords != NULL && !PyDict_Check(keywords)) ||
; 1332 :         format == NULL ||
; 1333 :         kwlist == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	74 55		 je	 SHORT $LN2@PyArg_Pars@2
  0000e	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00012	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  0001c	74 45		 je	 SHORT $LN2@PyArg_Pars@2
  0001e	48 85 d2	 test	 rdx, rdx
  00021	74 10		 je	 SHORT $LN1@PyArg_Pars@2
  00023	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00027	f7 80 00 01 00
	00 00 00 00 20	 test	 DWORD PTR [rax+256], 536870912 ; 20000000H
  00031	74 30		 je	 SHORT $LN2@PyArg_Pars@2
$LN1@PyArg_Pars@2:
  00033	4d 85 c0	 test	 r8, r8
  00036	74 2b		 je	 SHORT $LN2@PyArg_Pars@2
  00038	4d 85 c9	 test	 r9, r9
  0003b	74 26		 je	 SHORT $LN2@PyArg_Pars@2

; 1337 :     }
; 1338 : 
; 1339 :     va_start(va, kwlist);

  0003d	48 8d 44 24 70	 lea	 rax, QWORD PTR kwlist$[rsp+8]

; 1340 :     retval = vgetargskeywords(args, keywords, format,
; 1341 :                               kwlist, &va, FLAG_SIZE_T);

  00042	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR [rsp+40], 2
  0004a	48 89 44 24 30	 mov	 QWORD PTR va$[rsp], rax
  0004f	48 8d 44 24 30	 lea	 rax, QWORD PTR va$[rsp]
  00054	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00059	e8 00 00 00 00	 call	 vgetargskeywords

; 1342 :     va_end(va);
; 1343 :     return retval;
; 1344 : }

  0005e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00062	c3		 ret	 0
$LN2@PyArg_Pars@2:

; 1334 :     {
; 1335 :         PyErr_BadInternalCall();

  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@GAIPICFM@?4?4?2Python?2getargs?4c?$AA@
  0006a	ba 37 05 00 00	 mov	 edx, 1335		; 00000537H
  0006f	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1336 :         return 0;

  00074	33 c0		 xor	 eax, eax

; 1342 :     va_end(va);
; 1343 :     return retval;
; 1344 : }

  00076	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0007a	c3		 ret	 0
_PyArg_ParseTupleAndKeywords_SizeT ENDP
_TEXT	ENDS
PUBLIC	PyArg_VaParseTupleAndKeywords
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyArg_VaParseTupleAndKeywords DD imagerel $LN6
	DD	imagerel $LN6+118
	DD	imagerel $unwind$PyArg_VaParseTupleAndKeywords
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyArg_VaParseTupleAndKeywords DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyArg_VaParseTupleAndKeywords
_TEXT	SEGMENT
lva$ = 64
args$ = 64
keywords$ = 72
format$ = 80
kwlist$ = 88
va$ = 96
PyArg_VaParseTupleAndKeywords PROC			; COMDAT

; 1352 : {

$LN6:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1353 :     int retval;
; 1354 :     va_list lva;
; 1355 : 
; 1356 :     if ((args == NULL || !PyTuple_Check(args)) ||
; 1357 :         (keywords != NULL && !PyDict_Check(keywords)) ||
; 1358 :         format == NULL ||
; 1359 :         kwlist == NULL)

  00004	48 85 c9	 test	 rcx, rcx
  00007	74 55		 je	 SHORT $LN2@PyArg_VaPa
  00009	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000d	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  00017	74 45		 je	 SHORT $LN2@PyArg_VaPa
  00019	48 85 d2	 test	 rdx, rdx
  0001c	74 10		 je	 SHORT $LN1@PyArg_VaPa
  0001e	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00022	f7 80 00 01 00
	00 00 00 00 20	 test	 DWORD PTR [rax+256], 536870912 ; 20000000H
  0002c	74 30		 je	 SHORT $LN2@PyArg_VaPa
$LN1@PyArg_VaPa:
  0002e	4d 85 c0	 test	 r8, r8
  00031	74 2b		 je	 SHORT $LN2@PyArg_VaPa
  00033	4d 85 c9	 test	 r9, r9
  00036	74 26		 je	 SHORT $LN2@PyArg_VaPa

; 1363 :     }
; 1364 : 
; 1365 :         Py_VA_COPY(lva, va);

  00038	48 8b 44 24 60	 mov	 rax, QWORD PTR va$[rsp]

; 1366 : 
; 1367 :     retval = vgetargskeywords(args, keywords, format, kwlist, &lva, 0);

  0003d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00045	48 89 44 24 40	 mov	 QWORD PTR lva$[rsp], rax
  0004a	48 8d 44 24 40	 lea	 rax, QWORD PTR lva$[rsp]
  0004f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00054	e8 00 00 00 00	 call	 vgetargskeywords

; 1368 :     return retval;
; 1369 : }

  00059	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005d	c3		 ret	 0
$LN2@PyArg_VaPa:

; 1360 :     {
; 1361 :         PyErr_BadInternalCall();

  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@GAIPICFM@?4?4?2Python?2getargs?4c?$AA@
  00065	ba 51 05 00 00	 mov	 edx, 1361		; 00000551H
  0006a	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1362 :         return 0;

  0006f	33 c0		 xor	 eax, eax

; 1368 :     return retval;
; 1369 : }

  00071	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00075	c3		 ret	 0
PyArg_VaParseTupleAndKeywords ENDP
_TEXT	ENDS
PUBLIC	_PyArg_VaParseTupleAndKeywords_SizeT
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyArg_VaParseTupleAndKeywords_SizeT DD imagerel $LN6
	DD	imagerel $LN6+118
	DD	imagerel $unwind$_PyArg_VaParseTupleAndKeywords_SizeT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyArg_VaParseTupleAndKeywords_SizeT DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyArg_VaParseTupleAndKeywords_SizeT
_TEXT	SEGMENT
lva$ = 64
args$ = 64
keywords$ = 72
format$ = 80
kwlist$ = 88
va$ = 96
_PyArg_VaParseTupleAndKeywords_SizeT PROC		; COMDAT

; 1376 : {

$LN6:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1377 :     int retval;
; 1378 :     va_list lva;
; 1379 : 
; 1380 :     if ((args == NULL || !PyTuple_Check(args)) ||
; 1381 :         (keywords != NULL && !PyDict_Check(keywords)) ||
; 1382 :         format == NULL ||
; 1383 :         kwlist == NULL)

  00004	48 85 c9	 test	 rcx, rcx
  00007	74 55		 je	 SHORT $LN2@PyArg_VaPa@2
  00009	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000d	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  00017	74 45		 je	 SHORT $LN2@PyArg_VaPa@2
  00019	48 85 d2	 test	 rdx, rdx
  0001c	74 10		 je	 SHORT $LN1@PyArg_VaPa@2
  0001e	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00022	f7 80 00 01 00
	00 00 00 00 20	 test	 DWORD PTR [rax+256], 536870912 ; 20000000H
  0002c	74 30		 je	 SHORT $LN2@PyArg_VaPa@2
$LN1@PyArg_VaPa@2:
  0002e	4d 85 c0	 test	 r8, r8
  00031	74 2b		 je	 SHORT $LN2@PyArg_VaPa@2
  00033	4d 85 c9	 test	 r9, r9
  00036	74 26		 je	 SHORT $LN2@PyArg_VaPa@2

; 1387 :     }
; 1388 : 
; 1389 :         Py_VA_COPY(lva, va);

  00038	48 8b 44 24 60	 mov	 rax, QWORD PTR va$[rsp]

; 1390 : 
; 1391 :     retval = vgetargskeywords(args, keywords, format,
; 1392 :                               kwlist, &lva, FLAG_SIZE_T);

  0003d	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR [rsp+40], 2
  00045	48 89 44 24 40	 mov	 QWORD PTR lva$[rsp], rax
  0004a	48 8d 44 24 40	 lea	 rax, QWORD PTR lva$[rsp]
  0004f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00054	e8 00 00 00 00	 call	 vgetargskeywords

; 1393 :     return retval;
; 1394 : }

  00059	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005d	c3		 ret	 0
$LN2@PyArg_VaPa@2:

; 1384 :     {
; 1385 :         PyErr_BadInternalCall();

  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@GAIPICFM@?4?4?2Python?2getargs?4c?$AA@
  00065	ba 69 05 00 00	 mov	 edx, 1385		; 00000569H
  0006a	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1386 :         return 0;

  0006f	33 c0		 xor	 eax, eax

; 1393 :     return retval;
; 1394 : }

  00071	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00075	c3		 ret	 0
_PyArg_VaParseTupleAndKeywords_SizeT ENDP
_TEXT	ENDS
PUBLIC	PyArg_Parse
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyArg_Parse DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$PyArg_Parse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyArg_Parse DD 011301H
	DD	06213H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyArg_Parse
_TEXT	SEGMENT
va$ = 32
args$ = 64
format$ = 72
PyArg_Parse PROC					; COMDAT

; 72   : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 73   :     int retval;
; 74   :     va_list va;
; 75   : 
; 76   :     va_start(va, format);

  00013	48 8d 44 24 50	 lea	 rax, QWORD PTR format$[rsp+8]

; 77   :     retval = vgetargs1(args, format, &va, FLAG_COMPAT);

  00018	4c 8d 44 24 20	 lea	 r8, QWORD PTR va$[rsp]
  0001d	41 b9 01 00 00
	00		 mov	 r9d, 1
  00023	48 89 44 24 20	 mov	 QWORD PTR va$[rsp], rax
  00028	e8 00 00 00 00	 call	 vgetargs1

; 78   :     va_end(va);
; 79   :     return retval;
; 80   : }

  0002d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00031	c3		 ret	 0
PyArg_Parse ENDP
_TEXT	ENDS
PUBLIC	_PyArg_Parse_SizeT
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyArg_Parse_SizeT DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$_PyArg_Parse_SizeT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyArg_Parse_SizeT DD 011301H
	DD	06213H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyArg_Parse_SizeT
_TEXT	SEGMENT
va$ = 32
args$ = 64
format$ = 72
_PyArg_Parse_SizeT PROC					; COMDAT

; 84   : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 85   :     int retval;
; 86   :     va_list va;
; 87   : 
; 88   :     va_start(va, format);

  00013	48 8d 44 24 50	 lea	 rax, QWORD PTR format$[rsp+8]

; 89   :     retval = vgetargs1(args, format, &va, FLAG_COMPAT|FLAG_SIZE_T);

  00018	4c 8d 44 24 20	 lea	 r8, QWORD PTR va$[rsp]
  0001d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00023	48 89 44 24 20	 mov	 QWORD PTR va$[rsp], rax
  00028	e8 00 00 00 00	 call	 vgetargs1

; 90   :     va_end(va);
; 91   :     return retval;
; 92   : }

  0002d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00031	c3		 ret	 0
_PyArg_Parse_SizeT ENDP
_TEXT	ENDS
PUBLIC	PyArg_ParseTuple
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyArg_ParseTuple DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$PyArg_ParseTuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyArg_ParseTuple DD 011301H
	DD	06213H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyArg_ParseTuple
_TEXT	SEGMENT
va$ = 32
args$ = 64
format$ = 72
PyArg_ParseTuple PROC					; COMDAT

; 97   : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 98   :     int retval;
; 99   :     va_list va;
; 100  : 
; 101  :     va_start(va, format);

  00013	48 8d 44 24 50	 lea	 rax, QWORD PTR format$[rsp+8]

; 102  :     retval = vgetargs1(args, format, &va, 0);

  00018	4c 8d 44 24 20	 lea	 r8, QWORD PTR va$[rsp]
  0001d	45 33 c9	 xor	 r9d, r9d
  00020	48 89 44 24 20	 mov	 QWORD PTR va$[rsp], rax
  00025	e8 00 00 00 00	 call	 vgetargs1

; 103  :     va_end(va);
; 104  :     return retval;
; 105  : }

  0002a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002e	c3		 ret	 0
PyArg_ParseTuple ENDP
_TEXT	ENDS
PUBLIC	_PyArg_ParseTuple_SizeT
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyArg_ParseTuple_SizeT DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$_PyArg_ParseTuple_SizeT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyArg_ParseTuple_SizeT DD 011301H
	DD	06213H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyArg_ParseTuple_SizeT
_TEXT	SEGMENT
va$ = 32
args$ = 64
format$ = 72
_PyArg_ParseTuple_SizeT PROC				; COMDAT

; 109  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 110  :     int retval;
; 111  :     va_list va;
; 112  : 
; 113  :     va_start(va, format);

  00013	48 8d 44 24 50	 lea	 rax, QWORD PTR format$[rsp+8]

; 114  :     retval = vgetargs1(args, format, &va, FLAG_SIZE_T);

  00018	4c 8d 44 24 20	 lea	 r8, QWORD PTR va$[rsp]
  0001d	41 b9 02 00 00
	00		 mov	 r9d, 2
  00023	48 89 44 24 20	 mov	 QWORD PTR va$[rsp], rax
  00028	e8 00 00 00 00	 call	 vgetargs1

; 115  :     va_end(va);
; 116  :     return retval;
; 117  : }

  0002d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00031	c3		 ret	 0
_PyArg_ParseTuple_SizeT ENDP
_TEXT	ENDS
PUBLIC	PyArg_VaParse
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyArg_VaParse DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$PyArg_VaParse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyArg_VaParse DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyArg_VaParse
_TEXT	SEGMENT
args$ = 48
format$ = 56
lva$ = 64
va$ = 64
PyArg_VaParse PROC					; COMDAT

; 122  : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 123  :     va_list lva;
; 124  : 
; 125  :         Py_VA_COPY(lva, va);

  00004	4c 89 44 24 40	 mov	 QWORD PTR lva$[rsp], r8

; 126  : 
; 127  :     return vgetargs1(args, format, &lva, 0);

  00009	4c 8d 44 24 40	 lea	 r8, QWORD PTR lva$[rsp]
  0000e	45 33 c9	 xor	 r9d, r9d
  00011	e8 00 00 00 00	 call	 vgetargs1

; 128  : }

  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
PyArg_VaParse ENDP
_TEXT	ENDS
PUBLIC	_PyArg_VaParse_SizeT
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyArg_VaParse_SizeT DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$_PyArg_VaParse_SizeT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyArg_VaParse_SizeT DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyArg_VaParse_SizeT
_TEXT	SEGMENT
args$ = 48
format$ = 56
lva$ = 64
va$ = 64
_PyArg_VaParse_SizeT PROC				; COMDAT

; 132  : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 133  :     va_list lva;
; 134  : 
; 135  :         Py_VA_COPY(lva, va);

  00004	4c 89 44 24 40	 mov	 QWORD PTR lva$[rsp], r8

; 136  : 
; 137  :     return vgetargs1(args, format, &lva, FLAG_SIZE_T);

  00009	4c 8d 44 24 40	 lea	 r8, QWORD PTR lva$[rsp]
  0000e	41 b9 02 00 00
	00		 mov	 r9d, 2
  00014	e8 00 00 00 00	 call	 vgetargs1

; 138  : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
_PyArg_VaParse_SizeT ENDP
_TEXT	ENDS
END
