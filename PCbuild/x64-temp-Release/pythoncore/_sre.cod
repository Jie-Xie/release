; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_04LFOLHMFG@_sre?$AA@			; `string'
PUBLIC	??_C@_08GAHBPIPM@getlower?$AA@			; `string'
PUBLIC	??_C@_0M@PEJEAKBE@getcodesize?$AA@		; `string'
PUBLIC	??_C@_07OLJGFCKG@compile?$AA@			; `string'
PUBLIC	??_C@_0BB@BBOJIAJC@_sre?4SRE_Scanner?$AA@	; `string'
PUBLIC	??_C@_0P@HEJLNOBB@_sre?4SRE_Match?$AA@		; `string'
PUBLIC	??_C@_02EPEBAFDB@re?$AA@			; `string'
PUBLIC	??_C@_04PPLNELOM@regs?$AA@			; `string'
PUBLIC	??_C@_09COONDMIO@lastgroup?$AA@			; `string'
PUBLIC	??_C@_09LCAJIJAE@lastindex?$AA@			; `string'
PUBLIC	??_C@_06GFPMPEEP@expand?$AA@			; `string'
PUBLIC	??_C@_09GGPMIDAG@groupdict?$AA@			; `string'
PUBLIC	??_C@_04FOPLNFFP@span?$AA@			; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_05FAGFPHJG@start?$AA@			; `string'
PUBLIC	??_C@_05MGJOOGAJ@group?$AA@			; `string'
PUBLIC	??_C@_07DLHCIBDH@default?$AA@			; `string'
PUBLIC	??_C@_0BB@FJKNOFPK@_sre?4SRE_Pattern?$AA@	; `string'
PUBLIC	??_C@_0L@IAGOJEHI@groupindex?$AA@		; `string'
PUBLIC	??_C@_06HNAIAMHH@groups?$AA@			; `string'
PUBLIC	??_C@_05GECEPKB@flags?$AA@			; `string'
PUBLIC	??_C@_0N@LCDCNIJ@__deepcopy__?$AA@		; `string'
PUBLIC	??_C@_08MOMBEIKE@__copy__?$AA@			; `string'
PUBLIC	??_C@_07GPBKGHMB@scanner?$AA@			; `string'
PUBLIC	??_C@_08JCKNOCFD@finditer?$AA@			; `string'
PUBLIC	??_C@_07MHCELJLC@findall?$AA@			; `string'
PUBLIC	??_C@_05EHPMMFBK@split?$AA@			; `string'
PUBLIC	??_C@_04GLGDJLDE@subn?$AA@			; `string'
PUBLIC	??_C@_03KCMAIMAP@sub?$AA@			; `string'
PUBLIC	??_C@_06GFPLNGOC@search?$AA@			; `string'
PUBLIC	??_C@_05FNONLPDI@match?$AA@			; `string'
PUBLIC	??_C@_05IOMEMJEC@count?$AA@			; `string'
PUBLIC	??_C@_06ICGJLFIM@string?$AA@			; `string'
PUBLIC	??_C@_04CLIOPAIH@repl?$AA@			; `string'
PUBLIC	??_C@_08HONNCIIN@maxsplit?$AA@			; `string'
PUBLIC	??_C@_06OEKOLKIL@source?$AA@			; `string'
PUBLIC	??_C@_06MJPHPKNA@endpos?$AA@			; `string'
PUBLIC	??_C@_03PCBNCGFH@pos?$AA@			; `string'
PUBLIC	??_C@_07CHFOACKJ@pattern?$AA@			; `string'
;	COMDAT ??_C@_04LFOLHMFG@_sre?$AA@
CONST	SEGMENT
??_C@_04LFOLHMFG@_sre?$AA@ DB '_sre', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GAHBPIPM@getlower?$AA@
CONST	SEGMENT
??_C@_08GAHBPIPM@getlower?$AA@ DB 'getlower', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PEJEAKBE@getcodesize?$AA@
CONST	SEGMENT
??_C@_0M@PEJEAKBE@getcodesize?$AA@ DB 'getcodesize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07OLJGFCKG@compile?$AA@
CONST	SEGMENT
??_C@_07OLJGFCKG@compile?$AA@ DB 'compile', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BBOJIAJC@_sre?4SRE_Scanner?$AA@
CONST	SEGMENT
??_C@_0BB@BBOJIAJC@_sre?4SRE_Scanner?$AA@ DB '_sre.SRE_Scanner', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HEJLNOBB@_sre?4SRE_Match?$AA@
CONST	SEGMENT
??_C@_0P@HEJLNOBB@_sre?4SRE_Match?$AA@ DB '_sre.SRE_Match', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02EPEBAFDB@re?$AA@
CONST	SEGMENT
??_C@_02EPEBAFDB@re?$AA@ DB 're', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PPLNELOM@regs?$AA@
CONST	SEGMENT
??_C@_04PPLNELOM@regs?$AA@ DB 'regs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09COONDMIO@lastgroup?$AA@
CONST	SEGMENT
??_C@_09COONDMIO@lastgroup?$AA@ DB 'lastgroup', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LCAJIJAE@lastindex?$AA@
CONST	SEGMENT
??_C@_09LCAJIJAE@lastindex?$AA@ DB 'lastindex', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06GFPMPEEP@expand?$AA@
CONST	SEGMENT
??_C@_06GFPMPEEP@expand?$AA@ DB 'expand', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GGPMIDAG@groupdict?$AA@
CONST	SEGMENT
??_C@_09GGPMIDAG@groupdict?$AA@ DB 'groupdict', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04FOPLNFFP@span?$AA@
CONST	SEGMENT
??_C@_04FOPLNFFP@span?$AA@ DB 'span', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05FAGFPHJG@start?$AA@
CONST	SEGMENT
??_C@_05FAGFPHJG@start?$AA@ DB 'start', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MGJOOGAJ@group?$AA@
CONST	SEGMENT
??_C@_05MGJOOGAJ@group?$AA@ DB 'group', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DLHCIBDH@default?$AA@
CONST	SEGMENT
??_C@_07DLHCIBDH@default?$AA@ DB 'default', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FJKNOFPK@_sre?4SRE_Pattern?$AA@
CONST	SEGMENT
??_C@_0BB@FJKNOFPK@_sre?4SRE_Pattern?$AA@ DB '_sre.SRE_Pattern', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IAGOJEHI@groupindex?$AA@
CONST	SEGMENT
??_C@_0L@IAGOJEHI@groupindex?$AA@ DB 'groupindex', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06HNAIAMHH@groups?$AA@
CONST	SEGMENT
??_C@_06HNAIAMHH@groups?$AA@ DB 'groups', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GECEPKB@flags?$AA@
CONST	SEGMENT
??_C@_05GECEPKB@flags?$AA@ DB 'flags', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LCDCNIJ@__deepcopy__?$AA@
CONST	SEGMENT
??_C@_0N@LCDCNIJ@__deepcopy__?$AA@ DB '__deepcopy__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MOMBEIKE@__copy__?$AA@
CONST	SEGMENT
??_C@_08MOMBEIKE@__copy__?$AA@ DB '__copy__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GPBKGHMB@scanner?$AA@
CONST	SEGMENT
??_C@_07GPBKGHMB@scanner?$AA@ DB 'scanner', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08JCKNOCFD@finditer?$AA@
CONST	SEGMENT
??_C@_08JCKNOCFD@finditer?$AA@ DB 'finditer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MHCELJLC@findall?$AA@
CONST	SEGMENT
??_C@_07MHCELJLC@findall?$AA@ DB 'findall', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EHPMMFBK@split?$AA@
CONST	SEGMENT
??_C@_05EHPMMFBK@split?$AA@ DB 'split', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GLGDJLDE@subn?$AA@
CONST	SEGMENT
??_C@_04GLGDJLDE@subn?$AA@ DB 'subn', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KCMAIMAP@sub?$AA@
CONST	SEGMENT
??_C@_03KCMAIMAP@sub?$AA@ DB 'sub', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06GFPLNGOC@search?$AA@
CONST	SEGMENT
??_C@_06GFPLNGOC@search?$AA@ DB 'search', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FNONLPDI@match?$AA@
CONST	SEGMENT
??_C@_05FNONLPDI@match?$AA@ DB 'match', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IOMEMJEC@count?$AA@
CONST	SEGMENT
??_C@_05IOMEMJEC@count?$AA@ DB 'count', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06ICGJLFIM@string?$AA@
CONST	SEGMENT
??_C@_06ICGJLFIM@string?$AA@ DB 'string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CLIOPAIH@repl?$AA@
CONST	SEGMENT
??_C@_04CLIOPAIH@repl?$AA@ DB 'repl', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HONNCIIN@maxsplit?$AA@
CONST	SEGMENT
??_C@_08HONNCIIN@maxsplit?$AA@ DB 'maxsplit', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06OEKOLKIL@source?$AA@
CONST	SEGMENT
??_C@_06OEKOLKIL@source?$AA@ DB 'source', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MJPHPKNA@endpos?$AA@
CONST	SEGMENT
??_C@_06MJPHPKNA@endpos?$AA@ DB 'endpos', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PCBNCGFH@pos?$AA@
CONST	SEGMENT
??_C@_03PCBNCGFH@pos?$AA@ DB 'pos', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07CHFOACKJ@pattern?$AA@
CONST	SEGMENT
??_C@_07CHFOACKJ@pattern?$AA@ DB 'pattern', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
copyright DB	' SRE 2.2.2 Copyright (c) 1997-2002 by Secret Labs AB ', 00H
	ORG $+10
sre_char_info DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	DB	06H
	DB	02H
	DB	02H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	010H
	DB	00H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
sre_char_lower DB 00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	01aH
	DB	01bH
	DB	01cH
	DB	01dH
	DB	01eH
	DB	01fH
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	025H
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	02aH
	DB	02bH
	DB	02cH
	DB	02dH
	DB	02eH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	03aH
	DB	03bH
	DB	03cH
	DB	03dH
	DB	03eH
	DB	03fH
	DB	040H
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	05bH
	DB	05cH
	DB	05dH
	DB	05eH
	DB	05fH
	DB	060H
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	07bH
	DB	07cH
	DB	07dH
	DB	07eH
	DB	07fH
?kwlist@?1??pattern_match@@9@9 DQ FLAT:??_C@_07CHFOACKJ@pattern?$AA@ ; `pattern_match'::`2'::kwlist
	DQ	FLAT:??_C@_03PCBNCGFH@pos?$AA@
	DQ	FLAT:??_C@_06MJPHPKNA@endpos?$AA@
	DQ	0000000000000000H
?kwlist@?1??pattern_search@@9@9 DQ FLAT:??_C@_07CHFOACKJ@pattern?$AA@ ; `pattern_search'::`2'::kwlist
	DQ	FLAT:??_C@_03PCBNCGFH@pos?$AA@
	DQ	FLAT:??_C@_06MJPHPKNA@endpos?$AA@
	DQ	0000000000000000H
?kwlist@?1??pattern_findall@@9@9 DQ FLAT:??_C@_06OEKOLKIL@source?$AA@ ; `pattern_findall'::`2'::kwlist
	DQ	FLAT:??_C@_03PCBNCGFH@pos?$AA@
	DQ	FLAT:??_C@_06MJPHPKNA@endpos?$AA@
	DQ	0000000000000000H
?kwlist@?1??pattern_split@@9@9 DQ FLAT:??_C@_06OEKOLKIL@source?$AA@ ; `pattern_split'::`2'::kwlist
	DQ	FLAT:??_C@_08HONNCIIN@maxsplit?$AA@
	DQ	0000000000000000H
?kwlist@?1??pattern_sub@@9@9 DQ FLAT:??_C@_04CLIOPAIH@repl?$AA@ ; `pattern_sub'::`2'::kwlist
	DQ	FLAT:??_C@_06ICGJLFIM@string?$AA@
	DQ	FLAT:??_C@_05IOMEMJEC@count?$AA@
	DQ	0000000000000000H
?kwlist@?1??pattern_subn@@9@9 DQ FLAT:??_C@_04CLIOPAIH@repl?$AA@ ; `pattern_subn'::`2'::kwlist
	DQ	FLAT:??_C@_06ICGJLFIM@string?$AA@
	DQ	FLAT:??_C@_05IOMEMJEC@count?$AA@
	DQ	0000000000000000H
	ORG $+8
pattern_match_doc DB 'match(string[, pos[, endpos]]) -> match object or N'
	DB	'one.', 0aH, '    Matches zero or more characters at the begin'
	DB	'ning of the string', 00H
	ORG $+5
pattern_search_doc DB 'search(string[, pos[, endpos]]) -> match object or'
	DB	' None.', 0aH, '    Scan through string looking for a match, a'
	DB	'nd return a corresponding', 0aH, '    match object instance. '
	DB	'Return None if no position in the string matches.', 00H
	ORG $+2
pattern_split_doc DB 'split(string[, maxsplit = 0])  -> list.', 0aH, '   '
	DB	' Split string by the occurrences of pattern.', 00H
	ORG $+8
pattern_findall_doc DB 'findall(string[, pos[, endpos]]) -> list.', 0aH, ' '
	DB	'  Return a list of all non-overlapping matches of pattern in '
	DB	'string.', 00H
pattern_finditer_doc DB 'finditer(string[, pos[, endpos]]) -> iterator.', 0aH
	DB	'    Return an iterator over all non-overlapping matches for t'
	DB	'he ', 0aH, '    RE pattern in string. For each match, the ite'
	DB	'rator returns a', 0aH, '    match object.', 00H
	ORG $+13
pattern_sub_doc DB 'sub(repl, string[, count = 0]) -> newstring.', 0aH, ' '
	DB	'   Return the string obtained by replacing the leftmost non-o'
	DB	'verlapping', 0aH, '    occurrences of pattern in string by th'
	DB	'e replacement repl.', 00H
	ORG $+12
pattern_subn_doc DB 'subn(repl, string[, count = 0]) -> (newstring, numbe'
	DB	'r of subs)', 0aH, '    Return the tuple (new_string, number_o'
	DB	'f_subs_made) found by replacing', 0aH, '    the leftmost non-'
	DB	'overlapping occurrences of pattern with the', 0aH, '    repla'
	DB	'cement repl.', 00H
pattern_doc DB	'Compiled regular expression objects', 00H
	ORG $+12
pattern_methods DQ FLAT:??_C@_05FNONLPDI@match?$AA@
	DQ	FLAT:pattern_match
	DD	03H
	ORG $+4
	DQ	FLAT:pattern_match_doc
	DQ	FLAT:??_C@_06GFPLNGOC@search?$AA@
	DQ	FLAT:pattern_search
	DD	03H
	ORG $+4
	DQ	FLAT:pattern_search_doc
	DQ	FLAT:??_C@_03KCMAIMAP@sub?$AA@
	DQ	FLAT:pattern_sub
	DD	03H
	ORG $+4
	DQ	FLAT:pattern_sub_doc
	DQ	FLAT:??_C@_04GLGDJLDE@subn?$AA@
	DQ	FLAT:pattern_subn
	DD	03H
	ORG $+4
	DQ	FLAT:pattern_subn_doc
	DQ	FLAT:??_C@_05EHPMMFBK@split?$AA@
	DQ	FLAT:pattern_split
	DD	03H
	ORG $+4
	DQ	FLAT:pattern_split_doc
	DQ	FLAT:??_C@_07MHCELJLC@findall?$AA@
	DQ	FLAT:pattern_findall
	DD	03H
	ORG $+4
	DQ	FLAT:pattern_findall_doc
	DQ	FLAT:??_C@_08JCKNOCFD@finditer?$AA@
	DQ	FLAT:pattern_finditer
	DD	03H
	ORG $+4
	DQ	FLAT:pattern_finditer_doc
	DQ	FLAT:??_C@_07GPBKGHMB@scanner?$AA@
	DQ	FLAT:pattern_scanner
	DD	03H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_08MOMBEIKE@__copy__?$AA@
	DQ	FLAT:pattern_copy
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0N@LCDCNIJ@__deepcopy__?$AA@
	DQ	FLAT:pattern_deepcopy
	DD	08H
	ORG $+4
	ORG $+8
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
pattern_members DQ FLAT:??_C@_07CHFOACKJ@pattern?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000088H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_05GECEPKB@flags?$AA@
	DD	01H
	ORG $+4
	DQ	0000000000000090H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_06HNAIAMHH@groups?$AA@
	DD	013H
	ORG $+4
	DQ	0000000000000070H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0L@IAGOJEHI@groupindex?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000078H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
	ORG $+8
Pattern_Type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BB@FJKNOFPK@_sre?4SRE_Pattern?$AA@
	DQ	0000000000000110H
	DQ	0000000000000004H
	DQ	FLAT:pattern_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040000H
	ORG $+4
	DQ	FLAT:pattern_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000098H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:pattern_methods
	DQ	FLAT:pattern_members
	ORG $+144
?kwlist@?1??match_groups@@9@9 DQ FLAT:??_C@_07DLHCIBDH@default?$AA@ ; `match_groups'::`2'::kwlist
	DQ	0000000000000000H
?kwlist@?1??match_groupdict@@9@9 DQ FLAT:??_C@_07DLHCIBDH@default?$AA@ ; `match_groupdict'::`2'::kwlist
	DQ	0000000000000000H
match_doc DB	'The result of re.match() and re.search().', 0aH, 'Match '
	DB	'objects always have a boolean value of True.', 00H
	ORG $+3
match_group_doc DB 'group([group1, ...]) -> str or tuple.', 0aH, '    Ret'
	DB	'urn subgroup(s) of the match by indices or names.', 0aH, '   '
	DB	' For 0 returns the entire match.', 00H
	ORG $+13
match_start_doc DB 'start([group=0]) -> int.', 0aH, '    Return index of '
	DB	'the start of the substring matched by group.', 00H
	ORG $+6
match_end_doc DB 'end([group=0]) -> int.', 0aH, '    Return index of the '
	DB	'end of the substring matched by group.', 00H
	ORG $+10
match_span_doc DB 'span([group]) -> tuple.', 0aH, '    For MatchObject m,'
	DB	' return the 2-tuple (m.start(group), m.end(group)).', 00H
	ORG $+14
match_groups_doc DB 'groups([default=None]) -> tuple.', 0aH, '    Return '
	DB	'a tuple containing all the subgroups of the match, from 1.', 0aH
	DB	'    The default argument is used for groups', 0aH, '    that '
	DB	'did not participate in the match', 00H
	ORG $+3
match_groupdict_doc DB 'groupdict([default=None]) -> dict.', 0aH, '    Re'
	DB	'turn a dictionary containing all the named subgroups of the m'
	DB	'atch,', 0aH, '    keyed by the subgroup name. The default arg'
	DB	'ument is used for groups', 0aH, '    that did not participate'
	DB	' in the match', 00H
	ORG $+2
match_expand_doc DB 'expand(template) -> str.', 0aH, '    Return the stri'
	DB	'ng obtained by doing backslash substitution', 0aH, '    on th'
	DB	'e string template, as done by the sub() method.', 00H
	ORG $+15
match_methods DQ FLAT:??_C@_05MGJOOGAJ@group?$AA@
	DQ	FLAT:match_group
	DD	01H
	ORG $+4
	DQ	FLAT:match_group_doc
	DQ	FLAT:??_C@_05FAGFPHJG@start?$AA@
	DQ	FLAT:match_start
	DD	01H
	ORG $+4
	DQ	FLAT:match_start_doc
	DQ	FLAT:??_C@_03JBJLGPFL@end?$AA@
	DQ	FLAT:match_end
	DD	01H
	ORG $+4
	DQ	FLAT:match_end_doc
	DQ	FLAT:??_C@_04FOPLNFFP@span?$AA@
	DQ	FLAT:match_span
	DD	01H
	ORG $+4
	DQ	FLAT:match_span_doc
	DQ	FLAT:??_C@_06HNAIAMHH@groups?$AA@
	DQ	FLAT:match_groups
	DD	03H
	ORG $+4
	DQ	FLAT:match_groups_doc
	DQ	FLAT:??_C@_09GGPMIDAG@groupdict?$AA@
	DQ	FLAT:match_groupdict
	DD	03H
	ORG $+4
	DQ	FLAT:match_groupdict_doc
	DQ	FLAT:??_C@_06GFPMPEEP@expand?$AA@
	DQ	FLAT:match_expand
	DD	08H
	ORG $+4
	DQ	FLAT:match_expand_doc
	DQ	FLAT:??_C@_08MOMBEIKE@__copy__?$AA@
	DQ	FLAT:match_copy
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0N@LCDCNIJ@__deepcopy__?$AA@
	DQ	FLAT:match_deepcopy
	DD	08H
	ORG $+4
	ORG $+8
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
match_getset DQ	FLAT:??_C@_09LCAJIJAE@lastindex?$AA@
	DQ	FLAT:match_lastindex_get
	DQ	0000000000000000H
	ORG $+16
	DQ	FLAT:??_C@_09COONDMIO@lastgroup?$AA@
	DQ	FLAT:match_lastgroup_get
	DQ	0000000000000000H
	ORG $+16
	DQ	FLAT:??_C@_04PPLNELOM@regs?$AA@
	DQ	FLAT:match_regs_get
	DQ	0000000000000000H
	ORG $+16
	DQ	0000000000000000H
	ORG $+32
match_members DQ FLAT:??_C@_06ICGJLFIM@string?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000070H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_02EPEBAFDB@re?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000080H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_03PCBNCGFH@pos?$AA@
	DD	013H
	ORG $+4
	DQ	0000000000000088H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_06MJPHPKNA@endpos?$AA@
	DD	013H
	ORG $+4
	DQ	0000000000000090H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
	ORG $+8
Match_Type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0P@HEJLNOBB@_sre?4SRE_Match?$AA@
	DQ	00000000000000b0H
	DQ	0000000000000008H
	DQ	FLAT:match_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040000H
	ORG $+4
	DQ	FLAT:match_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:match_methods
	DQ	FLAT:match_members
	DQ	FLAT:match_getset
	ORG $+136
scanner_methods DQ FLAT:??_C@_05FNONLPDI@match?$AA@
	DQ	FLAT:scanner_match
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_06GFPLNGOC@search?$AA@
	DQ	FLAT:scanner_search
	DD	04H
	ORG $+4
	ORG $+8
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
scanner_members DQ FLAT:??_C@_07CHFOACKJ@pattern?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000060H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
Scanner_Type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BB@BBOJIAJC@_sre?4SRE_Scanner?$AA@
	DQ	0000000000000770H
	DQ	0000000000000000H
	DQ	FLAT:scanner_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040000H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:scanner_methods
	DQ	FLAT:scanner_members
	DQ	0000000000000000H
	ORG $+136
?kwlist@?1??pattern_scanner@@9@9 DQ FLAT:??_C@_06OEKOLKIL@source?$AA@ ; `pattern_scanner'::`2'::kwlist
	DQ	FLAT:??_C@_03PCBNCGFH@pos?$AA@
	DQ	FLAT:??_C@_06MJPHPKNA@endpos?$AA@
	DQ	0000000000000000H
_functions DQ	FLAT:??_C@_07OLJGFCKG@compile?$AA@
	DQ	FLAT:_compile
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0M@PEJEAKBE@getcodesize?$AA@
	DQ	FLAT:sre_codesize
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_08GAHBPIPM@getlower?$AA@
	DQ	FLAT:sre_getlower
	DD	01H
	ORG $+4
	ORG $+8
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
sremodule DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_04LFOLHMFG@_sre?$AA@
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	FLAT:_functions
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
EXTRN	PyObject_Init:PROC
EXTRN	PyObject_Malloc:PROC
EXTRN	_PxObject_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\objimpl.h
pdata	SEGMENT
$pdata$_PyObject_NEW DD imagerel _PyObject_NEW
	DD	imagerel _PyObject_NEW+56
	DD	imagerel $unwind$_PyObject_NEW
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_NEW DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyObject_NEW
_TEXT	SEGMENT
tp$ = 48
_PyObject_NEW PROC					; COMDAT

; 293  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 294  :     Px_RETURN(_PxObject_New(tp))

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 0d		 je	 SHORT $LN1@PyObject_N
  00012	48 8b cb	 mov	 rcx, rbx

; 296  : }

  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5b		 pop	 rbx
  0001a	e9 00 00 00 00	 jmp	 _PxObject_New
$LN1@PyObject_N:

; 295  :     return PyObject_Init((PyObject *)PyObject_MALLOC(_PyObject_SIZE(tp)), tp);

  0001f	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  00023	e8 00 00 00 00	 call	 PyObject_Malloc
  00028	48 8b d3	 mov	 rdx, rbx
  0002b	48 8b c8	 mov	 rcx, rax

; 296  : }

  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5b		 pop	 rbx
  00033	e9 00 00 00 00	 jmp	 PyObject_Init
_PyObject_NEW ENDP
_TEXT	ENDS
EXTRN	PyObject_InitVar:PROC
EXTRN	_PxObject_NewVar:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_NEW_VAR DD imagerel _PyObject_NEW_VAR
	DD	imagerel _PyObject_NEW_VAR+99
	DD	imagerel $unwind$_PyObject_NEW_VAR
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_NEW_VAR DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyObject_NEW_VAR
_TEXT	SEGMENT
tp$ = 48
n$ = 56
_PyObject_NEW_VAR PROC					; COMDAT

; 301  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 302  :     register PyObject *op;
; 303  :     Px_RETURN(_PxObject_NewVar(tp, n))

  00010	e8 00 00 00 00	 call	 _Py_PXCTX
  00015	85 c0		 test	 eax, eax
  00017	74 15		 je	 SHORT $LN1@PyObject_N@2
  00019	48 8b d7	 mov	 rdx, rdi
  0001c	48 8b cb	 mov	 rcx, rbx

; 306  : }

  0001f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00024	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00028	5f		 pop	 rdi
  00029	e9 00 00 00 00	 jmp	 _PxObject_NewVar
$LN1@PyObject_N@2:

; 304  :     op = (PyObject *)PyObject_MALLOC(_PyObject_VAR_SIZE(tp, n));

  0002e	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  00035	48 8b 43 78	 mov	 rax, QWORD PTR [rbx+120]
  00039	48 0f af cf	 imul	 rcx, rdi
  0003d	48 8d 4c 01 07	 lea	 rcx, QWORD PTR [rcx+rax+7]
  00042	48 83 e1 f8	 and	 rcx, -8
  00046	e8 00 00 00 00	 call	 PyObject_Malloc

; 305  :     return (PyVarObject *)PyObject_InitVar((PyVarObject*)op, tp, n);

  0004b	4c 8b c7	 mov	 r8, rdi
  0004e	48 8b d3	 mov	 rdx, rbx
  00051	48 8b c8	 mov	 rcx, rax

; 306  : }

  00054	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00059	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005d	5f		 pop	 rdi
  0005e	e9 00 00 00 00	 jmp	 PyObject_InitVar
_PyObject_NEW_VAR ENDP
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_sre.c
_TEXT	ENDS
;	COMDAT sre_lower
_TEXT	SEGMENT
ch$ = 8
sre_lower PROC						; COMDAT

; 147  :     return ((ch) < 128 ? (unsigned int)sre_char_lower[ch] : ch);

  00000	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  00006	73 0e		 jae	 SHORT $LN3@sre_lower
  00008	8b c1		 mov	 eax, ecx
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sre_char_lower
  00011	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]

; 148  : }

  00015	c3		 ret	 0
$LN3@sre_lower:

; 147  :     return ((ch) < 128 ? (unsigned int)sre_char_lower[ch] : ch);

  00016	8b c1		 mov	 eax, ecx

; 148  : }

  00018	c3		 ret	 0
sre_lower ENDP
_TEXT	ENDS
EXTRN	__imp_tolower:PROC
; Function compile flags: /Ogtpy
;	COMDAT sre_lower_locale
_TEXT	SEGMENT
ch$ = 8
sre_lower_locale PROC					; COMDAT

; 161  :     return ((ch) < 256 ? (unsigned int)tolower((ch)) : ch);

  00000	81 f9 00 01 00
	00		 cmp	 ecx, 256		; 00000100H
  00006	73 07		 jae	 SHORT $LN3@sre_lower_

; 162  : }

  00008	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_tolower
$LN3@sre_lower_:

; 161  :     return ((ch) < 256 ? (unsigned int)tolower((ch)) : ch);

  0000f	8b c1		 mov	 eax, ecx

; 162  : }

  00011	c3		 ret	 0
sre_lower_locale ENDP
_TEXT	ENDS
EXTRN	_PyUnicode_ToLowercase:PROC
; Function compile flags: /Ogtpy
;	COMDAT sre_lower_unicode
_TEXT	SEGMENT
ch$ = 8
sre_lower_unicode PROC					; COMDAT

; 174  :     return (unsigned int) Py_UNICODE_TOLOWER(ch);
; 175  : }

  00000	e9 00 00 00 00	 jmp	 _PyUnicode_ToLowercase
sre_lower_unicode ENDP
_TEXT	ENDS
EXTRN	_PyUnicode_IsLinebreak:PROC
EXTRN	_PyUnicode_IsNumeric:PROC
EXTRN	_PyUnicode_IsDigit:PROC
EXTRN	_PyUnicode_IsAlpha:PROC
EXTRN	_PyUnicode_IsWhitespace:PROC
EXTRN	_Py_ascii_whitespace:BYTE
EXTRN	_PyUnicode_IsDecimalDigit:PROC
EXTRN	__imp_isalnum:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$sre_category DD imagerel sre_category
	DD	imagerel sre_category+760
	DD	imagerel $unwind$sre_category
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sre_category DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT sre_category
_TEXT	SEGMENT
category$ = 48
ch$ = 56
sre_category PROC					; COMDAT

; 179  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	8b da		 mov	 ebx, edx

; 180  :     switch (category) {

  00008	83 f9 11	 cmp	 ecx, 17
  0000b	0f 87 95 02 00
	00		 ja	 $LN19@sre_catego
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00018	8b c1		 mov	 eax, ecx
  0001a	8b 84 82 00 00
	00 00		 mov	 eax, DWORD PTR $LN57@sre_catego[rdx+rax*4]
  00021	48 03 c2	 add	 rax, rdx
  00024	ff e0		 jmp	 rax
$LN18@sre_catego:

; 181  : 
; 182  :     case SRE_CATEGORY_DIGIT:
; 183  :         return SRE_IS_DIGIT(ch);

  00026	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  0002c	73 13		 jae	 SHORT $LN23@sre_catego
  0002e	0f be 8c 13 00
	00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rbx+rdx]
  00036	83 e1 01	 and	 ecx, 1
  00039	8b c1		 mov	 eax, ecx

; 222  : }

  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5b		 pop	 rbx
  00040	c3		 ret	 0
$LN23@sre_catego:

; 181  : 
; 182  :     case SRE_CATEGORY_DIGIT:
; 183  :         return SRE_IS_DIGIT(ch);

  00041	33 c9		 xor	 ecx, ecx
  00043	8b c1		 mov	 eax, ecx

; 222  : }

  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5b		 pop	 rbx
  0004a	c3		 ret	 0
$LN17@sre_catego:

; 184  :     case SRE_CATEGORY_NOT_DIGIT:
; 185  :         return !SRE_IS_DIGIT(ch);

  0004b	33 c9		 xor	 ecx, ecx
  0004d	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  00053	73 18		 jae	 SHORT $LN25@sre_catego
  00055	0f be 94 13 00
	00 00 00	 movsx	 edx, BYTE PTR sre_char_info[rbx+rdx]
  0005d	83 e2 01	 and	 edx, 1
  00060	85 d2		 test	 edx, edx
  00062	0f 94 c1	 sete	 cl
  00065	8b c1		 mov	 eax, ecx

; 222  : }

  00067	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006b	5b		 pop	 rbx
  0006c	c3		 ret	 0
$LN25@sre_catego:

; 184  :     case SRE_CATEGORY_NOT_DIGIT:
; 185  :         return !SRE_IS_DIGIT(ch);

  0006d	85 c9		 test	 ecx, ecx
  0006f	8b d1		 mov	 edx, ecx
  00071	0f 94 c1	 sete	 cl
  00074	8b c1		 mov	 eax, ecx

; 222  : }

  00076	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007a	5b		 pop	 rbx
  0007b	c3		 ret	 0
$LN16@sre_catego:

; 186  :     case SRE_CATEGORY_SPACE:
; 187  :         return SRE_IS_SPACE(ch);

  0007c	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  00082	73 bd		 jae	 SHORT $LN23@sre_catego
  00084	0f be 8c 13 00
	00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rbx+rdx]
  0008c	83 e1 02	 and	 ecx, 2
  0008f	8b c1		 mov	 eax, ecx

; 222  : }

  00091	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00095	5b		 pop	 rbx
  00096	c3		 ret	 0
$LN15@sre_catego:

; 188  :     case SRE_CATEGORY_NOT_SPACE:
; 189  :         return !SRE_IS_SPACE(ch);

  00097	33 c9		 xor	 ecx, ecx
  00099	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  0009f	73 cc		 jae	 SHORT $LN25@sre_catego
  000a1	0f be 94 13 00
	00 00 00	 movsx	 edx, BYTE PTR sre_char_info[rbx+rdx]
  000a9	83 e2 02	 and	 edx, 2
  000ac	85 d2		 test	 edx, edx
  000ae	0f 94 c1	 sete	 cl
  000b1	8b c1		 mov	 eax, ecx

; 222  : }

  000b3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b7	5b		 pop	 rbx
  000b8	c3		 ret	 0
$LN14@sre_catego:

; 190  :     case SRE_CATEGORY_WORD:
; 191  :         return SRE_IS_WORD(ch);

  000b9	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  000bf	73 80		 jae	 SHORT $LN23@sre_catego
  000c1	0f be 8c 13 00
	00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rbx+rdx]
  000c9	83 e1 10	 and	 ecx, 16
  000cc	8b c1		 mov	 eax, ecx

; 222  : }

  000ce	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d2	5b		 pop	 rbx
  000d3	c3		 ret	 0
$LN13@sre_catego:

; 192  :     case SRE_CATEGORY_NOT_WORD:
; 193  :         return !SRE_IS_WORD(ch);

  000d4	33 c9		 xor	 ecx, ecx
  000d6	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  000dc	73 8f		 jae	 SHORT $LN25@sre_catego
  000de	0f be 94 13 00
	00 00 00	 movsx	 edx, BYTE PTR sre_char_info[rbx+rdx]
  000e6	83 e2 10	 and	 edx, 16
  000e9	85 d2		 test	 edx, edx
  000eb	0f 94 c1	 sete	 cl
  000ee	8b c1		 mov	 eax, ecx

; 222  : }

  000f0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f4	5b		 pop	 rbx
  000f5	c3		 ret	 0
$LN12@sre_catego:

; 194  :     case SRE_CATEGORY_LINEBREAK:
; 195  :         return SRE_IS_LINEBREAK(ch);

  000f6	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  000fc	0f 83 3f ff ff
	ff		 jae	 $LN23@sre_catego
  00102	0f be 8c 13 00
	00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rbx+rdx]
  0010a	83 e1 04	 and	 ecx, 4
  0010d	8b c1		 mov	 eax, ecx

; 222  : }

  0010f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00113	5b		 pop	 rbx
  00114	c3		 ret	 0
$LN11@sre_catego:

; 196  :     case SRE_CATEGORY_NOT_LINEBREAK:
; 197  :         return !SRE_IS_LINEBREAK(ch);

  00115	33 c9		 xor	 ecx, ecx
  00117	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  0011d	0f 83 4a ff ff
	ff		 jae	 $LN25@sre_catego
  00123	0f be 94 13 00
	00 00 00	 movsx	 edx, BYTE PTR sre_char_info[rbx+rdx]
  0012b	83 e2 04	 and	 edx, 4
  0012e	85 d2		 test	 edx, edx
  00130	0f 94 c1	 sete	 cl
  00133	8b c1		 mov	 eax, ecx

; 222  : }

  00135	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00139	5b		 pop	 rbx
  0013a	c3		 ret	 0
$LN10@sre_catego:

; 198  : 
; 199  :     case SRE_CATEGORY_LOC_WORD:
; 200  :         return SRE_LOC_IS_WORD(ch);

  0013b	f7 c3 00 ff ff
	ff		 test	 ebx, -256		; ffffff00H
  00141	75 0c		 jne	 SHORT $LN55@sre_catego
  00143	8b cb		 mov	 ecx, ebx
  00145	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalnum
$LN59@sre_catego:
  0014b	85 c0		 test	 eax, eax
  0014d	75 0f		 jne	 SHORT $LN41@sre_catego
$LN55@sre_catego:
  0014f	83 fb 5f	 cmp	 ebx, 95			; 0000005fH
  00152	74 0a		 je	 SHORT $LN41@sre_catego
  00154	33 c9		 xor	 ecx, ecx
  00156	8b c1		 mov	 eax, ecx

; 222  : }

  00158	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0015c	5b		 pop	 rbx
  0015d	c3		 ret	 0
$LN41@sre_catego:

; 198  : 
; 199  :     case SRE_CATEGORY_LOC_WORD:
; 200  :         return SRE_LOC_IS_WORD(ch);

  0015e	b9 01 00 00 00	 mov	 ecx, 1
  00163	8b c1		 mov	 eax, ecx

; 222  : }

  00165	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00169	5b		 pop	 rbx
  0016a	c3		 ret	 0
$LN9@sre_catego:

; 201  :     case SRE_CATEGORY_LOC_NOT_WORD:
; 202  :         return !SRE_LOC_IS_WORD(ch);

  0016b	f7 c3 00 ff ff
	ff		 test	 ebx, -256		; ffffff00H
  00171	75 10		 jne	 SHORT $LN56@sre_catego
  00173	8b cb		 mov	 ecx, ebx
  00175	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalnum
$LN58@sre_catego:
  0017b	85 c0		 test	 eax, eax
  0017d	0f 85 be fe ff
	ff		 jne	 $LN23@sre_catego
$LN56@sre_catego:
  00183	83 fb 5f	 cmp	 ebx, 95			; 0000005fH
  00186	0f 84 b5 fe ff
	ff		 je	 $LN23@sre_catego
  0018c	b9 01 00 00 00	 mov	 ecx, 1

; 181  : 
; 182  :     case SRE_CATEGORY_DIGIT:
; 183  :         return SRE_IS_DIGIT(ch);

  00191	8b c1		 mov	 eax, ecx

; 222  : }

  00193	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00197	5b		 pop	 rbx
  00198	c3		 ret	 0
$LN8@sre_catego:

; 203  : 
; 204  :     case SRE_CATEGORY_UNI_DIGIT:
; 205  :         return SRE_UNI_IS_DIGIT(ch);

  00199	8b cb		 mov	 ecx, ebx

; 222  : }

  0019b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0019f	5b		 pop	 rbx
  001a0	e9 00 00 00 00	 jmp	 _PyUnicode_IsDecimalDigit
$LN7@sre_catego:

; 206  :     case SRE_CATEGORY_UNI_NOT_DIGIT:
; 207  :         return !SRE_UNI_IS_DIGIT(ch);

  001a5	8b cb		 mov	 ecx, ebx
  001a7	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  001ac	33 c9		 xor	 ecx, ecx
  001ae	85 c0		 test	 eax, eax
  001b0	0f 94 c1	 sete	 cl
  001b3	8b c1		 mov	 eax, ecx

; 222  : }

  001b5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001b9	5b		 pop	 rbx
  001ba	c3		 ret	 0
$LN6@sre_catego:

; 208  :     case SRE_CATEGORY_UNI_SPACE:
; 209  :         return SRE_UNI_IS_SPACE(ch);

  001bb	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  001c1	73 0e		 jae	 SHORT $LN47@sre_catego
  001c3	0f b6 84 13 00
	00 00 00	 movzx	 eax, BYTE PTR _Py_ascii_whitespace[rbx+rdx]

; 222  : }

  001cb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001cf	5b		 pop	 rbx
  001d0	c3		 ret	 0
$LN47@sre_catego:

; 208  :     case SRE_CATEGORY_UNI_SPACE:
; 209  :         return SRE_UNI_IS_SPACE(ch);

  001d1	8b cb		 mov	 ecx, ebx

; 222  : }

  001d3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001d7	5b		 pop	 rbx
  001d8	e9 00 00 00 00	 jmp	 _PyUnicode_IsWhitespace
$LN5@sre_catego:

; 210  :     case SRE_CATEGORY_UNI_NOT_SPACE:
; 211  :         return !SRE_UNI_IS_SPACE(ch);

  001dd	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  001e3	73 17		 jae	 SHORT $LN49@sre_catego
  001e5	0f b6 84 13 00
	00 00 00	 movzx	 eax, BYTE PTR _Py_ascii_whitespace[rbx+rdx]
  001ed	33 c9		 xor	 ecx, ecx
  001ef	85 c0		 test	 eax, eax
  001f1	0f 94 c1	 sete	 cl
  001f4	8b c1		 mov	 eax, ecx

; 222  : }

  001f6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001fa	5b		 pop	 rbx
  001fb	c3		 ret	 0
$LN49@sre_catego:

; 210  :     case SRE_CATEGORY_UNI_NOT_SPACE:
; 211  :         return !SRE_UNI_IS_SPACE(ch);

  001fc	8b cb		 mov	 ecx, ebx
  001fe	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
  00203	33 c9		 xor	 ecx, ecx
  00205	85 c0		 test	 eax, eax
  00207	0f 94 c1	 sete	 cl
  0020a	8b c1		 mov	 eax, ecx

; 222  : }

  0020c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00210	5b		 pop	 rbx
  00211	c3		 ret	 0
$LN4@sre_catego:

; 212  :     case SRE_CATEGORY_UNI_WORD:
; 213  :         return SRE_UNI_IS_WORD(ch);

  00212	8b cb		 mov	 ecx, ebx
  00214	e8 00 00 00 00	 call	 _PyUnicode_IsAlpha
  00219	85 c0		 test	 eax, eax
  0021b	0f 85 3d ff ff
	ff		 jne	 $LN41@sre_catego
  00221	8b cb		 mov	 ecx, ebx
  00223	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  00228	85 c0		 test	 eax, eax
  0022a	0f 85 2e ff ff
	ff		 jne	 $LN41@sre_catego
  00230	8b cb		 mov	 ecx, ebx
  00232	e8 00 00 00 00	 call	 _PyUnicode_IsDigit
  00237	85 c0		 test	 eax, eax
  00239	0f 85 1f ff ff
	ff		 jne	 $LN41@sre_catego
  0023f	8b cb		 mov	 ecx, ebx
  00241	e8 00 00 00 00	 call	 _PyUnicode_IsNumeric
  00246	e9 00 ff ff ff	 jmp	 $LN59@sre_catego
$LN3@sre_catego:

; 214  :     case SRE_CATEGORY_UNI_NOT_WORD:
; 215  :         return !SRE_UNI_IS_WORD(ch);

  0024b	8b cb		 mov	 ecx, ebx
  0024d	e8 00 00 00 00	 call	 _PyUnicode_IsAlpha
  00252	85 c0		 test	 eax, eax
  00254	0f 85 e7 fd ff
	ff		 jne	 $LN23@sre_catego
  0025a	8b cb		 mov	 ecx, ebx
  0025c	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  00261	85 c0		 test	 eax, eax
  00263	0f 85 d8 fd ff
	ff		 jne	 $LN23@sre_catego
  00269	8b cb		 mov	 ecx, ebx
  0026b	e8 00 00 00 00	 call	 _PyUnicode_IsDigit
  00270	85 c0		 test	 eax, eax
  00272	0f 85 c9 fd ff
	ff		 jne	 $LN23@sre_catego
  00278	8b cb		 mov	 ecx, ebx
  0027a	e8 00 00 00 00	 call	 _PyUnicode_IsNumeric
  0027f	e9 f7 fe ff ff	 jmp	 $LN58@sre_catego
$LN2@sre_catego:

; 216  :     case SRE_CATEGORY_UNI_LINEBREAK:
; 217  :         return SRE_UNI_IS_LINEBREAK(ch);

  00284	8b cb		 mov	 ecx, ebx

; 222  : }

  00286	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0028a	5b		 pop	 rbx
  0028b	e9 00 00 00 00	 jmp	 _PyUnicode_IsLinebreak
$LN1@sre_catego:

; 218  :     case SRE_CATEGORY_UNI_NOT_LINEBREAK:
; 219  :         return !SRE_UNI_IS_LINEBREAK(ch);

  00290	8b cb		 mov	 ecx, ebx
  00292	e8 00 00 00 00	 call	 _PyUnicode_IsLinebreak
  00297	33 c9		 xor	 ecx, ecx
  00299	85 c0		 test	 eax, eax
  0029b	0f 94 c1	 sete	 cl
  0029e	8b c1		 mov	 eax, ecx

; 222  : }

  002a0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002a4	5b		 pop	 rbx
  002a5	c3		 ret	 0
$LN19@sre_catego:

; 220  :     }
; 221  :     return 0;

  002a6	33 c0		 xor	 eax, eax

; 222  : }

  002a8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002ac	5b		 pop	 rbx
  002ad	c3		 ret	 0
  002ae	66 90		 npad	 2
$LN57@sre_catego:
  002b0	00 00 00 00	 DD	 $LN18@sre_catego
  002b4	00 00 00 00	 DD	 $LN17@sre_catego
  002b8	00 00 00 00	 DD	 $LN16@sre_catego
  002bc	00 00 00 00	 DD	 $LN15@sre_catego
  002c0	00 00 00 00	 DD	 $LN14@sre_catego
  002c4	00 00 00 00	 DD	 $LN13@sre_catego
  002c8	00 00 00 00	 DD	 $LN12@sre_catego
  002cc	00 00 00 00	 DD	 $LN11@sre_catego
  002d0	00 00 00 00	 DD	 $LN10@sre_catego
  002d4	00 00 00 00	 DD	 $LN9@sre_catego
  002d8	00 00 00 00	 DD	 $LN8@sre_catego
  002dc	00 00 00 00	 DD	 $LN7@sre_catego
  002e0	00 00 00 00	 DD	 $LN6@sre_catego
  002e4	00 00 00 00	 DD	 $LN5@sre_catego
  002e8	00 00 00 00	 DD	 $LN4@sre_catego
  002ec	00 00 00 00	 DD	 $LN3@sre_catego
  002f0	00 00 00 00	 DD	 $LN2@sre_catego
  002f4	00 00 00 00	 DD	 $LN1@sre_catego
sre_category ENDP
_TEXT	ENDS
EXTRN	__imp_free:PROC
EXTRN	_PxMem_Free:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$data_stack_dealloc DD imagerel data_stack_dealloc
	DD	imagerel data_stack_dealloc+99
	DD	imagerel $unwind$data_stack_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$data_stack_dealloc DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT data_stack_dealloc
_TEXT	SEGMENT
state$ = 48
data_stack_dealloc PROC					; COMDAT

; 228  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 229  :     if (state->data_stack) {

  00006	48 83 b9 90 06
	00 00 00	 cmp	 QWORD PTR [rcx+1680], 0
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	74 3a		 je	 SHORT $LN6@data_stack

; 230  :         PyMem_FREE(state->data_stack);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	48 8b 8b 90 06
	00 00		 mov	 rcx, QWORD PTR [rbx+1680]
  0001f	85 c0		 test	 eax, eax
  00021	74 07		 je	 SHORT $LN4@data_stack
  00023	e8 00 00 00 00	 call	 _PxMem_Free
  00028	eb 06		 jmp	 SHORT $LN5@data_stack
$LN4@data_stack:
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@data_stack:

; 231  :         state->data_stack = NULL;

  00030	33 c0		 xor	 eax, eax
  00032	48 89 83 90 06
	00 00		 mov	 QWORD PTR [rbx+1680], rax

; 232  :     }
; 233  :     state->data_stack_size = state->data_stack_base = 0;

  00039	48 89 83 a0 06
	00 00		 mov	 QWORD PTR [rbx+1696], rax
  00040	48 89 83 98 06
	00 00		 mov	 QWORD PTR [rbx+1688], rax

; 234  : }

  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5b		 pop	 rbx
  0004c	c3		 ret	 0
$LN6@data_stack:

; 232  :     }
; 233  :     state->data_stack_size = state->data_stack_base = 0;

  0004d	33 c0		 xor	 eax, eax
  0004f	48 89 81 a0 06
	00 00		 mov	 QWORD PTR [rcx+1696], rax
  00056	48 89 81 98 06
	00 00		 mov	 QWORD PTR [rcx+1688], rax

; 234  : }

  0005d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00061	5b		 pop	 rbx
  00062	c3		 ret	 0
data_stack_dealloc ENDP
_TEXT	ENDS
EXTRN	__imp_realloc:PROC
EXTRN	_PxMem_Realloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$data_stack_grow DD imagerel data_stack_grow
	DD	imagerel data_stack_grow+178
	DD	imagerel $unwind$data_stack_grow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$data_stack_grow DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT data_stack_grow
_TEXT	SEGMENT
state$ = 48
size$ = 56
data_stack_grow PROC					; COMDAT

; 238  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 239  :     Py_ssize_t minsize, cursize;
; 240  :     minsize = state->data_stack_base+size;

  0000a	48 8b 81 a0 06
	00 00		 mov	 rax, QWORD PTR [rcx+1696]
  00011	48 8b d9	 mov	 rbx, rcx
  00014	48 8d 0c 02	 lea	 rcx, QWORD PTR [rdx+rax]

; 241  :     cursize = state->data_stack_size;
; 242  :     if (cursize < minsize) {

  00018	48 39 8b 98 06
	00 00		 cmp	 QWORD PTR [rbx+1688], rcx
  0001f	7d 6c		 jge	 SHORT $LN2@data_stack@2

; 243  :         void* stack;
; 244  :         cursize = minsize+minsize/4+1024;

  00021	48 8b c1	 mov	 rax, rcx
  00024	48 99		 cdq
  00026	83 e2 03	 and	 edx, 3
  00029	48 03 c2	 add	 rax, rdx
  0002c	48 c1 f8 02	 sar	 rax, 2
  00030	48 8d bc 08 00
	04 00 00	 lea	 rdi, QWORD PTR [rax+rcx+1024]

; 245  :         TRACE(("allocate/grow stack %" PY_FORMAT_SIZE_T "d\n", cursize));
; 246  :         stack = PyMem_REALLOC(state->data_stack, cursize);

  00038	e8 00 00 00 00	 call	 _Py_PXCTX
  0003d	85 c0		 test	 eax, eax
  0003f	74 11		 je	 SHORT $LN7@data_stack@2
  00041	48 8b 8b 90 06
	00 00		 mov	 rcx, QWORD PTR [rbx+1680]
  00048	48 8b d7	 mov	 rdx, rdi
  0004b	e8 00 00 00 00	 call	 _PxMem_Realloc
  00050	eb 28		 jmp	 SHORT $LN6@data_stack@2
$LN7@data_stack@2:
  00052	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0005c	48 3b f8	 cmp	 rdi, rax
  0005f	77 39		 ja	 SHORT $LN9@data_stack@2
  00061	48 8b 8b 90 06
	00 00		 mov	 rcx, QWORD PTR [rbx+1680]
  00068	48 85 ff	 test	 rdi, rdi
  0006b	ba 01 00 00 00	 mov	 edx, 1
  00070	48 0f 45 d7	 cmovne	 rdx, rdi
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
$LN6@data_stack@2:

; 247  :         if (!stack) {

  0007a	48 85 c0	 test	 rax, rax
  0007d	74 1b		 je	 SHORT $LN9@data_stack@2

; 249  :             return SRE_ERROR_MEMORY;
; 250  :         }
; 251  :         state->data_stack = (char *)stack;

  0007f	48 89 83 90 06
	00 00		 mov	 QWORD PTR [rbx+1680], rax

; 252  :         state->data_stack_size = cursize;

  00086	48 89 bb 98 06
	00 00		 mov	 QWORD PTR [rbx+1688], rdi
$LN2@data_stack@2:

; 253  :     }
; 254  :     return 0;

  0008d	33 c0		 xor	 eax, eax

; 255  : }

  0008f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00094	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00098	5f		 pop	 rdi
  00099	c3		 ret	 0
$LN9@data_stack@2:

; 248  :             data_stack_dealloc(state);

  0009a	48 8b cb	 mov	 rcx, rbx
  0009d	e8 00 00 00 00	 call	 data_stack_dealloc

; 255  : }

  000a2	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a7	b8 f7 ff ff ff	 mov	 eax, -9
  000ac	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b0	5f		 pop	 rdi
  000b1	c3		 ret	 0
data_stack_grow ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sre_at DD imagerel sre_at
	DD	imagerel sre_at+1096
	DD	imagerel $unwind$sre_at
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sre_at DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT sre_at
_TEXT	SEGMENT
state$ = 48
ptr$ = 56
at$ = 64
sre_at	PROC						; COMDAT

; 308  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001a	48 8b fa	 mov	 rdi, rdx
  0001d	48 8b e9	 mov	 rbp, rcx

; 309  :     /* check if pointer is at given position */
; 310  : 
; 311  :     Py_ssize_t thisp, thatp;
; 312  : 
; 313  :     switch (at) {

  00020	41 83 f8 0b	 cmp	 r8d, 11
  00024	0f 87 d0 03 00
	00		 ja	 $LN18@sre_at
  0002a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:__ImageBase
  00031	41 8b c0	 mov	 eax, r8d
  00034	41 8b 84 81 00
	00 00 00	 mov	 eax, DWORD PTR $LN97@sre_at[r9+rax*4]
  0003c	49 03 c1	 add	 rax, r9
  0003f	ff e0		 jmp	 rax
$LN17@sre_at:

; 314  : 
; 315  :     case SRE_AT_BEGINNING:
; 316  :     case SRE_AT_BEGINNING_STRING:
; 317  :         return ((void*) ptr == state->beginning);

  00041	33 db		 xor	 ebx, ebx
  00043	48 3b 51 08	 cmp	 rdx, QWORD PTR [rcx+8]
  00047	0f 94 c3	 sete	 bl
  0004a	8b c3		 mov	 eax, ebx
  0004c	e9 ab 03 00 00	 jmp	 $LN20@sre_at
$LN16@sre_at:

; 318  : 
; 319  :     case SRE_AT_BEGINNING_LINE:
; 320  :         return ((void*) ptr == state->beginning ||
; 321  :                 SRE_IS_LINEBREAK((int) SRE_CHARGET(state, ptr, -1)));

  00051	48 3b 51 08	 cmp	 rdx, QWORD PTR [rcx+8]
  00055	74 19		 je	 SHORT $LN24@sre_at
  00057	0f b6 42 ff	 movzx	 eax, BYTE PTR [rdx-1]
  0005b	3c 80		 cmp	 al, 128			; 00000080H
  0005d	73 4a		 jae	 SHORT $LN91@sre_at
  0005f	0f b6 c0	 movzx	 eax, al
  00062	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  0006b	83 e1 04	 and	 ecx, 4
  0006e	74 39		 je	 SHORT $LN91@sre_at
$LN24@sre_at:
  00070	bb 01 00 00 00	 mov	 ebx, 1
  00075	8b c3		 mov	 eax, ebx
  00077	e9 80 03 00 00	 jmp	 $LN20@sre_at
$LN15@sre_at:

; 322  : 
; 323  :     case SRE_AT_END:
; 324  :         return (((void*) (ptr+state->charsize) == state->end &&
; 325  :                  SRE_IS_LINEBREAK((int) SRE_CHARGET(state, ptr, 0))) ||
; 326  :                 ((void*) ptr == state->end));

  0007c	48 63 41 3c	 movsxd	 rax, DWORD PTR [rcx+60]
  00080	48 8b 51 18	 mov	 rdx, QWORD PTR [rcx+24]
  00084	48 03 c7	 add	 rax, rdi
  00087	48 3b c2	 cmp	 rax, rdx
  0008a	75 18		 jne	 SHORT $LN28@sre_at
  0008c	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  0008f	3c 80		 cmp	 al, 128			; 00000080H
  00091	73 11		 jae	 SHORT $LN28@sre_at
  00093	0f b6 c0	 movzx	 eax, al
  00096	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  0009f	83 e1 04	 and	 ecx, 4
  000a2	75 cc		 jne	 SHORT $LN24@sre_at
$LN28@sre_at:
  000a4	48 3b fa	 cmp	 rdi, rdx
  000a7	74 c7		 je	 SHORT $LN24@sre_at
$LN91@sre_at:
  000a9	33 db		 xor	 ebx, ebx
  000ab	8b c3		 mov	 eax, ebx
  000ad	e9 4a 03 00 00	 jmp	 $LN20@sre_at
$LN14@sre_at:

; 327  : 
; 328  :     case SRE_AT_END_LINE:
; 329  :         return ((void*) ptr == state->end ||
; 330  :                 SRE_IS_LINEBREAK((int) SRE_CHARGET(state, ptr, 0)));

  000b2	48 3b 51 18	 cmp	 rdx, QWORD PTR [rcx+24]
  000b6	74 b8		 je	 SHORT $LN24@sre_at
  000b8	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  000bb	3c 80		 cmp	 al, 128			; 00000080H
  000bd	73 11		 jae	 SHORT $LN92@sre_at
  000bf	0f b6 c0	 movzx	 eax, al
  000c2	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  000cb	83 e1 04	 and	 ecx, 4
  000ce	75 a0		 jne	 SHORT $LN24@sre_at
$LN92@sre_at:
  000d0	33 db		 xor	 ebx, ebx
  000d2	8b c3		 mov	 eax, ebx
  000d4	e9 23 03 00 00	 jmp	 $LN20@sre_at
$LN13@sre_at:

; 331  : 
; 332  :     case SRE_AT_END_STRING:
; 333  :         return ((void*) ptr == state->end);

  000d9	33 db		 xor	 ebx, ebx
  000db	48 3b 51 18	 cmp	 rdx, QWORD PTR [rcx+24]
  000df	0f 94 c3	 sete	 bl
  000e2	8b c3		 mov	 eax, ebx
  000e4	e9 13 03 00 00	 jmp	 $LN20@sre_at
$LN12@sre_at:

; 334  : 
; 335  :     case SRE_AT_BOUNDARY:
; 336  :         if (state->beginning == state->end)

  000e9	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  000ed	48 8b 51 18	 mov	 rdx, QWORD PTR [rcx+24]
  000f1	48 3b c2	 cmp	 rax, rdx

; 337  :             return 0;

  000f4	0f 84 00 03 00
	00		 je	 $LN18@sre_at

; 338  :         thatp = ((void*) ptr > state->beginning) ?
; 339  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, -1)) : 0;

  000fa	33 db		 xor	 ebx, ebx
  000fc	48 3b f8	 cmp	 rdi, rax
  000ff	76 19		 jbe	 SHORT $LN37@sre_at
  00101	0f b6 47 ff	 movzx	 eax, BYTE PTR [rdi-1]
  00105	3c 80		 cmp	 al, 128			; 00000080H
  00107	73 11		 jae	 SHORT $LN37@sre_at
  00109	0f b6 c0	 movzx	 eax, al
  0010c	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  00115	83 e1 10	 and	 ecx, 16
  00118	eb 02		 jmp	 SHORT $LN38@sre_at
$LN37@sre_at:
  0011a	8b cb		 mov	 ecx, ebx
$LN38@sre_at:
  0011c	4c 63 c1	 movsxd	 r8, ecx

; 340  :         thisp = ((void*) ptr < state->end) ?
; 341  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  0011f	48 3b fa	 cmp	 rdi, rdx
  00122	73 26		 jae	 SHORT $LN41@sre_at
  00124	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  00127	3c 80		 cmp	 al, 128			; 00000080H
  00129	73 1f		 jae	 SHORT $LN41@sre_at
  0012b	0f b6 c0	 movzx	 eax, al
  0012e	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  00137	83 e1 10	 and	 ecx, 16

; 342  :         return thisp != thatp;

  0013a	48 63 c1	 movsxd	 rax, ecx
  0013d	49 3b c0	 cmp	 rax, r8
  00140	0f 95 c3	 setne	 bl
  00143	8b c3		 mov	 eax, ebx
  00145	e9 b2 02 00 00	 jmp	 $LN20@sre_at
$LN41@sre_at:
  0014a	48 63 c3	 movsxd	 rax, ebx
  0014d	8b cb		 mov	 ecx, ebx
  0014f	49 3b c0	 cmp	 rax, r8
  00152	0f 95 c3	 setne	 bl
  00155	8b c3		 mov	 eax, ebx
  00157	e9 a0 02 00 00	 jmp	 $LN20@sre_at
$LN10@sre_at:

; 343  : 
; 344  :     case SRE_AT_NON_BOUNDARY:
; 345  :         if (state->beginning == state->end)

  0015c	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00160	48 8b 51 18	 mov	 rdx, QWORD PTR [rcx+24]
  00164	48 3b c2	 cmp	 rax, rdx

; 346  :             return 0;

  00167	0f 84 8d 02 00
	00		 je	 $LN18@sre_at

; 347  :         thatp = ((void*) ptr > state->beginning) ?
; 348  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, -1)) : 0;

  0016d	33 db		 xor	 ebx, ebx
  0016f	48 3b f8	 cmp	 rdi, rax
  00172	76 19		 jbe	 SHORT $LN45@sre_at
  00174	0f b6 47 ff	 movzx	 eax, BYTE PTR [rdi-1]
  00178	3c 80		 cmp	 al, 128			; 00000080H
  0017a	73 11		 jae	 SHORT $LN45@sre_at
  0017c	0f b6 c0	 movzx	 eax, al
  0017f	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  00188	83 e1 10	 and	 ecx, 16
  0018b	eb 02		 jmp	 SHORT $LN46@sre_at
$LN45@sre_at:
  0018d	8b cb		 mov	 ecx, ebx
$LN46@sre_at:
  0018f	4c 63 c1	 movsxd	 r8, ecx

; 349  :         thisp = ((void*) ptr < state->end) ?
; 350  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  00192	48 3b fa	 cmp	 rdi, rdx
  00195	73 26		 jae	 SHORT $LN49@sre_at
  00197	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  0019a	3c 80		 cmp	 al, 128			; 00000080H
  0019c	73 1f		 jae	 SHORT $LN49@sre_at
  0019e	0f b6 c0	 movzx	 eax, al
  001a1	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  001aa	83 e1 10	 and	 ecx, 16

; 351  :         return thisp == thatp;

  001ad	48 63 c1	 movsxd	 rax, ecx
  001b0	49 3b c0	 cmp	 rax, r8
  001b3	0f 94 c3	 sete	 bl
  001b6	8b c3		 mov	 eax, ebx
  001b8	e9 3f 02 00 00	 jmp	 $LN20@sre_at
$LN49@sre_at:
  001bd	48 63 c3	 movsxd	 rax, ebx
  001c0	8b cb		 mov	 ecx, ebx
  001c2	49 3b c0	 cmp	 rax, r8
  001c5	0f 94 c3	 sete	 bl
  001c8	8b c3		 mov	 eax, ebx
  001ca	e9 2d 02 00 00	 jmp	 $LN20@sre_at
$LN8@sre_at:

; 352  : 
; 353  :     case SRE_AT_LOC_BOUNDARY:
; 354  :         if (state->beginning == state->end)

  001cf	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  001d3	48 3b 41 18	 cmp	 rax, QWORD PTR [rcx+24]

; 355  :             return 0;

  001d7	0f 84 1d 02 00
	00		 je	 $LN18@sre_at

; 356  :         thatp = ((void*) ptr > state->beginning) ?
; 357  :             SRE_LOC_IS_WORD((int) SRE_CHARGET(state, ptr, -1)) : 0;

  001dd	33 db		 xor	 ebx, ebx
  001df	8d 73 01	 lea	 esi, QWORD PTR [rbx+1]
  001e2	48 3b d0	 cmp	 rdx, rax
  001e5	76 20		 jbe	 SHORT $LN55@sre_at
  001e7	0f b6 4a ff	 movzx	 ecx, BYTE PTR [rdx-1]
  001eb	f7 c1 00 ff ff
	ff		 test	 ecx, -256		; ffffffffffffff00H
  001f1	75 0a		 jne	 SHORT $LN93@sre_at
  001f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalnum
  001f9	85 c0		 test	 eax, eax
  001fb	75 06		 jne	 SHORT $LN53@sre_at
$LN93@sre_at:
  001fd	80 7f ff 5f	 cmp	 BYTE PTR [rdi-1], 95	; 0000005fH
  00201	75 04		 jne	 SHORT $LN55@sre_at
$LN53@sre_at:
  00203	8b c6		 mov	 eax, esi
  00205	eb 02		 jmp	 SHORT $LN56@sre_at
$LN55@sre_at:
  00207	8b c3		 mov	 eax, ebx
$LN56@sre_at:
  00209	4c 63 e0	 movsxd	 r12, eax

; 358  :         thisp = ((void*) ptr < state->end) ?
; 359  :             SRE_LOC_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  0020c	48 3b 7d 18	 cmp	 rdi, QWORD PTR [rbp+24]
  00210	73 1a		 jae	 SHORT $LN61@sre_at
  00212	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  00215	f7 c1 00 ff ff
	ff		 test	 ecx, -256		; ffffffffffffff00H
  0021b	75 0a		 jne	 SHORT $LN94@sre_at
  0021d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalnum
  00223	85 c0		 test	 eax, eax
  00225	75 07		 jne	 SHORT $LN62@sre_at
$LN94@sre_at:
  00227	80 3f 5f	 cmp	 BYTE PTR [rdi], 95	; 0000005fH
  0022a	74 02		 je	 SHORT $LN62@sre_at
$LN61@sre_at:
  0022c	8b f3		 mov	 esi, ebx
$LN62@sre_at:

; 360  :         return thisp != thatp;

  0022e	48 63 c6	 movsxd	 rax, esi
  00231	49 3b c4	 cmp	 rax, r12
  00234	0f 95 c3	 setne	 bl
  00237	8b c3		 mov	 eax, ebx
  00239	e9 be 01 00 00	 jmp	 $LN20@sre_at
$LN6@sre_at:

; 361  : 
; 362  :     case SRE_AT_LOC_NON_BOUNDARY:
; 363  :         if (state->beginning == state->end)

  0023e	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00242	48 3b 41 18	 cmp	 rax, QWORD PTR [rcx+24]

; 364  :             return 0;

  00246	0f 84 ae 01 00
	00		 je	 $LN18@sre_at

; 365  :         thatp = ((void*) ptr > state->beginning) ?
; 366  :             SRE_LOC_IS_WORD((int) SRE_CHARGET(state, ptr, -1)) : 0;

  0024c	33 db		 xor	 ebx, ebx
  0024e	8d 73 01	 lea	 esi, QWORD PTR [rbx+1]
  00251	48 3b d0	 cmp	 rdx, rax
  00254	76 20		 jbe	 SHORT $LN67@sre_at
  00256	0f b6 4a ff	 movzx	 ecx, BYTE PTR [rdx-1]
  0025a	f7 c1 00 ff ff
	ff		 test	 ecx, -256		; ffffffffffffff00H
  00260	75 0a		 jne	 SHORT $LN95@sre_at
  00262	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalnum
  00268	85 c0		 test	 eax, eax
  0026a	75 06		 jne	 SHORT $LN65@sre_at
$LN95@sre_at:
  0026c	80 7f ff 5f	 cmp	 BYTE PTR [rdi-1], 95	; 0000005fH
  00270	75 04		 jne	 SHORT $LN67@sre_at
$LN65@sre_at:
  00272	8b c6		 mov	 eax, esi
  00274	eb 02		 jmp	 SHORT $LN68@sre_at
$LN67@sre_at:
  00276	8b c3		 mov	 eax, ebx
$LN68@sre_at:
  00278	4c 63 e0	 movsxd	 r12, eax

; 367  :         thisp = ((void*) ptr < state->end) ?
; 368  :             SRE_LOC_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  0027b	48 3b 7d 18	 cmp	 rdi, QWORD PTR [rbp+24]
  0027f	73 1a		 jae	 SHORT $LN73@sre_at
  00281	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  00284	f7 c1 00 ff ff
	ff		 test	 ecx, -256		; ffffffffffffff00H
  0028a	75 0a		 jne	 SHORT $LN96@sre_at
  0028c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalnum
  00292	85 c0		 test	 eax, eax
  00294	75 07		 jne	 SHORT $LN74@sre_at
$LN96@sre_at:
  00296	80 3f 5f	 cmp	 BYTE PTR [rdi], 95	; 0000005fH
  00299	74 02		 je	 SHORT $LN74@sre_at
$LN73@sre_at:
  0029b	8b f3		 mov	 esi, ebx
$LN74@sre_at:

; 369  :         return thisp == thatp;

  0029d	48 63 c6	 movsxd	 rax, esi
  002a0	49 3b c4	 cmp	 rax, r12
  002a3	0f 94 c3	 sete	 bl
  002a6	8b c3		 mov	 eax, ebx
  002a8	e9 4f 01 00 00	 jmp	 $LN20@sre_at
$LN4@sre_at:

; 370  : 
; 371  :     case SRE_AT_UNI_BOUNDARY:
; 372  :         if (state->beginning == state->end)

  002ad	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  002b1	48 3b 41 18	 cmp	 rax, QWORD PTR [rcx+24]

; 373  :             return 0;

  002b5	0f 84 3f 01 00
	00		 je	 $LN18@sre_at

; 374  :         thatp = ((void*) ptr > state->beginning) ?
; 375  :             SRE_UNI_IS_WORD((int) SRE_CHARGET(state, ptr, -1)) : 0;

  002bb	33 db		 xor	 ebx, ebx
  002bd	8d 73 01	 lea	 esi, QWORD PTR [rbx+1]
  002c0	48 3b d0	 cmp	 rdx, rax
  002c3	76 3e		 jbe	 SHORT $LN77@sre_at
  002c5	0f b6 4a ff	 movzx	 ecx, BYTE PTR [rdx-1]
  002c9	e8 00 00 00 00	 call	 _PyUnicode_IsAlpha
  002ce	85 c0		 test	 eax, eax
  002d0	75 2d		 jne	 SHORT $LN75@sre_at
  002d2	0f b6 4f ff	 movzx	 ecx, BYTE PTR [rdi-1]
  002d6	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  002db	85 c0		 test	 eax, eax
  002dd	75 20		 jne	 SHORT $LN75@sre_at
  002df	0f b6 4f ff	 movzx	 ecx, BYTE PTR [rdi-1]
  002e3	e8 00 00 00 00	 call	 _PyUnicode_IsDigit
  002e8	85 c0		 test	 eax, eax
  002ea	75 13		 jne	 SHORT $LN75@sre_at
  002ec	0f b6 4f ff	 movzx	 ecx, BYTE PTR [rdi-1]
  002f0	e8 00 00 00 00	 call	 _PyUnicode_IsNumeric
  002f5	85 c0		 test	 eax, eax
  002f7	75 06		 jne	 SHORT $LN75@sre_at
  002f9	80 7f ff 5f	 cmp	 BYTE PTR [rdi-1], 95	; 0000005fH
  002fd	75 04		 jne	 SHORT $LN77@sre_at
$LN75@sre_at:
  002ff	8b c6		 mov	 eax, esi
  00301	eb 02		 jmp	 SHORT $LN78@sre_at
$LN77@sre_at:
  00303	8b c3		 mov	 eax, ebx
$LN78@sre_at:
  00305	4c 63 e0	 movsxd	 r12, eax

; 376  :         thisp = ((void*) ptr < state->end) ?
; 377  :             SRE_UNI_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  00308	48 3b 7d 18	 cmp	 rdi, QWORD PTR [rbp+24]
  0030c	73 35		 jae	 SHORT $LN81@sre_at
  0030e	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  00311	e8 00 00 00 00	 call	 _PyUnicode_IsAlpha
  00316	85 c0		 test	 eax, eax
  00318	75 2b		 jne	 SHORT $LN82@sre_at
  0031a	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  0031d	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  00322	85 c0		 test	 eax, eax
  00324	75 1f		 jne	 SHORT $LN82@sre_at
  00326	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  00329	e8 00 00 00 00	 call	 _PyUnicode_IsDigit
  0032e	85 c0		 test	 eax, eax
  00330	75 13		 jne	 SHORT $LN82@sre_at
  00332	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  00335	e8 00 00 00 00	 call	 _PyUnicode_IsNumeric
  0033a	85 c0		 test	 eax, eax
  0033c	75 07		 jne	 SHORT $LN82@sre_at
  0033e	80 3f 5f	 cmp	 BYTE PTR [rdi], 95	; 0000005fH
  00341	74 02		 je	 SHORT $LN82@sre_at
$LN81@sre_at:
  00343	8b f3		 mov	 esi, ebx
$LN82@sre_at:

; 378  :         return thisp != thatp;

  00345	48 63 c6	 movsxd	 rax, esi
  00348	49 3b c4	 cmp	 rax, r12
  0034b	0f 95 c3	 setne	 bl
  0034e	8b c3		 mov	 eax, ebx
  00350	e9 a7 00 00 00	 jmp	 $LN20@sre_at
$LN2@sre_at:

; 379  : 
; 380  :     case SRE_AT_UNI_NON_BOUNDARY:
; 381  :         if (state->beginning == state->end)

  00355	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00359	48 3b 41 18	 cmp	 rax, QWORD PTR [rcx+24]

; 382  :             return 0;

  0035d	0f 84 97 00 00
	00		 je	 $LN18@sre_at

; 383  :         thatp = ((void*) ptr > state->beginning) ?
; 384  :             SRE_UNI_IS_WORD((int) SRE_CHARGET(state, ptr, -1)) : 0;

  00363	33 db		 xor	 ebx, ebx
  00365	8d 73 01	 lea	 esi, QWORD PTR [rbx+1]
  00368	48 3b d0	 cmp	 rdx, rax
  0036b	76 3e		 jbe	 SHORT $LN85@sre_at
  0036d	0f b6 4a ff	 movzx	 ecx, BYTE PTR [rdx-1]
  00371	e8 00 00 00 00	 call	 _PyUnicode_IsAlpha
  00376	85 c0		 test	 eax, eax
  00378	75 2d		 jne	 SHORT $LN83@sre_at
  0037a	0f b6 4f ff	 movzx	 ecx, BYTE PTR [rdi-1]
  0037e	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  00383	85 c0		 test	 eax, eax
  00385	75 20		 jne	 SHORT $LN83@sre_at
  00387	0f b6 4f ff	 movzx	 ecx, BYTE PTR [rdi-1]
  0038b	e8 00 00 00 00	 call	 _PyUnicode_IsDigit
  00390	85 c0		 test	 eax, eax
  00392	75 13		 jne	 SHORT $LN83@sre_at
  00394	0f b6 4f ff	 movzx	 ecx, BYTE PTR [rdi-1]
  00398	e8 00 00 00 00	 call	 _PyUnicode_IsNumeric
  0039d	85 c0		 test	 eax, eax
  0039f	75 06		 jne	 SHORT $LN83@sre_at
  003a1	80 7f ff 5f	 cmp	 BYTE PTR [rdi-1], 95	; 0000005fH
  003a5	75 04		 jne	 SHORT $LN85@sre_at
$LN83@sre_at:
  003a7	8b c6		 mov	 eax, esi
  003a9	eb 02		 jmp	 SHORT $LN86@sre_at
$LN85@sre_at:
  003ab	8b c3		 mov	 eax, ebx
$LN86@sre_at:
  003ad	4c 63 e0	 movsxd	 r12, eax

; 385  :         thisp = ((void*) ptr < state->end) ?
; 386  :             SRE_UNI_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  003b0	48 3b 7d 18	 cmp	 rdi, QWORD PTR [rbp+24]
  003b4	73 35		 jae	 SHORT $LN89@sre_at
  003b6	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  003b9	e8 00 00 00 00	 call	 _PyUnicode_IsAlpha
  003be	85 c0		 test	 eax, eax
  003c0	75 2b		 jne	 SHORT $LN90@sre_at
  003c2	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  003c5	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  003ca	85 c0		 test	 eax, eax
  003cc	75 1f		 jne	 SHORT $LN90@sre_at
  003ce	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  003d1	e8 00 00 00 00	 call	 _PyUnicode_IsDigit
  003d6	85 c0		 test	 eax, eax
  003d8	75 13		 jne	 SHORT $LN90@sre_at
  003da	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  003dd	e8 00 00 00 00	 call	 _PyUnicode_IsNumeric
  003e2	85 c0		 test	 eax, eax
  003e4	75 07		 jne	 SHORT $LN90@sre_at
  003e6	80 3f 5f	 cmp	 BYTE PTR [rdi], 95	; 0000005fH
  003e9	74 02		 je	 SHORT $LN90@sre_at
$LN89@sre_at:
  003eb	8b f3		 mov	 esi, ebx
$LN90@sre_at:

; 387  :         return thisp == thatp;

  003ed	48 63 ce	 movsxd	 rcx, esi
  003f0	49 3b cc	 cmp	 rcx, r12
  003f3	0f 94 c3	 sete	 bl
  003f6	8b c3		 mov	 eax, ebx
  003f8	eb 02		 jmp	 SHORT $LN20@sre_at
$LN18@sre_at:

; 388  : 
; 389  :     }
; 390  : 
; 391  :     return 0;

  003fa	33 c0		 xor	 eax, eax
$LN20@sre_at:

; 392  : }

  003fc	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00401	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00406	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0040b	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00410	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00414	41 5c		 pop	 r12
  00416	c3		 ret	 0
  00417	90		 npad	 1
$LN97@sre_at:
  00418	00 00 00 00	 DD	 $LN17@sre_at
  0041c	00 00 00 00	 DD	 $LN16@sre_at
  00420	00 00 00 00	 DD	 $LN17@sre_at
  00424	00 00 00 00	 DD	 $LN12@sre_at
  00428	00 00 00 00	 DD	 $LN10@sre_at
  0042c	00 00 00 00	 DD	 $LN15@sre_at
  00430	00 00 00 00	 DD	 $LN14@sre_at
  00434	00 00 00 00	 DD	 $LN13@sre_at
  00438	00 00 00 00	 DD	 $LN8@sre_at
  0043c	00 00 00 00	 DD	 $LN6@sre_at
  00440	00 00 00 00	 DD	 $LN4@sre_at
  00444	00 00 00 00	 DD	 $LN2@sre_at
sre_at	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sre_charset DD imagerel sre_charset
	DD	imagerel sre_charset+392
	DD	imagerel $unwind$sre_charset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sre_charset DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT sre_charset
_TEXT	SEGMENT
set$ = 48
ch$ = 56
sre_charset PROC					; COMDAT

; 396  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 397  :     /* check if character is a member of the given set */
; 398  : 
; 399  :     int ok = 1;
; 400  : 
; 401  :     for (;;) {
; 402  :         switch (*set++) {

  0001a	8b 01		 mov	 eax, DWORD PTR [rcx]
  0001c	8b f2		 mov	 esi, edx
  0001e	bf 01 00 00 00	 mov	 edi, 1
  00023	48 8d 59 04	 lea	 rbx, QWORD PTR [rcx+4]
  00027	83 f8 1b	 cmp	 eax, 27
  0002a	0f 87 ee 00 00
	00		 ja	 $LN1@sre_charse
  00030	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:__ImageBase
  00037	33 ed		 xor	 ebp, ebp
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL25@sre_charse:
  00040	41 0f b6 84 04
	00 00 00 00	 movzx	 eax, BYTE PTR $LN34@sre_charse[r12+rax]
  00049	41 8b 8c 84 00
	00 00 00	 mov	 ecx, DWORD PTR $LN35@sre_charse[r12+rax*4]
  00051	49 03 cc	 add	 rcx, r12
  00054	ff e1		 jmp	 rcx
$LN20@sre_charse:

; 406  : 
; 407  :         case SRE_OP_LITERAL:
; 408  :             /* <LITERAL> <code> */
; 409  :             if (ch == set[0])

  00056	3b 33		 cmp	 esi, DWORD PTR [rbx]
  00058	0f 84 dd 00 00
	00		 je	 $LN29@sre_charse

; 411  :             set++;

  0005e	48 83 c3 04	 add	 rbx, 4

; 412  :             break;

  00062	e9 a8 00 00 00	 jmp	 $LN5@sre_charse
$LN18@sre_charse:

; 413  : 
; 414  :         case SRE_OP_CATEGORY:
; 415  :             /* <CATEGORY> <code> */
; 416  :             if (sre_category(set[0], (int) ch))

  00067	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00069	8b d6		 mov	 edx, esi
  0006b	e8 00 00 00 00	 call	 sre_category
  00070	85 c0		 test	 eax, eax
  00072	0f 85 c3 00 00
	00		 jne	 $LN29@sre_charse

; 417  :                 return ok;
; 418  :             set += 1;

  00078	48 83 c3 04	 add	 rbx, 4

; 419  :             break;

  0007c	e9 8e 00 00 00	 jmp	 $LN5@sre_charse
$LN16@sre_charse:

; 420  : 
; 421  :         case SRE_OP_CHARSET:
; 422  :             if (sizeof(SRE_CODE) == 2) {
; 423  :                 /* <CHARSET> <bitmap> (16 bits per code word) */
; 424  :                 if (ch < 256 && (set[ch >> 4] & (1 << (ch & 15))))
; 425  :                     return ok;
; 426  :                 set += 16;
; 427  :             }
; 428  :             else {
; 429  :                 /* <CHARSET> <bitmap> (32 bits per code word) */
; 430  :                 if (ch < 256 && (set[ch >> 5] & (1u << (ch & 31))))

  00081	81 fe 00 01 00
	00		 cmp	 esi, 256		; 00000100H
  00087	73 18		 jae	 SHORT $LN12@sre_charse
  00089	48 8b c6	 mov	 rax, rsi
  0008c	8b ce		 mov	 ecx, esi
  0008e	48 c1 e8 05	 shr	 rax, 5
  00092	83 e1 1f	 and	 ecx, 31
  00095	8b 04 83	 mov	 eax, DWORD PTR [rbx+rax*4]
  00098	0f a3 c8	 bt	 eax, ecx
  0009b	0f 82 9a 00 00
	00		 jb	 $LN29@sre_charse
$LN12@sre_charse:

; 431  :                     return ok;
; 432  :                 set += 8;

  000a1	48 83 c3 20	 add	 rbx, 32			; 00000020H

; 433  :             }
; 434  :             break;

  000a5	eb 68		 jmp	 SHORT $LN5@sre_charse
$LN11@sre_charse:

; 435  : 
; 436  :         case SRE_OP_RANGE:
; 437  :             /* <RANGE> <lower> <upper> */
; 438  :             if (set[0] <= ch && ch <= set[1])

  000a7	39 33		 cmp	 DWORD PTR [rbx], esi
  000a9	77 09		 ja	 SHORT $LN10@sre_charse
  000ab	3b 73 04	 cmp	 esi, DWORD PTR [rbx+4]
  000ae	0f 86 87 00 00
	00		 jbe	 $LN29@sre_charse
$LN10@sre_charse:

; 439  :                 return ok;
; 440  :             set += 2;

  000b4	48 83 c3 08	 add	 rbx, 8

; 441  :             break;

  000b8	eb 55		 jmp	 SHORT $LN5@sre_charse
$LN9@sre_charse:

; 442  : 
; 443  :         case SRE_OP_NEGATE:
; 444  :             ok = !ok;

  000ba	85 ff		 test	 edi, edi
  000bc	8b c5		 mov	 eax, ebp
  000be	0f 94 c0	 sete	 al
  000c1	8b f8		 mov	 edi, eax

; 445  :             break;

  000c3	eb 4a		 jmp	 SHORT $LN5@sre_charse
$LN8@sre_charse:

; 446  : 
; 447  :         case SRE_OP_BIGCHARSET:
; 448  :             /* <BIGCHARSET> <blockcount> <256 blockindices> <blocks> */
; 449  :         {
; 450  :             Py_ssize_t count, block;
; 451  :             count = *(set++);

  000c5	44 8b 03	 mov	 r8d, DWORD PTR [rbx]

; 452  : 
; 453  :             if (sizeof(SRE_CODE) == 2) {
; 454  :                 block = ((unsigned char*)set)[ch >> 8];
; 455  :                 set += 128;
; 456  :                 if (set[block*16 + ((ch & 255)>>4)] & (1 << (ch & 15)))
; 457  :                     return ok;
; 458  :                 set += count*16;
; 459  :             }
; 460  :             else {
; 461  :                 /* !(c & ~N) == (c < N+1) for any unsigned c, this avoids
; 462  :                  * warnings when c's type supports only numbers < N+1 */
; 463  :                 if (!(ch & ~65535))

  000c8	f7 c6 00 00 ff
	ff		 test	 esi, -65536		; ffff0000H
  000ce	75 0e		 jne	 SHORT $LN4@sre_charse

; 464  :                     block = ((unsigned char*)set)[ch >> 8];

  000d0	48 8b c6	 mov	 rax, rsi
  000d3	48 c1 e8 08	 shr	 rax, 8
  000d7	0f b6 4c 18 04	 movzx	 ecx, BYTE PTR [rax+rbx+4]

; 465  :                 else

  000dc	eb 04		 jmp	 SHORT $LN3@sre_charse
$LN4@sre_charse:

; 466  :                     block = -1;

  000de	48 83 c9 ff	 or	 rcx, -1
$LN3@sre_charse:

; 467  :                 set += 64;

  000e2	48 81 c3 04 01
	00 00		 add	 rbx, 260		; 00000104H

; 468  :                 if (block >=0 &&
; 469  :                     (set[block*8 + ((ch & 255)>>5)] & (1u << (ch & 31))))

  000e9	48 85 c9	 test	 rcx, rcx
  000ec	78 1a		 js	 SHORT $LN2@sre_charse
  000ee	8b c6		 mov	 eax, esi
  000f0	48 c1 e8 05	 shr	 rax, 5
  000f4	83 e0 07	 and	 eax, 7
  000f7	48 8d 14 c8	 lea	 rdx, QWORD PTR [rax+rcx*8]
  000fb	8b ce		 mov	 ecx, esi
  000fd	8b 04 93	 mov	 eax, DWORD PTR [rbx+rdx*4]
  00100	83 e1 1f	 and	 ecx, 31
  00103	0f a3 c8	 bt	 eax, ecx
  00106	72 33		 jb	 SHORT $LN29@sre_charse
$LN2@sre_charse:

; 470  :                     return ok;
; 471  :                 set += count*8;

  00108	49 c1 e0 05	 shl	 r8, 5
  0010c	49 03 d8	 add	 rbx, r8
$LN5@sre_charse:

; 397  :     /* check if character is a member of the given set */
; 398  : 
; 399  :     int ok = 1;
; 400  : 
; 401  :     for (;;) {
; 402  :         switch (*set++) {

  0010f	8b 03		 mov	 eax, DWORD PTR [rbx]
  00111	48 83 c3 04	 add	 rbx, 4
  00115	83 f8 1b	 cmp	 eax, 27
  00118	0f 86 22 ff ff
	ff		 jbe	 $LL25@sre_charse
$LN1@sre_charse:

; 472  :             }
; 473  :             break;
; 474  :         }
; 475  : 
; 476  :         default:
; 477  :             /* internal error -- there's not much we can do about it
; 478  :                here, so let's just pretend it didn't match... */
; 479  :             return 0;

  0011e	33 c0		 xor	 eax, eax
$LN24@sre_charse:

; 480  :         }
; 481  :     }
; 482  : }

  00120	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00125	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0012a	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0012f	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00134	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00138	41 5c		 pop	 r12
  0013a	c3		 ret	 0
$LN29@sre_charse:

; 410  :                 return ok;

  0013b	8b c7		 mov	 eax, edi
  0013d	eb e1		 jmp	 SHORT $LN24@sre_charse
$LN21@sre_charse:

; 403  : 
; 404  :         case SRE_OP_FAILURE:
; 405  :             return !ok;

  0013f	85 ff		 test	 edi, edi
  00141	40 0f 94 c5	 sete	 bpl
  00145	8b c5		 mov	 eax, ebp
  00147	eb d7		 jmp	 SHORT $LN24@sre_charse
  00149	0f 1f 00	 npad	 3
$LN35@sre_charse:

; 480  :         }
; 481  :     }
; 482  : }

  0014c	00 00 00 00	 DD	 $LN21@sre_charse
  00150	00 00 00 00	 DD	 $LN18@sre_charse
  00154	00 00 00 00	 DD	 $LN16@sre_charse
  00158	00 00 00 00	 DD	 $LN8@sre_charse
  0015c	00 00 00 00	 DD	 $LN20@sre_charse
  00160	00 00 00 00	 DD	 $LN9@sre_charse
  00164	00 00 00 00	 DD	 $LN11@sre_charse
  00168	00 00 00 00	 DD	 $LN1@sre_charse
$LN34@sre_charse:
  0016c	00		 DB	 0
  0016d	07		 DB	 7
  0016e	07		 DB	 7
  0016f	07		 DB	 7
  00170	07		 DB	 7
  00171	07		 DB	 7
  00172	07		 DB	 7
  00173	07		 DB	 7
  00174	07		 DB	 7
  00175	01		 DB	 1
  00176	02		 DB	 2
  00177	03		 DB	 3
  00178	07		 DB	 7
  00179	07		 DB	 7
  0017a	07		 DB	 7
  0017b	07		 DB	 7
  0017c	07		 DB	 7
  0017d	07		 DB	 7
  0017e	07		 DB	 7
  0017f	04		 DB	 4
  00180	07		 DB	 7
  00181	07		 DB	 7
  00182	07		 DB	 7
  00183	07		 DB	 7
  00184	07		 DB	 7
  00185	07		 DB	 7
  00186	05		 DB	 5
  00187	06		 DB	 6
sre_charset ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sre_count DD imagerel sre_count
	DD	imagerel sre_count+532
	DD	imagerel $unwind$sre_count
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sre_count DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT sre_count
_TEXT	SEGMENT
state$ = 48
pattern$ = 56
maxcount$ = 64
sre_count PROC						; COMDAT

; 488  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 489  :     SRE_CODE chr;
; 490  :     char* ptr = (char *)state->ptr;
; 491  :     char* end = (char *)state->end;

  00014	48 8b 79 18	 mov	 rdi, QWORD PTR [rcx+24]
  00018	48 8b 19	 mov	 rbx, QWORD PTR [rcx]

; 492  :     Py_ssize_t i;
; 493  : 
; 494  :     /* adjust end */
; 495  :     if (maxcount < (end - ptr) / state->charsize && maxcount != SRE_MAXREPEAT)

  0001b	4c 63 49 3c	 movsxd	 r9, DWORD PTR [rcx+60]
  0001f	48 8b ea	 mov	 rbp, rdx
  00022	48 8b c7	 mov	 rax, rdi
  00025	48 8b f1	 mov	 rsi, rcx
  00028	48 2b c3	 sub	 rax, rbx
  0002b	48 99		 cdq
  0002d	49 f7 f9	 idiv	 r9
  00030	4c 3b c0	 cmp	 r8, rax
  00033	7d 14		 jge	 SHORT $LN27@sre_count
  00035	b8 ff ff ff ff	 mov	 eax, -1
  0003a	4c 3b c0	 cmp	 r8, rax
  0003d	74 0a		 je	 SHORT $LN27@sre_count

; 496  :         end = ptr + maxcount*state->charsize;

  0003f	49 8b f9	 mov	 rdi, r9
  00042	49 0f af f8	 imul	 rdi, r8
  00046	48 03 fb	 add	 rdi, rbx
$LN27@sre_count:

; 497  : 
; 498  :     switch (pattern[0]) {

  00049	8b 45 00	 mov	 eax, DWORD PTR [rbp]
  0004c	83 c0 fe	 add	 eax, -2			; fffffffeH
  0004f	83 f8 17	 cmp	 eax, 23
  00052	0f 87 39 01 00
	00		 ja	 $LN38@sre_count
  00058	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  0005f	0f b6 84 02 00
	00 00 00	 movzx	 eax, BYTE PTR $LN48@sre_count[rdx+rax]
  00067	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN49@sre_count[rdx+rax*4]
  0006e	48 03 ca	 add	 rcx, rdx
  00071	ff e1		 jmp	 rcx
$LN32@sre_count:

; 499  : 
; 500  :     case SRE_OP_IN:
; 501  :         /* repeated set */
; 502  :         TRACE(("|%p|%p|COUNT IN\n", pattern, ptr));
; 503  :         while (ptr < end &&
; 504  :                SRE_CHARSET(pattern + 2, SRE_CHARGET(state, ptr, 0)))

  00073	48 3b df	 cmp	 rbx, rdi
  00076	0f 83 0d 01 00
	00		 jae	 $LN50@sre_count
  0007c	0f 1f 40 00	 npad	 4
$LL23@sre_count:
  00080	0f b6 13	 movzx	 edx, BYTE PTR [rbx]
  00083	48 8d 4d 08	 lea	 rcx, QWORD PTR [rbp+8]
  00087	e8 00 00 00 00	 call	 sre_charset
  0008c	85 c0		 test	 eax, eax
  0008e	0f 84 f5 00 00
	00		 je	 $LN50@sre_count

; 505  :             ptr += state->charsize;

  00094	48 63 46 3c	 movsxd	 rax, DWORD PTR [rsi+60]
  00098	48 03 d8	 add	 rbx, rax
  0009b	48 3b df	 cmp	 rbx, rdi
  0009e	72 e0		 jb	 SHORT $LL23@sre_count

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  000a0	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  000a3	48 8b c3	 mov	 rax, rbx
  000a6	e9 12 01 00 00	 jmp	 $LN51@sre_count
$LN33@sre_count:

; 506  :         break;
; 507  : 
; 508  :     case SRE_OP_ANY:
; 509  :         /* repeated dot wildcard. */
; 510  :         TRACE(("|%p|%p|COUNT ANY\n", pattern, ptr));
; 511  :         while (ptr < end && !SRE_IS_LINEBREAK(SRE_CHARGET(state, ptr, 0)))

  000ab	48 3b df	 cmp	 rbx, rdi
  000ae	0f 83 d5 00 00
	00		 jae	 $LN50@sre_count
$LL20@sre_count:
  000b4	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  000b7	3c 80		 cmp	 al, 128			; 00000080H
  000b9	73 14		 jae	 SHORT $LN47@sre_count
  000bb	0f b6 c0	 movzx	 eax, al
  000be	0f be 8c 10 00
	00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+rdx]
  000c6	83 e1 04	 and	 ecx, 4
  000c9	0f 85 ba 00 00
	00		 jne	 $LN50@sre_count
$LN47@sre_count:

; 512  :             ptr += state->charsize;

  000cf	49 03 d9	 add	 rbx, r9
  000d2	48 3b df	 cmp	 rbx, rdi
  000d5	72 dd		 jb	 SHORT $LL20@sre_count

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  000d7	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  000da	48 8b c3	 mov	 rax, rbx
  000dd	e9 db 00 00 00	 jmp	 $LN51@sre_count
$LN18@sre_count:

; 513  :         break;
; 514  : 
; 515  :     case SRE_OP_ANY_ALL:
; 516  :         /* repeated dot wildcard.  skip to the end of the target
; 517  :            string, and backtrack from there */
; 518  :         TRACE(("|%p|%p|COUNT ANY_ALL\n", pattern, ptr));
; 519  :         ptr = end;

  000e2	48 8b df	 mov	 rbx, rdi

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  000e5	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  000e8	48 8b c3	 mov	 rax, rbx
  000eb	e9 cd 00 00 00	 jmp	 $LN51@sre_count
$LN17@sre_count:

; 520  :         break;
; 521  : 
; 522  :     case SRE_OP_LITERAL:
; 523  :         /* repeated literal */
; 524  :         chr = pattern[1];

  000f0	8b 4d 04	 mov	 ecx, DWORD PTR [rbp+4]

; 525  :         TRACE(("|%p|%p|COUNT LITERAL %d\n", pattern, ptr, chr));
; 526  :         while (ptr < end && (SRE_CODE) SRE_CHARGET(state, ptr, 0) == chr)

  000f3	48 3b df	 cmp	 rbx, rdi
  000f6	0f 83 8d 00 00
	00		 jae	 $LN50@sre_count
  000fc	0f 1f 40 00	 npad	 4
$LL16@sre_count:
  00100	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00103	3b c1		 cmp	 eax, ecx
  00105	0f 85 7e 00 00
	00		 jne	 $LN50@sre_count

; 527  :             ptr += state->charsize;

  0010b	49 03 d9	 add	 rbx, r9
  0010e	48 3b df	 cmp	 rbx, rdi
  00111	72 ed		 jb	 SHORT $LL16@sre_count

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  00113	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  00116	48 8b c3	 mov	 rax, rbx
  00119	e9 9f 00 00 00	 jmp	 $LN51@sre_count
$LN14@sre_count:

; 528  :         break;
; 529  : 
; 530  :     case SRE_OP_LITERAL_IGNORE:
; 531  :         /* repeated literal */
; 532  :         chr = pattern[1];

  0011e	8b 6d 04	 mov	 ebp, DWORD PTR [rbp+4]

; 533  :         TRACE(("|%p|%p|COUNT LITERAL_IGNORE %d\n", pattern, ptr, chr));
; 534  :         while (ptr < end && (SRE_CODE) state->lower(SRE_CHARGET(state, ptr, 0)) == chr)

  00121	48 3b df	 cmp	 rbx, rdi
  00124	73 63		 jae	 SHORT $LN50@sre_count
$LL13@sre_count:
  00126	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  00129	ff 96 00 07 00
	00		 call	 QWORD PTR [rsi+1792]
  0012f	3b c5		 cmp	 eax, ebp
  00131	75 56		 jne	 SHORT $LN50@sre_count

; 535  :             ptr += state->charsize;

  00133	48 63 46 3c	 movsxd	 rax, DWORD PTR [rsi+60]
  00137	48 03 d8	 add	 rbx, rax
  0013a	48 3b df	 cmp	 rbx, rdi
  0013d	72 e7		 jb	 SHORT $LL13@sre_count

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  0013f	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  00142	48 8b c3	 mov	 rax, rbx
  00145	eb 76		 jmp	 SHORT $LN51@sre_count
$LN11@sre_count:

; 536  :         break;
; 537  : 
; 538  :     case SRE_OP_NOT_LITERAL:
; 539  :         /* repeated non-literal */
; 540  :         chr = pattern[1];

  00147	8b 4d 04	 mov	 ecx, DWORD PTR [rbp+4]

; 541  :         TRACE(("|%p|%p|COUNT NOT_LITERAL %d\n", pattern, ptr, chr));
; 542  :         while (ptr < end && (SRE_CODE) SRE_CHARGET(state, ptr, 0) != chr)

  0014a	48 3b df	 cmp	 rbx, rdi
  0014d	73 3a		 jae	 SHORT $LN50@sre_count
  0014f	90		 npad	 1
$LL10@sre_count:
  00150	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00153	3b c1		 cmp	 eax, ecx
  00155	74 32		 je	 SHORT $LN50@sre_count

; 543  :             ptr += state->charsize;

  00157	49 03 d9	 add	 rbx, r9
  0015a	48 3b df	 cmp	 rbx, rdi
  0015d	72 f1		 jb	 SHORT $LL10@sre_count

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  0015f	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  00162	48 8b c3	 mov	 rax, rbx
  00165	eb 56		 jmp	 SHORT $LN51@sre_count
$LN8@sre_count:

; 544  :         break;
; 545  : 
; 546  :     case SRE_OP_NOT_LITERAL_IGNORE:
; 547  :         /* repeated non-literal */
; 548  :         chr = pattern[1];

  00167	8b 6d 04	 mov	 ebp, DWORD PTR [rbp+4]

; 549  :         TRACE(("|%p|%p|COUNT NOT_LITERAL_IGNORE %d\n", pattern, ptr, chr));
; 550  :         while (ptr < end && (SRE_CODE) state->lower(SRE_CHARGET(state, ptr, 0)) != chr)

  0016a	48 3b df	 cmp	 rbx, rdi
  0016d	73 1a		 jae	 SHORT $LN50@sre_count
  0016f	90		 npad	 1
$LL7@sre_count:
  00170	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  00173	ff 96 00 07 00
	00		 call	 QWORD PTR [rsi+1792]
  00179	3b c5		 cmp	 eax, ebp
  0017b	74 0c		 je	 SHORT $LN50@sre_count

; 551  :             ptr += state->charsize;

  0017d	48 63 4e 3c	 movsxd	 rcx, DWORD PTR [rsi+60]
  00181	48 03 d9	 add	 rbx, rcx
  00184	48 3b df	 cmp	 rbx, rdi
  00187	72 e7		 jb	 SHORT $LL7@sre_count
$LN50@sre_count:

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  00189	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  0018c	48 8b c3	 mov	 rax, rbx
  0018f	eb 2c		 jmp	 SHORT $LN51@sre_count
$LN38@sre_count:

; 552  :         break;
; 553  : 
; 554  :     default:
; 555  :         /* repeated single character pattern */
; 556  :         TRACE(("|%p|%p|COUNT SUBPATTERN\n", pattern, ptr));
; 557  :         while ((char*) state->ptr < end) {

  00191	48 3b df	 cmp	 rbx, rdi
  00194	73 21		 jae	 SHORT $LN40@sre_count
  00196	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@sre_count:

; 558  :             i = SRE_MATCH(state, pattern);

  001a0	48 8b d5	 mov	 rdx, rbp
  001a3	48 8b ce	 mov	 rcx, rsi
  001a6	e8 00 00 00 00	 call	 sre_match

; 559  :             if (i < 0)

  001ab	48 85 c0	 test	 rax, rax
  001ae	78 16		 js	 SHORT $LN28@sre_count

; 560  :                 return i;
; 561  :             if (!i)

  001b0	74 05		 je	 SHORT $LN40@sre_count

; 552  :         break;
; 553  : 
; 554  :     default:
; 555  :         /* repeated single character pattern */
; 556  :         TRACE(("|%p|%p|COUNT SUBPATTERN\n", pattern, ptr));
; 557  :         while ((char*) state->ptr < end) {

  001b2	48 39 3e	 cmp	 QWORD PTR [rsi], rdi
  001b5	72 e9		 jb	 SHORT $LL4@sre_count
$LN40@sre_count:

; 562  :                 break;
; 563  :         }
; 564  :         TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 565  :                ((char*)state->ptr - ptr)/state->charsize));
; 566  :         return ((char*)state->ptr - ptr)/state->charsize;

  001b7	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  001ba	48 2b c3	 sub	 rax, rbx
$LN51@sre_count:
  001bd	48 63 4e 3c	 movsxd	 rcx, DWORD PTR [rsi+60]
  001c1	48 99		 cdq
  001c3	48 f7 f9	 idiv	 rcx
$LN28@sre_count:

; 572  : }

  001c6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  001cb	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  001d0	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  001d5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001d9	5f		 pop	 rdi
  001da	c3		 ret	 0
  001db	90		 npad	 1
$LN49@sre_count:
  001dc	00 00 00 00	 DD	 $LN33@sre_count
  001e0	00 00 00 00	 DD	 $LN18@sre_count
  001e4	00 00 00 00	 DD	 $LN32@sre_count
  001e8	00 00 00 00	 DD	 $LN17@sre_count
  001ec	00 00 00 00	 DD	 $LN14@sre_count
  001f0	00 00 00 00	 DD	 $LN11@sre_count
  001f4	00 00 00 00	 DD	 $LN8@sre_count
  001f8	00 00 00 00	 DD	 $LN38@sre_count
$LN48@sre_count:
  001fc	00		 DB	 0
  001fd	01		 DB	 1
  001fe	07		 DB	 7
  001ff	07		 DB	 7
  00200	07		 DB	 7
  00201	07		 DB	 7
  00202	07		 DB	 7
  00203	07		 DB	 7
  00204	07		 DB	 7
  00205	07		 DB	 7
  00206	07		 DB	 7
  00207	07		 DB	 7
  00208	07		 DB	 7
  00209	02		 DB	 2
  0020a	07		 DB	 7
  0020b	07		 DB	 7
  0020c	07		 DB	 7
  0020d	03		 DB	 3
  0020e	04		 DB	 4
  0020f	07		 DB	 7
  00210	07		 DB	 7
  00211	07		 DB	 7
  00212	05		 DB	 5
  00213	06		 DB	 6
sre_count ENDP
_TEXT	ENDS
EXTRN	PyObject_Free:PROC
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyErr_CheckSignals:PROC
EXTRN	memset:PROC
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$sre_match DD imagerel sre_match
	DD	imagerel sre_match+92
	DD	imagerel $unwind$sre_match
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$sre_match DD imagerel sre_match+92
	DD	imagerel sre_match+4896
	DD	imagerel $chain$2$sre_match
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$sre_match DD imagerel sre_match+4896
	DD	imagerel sre_match+5076
	DD	imagerel $chain$4$sre_match
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$sre_match DD 060021H
	DD	0cc400H
	DD	0b7400H
	DD	0a6400H
	DD	imagerel sre_match
	DD	imagerel sre_match+92
	DD	imagerel $unwind$sre_match
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$sre_match DD 061421H
	DD	0cc414H
	DD	0b740aH
	DD	0a6405H
	DD	imagerel sre_match
	DD	imagerel sre_match+92
	DD	imagerel $unwind$sre_match
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sre_match DD 060d01H
	DD	0f009320dH
	DD	0d005e007H
	DD	030025003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT sre_match
_TEXT	SEGMENT
state$ = 80
pattern$ = 88
sre_match PROC						; COMDAT

; 782  : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	41 55		 push	 r13
  00005	41 56		 push	 r14
  00007	41 57		 push	 r15
  00009	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 783  :     char* end = (char*)state->end;
; 784  :     Py_ssize_t alloc_pos, ctx_pos = -1;
; 785  :     Py_ssize_t i, ret = 0;
; 786  :     Py_ssize_t jump;
; 787  :     unsigned int sigcount=0;
; 788  : 
; 789  :     SRE_MATCH_CONTEXT* ctx;
; 790  :     SRE_MATCH_CONTEXT* nextctx;
; 791  : 
; 792  :     TRACE(("|%p|%p|ENTER\n", pattern, state->ptr));
; 793  : 
; 794  :     DATA_ALLOC(SRE_MATCH_CONTEXT, ctx);

  0000d	4c 8b a9 a0 06
	00 00		 mov	 r13, QWORD PTR [rcx+1696]
  00014	48 8b 81 98 06
	00 00		 mov	 rax, QWORD PTR [rcx+1688]
  0001b	4c 8b 71 18	 mov	 r14, QWORD PTR [rcx+24]
  0001f	49 2b c5	 sub	 rax, r13
  00022	45 33 ff	 xor	 r15d, r15d
  00025	48 8b da	 mov	 rbx, rdx
  00028	48 8b e9	 mov	 rbp, rcx
  0002b	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  0002f	73 1c		 jae	 SHORT $LN709@sre_match
  00031	41 8d 57 40	 lea	 edx, QWORD PTR [r15+64]
  00035	e8 00 00 00 00	 call	 data_stack_grow
  0003a	85 c0		 test	 eax, eax
  0003c	79 0f		 jns	 SHORT $LN709@sre_match
  0003e	48 98		 cdqe

; 1427 :         case JUMP_MAX_UNTIL_2:
; 1428 :             TRACE(("|%p|%p|JUMP_MAX_UNTIL_2\n", ctx->pattern, ctx->ptr));
; 1429 :             goto jump_max_until_2;
; 1430 :         case JUMP_MAX_UNTIL_3:
; 1431 :             TRACE(("|%p|%p|JUMP_MAX_UNTIL_3\n", ctx->pattern, ctx->ptr));
; 1432 :             goto jump_max_until_3;
; 1433 :         case JUMP_MIN_UNTIL_2:
; 1434 :             TRACE(("|%p|%p|JUMP_MIN_UNTIL_2\n", ctx->pattern, ctx->ptr));
; 1435 :             goto jump_min_until_2;
; 1436 :         case JUMP_MIN_UNTIL_3:
; 1437 :             TRACE(("|%p|%p|JUMP_MIN_UNTIL_3\n", ctx->pattern, ctx->ptr));
; 1438 :             goto jump_min_until_3;
; 1439 :         case JUMP_BRANCH:
; 1440 :             TRACE(("|%p|%p|JUMP_BRANCH\n", ctx->pattern, ctx->ptr));
; 1441 :             goto jump_branch;
; 1442 :         case JUMP_MAX_UNTIL_1:
; 1443 :             TRACE(("|%p|%p|JUMP_MAX_UNTIL_1\n", ctx->pattern, ctx->ptr));
; 1444 :             goto jump_max_until_1;
; 1445 :         case JUMP_MIN_UNTIL_1:
; 1446 :             TRACE(("|%p|%p|JUMP_MIN_UNTIL_1\n", ctx->pattern, ctx->ptr));
; 1447 :             goto jump_min_until_1;
; 1448 :         case JUMP_REPEAT:
; 1449 :             TRACE(("|%p|%p|JUMP_REPEAT\n", ctx->pattern, ctx->ptr));
; 1450 :             goto jump_repeat;
; 1451 :         case JUMP_REPEAT_ONE_1:
; 1452 :             TRACE(("|%p|%p|JUMP_REPEAT_ONE_1\n", ctx->pattern, ctx->ptr));
; 1453 :             goto jump_repeat_one_1;
; 1454 :         case JUMP_REPEAT_ONE_2:
; 1455 :             TRACE(("|%p|%p|JUMP_REPEAT_ONE_2\n", ctx->pattern, ctx->ptr));
; 1456 :             goto jump_repeat_one_2;
; 1457 :         case JUMP_MIN_REPEAT_ONE:
; 1458 :             TRACE(("|%p|%p|JUMP_MIN_REPEAT_ONE\n", ctx->pattern, ctx->ptr));
; 1459 :             goto jump_min_repeat_one;
; 1460 :         case JUMP_ASSERT:
; 1461 :             TRACE(("|%p|%p|JUMP_ASSERT\n", ctx->pattern, ctx->ptr));
; 1462 :             goto jump_assert;
; 1463 :         case JUMP_ASSERT_NOT:
; 1464 :             TRACE(("|%p|%p|JUMP_ASSERT_NOT\n", ctx->pattern, ctx->ptr));
; 1465 :             goto jump_assert_not;
; 1466 :         case JUMP_NONE:
; 1467 :             TRACE(("|%p|%p|RETURN %" PY_FORMAT_SIZE_T "d\n", ctx->pattern,
; 1468 :                    ctx->ptr, ret));
; 1469 :             break;
; 1470 :     }
; 1471 : 
; 1472 :     return ret; /* should never get here */
; 1473 : }

  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	41 5f		 pop	 r15
  00046	41 5e		 pop	 r14
  00048	41 5d		 pop	 r13
  0004a	5d		 pop	 rbp
  0004b	5b		 pop	 rbx
  0004c	c3		 ret	 0
$LN709@sre_match:

; 783  :     char* end = (char*)state->end;
; 784  :     Py_ssize_t alloc_pos, ctx_pos = -1;
; 785  :     Py_ssize_t i, ret = 0;
; 786  :     Py_ssize_t jump;
; 787  :     unsigned int sigcount=0;
; 788  : 
; 789  :     SRE_MATCH_CONTEXT* ctx;
; 790  :     SRE_MATCH_CONTEXT* nextctx;
; 791  : 
; 792  :     TRACE(("|%p|%p|ENTER\n", pattern, state->ptr));
; 793  : 
; 794  :     DATA_ALLOC(SRE_MATCH_CONTEXT, ctx);

  0004d	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  00054	48 83 85 a0 06
	00 00 40	 add	 QWORD PTR [rbp+1696], 64 ; 00000040H
  0005c	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  00061	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi
  00066	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
  0006b	4c 89 64 24 60	 mov	 QWORD PTR [rsp+96], r12

; 795  :     ctx->last_ctx_pos = -1;

  00070	48 c7 07 ff ff
	ff ff		 mov	 QWORD PTR [rdi], -1

; 796  :     ctx->jump = JUMP_NONE;

  00077	4c 89 7f 08	 mov	 QWORD PTR [rdi+8], r15

; 797  :     ctx->pattern = pattern;

  0007b	48 89 5f 18	 mov	 QWORD PTR [rdi+24], rbx
$LN987@sre_match:

; 798  :     ctx_pos = alloc_pos;

  0007f	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:__ImageBase
  00086	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$entrance$20804:

; 799  : 
; 800  : entrance:
; 801  : 
; 802  :     ctx->ptr = (char *)state->ptr;

  00090	48 8b 4d 00	 mov	 rcx, QWORD PTR [rbp]

; 803  : 
; 804  :     if (ctx->pattern[0] == SRE_OP_INFO) {

  00094	4c 8b 47 18	 mov	 r8, QWORD PTR [rdi+24]
  00098	48 89 4f 10	 mov	 QWORD PTR [rdi+16], rcx
  0009c	41 83 38 11	 cmp	 DWORD PTR [r8], 17
  000a0	75 2f		 jne	 SHORT $LN703@sre_match

; 805  :         /* optimization info block */
; 806  :         /* <INFO> <1=skip> <2=flags> <3=min> ... */
; 807  :         if (ctx->pattern[3] && (end - ctx->ptr)/state->charsize < ctx->pattern[3]) {

  000a2	45 8b 48 0c	 mov	 r9d, DWORD PTR [r8+12]
  000a6	45 85 c9	 test	 r9d, r9d
  000a9	74 18		 je	 SHORT $LN704@sre_match
  000ab	49 8b c6	 mov	 rax, r14
  000ae	48 2b c1	 sub	 rax, rcx
  000b1	48 63 4d 3c	 movsxd	 rcx, DWORD PTR [rbp+60]
  000b5	48 99		 cdq
  000b7	48 f7 f9	 idiv	 rcx
  000ba	49 3b c1	 cmp	 rax, r9

; 808  :             TRACE(("reject (got %" PY_FORMAT_SIZE_T "d chars, "
; 809  :                    "need %" PY_FORMAT_SIZE_T "d)\n",
; 810  :                    (end - ctx->ptr)/state->charsize,
; 811  :                    (Py_ssize_t) ctx->pattern[3]));
; 812  :             RETURN_FAILURE;

  000bd	0f 8c 7d 06 00
	00		 jl	 $LL30@sre_match
$LN704@sre_match:

; 813  :         }
; 814  :         ctx->pattern += ctx->pattern[1] + 1;

  000c3	41 8b 40 04	 mov	 eax, DWORD PTR [r8+4]
  000c7	ff c0		 inc	 eax
  000c9	49 8d 0c 80	 lea	 rcx, QWORD PTR [r8+rax*4]
$LN985@sre_match:
  000cd	48 89 4f 18	 mov	 QWORD PTR [rdi+24], rcx
$LN703@sre_match:

; 815  :     }
; 816  : 
; 817  :     for (;;) {
; 818  :         ++sigcount;

  000d1	41 ff c7	 inc	 r15d

; 819  :         if ((0 == (sigcount & 0xfff)) && PyErr_CheckSignals())

  000d4	41 f7 c7 ff 0f
	00 00		 test	 r15d, 4095		; 00000fffH
  000db	75 0d		 jne	 SHORT $LN698@sre_match
  000dd	e8 00 00 00 00	 call	 PyErr_CheckSignals
  000e2	85 c0		 test	 eax, eax
  000e4	0f 85 fe 11 00
	00		 jne	 $LN943@sre_match
$LN698@sre_match:

; 821  : 
; 822  :         switch (*ctx->pattern++) {

  000ea	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  000ee	8b 08		 mov	 ecx, DWORD PTR [rax]
  000f0	4c 8d 48 04	 lea	 r9, QWORD PTR [rax+4]
  000f4	4c 89 4f 18	 mov	 QWORD PTR [rdi+24], r9
  000f8	83 f9 1f	 cmp	 ecx, 31
  000fb	0f 87 fd 11 00
	00		 ja	 $LN28@sre_match
  00101	8b c1		 mov	 eax, ecx
  00103	8b 8c 8e 00 00
	00 00		 mov	 ecx, DWORD PTR $LN973@sre_match[rsi+rcx*4]
  0010a	48 03 ce	 add	 rcx, rsi
  0010d	ff e1		 jmp	 rcx
$LN695@sre_match:

; 823  : 
; 824  :         case SRE_OP_MARK:
; 825  :             /* set mark */
; 826  :             /* <MARK> <gid> */
; 827  :             TRACE(("|%p|%p|MARK %d\n", ctx->pattern,
; 828  :                    ctx->ptr, ctx->pattern[0]));
; 829  :             i = ctx->pattern[0];

  0010f	41 8b 19	 mov	 ebx, DWORD PTR [r9]

; 830  :             if (i & 1)

  00112	f6 c3 01	 test	 bl, 1
  00115	74 11		 je	 SHORT $LN694@sre_match

; 831  :                 state->lastindex = i/2 + 1;

  00117	8b c3		 mov	 eax, ebx
  00119	48 99		 cdq
  0011b	48 2b c2	 sub	 rax, rdx
  0011e	48 d1 f8	 sar	 rax, 1
  00121	48 ff c0	 inc	 rax
  00124	48 89 45 40	 mov	 QWORD PTR [rbp+64], rax
$LN694@sre_match:

; 832  :             if (i > state->lastmark) {

  00128	48 8b 45 48	 mov	 rax, QWORD PTR [rbp+72]
  0012c	48 3b d8	 cmp	 rbx, rax
  0012f	7e 22		 jle	 SHORT $LN693@sre_match

; 833  :                 /* state->lastmark is the highest valid index in the
; 834  :                    state->mark array.  If it is increased by more than 1,
; 835  :                    the intervening marks must be set to NULL to signal
; 836  :                    that these marks have not been encountered. */
; 837  :                 Py_ssize_t j = state->lastmark + 1;

  00131	48 ff c0	 inc	 rax

; 838  :                 while (j < i)

  00134	48 3b c3	 cmp	 rax, rbx
  00137	7d 16		 jge	 SHORT $LN692@sre_match

; 833  :                 /* state->lastmark is the highest valid index in the
; 834  :                    state->mark array.  If it is increased by more than 1,
; 835  :                    the intervening marks must be set to NULL to signal
; 836  :                    that these marks have not been encountered. */
; 837  :                 Py_ssize_t j = state->lastmark + 1;

  00139	4c 8b c3	 mov	 r8, rbx
  0013c	48 8d 4c c5 50	 lea	 rcx, QWORD PTR [rbp+rax*8+80]
  00141	33 d2		 xor	 edx, edx
  00143	4c 2b c0	 sub	 r8, rax
  00146	49 c1 e0 03	 shl	 r8, 3
  0014a	e8 00 00 00 00	 call	 memset
$LN692@sre_match:

; 839  :                     state->mark[j++] = NULL;
; 840  :                 state->lastmark = i;

  0014f	48 89 5d 48	 mov	 QWORD PTR [rbp+72], rbx
$LN693@sre_match:

; 841  :             }
; 842  :             state->mark[i] = ctx->ptr;

  00153	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00157	48 89 44 dd 50	 mov	 QWORD PTR [rbp+rbx*8+80], rax
$LN670@sre_match:

; 843  :             ctx->pattern++;

  0015c	48 83 47 18 04	 add	 QWORD PTR [rdi+24], 4

; 844  :             break;

  00161	e9 6b ff ff ff	 jmp	 $LN703@sre_match
$LN690@sre_match:

; 845  : 
; 846  :         case SRE_OP_LITERAL:
; 847  :             /* match literal string */
; 848  :             /* <LITERAL> <code> */
; 849  :             TRACE(("|%p|%p|LITERAL %d\n", ctx->pattern,
; 850  :                    ctx->ptr, *ctx->pattern));
; 851  :             if (ctx->ptr >= end || (SRE_CODE) SRE_CHARGET(state, ctx->ptr, 0) != ctx->pattern[0])

  00166	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  0016a	49 3b ce	 cmp	 rcx, r14
  0016d	0f 83 cd 05 00
	00		 jae	 $LL30@sre_match
  00173	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00176	41 3b 01	 cmp	 eax, DWORD PTR [r9]
  00179	0f 85 c1 05 00
	00		 jne	 $LL30@sre_match
$LN982@sre_match:

; 852  :                 RETURN_FAILURE;
; 853  :             ctx->pattern++;

  0017f	49 8d 41 04	 lea	 rax, QWORD PTR [r9+4]
  00183	48 89 47 18	 mov	 QWORD PTR [rdi+24], rax
$LN653@sre_match:

; 854  :             ctx->ptr += state->charsize;

  00187	48 63 45 3c	 movsxd	 rax, DWORD PTR [rbp+60]
  0018b	48 03 c1	 add	 rax, rcx
  0018e	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 855  :             break;

  00192	e9 3a ff ff ff	 jmp	 $LN703@sre_match
$LN684@sre_match:

; 856  : 
; 857  :         case SRE_OP_NOT_LITERAL:
; 858  :             /* match anything that is not literal character */
; 859  :             /* <NOT_LITERAL> <code> */
; 860  :             TRACE(("|%p|%p|NOT_LITERAL %d\n", ctx->pattern,
; 861  :                    ctx->ptr, *ctx->pattern));
; 862  :             if (ctx->ptr >= end || (SRE_CODE) SRE_CHARGET(state, ctx->ptr, 0) == ctx->pattern[0])

  00197	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  0019b	49 3b ce	 cmp	 rcx, r14
  0019e	0f 83 9c 05 00
	00		 jae	 $LL30@sre_match
  001a4	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  001a7	41 3b 01	 cmp	 eax, DWORD PTR [r9]

; 864  :             ctx->pattern++;
; 865  :             ctx->ptr += state->charsize;
; 866  :             break;

  001aa	75 d3		 jne	 SHORT $LN982@sre_match

; 863  :                 RETURN_FAILURE;

  001ac	e9 8f 05 00 00	 jmp	 $LL30@sre_match
$LN675@sre_match:

; 867  : 
; 868  :         case SRE_OP_SUCCESS:
; 869  :             /* end of pattern */
; 870  :             TRACE(("|%p|%p|SUCCESS\n", ctx->pattern, ctx->ptr));
; 871  :             state->ptr = ctx->ptr;
; 872  :             RETURN_SUCCESS;
; 873  : 
; 874  :         case SRE_OP_AT:
; 875  :             /* match at given position */
; 876  :             /* <AT> <code> */
; 877  :             TRACE(("|%p|%p|AT %d\n", ctx->pattern, ctx->ptr, *ctx->pattern));
; 878  :             if (!SRE_AT(state, ctx->ptr, *ctx->pattern))

  001b1	45 8b 01	 mov	 r8d, DWORD PTR [r9]
  001b4	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  001b8	48 8b cd	 mov	 rcx, rbp
  001bb	e8 00 00 00 00	 call	 sre_at
  001c0	85 c0		 test	 eax, eax
  001c2	75 98		 jne	 SHORT $LN670@sre_match

; 879  :                 RETURN_FAILURE;

  001c4	e9 77 05 00 00	 jmp	 $LL30@sre_match
$LN669@sre_match:

; 880  :             ctx->pattern++;
; 881  :             break;
; 882  : 
; 883  :         case SRE_OP_CATEGORY:
; 884  :             /* match at given category */
; 885  :             /* <CATEGORY> <code> */
; 886  :             TRACE(("|%p|%p|CATEGORY %d\n", ctx->pattern,
; 887  :                    ctx->ptr, *ctx->pattern));
; 888  :             if (ctx->ptr >= end || !sre_category(ctx->pattern[0], SRE_CHARGET(state, ctx->ptr, 0)))

  001c9	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  001cd	49 3b c6	 cmp	 rax, r14
  001d0	0f 83 6a 05 00
	00		 jae	 $LL30@sre_match
  001d6	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  001d9	41 8b 09	 mov	 ecx, DWORD PTR [r9]
  001dc	e8 00 00 00 00	 call	 sre_category
  001e1	85 c0		 test	 eax, eax
$LN989@sre_match:
  001e3	0f 84 57 05 00
	00		 je	 $LL30@sre_match

; 889  :                 RETURN_FAILURE;
; 890  :             ctx->pattern++;

  001e9	48 83 47 18 04	 add	 QWORD PTR [rdi+24], 4

; 891  :             ctx->ptr += state->charsize;

  001ee	48 63 45 3c	 movsxd	 rax, DWORD PTR [rbp+60]
  001f2	48 01 47 10	 add	 QWORD PTR [rdi+16], rax

; 892  :             break;

  001f6	e9 d6 fe ff ff	 jmp	 $LN703@sre_match
$LN663@sre_match:

; 893  : 
; 894  :         case SRE_OP_ANY:
; 895  :             /* match anything (except a newline) */
; 896  :             /* <ANY> */
; 897  :             TRACE(("|%p|%p|ANY\n", ctx->pattern, ctx->ptr));
; 898  :                 if (ctx->ptr >= end || SRE_IS_LINEBREAK(SRE_CHARGET(state, ctx->ptr, 0)))

  001fb	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  001ff	49 3b d6	 cmp	 rdx, r14
  00202	0f 83 38 05 00
	00		 jae	 $LL30@sre_match
  00208	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  0020b	3c 80		 cmp	 al, 128			; 00000080H
  0020d	73 14		 jae	 SHORT $LN971@sre_match
  0020f	0f b6 c0	 movzx	 eax, al
  00212	0f be 8c 30 00
	00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+rsi]
  0021a	83 e1 04	 and	 ecx, 4
  0021d	0f 85 1d 05 00
	00		 jne	 $LL30@sre_match
$LN971@sre_match:

; 899  :                     RETURN_FAILURE;
; 900  :             ctx->ptr += state->charsize;

  00223	48 63 45 3c	 movsxd	 rax, DWORD PTR [rbp+60]
  00227	48 03 c2	 add	 rax, rdx
  0022a	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax
  0022e	e9 9e fe ff ff	 jmp	 $LN703@sre_match
$LN657@sre_match:

; 901  :             break;
; 902  : 
; 903  :         case SRE_OP_ANY_ALL:
; 904  :             /* match anything */
; 905  :             /* <ANY_ALL> */
; 906  :             TRACE(("|%p|%p|ANY_ALL\n", ctx->pattern, ctx->ptr));
; 907  :             if (ctx->ptr >= end)

  00233	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00237	49 3b ce	 cmp	 rcx, r14
  0023a	0f 82 47 ff ff
	ff		 jb	 $LN653@sre_match

; 908  :                 RETURN_FAILURE;

  00240	e9 fb 04 00 00	 jmp	 $LL30@sre_match
$LN652@sre_match:

; 909  :             ctx->ptr += state->charsize;
; 910  :             break;
; 911  : 
; 912  :         case SRE_OP_IN:
; 913  :             /* match set member (or non_member) */
; 914  :             /* <IN> <skip> <set> */
; 915  :             TRACE(("|%p|%p|IN\n", ctx->pattern, ctx->ptr));
; 916  :                 if (ctx->ptr >= end || !SRE_CHARSET(ctx->pattern + 1, SRE_CHARGET(state, ctx->ptr, 0)))

  00245	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00249	49 3b c6	 cmp	 rax, r14
  0024c	0f 83 ee 04 00
	00		 jae	 $LL30@sre_match
  00252	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00255	49 8d 49 04	 lea	 rcx, QWORD PTR [r9+4]
  00259	e8 00 00 00 00	 call	 sre_charset
  0025e	85 c0		 test	 eax, eax
  00260	0f 84 da 04 00
	00		 je	 $LL30@sre_match
$LN984@sre_match:

; 917  :                     RETURN_FAILURE;
; 918  :             ctx->pattern += ctx->pattern[0];

  00266	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  0026a	8b 01		 mov	 eax, DWORD PTR [rcx]
  0026c	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  00270	48 89 4f 18	 mov	 QWORD PTR [rdi+24], rcx

; 919  :             ctx->ptr += state->charsize;

  00274	48 63 45 3c	 movsxd	 rax, DWORD PTR [rbp+60]
  00278	48 01 47 10	 add	 QWORD PTR [rdi+16], rax

; 920  :             break;

  0027c	e9 50 fe ff ff	 jmp	 $LN703@sre_match
$LN646@sre_match:

; 921  : 
; 922  :         case SRE_OP_LITERAL_IGNORE:
; 923  :             TRACE(("|%p|%p|LITERAL_IGNORE %d\n",
; 924  :                    ctx->pattern, ctx->ptr, ctx->pattern[0]));
; 925  :             if (ctx->ptr >= end ||
; 926  :                 state->lower(SRE_CHARGET(state, ctx->ptr, 0)) != state->lower(*ctx->pattern))

  00281	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00285	49 3b c6	 cmp	 rax, r14
  00288	0f 83 b2 04 00
	00		 jae	 $LL30@sre_match
  0028e	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00291	ff 95 00 07 00
	00		 call	 QWORD PTR [rbp+1792]
  00297	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  0029b	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0029d	8b d8		 mov	 ebx, eax
  0029f	ff 95 00 07 00
	00		 call	 QWORD PTR [rbp+1792]
  002a5	3b d8		 cmp	 ebx, eax
  002a7	0f 85 93 04 00
	00		 jne	 $LL30@sre_match

; 927  :                 RETURN_FAILURE;
; 928  :             ctx->pattern++;

  002ad	48 83 47 18 04	 add	 QWORD PTR [rdi+24], 4

; 929  :             ctx->ptr += state->charsize;

  002b2	48 63 45 3c	 movsxd	 rax, DWORD PTR [rbp+60]
  002b6	48 01 47 10	 add	 QWORD PTR [rdi+16], rax

; 930  :             break;

  002ba	e9 12 fe ff ff	 jmp	 $LN703@sre_match
$LN640@sre_match:

; 931  : 
; 932  :         case SRE_OP_NOT_LITERAL_IGNORE:
; 933  :             TRACE(("|%p|%p|NOT_LITERAL_IGNORE %d\n",
; 934  :                    ctx->pattern, ctx->ptr, *ctx->pattern));
; 935  :             if (ctx->ptr >= end ||
; 936  :                 state->lower(SRE_CHARGET(state, ctx->ptr, 0)) == state->lower(*ctx->pattern))

  002bf	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  002c3	49 3b c6	 cmp	 rax, r14
  002c6	0f 83 74 04 00
	00		 jae	 $LL30@sre_match
  002cc	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  002cf	ff 95 00 07 00
	00		 call	 QWORD PTR [rbp+1792]
  002d5	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  002d9	8b 09		 mov	 ecx, DWORD PTR [rcx]
  002db	8b d8		 mov	 ebx, eax
  002dd	ff 95 00 07 00
	00		 call	 QWORD PTR [rbp+1792]
  002e3	3b d8		 cmp	 ebx, eax

; 937  :                 RETURN_FAILURE;
; 938  :             ctx->pattern++;
; 939  :             ctx->ptr += state->charsize;
; 940  :             break;

  002e5	e9 f9 fe ff ff	 jmp	 $LN989@sre_match
$LN634@sre_match:

; 941  : 
; 942  :         case SRE_OP_IN_IGNORE:
; 943  :             TRACE(("|%p|%p|IN_IGNORE\n", ctx->pattern, ctx->ptr));
; 944  :             if (ctx->ptr >= end
; 945  :                 || !SRE_CHARSET(ctx->pattern+1,
; 946  :                                 (SRE_CODE)state->lower(SRE_CHARGET(state, ctx->ptr, 0))))

  002ea	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  002ee	49 3b c6	 cmp	 rax, r14
  002f1	0f 83 49 04 00
	00		 jae	 $LL30@sre_match
  002f7	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  002fa	ff 95 00 07 00
	00		 call	 QWORD PTR [rbp+1792]
  00300	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00304	48 83 c1 04	 add	 rcx, 4
  00308	8b d0		 mov	 edx, eax
  0030a	e8 00 00 00 00	 call	 sre_charset
  0030f	85 c0		 test	 eax, eax

; 948  :             ctx->pattern += ctx->pattern[0];
; 949  :             ctx->ptr += state->charsize;
; 950  :             break;

  00311	0f 85 4f ff ff
	ff		 jne	 $LN984@sre_match

; 947  :                 RETURN_FAILURE;

  00317	e9 24 04 00 00	 jmp	 $LL30@sre_match
$LN628@sre_match:

; 951  : 
; 952  :         case SRE_OP_JUMP:
; 953  :         case SRE_OP_INFO:
; 954  :             /* jump forward */
; 955  :             /* <JUMP> <offset> */
; 956  :             TRACE(("|%p|%p|JUMP %d\n", ctx->pattern,
; 957  :                    ctx->ptr, ctx->pattern[0]));
; 958  :             ctx->pattern += ctx->pattern[0];

  0031c	41 8b 01	 mov	 eax, DWORD PTR [r9]
  0031f	49 8d 0c 81	 lea	 rcx, QWORD PTR [r9+rax*4]

; 959  :             break;

  00323	e9 a5 fd ff ff	 jmp	 $LN985@sre_match
  00328	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL626@sre_match:

; 960  : 
; 961  :         case SRE_OP_BRANCH:
; 962  :             /* alternation */
; 963  :             /* <BRANCH> <0=skip> code <JUMP> ... <NULL> */
; 964  :             TRACE(("|%p|%p|BRANCH\n", ctx->pattern, ctx->ptr));
; 965  :             LASTMARK_SAVE();

  00330	48 8b 5d 48	 mov	 rbx, QWORD PTR [rbp+72]
  00334	48 89 5f 28	 mov	 QWORD PTR [rdi+40], rbx
  00338	48 8b 45 40	 mov	 rax, QWORD PTR [rbp+64]
  0033c	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax

; 966  :             ctx->u.rep = state->repeat;

  00340	48 8b 85 f8 06
	00 00		 mov	 rax, QWORD PTR [rbp+1784]
  00347	48 89 47 38	 mov	 QWORD PTR [rdi+56], rax

; 967  :             if (ctx->u.rep)

  0034b	48 85 c0	 test	 rax, rax
  0034e	0f 84 7c 06 00
	00		 je	 $LN609@sre_match

; 968  :                 MARK_PUSH(ctx->lastmark);

  00354	48 85 db	 test	 rbx, rbx
  00357	0f 8e 73 06 00
	00		 jle	 $LN609@sre_match
  0035d	48 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [rbp+1688]
  00364	48 8d 34 dd 08
	00 00 00	 lea	 rsi, QWORD PTR [rbx*8+8]
  0036c	48 2b 85 a0 06
	00 00		 sub	 rax, QWORD PTR [rbp+1696]
  00373	48 3b f0	 cmp	 rsi, rax
  00376	76 25		 jbe	 SHORT $LN610@sre_match
  00378	48 8b d6	 mov	 rdx, rsi
  0037b	48 8b cd	 mov	 rcx, rbp
  0037e	e8 00 00 00 00	 call	 data_stack_grow
  00383	85 c0		 test	 eax, eax
  00385	0f 88 66 0f 00
	00		 js	 $LN957@sre_match
  0038b	49 83 fd ff	 cmp	 r13, -1
  0038f	74 0c		 je	 SHORT $LN610@sre_match
  00391	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  00398	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN610@sre_match:
  0039d	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR [rbp+1680]
  003a4	48 8d 55 50	 lea	 rdx, QWORD PTR [rbp+80]
  003a8	4c 8b c6	 mov	 r8, rsi
  003ab	48 03 8d a0 06
	00 00		 add	 rcx, QWORD PTR [rbp+1696]
  003b2	e8 00 00 00 00	 call	 memcpy
  003b7	4c 8d 1c dd 08
	00 00 00	 lea	 r11, QWORD PTR [rbx*8+8]
  003bf	4c 01 9d a0 06
	00 00		 add	 QWORD PTR [rbp+1696], r11

; 969  :             for (; ctx->pattern[0]; ctx->pattern += ctx->pattern[0]) {

  003c6	e9 05 06 00 00	 jmp	 $LN609@sre_match
$LN550@sre_match:

; 993  : 
; 994  :         case SRE_OP_REPEAT_ONE:
; 995  :             /* match repeated sequence (maximizing regexp) */
; 996  : 
; 997  :             /* this operator only works if the repeated item is
; 998  :                exactly one character wide, and we're not already
; 999  :                collecting backtracking points.  for other cases,
; 1000 :                use the MAX_REPEAT operator */
; 1001 : 
; 1002 :             /* <REPEAT_ONE> <skip> <1=min> <2=max> item <SUCCESS> tail */
; 1003 : 
; 1004 :             TRACE(("|%p|%p|REPEAT_ONE %d %d\n", ctx->pattern, ctx->ptr,
; 1005 :                    ctx->pattern[1], ctx->pattern[2]));
; 1006 : 
; 1007 :             if ((Py_ssize_t) ctx->pattern[1] > (end - ctx->ptr) / state->charsize)

  003cb	48 63 4d 3c	 movsxd	 rcx, DWORD PTR [rbp+60]
  003cf	4c 8b 47 10	 mov	 r8, QWORD PTR [rdi+16]
  003d3	49 8b c6	 mov	 rax, r14
  003d6	49 2b c0	 sub	 rax, r8
  003d9	48 99		 cdq
  003db	48 f7 f9	 idiv	 rcx
  003de	41 8b 49 04	 mov	 ecx, DWORD PTR [r9+4]
  003e2	48 3b c8	 cmp	 rcx, rax

; 1008 :                 RETURN_FAILURE; /* cannot match */

  003e5	0f 8f 55 03 00
	00		 jg	 $LL30@sre_match

; 1009 : 
; 1010 :             state->ptr = ctx->ptr;

  003eb	4c 89 45 00	 mov	 QWORD PTR [rbp], r8

; 1011 : 
; 1012 :             ret = SRE_COUNT(state, ctx->pattern+3, ctx->pattern[2]);

  003ef	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  003f3	48 8b cd	 mov	 rcx, rbp
  003f6	44 8b 42 08	 mov	 r8d, DWORD PTR [rdx+8]
  003fa	48 83 c2 0c	 add	 rdx, 12
  003fe	e8 00 00 00 00	 call	 sre_count

; 1013 :             RETURN_ON_ERROR(ret);

  00403	48 85 c0	 test	 rax, rax
  00406	0f 88 f6 0e 00
	00		 js	 $LN977@sre_match

; 1014 :             DATA_LOOKUP_AT(SRE_MATCH_CONTEXT, ctx, ctx_pos);

  0040c	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR [rbp+1680]

; 1015 :             ctx->count = ret;

  00413	49 89 44 0d 20	 mov	 QWORD PTR [r13+rcx+32], rax

; 1016 :             ctx->ptr += state->charsize * ctx->count;
; 1017 : 
; 1018 :             /* when we arrive here, count contains the number of
; 1019 :                matches, and ctx->ptr points to the tail of the target
; 1020 :                string.  check if the rest of the pattern matches,
; 1021 :                and backtrack if not. */
; 1022 : 
; 1023 :             if (ctx->count < (Py_ssize_t) ctx->pattern[1])

  00418	49 8b 54 0d 18	 mov	 rdx, QWORD PTR [r13+rcx+24]
  0041d	49 8d 7c 0d 00	 lea	 rdi, QWORD PTR [r13+rcx]
  00422	48 63 4d 3c	 movsxd	 rcx, DWORD PTR [rbp+60]
  00426	48 0f af c8	 imul	 rcx, rax
  0042a	48 01 4f 10	 add	 QWORD PTR [rdi+16], rcx
  0042e	8b 4a 04	 mov	 ecx, DWORD PTR [rdx+4]
  00431	4c 8b 47 10	 mov	 r8, QWORD PTR [rdi+16]
  00435	48 3b c1	 cmp	 rax, rcx

; 1024 :                 RETURN_FAILURE;

  00438	0f 8c 02 03 00
	00		 jl	 $LL30@sre_match

; 1025 : 
; 1026 :             if (ctx->pattern[ctx->pattern[0]] == SRE_OP_SUCCESS) {

  0043e	8b 02		 mov	 eax, DWORD PTR [rdx]
  00440	83 3c 82 01	 cmp	 DWORD PTR [rdx+rax*4], 1
  00444	75 0e		 jne	 SHORT $LN527@sre_match

; 1027 :                 /* tail is empty.  we're finished */
; 1028 :                 state->ptr = ctx->ptr;

  00446	4c 89 45 00	 mov	 QWORD PTR [rbp], r8

; 1029 :                 RETURN_SUCCESS;

  0044a	bb 01 00 00 00	 mov	 ebx, 1
  0044f	e9 ee 02 00 00	 jmp	 $exit$20811
$LN527@sre_match:

; 1030 :             }
; 1031 : 
; 1032 :             LASTMARK_SAVE();

  00454	48 8b 45 48	 mov	 rax, QWORD PTR [rbp+72]
  00458	48 89 47 28	 mov	 QWORD PTR [rdi+40], rax
  0045c	48 8b 45 40	 mov	 rax, QWORD PTR [rbp+64]
  00460	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax

; 1033 : 
; 1034 :             if (ctx->pattern[ctx->pattern[0]] == SRE_OP_LITERAL) {

  00464	8b 02		 mov	 eax, DWORD PTR [rdx]
  00466	83 3c 82 13	 cmp	 DWORD PTR [rdx+rax*4], 19
  0046a	0f 85 90 07 00
	00		 jne	 $LN490@sre_match

; 1035 :                 /* tail starts with a literal. skip positions where
; 1036 :                    the rest of the pattern cannot possibly match */
; 1037 :                 ctx->u.chr = ctx->pattern[ctx->pattern[0]+1];

  00470	ff c0		 inc	 eax
  00472	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00475	89 47 38	 mov	 DWORD PTR [rdi+56], eax
  00478	e9 9d 06 00 00	 jmp	 $LN522@sre_match
$LN461@sre_match:

; 1074 :                 }
; 1075 :             }
; 1076 :             RETURN_FAILURE;
; 1077 : 
; 1078 :         case SRE_OP_MIN_REPEAT_ONE:
; 1079 :             /* match repeated sequence (minimizing regexp) */
; 1080 : 
; 1081 :             /* this operator only works if the repeated item is
; 1082 :                exactly one character wide, and we're not already
; 1083 :                collecting backtracking points.  for other cases,
; 1084 :                use the MIN_REPEAT operator */
; 1085 : 
; 1086 :             /* <MIN_REPEAT_ONE> <skip> <1=min> <2=max> item <SUCCESS> tail */
; 1087 : 
; 1088 :             TRACE(("|%p|%p|MIN_REPEAT_ONE %d %d\n", ctx->pattern, ctx->ptr,
; 1089 :                    ctx->pattern[1], ctx->pattern[2]));
; 1090 : 
; 1091 :             if ((Py_ssize_t) ctx->pattern[1] > (end - ctx->ptr) / state->charsize)

  0047d	48 63 4d 3c	 movsxd	 rcx, DWORD PTR [rbp+60]
  00481	4c 8b 47 10	 mov	 r8, QWORD PTR [rdi+16]
  00485	49 8b c6	 mov	 rax, r14
  00488	49 2b c0	 sub	 rax, r8
  0048b	48 99		 cdq
  0048d	48 f7 f9	 idiv	 rcx
  00490	41 8b 49 04	 mov	 ecx, DWORD PTR [r9+4]
  00494	48 3b c8	 cmp	 rcx, rax

; 1092 :                 RETURN_FAILURE; /* cannot match */

  00497	0f 8f a3 02 00
	00		 jg	 $LL30@sre_match

; 1093 : 
; 1094 :             state->ptr = ctx->ptr;

  0049d	4c 89 45 00	 mov	 QWORD PTR [rbp], r8

; 1095 : 
; 1096 :             if (ctx->pattern[1] == 0)

  004a1	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  004a5	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  004a8	85 c0		 test	 eax, eax
  004aa	75 0a		 jne	 SHORT $LN455@sre_match

; 1097 :                 ctx->count = 0;

  004ac	48 c7 47 20 00
	00 00 00	 mov	 QWORD PTR [rdi+32], 0

; 1098 :             else {

  004b4	eb 48		 jmp	 SHORT $LN454@sre_match
$LN455@sre_match:

; 1099 :                 /* count using pattern min as the maximum */
; 1100 :                 ret = SRE_COUNT(state, ctx->pattern+3, ctx->pattern[1]);

  004b6	4c 8b c0	 mov	 r8, rax
  004b9	48 83 c2 0c	 add	 rdx, 12
  004bd	48 8b cd	 mov	 rcx, rbp
  004c0	e8 00 00 00 00	 call	 sre_count
  004c5	4c 8b d8	 mov	 r11, rax

; 1101 :                 RETURN_ON_ERROR(ret);

  004c8	48 85 c0	 test	 rax, rax
  004cb	0f 88 31 0e 00
	00		 js	 $LN977@sre_match

; 1102 :                 DATA_LOOKUP_AT(SRE_MATCH_CONTEXT, ctx, ctx_pos);

  004d1	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR [rbp+1680]
  004d8	49 8d 7c 0d 00	 lea	 rdi, QWORD PTR [r13+rcx]

; 1103 :                 if (ret < (Py_ssize_t) ctx->pattern[1])

  004dd	49 8b 4c 0d 18	 mov	 rcx, QWORD PTR [r13+rcx+24]
  004e2	8b 51 04	 mov	 edx, DWORD PTR [rcx+4]
  004e5	48 3b c2	 cmp	 rax, rdx

; 1104 :                     /* didn't match minimum number of times */
; 1105 :                     RETURN_FAILURE;

  004e8	0f 8c 52 02 00
	00		 jl	 $LL30@sre_match

; 1106 :                 /* advance past minimum matches of repeat */
; 1107 :                 ctx->count = ret;

  004ee	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 1108 :                 ctx->ptr += state->charsize * ctx->count;

  004f2	48 63 45 3c	 movsxd	 rax, DWORD PTR [rbp+60]
  004f6	49 0f af c3	 imul	 rax, r11
  004fa	48 01 47 10	 add	 QWORD PTR [rdi+16], rax
$LN454@sre_match:

; 1109 :             }
; 1110 : 
; 1111 :             if (ctx->pattern[ctx->pattern[0]] == SRE_OP_SUCCESS) {

  004fe	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00502	8b 01		 mov	 eax, DWORD PTR [rcx]
  00504	83 3c 81 01	 cmp	 DWORD PTR [rcx+rax*4], 1
  00508	75 16		 jne	 SHORT $LL434@sre_match
$LN678@sre_match:

; 1112 :                 /* tail is empty.  we're finished */
; 1113 :                 state->ptr = ctx->ptr;

  0050a	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 1114 :                 RETURN_SUCCESS;

  0050e	bb 01 00 00 00	 mov	 ebx, 1
  00513	48 89 45 00	 mov	 QWORD PTR [rbp], rax
  00517	e9 26 02 00 00	 jmp	 $exit$20811
  0051c	0f 1f 40 00	 npad	 4
$LL434@sre_match:

; 1115 : 
; 1116 :             } else {
; 1117 :                 /* general case */
; 1118 :                 LASTMARK_SAVE();

  00520	48 8b 45 48	 mov	 rax, QWORD PTR [rbp+72]
  00524	48 89 47 28	 mov	 QWORD PTR [rdi+40], rax
  00528	48 8b 45 40	 mov	 rax, QWORD PTR [rbp+64]
  0052c	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax
  00530	e9 b6 07 00 00	 jmp	 $LN431@sre_match
$LN390@sre_match:

; 1138 :                 }
; 1139 :             }
; 1140 :             RETURN_FAILURE;
; 1141 : 
; 1142 :         case SRE_OP_REPEAT:
; 1143 :             /* create repeat context.  all the hard work is done
; 1144 :                by the UNTIL operator (MAX_UNTIL, MIN_UNTIL) */
; 1145 :             /* <REPEAT> <skip> <1=min> <2=max> item <UNTIL> tail */
; 1146 :             TRACE(("|%p|%p|REPEAT %d %d\n", ctx->pattern, ctx->ptr,
; 1147 :                    ctx->pattern[1], ctx->pattern[2]));
; 1148 : 
; 1149 :             /* install new repeat context */
; 1150 :             ctx->u.rep = (SRE_REPEAT*) PyObject_MALLOC(sizeof(*ctx->u.rep));

  00535	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0053a	e8 00 00 00 00	 call	 PyObject_Malloc
  0053f	48 89 47 38	 mov	 QWORD PTR [rdi+56], rax

; 1151 :             if (!ctx->u.rep) {

  00543	48 85 c0	 test	 rax, rax
  00546	0f 85 5a 08 00
	00		 jne	 $LN385@sre_match

; 1152 :                 PyErr_NoMemory();

  0054c	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1153 :                 RETURN_FAILURE;

  00551	e9 ea 01 00 00	 jmp	 $LL30@sre_match
$LN127@sre_match:

; 1301 : 
; 1302 :         case SRE_OP_GROUPREF:
; 1303 :             /* match backreference */
; 1304 :             TRACE(("|%p|%p|GROUPREF %d\n", ctx->pattern,
; 1305 :                    ctx->ptr, ctx->pattern[0]));
; 1306 :             i = ctx->pattern[0];
; 1307 :             {
; 1308 :                 Py_ssize_t groupref = i+i;

  00556	41 8b 01	 mov	 eax, DWORD PTR [r9]
  00559	48 03 c0	 add	 rax, rax

; 1309 :                 if (groupref >= state->lastmark) {

  0055c	48 3b 45 48	 cmp	 rax, QWORD PTR [rbp+72]

; 1310 :                     RETURN_FAILURE;

  00560	0f 8d da 01 00
	00		 jge	 $LL30@sre_match

; 1311 :                 } else {
; 1312 :                     char* p = (char*) state->mark[groupref];

  00566	48 8b 54 c5 50	 mov	 rdx, QWORD PTR [rbp+rax*8+80]

; 1313 :                     char* e = (char*) state->mark[groupref+1];

  0056b	4c 8b 44 c5 58	 mov	 r8, QWORD PTR [rbp+rax*8+88]

; 1314 :                     if (!p || !e || e < p)

  00570	48 85 d2	 test	 rdx, rdx
  00573	0f 84 c7 01 00
	00		 je	 $LL30@sre_match
  00579	4d 85 c0	 test	 r8, r8
  0057c	0f 84 be 01 00
	00		 je	 $LL30@sre_match
  00582	49 3b d0	 cmp	 rdx, r8
  00585	0f 87 b5 01 00
	00		 ja	 $LL30@sre_match

; 1315 :                         RETURN_FAILURE;
; 1316 :                     while (p < e) {

  0058b	73 2e		 jae	 SHORT $LN114@sre_match
  0058d	0f 1f 00	 npad	 3
$LL115@sre_match:

; 1317 :                         if (ctx->ptr >= end ||
; 1318 :                             SRE_CHARGET(state, ctx->ptr, 0) != SRE_CHARGET(state, p, 0))

  00590	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00594	49 3b ce	 cmp	 rcx, r14
  00597	0f 83 a3 01 00
	00		 jae	 $LL30@sre_match
  0059d	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  005a0	38 01		 cmp	 BYTE PTR [rcx], al
  005a2	0f 85 98 01 00
	00		 jne	 $LL30@sre_match

; 1319 :                             RETURN_FAILURE;
; 1320 :                         p += state->charsize;

  005a8	48 63 45 3c	 movsxd	 rax, DWORD PTR [rbp+60]
  005ac	48 03 d0	 add	 rdx, rax

; 1321 :                         ctx->ptr += state->charsize;

  005af	48 03 c1	 add	 rax, rcx
  005b2	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax
  005b6	49 3b d0	 cmp	 rdx, r8
  005b9	72 d5		 jb	 SHORT $LL115@sre_match
$LN114@sre_match:

; 1322 :                     }
; 1323 :                 }
; 1324 :             }
; 1325 :             ctx->pattern++;

  005bb	49 8d 41 04	 lea	 rax, QWORD PTR [r9+4]
  005bf	48 89 47 18	 mov	 QWORD PTR [rdi+24], rax

; 1326 :             break;

  005c3	e9 09 fb ff ff	 jmp	 $LN703@sre_match
$LN108@sre_match:

; 1327 : 
; 1328 :         case SRE_OP_GROUPREF_IGNORE:
; 1329 :             /* match backreference */
; 1330 :             TRACE(("|%p|%p|GROUPREF_IGNORE %d\n", ctx->pattern,
; 1331 :                    ctx->ptr, ctx->pattern[0]));
; 1332 :             i = ctx->pattern[0];
; 1333 :             {
; 1334 :                 Py_ssize_t groupref = i+i;

  005c8	41 8b 01	 mov	 eax, DWORD PTR [r9]
  005cb	48 03 c0	 add	 rax, rax

; 1335 :                 if (groupref >= state->lastmark) {

  005ce	48 3b 45 48	 cmp	 rax, QWORD PTR [rbp+72]

; 1336 :                     RETURN_FAILURE;

  005d2	0f 8d 68 01 00
	00		 jge	 $LL30@sre_match

; 1337 :                 } else {
; 1338 :                     char* p = (char*) state->mark[groupref];

  005d8	48 8b 74 c5 50	 mov	 rsi, QWORD PTR [rbp+rax*8+80]

; 1339 :                     char* e = (char*) state->mark[groupref+1];

  005dd	4c 8b 64 c5 58	 mov	 r12, QWORD PTR [rbp+rax*8+88]

; 1340 :                     if (!p || !e || e < p)

  005e2	48 85 f6	 test	 rsi, rsi
  005e5	0f 84 ca 04 00
	00		 je	 $LN557@sre_match
  005eb	4d 85 e4	 test	 r12, r12
  005ee	0f 84 c1 04 00
	00		 je	 $LN557@sre_match
  005f4	49 3b f4	 cmp	 rsi, r12
  005f7	0f 87 b8 04 00
	00		 ja	 $LN557@sre_match

; 1341 :                         RETURN_FAILURE;
; 1342 :                     while (p < e) {

  005fd	73 3a		 jae	 SHORT $LN96@sre_match
  005ff	90		 npad	 1
$LL97@sre_match:

; 1343 :                         if (ctx->ptr >= end ||
; 1344 :                             state->lower(SRE_CHARGET(state, ctx->ptr, 0)) !=
; 1345 :                             state->lower(SRE_CHARGET(state, p, 0)))

  00600	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00604	49 3b c6	 cmp	 rax, r14
  00607	0f 83 a8 04 00
	00		 jae	 $LN557@sre_match
  0060d	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00610	ff 95 00 07 00
	00		 call	 QWORD PTR [rbp+1792]
  00616	0f b6 0e	 movzx	 ecx, BYTE PTR [rsi]
  00619	8b d8		 mov	 ebx, eax
  0061b	ff 95 00 07 00
	00		 call	 QWORD PTR [rbp+1792]
  00621	3b d8		 cmp	 ebx, eax
  00623	0f 85 8c 04 00
	00		 jne	 $LN557@sre_match

; 1346 :                             RETURN_FAILURE;
; 1347 :                         p += state->charsize;

  00629	48 63 45 3c	 movsxd	 rax, DWORD PTR [rbp+60]

; 1348 :                         ctx->ptr += state->charsize;

  0062d	48 01 47 10	 add	 QWORD PTR [rdi+16], rax
  00631	48 03 f0	 add	 rsi, rax
  00634	49 3b f4	 cmp	 rsi, r12
  00637	72 c7		 jb	 SHORT $LL97@sre_match
$LN96@sre_match:

; 1349 :                     }
; 1350 :                 }
; 1351 :             }
; 1352 :             ctx->pattern++;

  00639	48 83 47 18 04	 add	 QWORD PTR [rdi+24], 4

; 1353 :             break;

  0063e	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:__ImageBase
  00645	e9 87 fa ff ff	 jmp	 $LN703@sre_match
$LN90@sre_match:

; 1354 : 
; 1355 :         case SRE_OP_GROUPREF_EXISTS:
; 1356 :             TRACE(("|%p|%p|GROUPREF_EXISTS %d\n", ctx->pattern,
; 1357 :                    ctx->ptr, ctx->pattern[0]));
; 1358 :             /* <GROUPREF_EXISTS> <group> <skip> codeyes <JUMP> codeno ... */
; 1359 :             i = ctx->pattern[0];
; 1360 :             {
; 1361 :                 Py_ssize_t groupref = i+i;

  0064a	41 8b 01	 mov	 eax, DWORD PTR [r9]
  0064d	48 03 c0	 add	 rax, rax

; 1362 :                 if (groupref >= state->lastmark) {

  00650	48 3b 45 48	 cmp	 rax, QWORD PTR [rbp+72]
  00654	7c 0d		 jl	 SHORT $LN89@sre_match
$LN86@sre_match:

; 1363 :                     ctx->pattern += ctx->pattern[1];

  00656	41 8b 41 04	 mov	 eax, DWORD PTR [r9+4]
  0065a	49 8d 0c 81	 lea	 rcx, QWORD PTR [r9+rax*4]

; 1364 :                     break;

  0065e	e9 6a fa ff ff	 jmp	 $LN985@sre_match
$LN89@sre_match:

; 1365 :                 } else {
; 1366 :                     SRE_CHAR* p = (SRE_CHAR*) state->mark[groupref];

  00663	48 8b 54 c5 50	 mov	 rdx, QWORD PTR [rbp+rax*8+80]

; 1367 :                     SRE_CHAR* e = (SRE_CHAR*) state->mark[groupref+1];

  00668	48 8b 4c c5 58	 mov	 rcx, QWORD PTR [rbp+rax*8+88]

; 1368 :                     if (!p || !e || e < p) {

  0066d	48 85 d2	 test	 rdx, rdx
  00670	74 e4		 je	 SHORT $LN86@sre_match
  00672	48 85 c9	 test	 rcx, rcx
  00675	74 df		 je	 SHORT $LN86@sre_match
  00677	48 3b ca	 cmp	 rcx, rdx
  0067a	72 da		 jb	 SHORT $LN86@sre_match

; 1369 :                         ctx->pattern += ctx->pattern[1];
; 1370 :                         break;
; 1371 :                     }
; 1372 :                 }
; 1373 :             }
; 1374 :             ctx->pattern += 2;

  0067c	49 8d 41 08	 lea	 rax, QWORD PTR [r9+8]
  00680	48 89 47 18	 mov	 QWORD PTR [rdi+24], rax

; 1375 :             break;

  00684	e9 48 fa ff ff	 jmp	 $LN703@sre_match
$LN85@sre_match:

; 1376 : 
; 1377 :         case SRE_OP_ASSERT:
; 1378 :             /* assert subpattern */
; 1379 :             /* <ASSERT> <skip> <back> <pattern> */
; 1380 :             TRACE(("|%p|%p|ASSERT %d\n", ctx->pattern,
; 1381 :                    ctx->ptr, ctx->pattern[1]));
; 1382 :             state->ptr = ctx->ptr - state->charsize * ctx->pattern[1];

  00689	41 8b 49 04	 mov	 ecx, DWORD PTR [r9+4]
  0068d	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00691	0f af 4d 3c	 imul	 ecx, DWORD PTR [rbp+60]
  00695	48 2b c1	 sub	 rax, rcx
  00698	48 89 45 00	 mov	 QWORD PTR [rbp], rax

; 1383 :             if (state->ptr < state->beginning)

  0069c	48 3b 45 08	 cmp	 rax, QWORD PTR [rbp+8]
  006a0	0f 82 9a 00 00
	00		 jb	 $LL30@sre_match

; 1384 :                 RETURN_FAILURE;
; 1385 :             DO_JUMP(JUMP_ASSERT, jump_assert, ctx->pattern+2);

  006a6	48 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [rbp+1696]
  006ad	48 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [rbp+1688]
  006b4	48 2b c3	 sub	 rax, rbx
  006b7	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  006bb	73 27		 jae	 SHORT $LN72@sre_match
  006bd	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  006c2	48 8b cd	 mov	 rcx, rbp
  006c5	e8 00 00 00 00	 call	 data_stack_grow
  006ca	85 c0		 test	 eax, eax
  006cc	0f 88 1f 0c 00
	00		 js	 $LN957@sre_match
  006d2	49 83 fd ff	 cmp	 r13, -1
  006d6	74 0c		 je	 SHORT $LN72@sre_match
  006d8	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  006df	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN72@sre_match:
  006e4	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  006eb	48 83 85 a0 06
	00 00 40	 add	 QWORD PTR [rbp+1696], 64 ; 00000040H
  006f3	48 c7 44 03 08
	0c 00 00 00	 mov	 QWORD PTR [rbx+rax+8], 12
  006fc	48 8d 0c 03	 lea	 rcx, QWORD PTR [rbx+rax]
  00700	e9 b2 07 00 00	 jmp	 $LN986@sre_match
$LN55@sre_match:

; 1387 :             ctx->pattern += ctx->pattern[0];
; 1388 :             break;
; 1389 : 
; 1390 :         case SRE_OP_ASSERT_NOT:
; 1391 :             /* assert not subpattern */
; 1392 :             /* <ASSERT_NOT> <skip> <back> <pattern> */
; 1393 :             TRACE(("|%p|%p|ASSERT_NOT %d\n", ctx->pattern,
; 1394 :                    ctx->ptr, ctx->pattern[1]));
; 1395 :             state->ptr = ctx->ptr - state->charsize * ctx->pattern[1];

  00705	41 8b 49 04	 mov	 ecx, DWORD PTR [r9+4]
  00709	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  0070d	0f af 4d 3c	 imul	 ecx, DWORD PTR [rbp+60]
  00711	48 2b c1	 sub	 rax, rcx
  00714	48 89 45 00	 mov	 QWORD PTR [rbp], rax

; 1396 :             if (state->ptr >= state->beginning) {

  00718	48 3b 45 08	 cmp	 rax, QWORD PTR [rbp+8]
  0071c	0f 83 3b 07 00
	00		 jae	 $LN947@sre_match
$LN32@sre_match:

; 1400 :                     RETURN_FAILURE;
; 1401 :                 }
; 1402 :             }
; 1403 :             ctx->pattern += ctx->pattern[0];

  00722	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00726	8b 01		 mov	 eax, DWORD PTR [rcx]
  00728	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]

; 1415 :         }
; 1416 :     }

  0072c	e9 9c f9 ff ff	 jmp	 $LN985@sre_match
$LN990@sre_match:

; 1299 :             state->ptr = ctx->ptr;

  00731	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00735	48 89 45 00	 mov	 QWORD PTR [rbp], rax
  00739	0f 1f 80 00 00
	00 00		 npad	 7
$LL30@sre_match:

; 1404 :             break;
; 1405 : 
; 1406 :         case SRE_OP_FAILURE:
; 1407 :             /* immediate failure */
; 1408 :             TRACE(("|%p|%p|FAILURE\n", ctx->pattern, ctx->ptr));
; 1409 :             RETURN_FAILURE;

  00740	33 db		 xor	 ebx, ebx
$exit$20811:

; 1417 : 
; 1418 : exit:
; 1419 :     ctx_pos = ctx->last_ctx_pos;

  00742	4c 8b 2f	 mov	 r13, QWORD PTR [rdi]

; 1420 :     jump = ctx->jump;

  00745	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]

; 1421 :     DATA_POP_DISCARD(ctx);

  00749	48 83 85 a0 06
	00 00 c0	 add	 QWORD PTR [rbp+1696], -64 ; ffffffffffffffc0H
  00751	4c 8b 8d a0 06
	00 00		 mov	 r9, QWORD PTR [rbp+1696]

; 1422 :     if (ctx_pos == -1)

  00758	49 83 fd ff	 cmp	 r13, -1
  0075c	0f 84 3c 06 00
	00		 je	 $LN927@sre_match

; 1424 :     DATA_LOOKUP_AT(SRE_MATCH_CONTEXT, ctx, ctx_pos);

  00762	48 8b 95 90 06
	00 00		 mov	 rdx, QWORD PTR [rbp+1680]

; 1425 : 
; 1426 :     switch (jump) {

  00769	48 ff c8	 dec	 rax
  0076c	4a 8d 3c 2a	 lea	 rdi, QWORD PTR [rdx+r13]
  00770	48 83 f8 0c	 cmp	 rax, 12
  00774	0f 87 24 06 00
	00		 ja	 $LN927@sre_match
  0077a	8b 84 86 00 00
	00 00		 mov	 eax, DWORD PTR $LN972@sre_match[rsi+rax*4]
  00781	48 03 c6	 add	 rax, rsi
  00784	ff e0		 jmp	 rax
$jump_max_until_2$21342:

; 1217 :                 DATA_POP(&ctx->u.rep->last_ptr);

  00786	4a 8b 44 0a f8	 mov	 rax, QWORD PTR [rdx+r9-8]
  0078b	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  0078f	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  00793	48 83 85 a0 06
	00 00 f8	 add	 QWORD PTR [rbp+1696], -8
  0079b	48 8b 95 a0 06
	00 00		 mov	 rdx, QWORD PTR [rbp+1696]

; 1218 :                 if (ret) {

  007a2	48 85 db	 test	 rbx, rbx
  007a5	0f 84 26 07 00
	00		 je	 $LN269@sre_match

; 1219 :                     MARK_POP_DISCARD(ctx->lastmark);

  007ab	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  007af	48 85 c0	 test	 rax, rax
  007b2	0f 8e be 01 00
	00		 jle	 $LN587@sre_match
  007b8	48 c1 e0 03	 shl	 rax, 3
  007bc	48 2b d0	 sub	 rdx, rax
  007bf	48 83 ea 08	 sub	 rdx, 8
  007c3	48 89 95 a0 06
	00 00		 mov	 QWORD PTR [rbp+1696], rdx

; 1220 :                     RETURN_ON_ERROR(ret);
; 1221 :                     RETURN_SUCCESS;

  007ca	e9 a7 01 00 00	 jmp	 $LN587@sre_match
$jump_max_until_3$21398:

; 1233 :             RETURN_ON_SUCCESS(ret);

  007cf	48 85 db	 test	 rbx, rbx
  007d2	0f 88 c6 05 00
	00		 js	 $LN927@sre_match
  007d8	0f 8f a1 01 00
	00		 jg	 $LN992@sre_match

; 1234 :             state->repeat = ctx->u.rep;

  007de	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  007e2	48 89 85 f8 06
	00 00		 mov	 QWORD PTR [rbp+1784], rax

; 1235 :             state->ptr = ctx->ptr;
; 1236 :             RETURN_FAILURE;

  007e9	e9 43 ff ff ff	 jmp	 $LN990@sre_match
$jump_min_until_2$21477:

; 1272 :             if (ret) {

  007ee	48 85 db	 test	 rbx, rbx

; 1273 :                 RETURN_ON_ERROR(ret);
; 1274 :                 RETURN_SUCCESS;

  007f1	0f 85 82 01 00
	00		 jne	 $LN991@sre_match

; 1275 :             }
; 1276 : 
; 1277 :             state->repeat = ctx->u.rep;

  007f7	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  007fb	48 89 85 f8 06
	00 00		 mov	 QWORD PTR [rbp+1784], rax

; 1278 :             state->ptr = ctx->ptr;

  00802	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00806	48 89 45 00	 mov	 QWORD PTR [rbp], rax

; 1279 : 
; 1280 :             LASTMARK_RESTORE();

  0080a	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  0080e	48 89 45 48	 mov	 QWORD PTR [rbp+72], rax
  00812	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  00816	48 89 45 40	 mov	 QWORD PTR [rbp+64], rax

; 1281 : 
; 1282 :             if ((ctx->count >= (Py_ssize_t) ctx->u.rep->pattern[2]
; 1283 :                 && ctx->u.rep->pattern[2] != SRE_MAXREPEAT) ||
; 1284 :                 state->ptr == ctx->u.rep->last_ptr)

  0081a	48 8b 57 38	 mov	 rdx, QWORD PTR [rdi+56]
  0081e	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00822	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00825	48 39 4f 20	 cmp	 QWORD PTR [rdi+32], rcx
  00829	7c 09		 jl	 SHORT $LN168@sre_match
  0082b	83 f9 ff	 cmp	 ecx, -1			; ffffffffH
  0082e	0f 85 0c ff ff
	ff		 jne	 $LL30@sre_match
$LN168@sre_match:
  00834	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
  00838	48 39 45 00	 cmp	 QWORD PTR [rbp], rax
  0083c	0f 84 fe fe ff
	ff		 je	 $LL30@sre_match

; 1285 :                 RETURN_FAILURE;
; 1286 : 
; 1287 :             ctx->u.rep->count = ctx->count;

  00842	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00846	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  0084a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1288 :             /* zero-width match protection */
; 1289 :             DATA_PUSH(&ctx->u.rep->last_ptr);

  0084d	48 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [rbp+1688]
  00854	48 2b 85 a0 06
	00 00		 sub	 rax, QWORD PTR [rbp+1696]
  0085b	48 83 f8 08	 cmp	 rax, 8
  0085f	73 21		 jae	 SHORT $LN156@sre_match
  00861	ba 08 00 00 00	 mov	 edx, 8
  00866	48 8b cd	 mov	 rcx, rbp
  00869	e8 00 00 00 00	 call	 data_stack_grow
  0086e	85 c0		 test	 eax, eax
  00870	0f 88 7b 0a 00
	00		 js	 $LN957@sre_match
  00876	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  0087d	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN156@sre_match:
  00882	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00886	48 8b 95 a0 06
	00 00		 mov	 rdx, QWORD PTR [rbp+1696]
  0088d	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR [rbp+1680]
  00894	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00898	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax
  0089c	48 83 85 a0 06
	00 00 08	 add	 QWORD PTR [rbp+1696], 8

; 1290 :             ctx->u.rep->last_ptr = state->ptr;

  008a4	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  008a8	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  008ac	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1291 :             DO_JUMP(JUMP_MIN_UNTIL_3,jump_min_until_3,
; 1292 :                     ctx->u.rep->pattern+3);

  008b0	48 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [rbp+1696]
  008b7	48 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [rbp+1688]
  008be	48 2b c3	 sub	 rax, rbx
  008c1	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  008c5	73 21		 jae	 SHORT $LN147@sre_match
  008c7	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  008cc	48 8b cd	 mov	 rcx, rbp
  008cf	e8 00 00 00 00	 call	 data_stack_grow
  008d4	85 c0		 test	 eax, eax
  008d6	0f 88 15 0a 00
	00		 js	 $LN957@sre_match
  008dc	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  008e3	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN147@sre_match:
  008e8	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  008ef	48 83 85 a0 06
	00 00 40	 add	 QWORD PTR [rbp+1696], 64 ; 00000040H
  008f7	48 c7 44 03 08
	06 00 00 00	 mov	 QWORD PTR [rbx+rax+8], 6
  00900	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]
$LN988@sre_match:
  00904	4c 89 2a	 mov	 QWORD PTR [rdx], r13
  00907	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  0090b	4c 8b eb	 mov	 r13, rbx
  0090e	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00912	48 8b fa	 mov	 rdi, rdx
  00915	48 83 c1 0c	 add	 rcx, 12
  00919	48 89 4a 18	 mov	 QWORD PTR [rdx+24], rcx
  0091d	e9 6e f7 ff ff	 jmp	 $entrance$20804
$jump_min_until_3$21529:

; 1293 :             DATA_POP(&ctx->u.rep->last_ptr);

  00922	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00926	4a 8b 44 0a f8	 mov	 rax, QWORD PTR [rdx+r9-8]
  0092b	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  0092f	48 83 85 a0 06
	00 00 f8	 add	 QWORD PTR [rbp+1696], -8

; 1294 :             if (ret) {

  00937	48 85 db	 test	 rbx, rbx

; 1295 :                 RETURN_ON_ERROR(ret);
; 1296 :                 RETURN_SUCCESS;

  0093a	75 3d		 jne	 SHORT $LN991@sre_match
$LN130@sre_match:

; 1297 :             }
; 1298 :             ctx->u.rep->count = ctx->count-1;

  0093c	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  00940	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00944	48 ff c9	 dec	 rcx
  00947	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1300 :             RETURN_FAILURE;

  0094a	e9 e2 fd ff ff	 jmp	 $LN990@sre_match
$jump_branch$20956:

; 980  :                 if (ret) {

  0094f	48 85 db	 test	 rbx, rbx
  00952	74 35		 je	 SHORT $LN573@sre_match

; 981  :                     if (ctx->u.rep)

  00954	48 83 7f 38 00	 cmp	 QWORD PTR [rdi+56], 0
  00959	74 1b		 je	 SHORT $LN587@sre_match

; 982  :                         MARK_POP_DISCARD(ctx->lastmark);

  0095b	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  0095f	48 85 c0	 test	 rax, rax
  00962	7e 12		 jle	 SHORT $LN587@sre_match
  00964	48 c1 e0 03	 shl	 rax, 3
  00968	4c 2b c8	 sub	 r9, rax
  0096b	49 83 e9 08	 sub	 r9, 8
  0096f	4c 89 8d a0 06
	00 00		 mov	 QWORD PTR [rbp+1696], r9
$LN587@sre_match:

; 983  :                     RETURN_ON_ERROR(ret);

  00976	48 85 db	 test	 rbx, rbx
$LN991@sre_match:
  00979	0f 88 1f 04 00
	00		 js	 $LN927@sre_match
$LN992@sre_match:

; 984  :                     RETURN_SUCCESS;

  0097f	bb 01 00 00 00	 mov	 ebx, 1
  00984	e9 b9 fd ff ff	 jmp	 $exit$20811
$LN573@sre_match:

; 985  :                 }
; 986  :                 if (ctx->u.rep)

  00989	48 83 7f 38 00	 cmp	 QWORD PTR [rdi+56], 0
  0098e	74 22		 je	 SHORT $LN569@sre_match

; 987  :                     MARK_POP_KEEP(ctx->lastmark);

  00990	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00994	48 85 c0	 test	 rax, rax
  00997	7e 19		 jle	 SHORT $LN569@sre_match
  00999	48 c1 e0 03	 shl	 rax, 3
  0099d	48 8d 4d 50	 lea	 rcx, QWORD PTR [rbp+80]
  009a1	48 2b d0	 sub	 rdx, rax
  009a4	4c 8d 40 08	 lea	 r8, QWORD PTR [rax+8]
  009a8	4a 8d 54 0a f8	 lea	 rdx, QWORD PTR [rdx+r9-8]
  009ad	e8 00 00 00 00	 call	 memcpy
$LN569@sre_match:

; 988  :                 LASTMARK_RESTORE();

  009b2	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  009b6	48 89 45 48	 mov	 QWORD PTR [rbp+72], rax
  009ba	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  009be	48 89 45 40	 mov	 QWORD PTR [rbp+64], rax
$LN608@sre_match:

; 969  :             for (; ctx->pattern[0]; ctx->pattern += ctx->pattern[0]) {

  009c2	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  009c6	8b 01		 mov	 eax, DWORD PTR [rcx]
  009c8	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  009cc	48 89 4f 18	 mov	 QWORD PTR [rdi+24], rcx
$LN609@sre_match:
  009d0	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  009d4	83 39 00	 cmp	 DWORD PTR [rcx], 0
  009d7	0f 84 b3 00 00
	00		 je	 $LN607@sre_match

; 970  :                 if (ctx->pattern[1] == SRE_OP_LITERAL &&
; 971  :                     (ctx->ptr >= end ||
; 972  :                      (SRE_CODE) SRE_CHARGET(state, ctx->ptr, 0) != ctx->pattern[2]))

  009dd	8b 51 04	 mov	 edx, DWORD PTR [rcx+4]
  009e0	83 fa 13	 cmp	 edx, 19
  009e3	75 11		 jne	 SHORT $LN606@sre_match
  009e5	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  009e9	49 3b c6	 cmp	 rax, r14
  009ec	73 d4		 jae	 SHORT $LN608@sre_match
  009ee	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  009f1	3b 41 08	 cmp	 eax, DWORD PTR [rcx+8]

; 973  :                     continue;

  009f4	75 cc		 jne	 SHORT $LN608@sre_match
$LN606@sre_match:

; 974  :                 if (ctx->pattern[1] == SRE_OP_IN &&
; 975  :                     (ctx->ptr >= end ||
; 976  :                      !SRE_CHARSET(ctx->pattern + 3, (SRE_CODE) SRE_CHARGET(state, ctx->ptr, 0))))

  009f6	83 fa 0f	 cmp	 edx, 15
  009f9	75 19		 jne	 SHORT $LN604@sre_match
  009fb	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  009ff	49 3b c6	 cmp	 rax, r14
  00a02	73 be		 jae	 SHORT $LN608@sre_match
  00a04	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00a07	48 83 c1 0c	 add	 rcx, 12
  00a0b	e8 00 00 00 00	 call	 sre_charset
  00a10	85 c0		 test	 eax, eax
  00a12	74 ae		 je	 SHORT $LN608@sre_match
$LN604@sre_match:

; 977  :                     continue;
; 978  :                 state->ptr = ctx->ptr;

  00a14	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 979  :                 DO_JUMP(JUMP_BRANCH, jump_branch, ctx->pattern+1);

  00a18	48 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [rbp+1696]
  00a1f	48 89 45 00	 mov	 QWORD PTR [rbp], rax
  00a23	48 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [rbp+1688]
  00a2a	48 2b c3	 sub	 rax, rbx
  00a2d	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00a31	73 27		 jae	 SHORT $LN594@sre_match
  00a33	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00a38	48 8b cd	 mov	 rcx, rbp
  00a3b	e8 00 00 00 00	 call	 data_stack_grow
  00a40	85 c0		 test	 eax, eax
  00a42	0f 88 a9 08 00
	00		 js	 $LN957@sre_match
  00a48	49 83 fd ff	 cmp	 r13, -1
  00a4c	74 0c		 je	 SHORT $LN594@sre_match
  00a4e	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  00a55	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN594@sre_match:
  00a5a	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  00a61	48 83 85 a0 06
	00 00 40	 add	 QWORD PTR [rbp+1696], 64 ; 00000040H
  00a69	4c 89 2c 03	 mov	 QWORD PTR [rbx+rax], r13
  00a6d	48 8d 0c 03	 lea	 rcx, QWORD PTR [rbx+rax]
  00a71	4c 8b eb	 mov	 r13, rbx
  00a74	48 c7 41 08 0b
	00 00 00	 mov	 QWORD PTR [rcx+8], 11
  00a7c	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00a80	48 8b f9	 mov	 rdi, rcx
  00a83	48 83 c0 04	 add	 rax, 4
  00a87	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
  00a8b	e9 ef f5 ff ff	 jmp	 $LN987@sre_match
$LN607@sre_match:

; 989  :             }
; 990  :             if (ctx->u.rep)

  00a90	48 83 7f 38 00	 cmp	 QWORD PTR [rdi+56], 0
  00a95	74 1e		 je	 SHORT $LN557@sre_match

; 991  :                 MARK_POP_DISCARD(ctx->lastmark);

  00a97	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00a9b	48 85 c0	 test	 rax, rax
  00a9e	7e 15		 jle	 SHORT $LN557@sre_match
  00aa0	48 c1 e0 03	 shl	 rax, 3
  00aa4	48 c7 c1 f8 ff
	ff ff		 mov	 rcx, -8
  00aab	48 2b c8	 sub	 rcx, rax
  00aae	48 01 8d a0 06
	00 00		 add	 QWORD PTR [rbp+1696], rcx
$LN557@sre_match:

; 992  :             RETURN_FAILURE;

  00ab5	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:__ImageBase
  00abc	e9 7f fc ff ff	 jmp	 $LL30@sre_match
$jump_min_until_1$21441:
$jump_max_until_1$21272:

; 1258 :                 if (ret) {

  00ac1	48 85 db	 test	 rbx, rbx
  00ac4	0f 84 72 fe ff
	ff		 je	 $LN130@sre_match

; 1259 :                     RETURN_ON_ERROR(ret);
; 1260 :                     RETURN_SUCCESS;

  00aca	e9 aa fe ff ff	 jmp	 $LN991@sre_match
$jump_repeat$21232:

; 1163 :             state->repeat = ctx->u.rep->prev;

  00acf	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00ad3	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00ad7	48 89 8d f8 06
	00 00		 mov	 QWORD PTR [rbp+1784], rcx

; 1164 :             PyObject_FREE(ctx->u.rep);

  00ade	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00ae2	e8 00 00 00 00	 call	 PyObject_Free

; 1165 : 
; 1166 :             if (ret) {

  00ae7	48 85 db	 test	 rbx, rbx
  00aea	0f 84 50 fc ff
	ff		 je	 $LL30@sre_match

; 1167 :                 RETURN_ON_ERROR(ret);
; 1168 :                 RETURN_SUCCESS;

  00af0	e9 84 fe ff ff	 jmp	 $LN991@sre_match
$jump_repeat_one_1$21063:

; 1050 :                     if (ret) {

  00af5	48 85 db	 test	 rbx, rbx

; 1051 :                         RETURN_ON_ERROR(ret);
; 1052 :                         RETURN_SUCCESS;

  00af8	0f 85 7b fe ff
	ff		 jne	 $LN991@sre_match

; 1053 :                     }
; 1054 : 
; 1055 :                     LASTMARK_RESTORE();

  00afe	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00b02	48 89 45 48	 mov	 QWORD PTR [rbp+72], rax
  00b06	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  00b0a	48 89 45 40	 mov	 QWORD PTR [rbp+64], rax

; 1056 : 
; 1057 :                     ctx->ptr -= state->charsize;

  00b0e	48 63 45 3c	 movsxd	 rax, DWORD PTR [rbp+60]
  00b12	48 29 47 10	 sub	 QWORD PTR [rdi+16], rax

; 1058 :                     ctx->count--;

  00b16	48 ff 4f 20	 dec	 QWORD PTR [rdi+32]
$LN522@sre_match:

; 1038 :                 for (;;) {
; 1039 :                     while (ctx->count >= (Py_ssize_t) ctx->pattern[1] &&
; 1040 :                            (ctx->ptr >= end ||
; 1041 :                             SRE_CHARGET(state, ctx->ptr, 0) != ctx->u.chr)) {

  00b1a	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  00b1e	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  00b21	48 39 47 20	 cmp	 QWORD PTR [rdi+32], rax
  00b25	7c 29		 jl	 SHORT $LN974@sre_match
$LL520@sre_match:
  00b27	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00b2b	49 3b ce	 cmp	 rcx, r14
  00b2e	73 08		 jae	 SHORT $LN518@sre_match
  00b30	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00b33	3b 47 38	 cmp	 eax, DWORD PTR [rdi+56]
  00b36	74 18		 je	 SHORT $LN974@sre_match
$LN518@sre_match:

; 1042 :                         ctx->ptr -= state->charsize;

  00b38	48 63 45 3c	 movsxd	 rax, DWORD PTR [rbp+60]

; 1043 :                         ctx->count--;

  00b3c	48 ff 4f 20	 dec	 QWORD PTR [rdi+32]
  00b40	48 2b c8	 sub	 rcx, rax
  00b43	48 89 4f 10	 mov	 QWORD PTR [rdi+16], rcx
  00b47	8b 4a 04	 mov	 ecx, DWORD PTR [rdx+4]
  00b4a	48 39 4f 20	 cmp	 QWORD PTR [rdi+32], rcx
  00b4e	7d d7		 jge	 SHORT $LL520@sre_match
$LN974@sre_match:

; 1044 :                     }
; 1045 :                     if (ctx->count < (Py_ssize_t) ctx->pattern[1])

  00b50	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  00b53	48 39 47 20	 cmp	 QWORD PTR [rdi+32], rax
  00b57	0f 8c e3 fb ff
	ff		 jl	 $LL30@sre_match

; 1046 :                         break;
; 1047 :                     state->ptr = ctx->ptr;

  00b5d	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 1048 :                     DO_JUMP(JUMP_REPEAT_ONE_1, jump_repeat_one_1,
; 1049 :                             ctx->pattern+ctx->pattern[0]);

  00b61	48 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [rbp+1696]
  00b68	48 89 45 00	 mov	 QWORD PTR [rbp], rax
  00b6c	48 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [rbp+1688]
  00b73	48 2b c3	 sub	 rax, rbx
  00b76	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00b7a	73 27		 jae	 SHORT $LN508@sre_match
  00b7c	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00b81	48 8b cd	 mov	 rcx, rbp
  00b84	e8 00 00 00 00	 call	 data_stack_grow
  00b89	85 c0		 test	 eax, eax
  00b8b	0f 88 60 07 00
	00		 js	 $LN957@sre_match
  00b91	49 83 fd ff	 cmp	 r13, -1
  00b95	74 0c		 je	 SHORT $LN508@sre_match
  00b97	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  00b9e	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN508@sre_match:
  00ba3	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  00baa	48 83 85 a0 06
	00 00 40	 add	 QWORD PTR [rbp+1696], 64 ; 00000040H
  00bb2	4c 89 2c 03	 mov	 QWORD PTR [rbx+rax], r13
  00bb6	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]

; 1291 :             DO_JUMP(JUMP_MIN_UNTIL_3,jump_min_until_3,
; 1292 :                     ctx->u.rep->pattern+3);

  00bba	4c 8b eb	 mov	 r13, rbx
  00bbd	48 c7 42 08 08
	00 00 00	 mov	 QWORD PTR [rdx+8], 8
  00bc5	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00bc9	48 8b fa	 mov	 rdi, rdx
  00bcc	8b 01		 mov	 eax, DWORD PTR [rcx]
  00bce	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  00bd2	48 89 4a 18	 mov	 QWORD PTR [rdx+24], rcx
  00bd6	e9 b5 f4 ff ff	 jmp	 $entrance$20804
$jump_repeat_one_2$21101:

; 1067 :                     if (ret) {

  00bdb	48 85 db	 test	 rbx, rbx

; 1068 :                         RETURN_ON_ERROR(ret);
; 1069 :                         RETURN_SUCCESS;

  00bde	0f 85 95 fd ff
	ff		 jne	 $LN991@sre_match

; 1070 :                     }
; 1071 :                     ctx->ptr -= state->charsize;

  00be4	48 63 45 3c	 movsxd	 rax, DWORD PTR [rbp+60]
  00be8	48 29 47 10	 sub	 QWORD PTR [rdi+16], rax

; 1072 :                     ctx->count--;
; 1073 :                     LASTMARK_RESTORE();

  00bec	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00bf0	48 ff 4f 20	 dec	 QWORD PTR [rdi+32]
  00bf4	48 89 45 48	 mov	 QWORD PTR [rbp+72], rax
  00bf8	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  00bfc	48 89 45 40	 mov	 QWORD PTR [rbp+64], rax
$LN490@sre_match:

; 1059 :                 }
; 1060 : 
; 1061 :             } else {
; 1062 :                 /* general case */
; 1063 :                 while (ctx->count >= (Py_ssize_t) ctx->pattern[1]) {

  00c00	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00c04	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  00c07	48 39 4f 20	 cmp	 QWORD PTR [rdi+32], rcx
  00c0b	0f 8c 2f fb ff
	ff		 jl	 $LL30@sre_match

; 1064 :                     state->ptr = ctx->ptr;

  00c11	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 1065 :                     DO_JUMP(JUMP_REPEAT_ONE_2, jump_repeat_one_2,
; 1066 :                             ctx->pattern+ctx->pattern[0]);

  00c15	48 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [rbp+1696]
  00c1c	48 89 45 00	 mov	 QWORD PTR [rbp], rax
  00c20	48 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [rbp+1688]
  00c27	48 2b c3	 sub	 rax, rbx
  00c2a	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00c2e	73 27		 jae	 SHORT $LN480@sre_match
  00c30	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00c35	48 8b cd	 mov	 rcx, rbp
  00c38	e8 00 00 00 00	 call	 data_stack_grow
  00c3d	85 c0		 test	 eax, eax
  00c3f	0f 88 ac 06 00
	00		 js	 $LN957@sre_match
  00c45	49 83 fd ff	 cmp	 r13, -1
  00c49	74 0c		 je	 SHORT $LN480@sre_match
  00c4b	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  00c52	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN480@sre_match:
  00c57	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  00c5e	48 83 85 a0 06
	00 00 40	 add	 QWORD PTR [rbp+1696], 64 ; 00000040H
  00c66	4c 89 2c 03	 mov	 QWORD PTR [rbx+rax], r13
  00c6a	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]

; 1291 :             DO_JUMP(JUMP_MIN_UNTIL_3,jump_min_until_3,
; 1292 :                     ctx->u.rep->pattern+3);

  00c6e	4c 8b eb	 mov	 r13, rbx
  00c71	48 c7 42 08 09
	00 00 00	 mov	 QWORD PTR [rdx+8], 9
  00c79	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00c7d	48 8b fa	 mov	 rdi, rdx
  00c80	8b 01		 mov	 eax, DWORD PTR [rcx]
  00c82	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  00c86	48 89 4a 18	 mov	 QWORD PTR [rdx+24], rcx
  00c8a	e9 01 f4 ff ff	 jmp	 $entrance$20804
$jump_min_repeat_one$21176:

; 1124 :                     if (ret) {

  00c8f	48 85 db	 test	 rbx, rbx

; 1125 :                         RETURN_ON_ERROR(ret);
; 1126 :                         RETURN_SUCCESS;

  00c92	0f 85 e1 fc ff
	ff		 jne	 $LN991@sre_match

; 1127 :                     }
; 1128 :                     state->ptr = ctx->ptr;

  00c98	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 1129 :                     ret = SRE_COUNT(state, ctx->pattern+3, 1);

  00c9c	44 8d 43 01	 lea	 r8d, QWORD PTR [rbx+1]
  00ca0	48 8b cd	 mov	 rcx, rbp
  00ca3	48 89 45 00	 mov	 QWORD PTR [rbp], rax
  00ca7	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  00cab	48 83 c2 0c	 add	 rdx, 12
  00caf	e8 00 00 00 00	 call	 sre_count

; 1130 :                     RETURN_ON_ERROR(ret);

  00cb4	48 85 c0	 test	 rax, rax
  00cb7	0f 88 45 06 00
	00		 js	 $LN977@sre_match

; 1131 :                     DATA_LOOKUP_AT(SRE_MATCH_CONTEXT, ctx, ctx_pos);

  00cbd	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR [rbp+1680]
  00cc4	49 8d 7c 0d 00	 lea	 rdi, QWORD PTR [r13+rcx]

; 1132 :                     if (ret == 0)

  00cc9	0f 84 71 fa ff
	ff		 je	 $LL30@sre_match

; 1133 :                         break;
; 1134 :                     assert(ret == 1);
; 1135 :                     ctx->ptr += state->charsize;

  00ccf	48 63 45 3c	 movsxd	 rax, DWORD PTR [rbp+60]
  00cd3	48 01 47 10	 add	 QWORD PTR [rdi+16], rax

; 1136 :                     ctx->count++;
; 1137 :                     LASTMARK_RESTORE();

  00cd7	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00cdb	48 ff 47 20	 inc	 QWORD PTR [rdi+32]
  00cdf	48 89 45 48	 mov	 QWORD PTR [rbp+72], rax
  00ce3	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  00ce7	48 89 45 40	 mov	 QWORD PTR [rbp+64], rax
$LN431@sre_match:

; 1119 :                 while ((Py_ssize_t)ctx->pattern[2] == SRE_MAXREPEAT
; 1120 :                        || ctx->count <= (Py_ssize_t)ctx->pattern[2]) {

  00ceb	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00cef	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00cf2	83 f9 ff	 cmp	 ecx, -1			; ffffffffH
  00cf5	74 0a		 je	 SHORT $LN941@sre_match
  00cf7	48 39 4f 20	 cmp	 QWORD PTR [rdi+32], rcx
  00cfb	0f 8f 3f fa ff
	ff		 jg	 $LL30@sre_match
$LN941@sre_match:

; 1121 :                     state->ptr = ctx->ptr;

  00d01	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 1122 :                     DO_JUMP(JUMP_MIN_REPEAT_ONE,jump_min_repeat_one,
; 1123 :                             ctx->pattern+ctx->pattern[0]);

  00d05	48 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [rbp+1696]
  00d0c	48 89 45 00	 mov	 QWORD PTR [rbp], rax
  00d10	48 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [rbp+1688]
  00d17	48 2b c3	 sub	 rax, rbx
  00d1a	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00d1e	73 27		 jae	 SHORT $LN420@sre_match
  00d20	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00d25	48 8b cd	 mov	 rcx, rbp
  00d28	e8 00 00 00 00	 call	 data_stack_grow
  00d2d	85 c0		 test	 eax, eax
  00d2f	0f 88 bc 05 00
	00		 js	 $LN957@sre_match
  00d35	49 83 fd ff	 cmp	 r13, -1
  00d39	74 0c		 je	 SHORT $LN420@sre_match
  00d3b	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  00d42	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN420@sre_match:
  00d47	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  00d4e	48 83 85 a0 06
	00 00 40	 add	 QWORD PTR [rbp+1696], 64 ; 00000040H
  00d56	4c 89 2c 03	 mov	 QWORD PTR [rbx+rax], r13
  00d5a	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]

; 1291 :             DO_JUMP(JUMP_MIN_UNTIL_3,jump_min_until_3,
; 1292 :                     ctx->u.rep->pattern+3);

  00d5e	4c 8b eb	 mov	 r13, rbx
  00d61	48 c7 42 08 0a
	00 00 00	 mov	 QWORD PTR [rdx+8], 10
  00d69	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00d6d	48 8b fa	 mov	 rdi, rdx
  00d70	8b 01		 mov	 eax, DWORD PTR [rcx]
  00d72	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  00d76	48 89 4a 18	 mov	 QWORD PTR [rdx+24], rcx
  00d7a	e9 11 f3 ff ff	 jmp	 $entrance$20804
$jump_assert$21633:

; 1386 :             RETURN_ON_FAILURE(ret);

  00d7f	48 85 db	 test	 rbx, rbx
  00d82	78 1a		 js	 SHORT $LN927@sre_match
  00d84	0f 85 98 f9 ff
	ff		 jne	 $LN32@sre_match
  00d8a	e9 b1 f9 ff ff	 jmp	 $LL30@sre_match
$jump_assert_not$21668:

; 1398 :                 if (ret) {

  00d8f	48 85 db	 test	 rbx, rbx
  00d92	0f 84 8a f9 ff
	ff		 je	 $LN32@sre_match

; 1399 :                     RETURN_ON_ERROR(ret);

  00d98	0f 89 a2 f9 ff
	ff		 jns	 $LL30@sre_match
$LN927@sre_match:

; 1423 :         return ret;

  00d9e	48 8b c3	 mov	 rax, rbx
  00da1	e9 5c 05 00 00	 jmp	 $LN977@sre_match
$LN385@sre_match:

; 1154 :             }
; 1155 :             ctx->u.rep->count = -1;

  00da6	48 c7 00 ff ff
	ff ff		 mov	 QWORD PTR [rax], -1

; 1156 :             ctx->u.rep->pattern = ctx->pattern;

  00dad	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00db1	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00db5	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1157 :             ctx->u.rep->prev = state->repeat;

  00db9	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00dbd	48 8b 85 f8 06
	00 00		 mov	 rax, QWORD PTR [rbp+1784]
  00dc4	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 1158 :             ctx->u.rep->last_ptr = NULL;

  00dc8	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00dcc	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 1159 :             state->repeat = ctx->u.rep;

  00dd4	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]

; 1160 : 
; 1161 :             state->ptr = ctx->ptr;
; 1162 :             DO_JUMP(JUMP_REPEAT, jump_repeat, ctx->pattern+ctx->pattern[0]);

  00dd8	48 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [rbp+1696]
  00ddf	48 89 85 f8 06
	00 00		 mov	 QWORD PTR [rbp+1784], rax
  00de6	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00dea	48 89 45 00	 mov	 QWORD PTR [rbp], rax
  00dee	48 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [rbp+1688]
  00df5	48 2b c3	 sub	 rax, rbx
  00df8	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00dfc	73 27		 jae	 SHORT $LN376@sre_match
  00dfe	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00e03	48 8b cd	 mov	 rcx, rbp
  00e06	e8 00 00 00 00	 call	 data_stack_grow
  00e0b	85 c0		 test	 eax, eax
  00e0d	0f 88 de 04 00
	00		 js	 $LN957@sre_match
  00e13	49 83 fd ff	 cmp	 r13, -1
  00e17	74 0c		 je	 SHORT $LN376@sre_match
  00e19	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  00e20	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN376@sre_match:
  00e25	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  00e2c	48 83 85 a0 06
	00 00 40	 add	 QWORD PTR [rbp+1696], 64 ; 00000040H
  00e34	4c 89 2c 03	 mov	 QWORD PTR [rbx+rax], r13
  00e38	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]

; 1291 :             DO_JUMP(JUMP_MIN_UNTIL_3,jump_min_until_3,
; 1292 :                     ctx->u.rep->pattern+3);

  00e3c	4c 8b eb	 mov	 r13, rbx
  00e3f	48 c7 42 08 07
	00 00 00	 mov	 QWORD PTR [rdx+8], 7
  00e47	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00e4b	48 8b fa	 mov	 rdi, rdx
  00e4e	8b 01		 mov	 eax, DWORD PTR [rcx]
  00e50	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  00e54	48 89 4a 18	 mov	 QWORD PTR [rdx+24], rcx
  00e58	e9 33 f2 ff ff	 jmp	 $entrance$20804
$LN947@sre_match:

; 1397 :                 DO_JUMP(JUMP_ASSERT_NOT, jump_assert_not, ctx->pattern+2);

  00e5d	48 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [rbp+1696]
  00e64	48 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [rbp+1688]
  00e6b	48 2b c3	 sub	 rax, rbx
  00e6e	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00e72	73 27		 jae	 SHORT $LN45@sre_match
  00e74	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00e79	48 8b cd	 mov	 rcx, rbp
  00e7c	e8 00 00 00 00	 call	 data_stack_grow
  00e81	85 c0		 test	 eax, eax
  00e83	0f 88 68 04 00
	00		 js	 $LN957@sre_match
  00e89	49 83 fd ff	 cmp	 r13, -1
  00e8d	74 0c		 je	 SHORT $LN45@sre_match
  00e8f	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  00e96	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN45@sre_match:
  00e9b	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  00ea2	48 83 85 a0 06
	00 00 40	 add	 QWORD PTR [rbp+1696], 64 ; 00000040H
  00eaa	48 c7 44 03 08
	0d 00 00 00	 mov	 QWORD PTR [rbx+rax+8], 13
  00eb3	48 8d 0c 03	 lea	 rcx, QWORD PTR [rbx+rax]
$LN986@sre_match:
  00eb7	4c 89 29	 mov	 QWORD PTR [rcx], r13
  00eba	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00ebe	4c 8b eb	 mov	 r13, rbx
  00ec1	48 83 c0 08	 add	 rax, 8
  00ec5	48 8b f9	 mov	 rdi, rcx
  00ec8	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
  00ecc	e9 bf f1 ff ff	 jmp	 $entrance$20804
$LN269@sre_match:

; 1222 :                 }
; 1223 :                 MARK_POP(ctx->lastmark);

  00ed1	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  00ed5	48 85 c9	 test	 rcx, rcx
  00ed8	7e 39		 jle	 SHORT $LN262@sre_match
  00eda	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  00ee1	48 c1 e1 03	 shl	 rcx, 3
  00ee5	48 2b c1	 sub	 rax, rcx
  00ee8	4c 8d 41 08	 lea	 r8, QWORD PTR [rcx+8]
  00eec	48 8d 4d 50	 lea	 rcx, QWORD PTR [rbp+80]
  00ef0	48 8d 54 10 f8	 lea	 rdx, QWORD PTR [rax+rdx-8]
  00ef5	e8 00 00 00 00	 call	 memcpy
  00efa	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  00efe	48 c7 c0 f8 ff
	ff ff		 mov	 rax, -8
  00f05	48 c1 e1 03	 shl	 rcx, 3
  00f09	48 2b c1	 sub	 rax, rcx
  00f0c	48 01 85 a0 06
	00 00		 add	 QWORD PTR [rbp+1696], rax
$LN262@sre_match:

; 1224 :                 LASTMARK_RESTORE();

  00f13	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00f17	48 89 45 48	 mov	 QWORD PTR [rbp+72], rax
  00f1b	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  00f1f	48 89 45 40	 mov	 QWORD PTR [rbp+64], rax

; 1225 :                 ctx->u.rep->count = ctx->count-1;

  00f23	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  00f27	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00f2b	48 ff c9	 dec	 rcx
  00f2e	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1226 :                 state->ptr = ctx->ptr;

  00f31	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00f35	48 89 45 00	 mov	 QWORD PTR [rbp], rax
$LN328@sre_match:

; 1227 :             }
; 1228 : 
; 1229 :             /* cannot match more repeated items here.  make sure the
; 1230 :                tail matches */
; 1231 :             state->repeat = ctx->u.rep->prev;

  00f39	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]

; 1232 :             DO_JUMP(JUMP_MAX_UNTIL_3, jump_max_until_3, ctx->pattern);

  00f3d	48 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [rbp+1696]
  00f44	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00f48	48 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [rbp+1688]
  00f4f	48 2b c3	 sub	 rax, rbx
  00f52	48 89 8d f8 06
	00 00		 mov	 QWORD PTR [rbp+1784], rcx
  00f59	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00f5d	73 27		 jae	 SHORT $LN249@sre_match
  00f5f	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00f64	48 8b cd	 mov	 rcx, rbp
  00f67	e8 00 00 00 00	 call	 data_stack_grow
  00f6c	85 c0		 test	 eax, eax
  00f6e	0f 88 7d 03 00
	00		 js	 $LN957@sre_match
  00f74	49 83 fd ff	 cmp	 r13, -1
  00f78	74 0c		 je	 SHORT $LN249@sre_match
  00f7a	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  00f81	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN249@sre_match:
  00f86	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  00f8d	48 83 85 a0 06
	00 00 40	 add	 QWORD PTR [rbp+1696], 64 ; 00000040H
  00f95	4c 89 2c 03	 mov	 QWORD PTR [rbx+rax], r13
  00f99	48 8d 0c 03	 lea	 rcx, QWORD PTR [rbx+rax]

; 1397 :                 DO_JUMP(JUMP_ASSERT_NOT, jump_assert_not, ctx->pattern+2);

  00f9d	4c 8b eb	 mov	 r13, rbx
  00fa0	48 c7 41 08 03
	00 00 00	 mov	 QWORD PTR [rcx+8], 3
  00fa8	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00fac	48 8b f9	 mov	 rdi, rcx
  00faf	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
  00fb3	e9 d8 f0 ff ff	 jmp	 $entrance$20804
$LN360@sre_match:

; 1169 :             }
; 1170 :             RETURN_FAILURE;
; 1171 : 
; 1172 :         case SRE_OP_MAX_UNTIL:
; 1173 :             /* maximizing repeat */
; 1174 :             /* <REPEAT> <skip> <1=min> <2=max> item <MAX_UNTIL> tail */
; 1175 : 
; 1176 :             /* FIXME: we probably need to deal with zero-width
; 1177 :                matches in here... */
; 1178 : 
; 1179 :             ctx->u.rep = state->repeat;

  00fb8	48 8b 85 f8 06
	00 00		 mov	 rax, QWORD PTR [rbp+1784]
  00fbf	48 89 47 38	 mov	 QWORD PTR [rdi+56], rax

; 1180 :             if (!ctx->u.rep)

  00fc3	48 85 c0	 test	 rax, rax
  00fc6	0f 84 29 03 00
	00		 je	 $LN955@sre_match

; 1181 :                 RETURN_ERROR(SRE_ERROR_STATE);
; 1182 : 
; 1183 :             state->ptr = ctx->ptr;

  00fcc	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00fd0	48 89 45 00	 mov	 QWORD PTR [rbp], rax

; 1184 : 
; 1185 :             ctx->count = ctx->u.rep->count+1;

  00fd4	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00fd8	4c 8b 00	 mov	 r8, QWORD PTR [rax]

; 1186 : 
; 1187 :             TRACE(("|%p|%p|MAX_UNTIL %" PY_FORMAT_SIZE_T "d\n", ctx->pattern,
; 1188 :                    ctx->ptr, ctx->count));
; 1189 : 
; 1190 :             if (ctx->count < (Py_ssize_t) ctx->u.rep->pattern[1]) {

  00fdb	48 8b d0	 mov	 rdx, rax
  00fde	49 ff c0	 inc	 r8
  00fe1	4c 89 47 20	 mov	 QWORD PTR [rdi+32], r8
  00fe5	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00fe9	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  00fec	4c 3b c1	 cmp	 r8, rcx
  00fef	7d 62		 jge	 SHORT $LN329@sre_match

; 1191 :                 /* not enough matches */
; 1192 :                 ctx->u.rep->count = ctx->count;

  00ff1	4c 89 02	 mov	 QWORD PTR [rdx], r8

; 1193 :                 DO_JUMP(JUMP_MAX_UNTIL_1, jump_max_until_1,
; 1194 :                         ctx->u.rep->pattern+3);

  00ff4	48 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [rbp+1696]
  00ffb	48 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [rbp+1688]
  01002	48 2b c3	 sub	 rax, rbx
  01005	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  01009	73 27		 jae	 SHORT $LN345@sre_match
  0100b	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  01010	48 8b cd	 mov	 rcx, rbp
  01013	e8 00 00 00 00	 call	 data_stack_grow
  01018	85 c0		 test	 eax, eax
  0101a	0f 88 d1 02 00
	00		 js	 $LN957@sre_match
  01020	49 83 fd ff	 cmp	 r13, -1
  01024	74 0c		 je	 SHORT $LN345@sre_match
  01026	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  0102d	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN345@sre_match:
  01032	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  01039	48 83 85 a0 06
	00 00 40	 add	 QWORD PTR [rbp+1696], 64 ; 00000040H
  01041	48 c7 44 03 08
	01 00 00 00	 mov	 QWORD PTR [rbx+rax+8], 1
  0104a	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]
  0104e	e9 b1 f8 ff ff	 jmp	 $LN988@sre_match
$LN329@sre_match:

; 1195 :                 if (ret) {
; 1196 :                     RETURN_ON_ERROR(ret);
; 1197 :                     RETURN_SUCCESS;
; 1198 :                 }
; 1199 :                 ctx->u.rep->count = ctx->count-1;
; 1200 :                 state->ptr = ctx->ptr;
; 1201 :                 RETURN_FAILURE;
; 1202 :             }
; 1203 : 
; 1204 :             if ((ctx->count < (Py_ssize_t) ctx->u.rep->pattern[2] ||
; 1205 :                 ctx->u.rep->pattern[2] == SRE_MAXREPEAT) &&
; 1206 :                 state->ptr != ctx->u.rep->last_ptr) {

  01053	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  01056	4c 3b c1	 cmp	 r8, rcx
  01059	7c 09		 jl	 SHORT $LN327@sre_match
  0105b	83 f9 ff	 cmp	 ecx, -1			; ffffffffH
  0105e	0f 85 d5 fe ff
	ff		 jne	 $LN328@sre_match
$LN327@sre_match:
  01064	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
  01068	48 39 45 00	 cmp	 QWORD PTR [rbp], rax
  0106c	0f 84 c7 fe ff
	ff		 je	 $LN328@sre_match

; 1207 :                 /* we may have enough matches, but if we can
; 1208 :                    match another item, do so */
; 1209 :                 ctx->u.rep->count = ctx->count;

  01072	4c 89 02	 mov	 QWORD PTR [rdx], r8

; 1210 :                 LASTMARK_SAVE();

  01075	48 8b 5d 48	 mov	 rbx, QWORD PTR [rbp+72]
  01079	48 89 5f 28	 mov	 QWORD PTR [rdi+40], rbx
  0107d	48 8b 45 40	 mov	 rax, QWORD PTR [rbp+64]
  01081	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax

; 1211 :                 MARK_PUSH(ctx->lastmark);

  01085	48 85 db	 test	 rbx, rbx
  01088	7e 70		 jle	 SHORT $LN317@sre_match
  0108a	48 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [rbp+1688]
  01091	48 8d 34 dd 08
	00 00 00	 lea	 rsi, QWORD PTR [rbx*8+8]
  01099	48 2b 85 a0 06
	00 00		 sub	 rax, QWORD PTR [rbp+1696]
  010a0	48 3b f0	 cmp	 rsi, rax
  010a3	76 25		 jbe	 SHORT $LN311@sre_match
  010a5	48 8b d6	 mov	 rdx, rsi
  010a8	48 8b cd	 mov	 rcx, rbp
  010ab	e8 00 00 00 00	 call	 data_stack_grow
  010b0	85 c0		 test	 eax, eax
  010b2	0f 88 39 02 00
	00		 js	 $LN957@sre_match
  010b8	49 83 fd ff	 cmp	 r13, -1
  010bc	74 0c		 je	 SHORT $LN311@sre_match
  010be	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  010c5	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN311@sre_match:
  010ca	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR [rbp+1680]
  010d1	48 8d 55 50	 lea	 rdx, QWORD PTR [rbp+80]
  010d5	4c 8b c6	 mov	 r8, rsi
  010d8	48 03 8d a0 06
	00 00		 add	 rcx, QWORD PTR [rbp+1696]
  010df	e8 00 00 00 00	 call	 memcpy
  010e4	4c 8d 1c dd 08
	00 00 00	 lea	 r11, QWORD PTR [rbx*8+8]
  010ec	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:__ImageBase
  010f3	4c 01 9d a0 06
	00 00		 add	 QWORD PTR [rbp+1696], r11
$LN317@sre_match:

; 1212 :                 /* zero-width match protection */
; 1213 :                 DATA_PUSH(&ctx->u.rep->last_ptr);

  010fa	48 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [rbp+1688]
  01101	48 2b 85 a0 06
	00 00		 sub	 rax, QWORD PTR [rbp+1696]
  01108	48 83 f8 08	 cmp	 rax, 8
  0110c	73 27		 jae	 SHORT $LN302@sre_match
  0110e	ba 08 00 00 00	 mov	 edx, 8
  01113	48 8b cd	 mov	 rcx, rbp
  01116	e8 00 00 00 00	 call	 data_stack_grow
  0111b	85 c0		 test	 eax, eax
  0111d	0f 88 ce 01 00
	00		 js	 $LN957@sre_match
  01123	49 83 fd ff	 cmp	 r13, -1
  01127	74 0c		 je	 SHORT $LN302@sre_match
  01129	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  01130	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN302@sre_match:
  01135	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  01139	48 8b 95 a0 06
	00 00		 mov	 rdx, QWORD PTR [rbp+1696]
  01140	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR [rbp+1680]
  01147	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0114b	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax
  0114f	48 83 85 a0 06
	00 00 08	 add	 QWORD PTR [rbp+1696], 8

; 1214 :                 ctx->u.rep->last_ptr = state->ptr;

  01157	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  0115b	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  0115f	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1215 :                 DO_JUMP(JUMP_MAX_UNTIL_2, jump_max_until_2,
; 1216 :                         ctx->u.rep->pattern+3);

  01163	48 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [rbp+1696]
  0116a	48 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [rbp+1688]
  01171	48 2b c3	 sub	 rax, rbx
  01174	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  01178	73 27		 jae	 SHORT $LN293@sre_match
  0117a	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0117f	48 8b cd	 mov	 rcx, rbp
  01182	e8 00 00 00 00	 call	 data_stack_grow
  01187	85 c0		 test	 eax, eax
  01189	0f 88 62 01 00
	00		 js	 $LN957@sre_match
  0118f	49 83 fd ff	 cmp	 r13, -1
  01193	74 0c		 je	 SHORT $LN293@sre_match
  01195	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  0119c	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN293@sre_match:
  011a1	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  011a8	48 83 85 a0 06
	00 00 40	 add	 QWORD PTR [rbp+1696], 64 ; 00000040H
  011b0	48 c7 44 03 08
	02 00 00 00	 mov	 QWORD PTR [rbx+rax+8], 2
  011b9	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]
  011bd	e9 42 f7 ff ff	 jmp	 $LN988@sre_match
$LN230@sre_match:

; 1237 : 
; 1238 :         case SRE_OP_MIN_UNTIL:
; 1239 :             /* minimizing repeat */
; 1240 :             /* <REPEAT> <skip> <1=min> <2=max> item <MIN_UNTIL> tail */
; 1241 : 
; 1242 :             ctx->u.rep = state->repeat;

  011c2	48 8b 85 f8 06
	00 00		 mov	 rax, QWORD PTR [rbp+1784]
  011c9	48 89 47 38	 mov	 QWORD PTR [rdi+56], rax

; 1243 :             if (!ctx->u.rep)

  011cd	48 85 c0	 test	 rax, rax
  011d0	0f 84 1f 01 00
	00		 je	 $LN955@sre_match

; 1245 : 
; 1246 :             state->ptr = ctx->ptr;

  011d6	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  011da	48 89 45 00	 mov	 QWORD PTR [rbp], rax

; 1247 : 
; 1248 :             ctx->count = ctx->u.rep->count+1;

  011de	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  011e2	48 8b 10	 mov	 rdx, QWORD PTR [rax]

; 1249 : 
; 1250 :             TRACE(("|%p|%p|MIN_UNTIL %" PY_FORMAT_SIZE_T "d %p\n", ctx->pattern,
; 1251 :                    ctx->ptr, ctx->count, ctx->u.rep->pattern));
; 1252 : 
; 1253 :             if (ctx->count < (Py_ssize_t) ctx->u.rep->pattern[1]) {

  011e5	4c 8b c0	 mov	 r8, rax
  011e8	48 ff c2	 inc	 rdx
  011eb	48 89 57 20	 mov	 QWORD PTR [rdi+32], rdx
  011ef	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  011f3	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  011f6	48 3b d1	 cmp	 rdx, rcx
  011f9	7d 62		 jge	 SHORT $LN199@sre_match

; 1254 :                 /* not enough matches */
; 1255 :                 ctx->u.rep->count = ctx->count;

  011fb	49 89 10	 mov	 QWORD PTR [r8], rdx

; 1256 :                 DO_JUMP(JUMP_MIN_UNTIL_1, jump_min_until_1,
; 1257 :                         ctx->u.rep->pattern+3);

  011fe	48 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [rbp+1696]
  01205	48 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [rbp+1688]
  0120c	48 2b c3	 sub	 rax, rbx
  0120f	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  01213	73 27		 jae	 SHORT $LN215@sre_match
  01215	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0121a	48 8b cd	 mov	 rcx, rbp
  0121d	e8 00 00 00 00	 call	 data_stack_grow
  01222	85 c0		 test	 eax, eax
  01224	0f 88 c7 00 00
	00		 js	 $LN957@sre_match
  0122a	49 83 fd ff	 cmp	 r13, -1
  0122e	74 0c		 je	 SHORT $LN215@sre_match
  01230	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  01237	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN215@sre_match:
  0123c	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  01243	48 83 85 a0 06
	00 00 40	 add	 QWORD PTR [rbp+1696], 64 ; 00000040H
  0124b	48 c7 44 03 08
	04 00 00 00	 mov	 QWORD PTR [rbx+rax+8], 4
  01254	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]
  01258	e9 a7 f6 ff ff	 jmp	 $LN988@sre_match
$LN199@sre_match:

; 1261 :                 }
; 1262 :                 ctx->u.rep->count = ctx->count-1;
; 1263 :                 state->ptr = ctx->ptr;
; 1264 :                 RETURN_FAILURE;
; 1265 :             }
; 1266 : 
; 1267 :             LASTMARK_SAVE();

  0125d	48 8b 45 48	 mov	 rax, QWORD PTR [rbp+72]
  01261	48 89 47 28	 mov	 QWORD PTR [rdi+40], rax
  01265	48 8b 45 40	 mov	 rax, QWORD PTR [rbp+64]
  01269	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax

; 1268 : 
; 1269 :             /* see if the tail matches */
; 1270 :             state->repeat = ctx->u.rep->prev;

  0126d	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]

; 1271 :             DO_JUMP(JUMP_MIN_UNTIL_2, jump_min_until_2, ctx->pattern);

  01271	48 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [rbp+1696]
  01278	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0127c	48 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [rbp+1688]
  01283	48 2b c3	 sub	 rax, rbx
  01286	48 89 8d f8 06
	00 00		 mov	 QWORD PTR [rbp+1784], rcx
  0128d	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  01291	73 23		 jae	 SHORT $LN187@sre_match
  01293	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  01298	48 8b cd	 mov	 rcx, rbp
  0129b	e8 00 00 00 00	 call	 data_stack_grow
  012a0	85 c0		 test	 eax, eax
  012a2	78 4d		 js	 SHORT $LN957@sre_match
  012a4	49 83 fd ff	 cmp	 r13, -1
  012a8	74 0c		 je	 SHORT $LN187@sre_match
  012aa	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  012b1	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN187@sre_match:
  012b6	48 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [rbp+1680]
  012bd	48 83 85 a0 06
	00 00 40	 add	 QWORD PTR [rbp+1696], 64 ; 00000040H
  012c5	4c 89 2c 03	 mov	 QWORD PTR [rbx+rax], r13
  012c9	48 8d 0c 03	 lea	 rcx, QWORD PTR [rbx+rax]

; 1397 :                 DO_JUMP(JUMP_ASSERT_NOT, jump_assert_not, ctx->pattern+2);

  012cd	4c 8b eb	 mov	 r13, rbx
  012d0	48 c7 41 08 05
	00 00 00	 mov	 QWORD PTR [rcx+8], 5
  012d8	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  012dc	48 8b f9	 mov	 rdi, rcx
  012df	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
  012e3	e9 a8 ed ff ff	 jmp	 $entrance$20804
$LN943@sre_match:

; 820  :             RETURN_ERROR(SRE_ERROR_INTERRUPTED);

  012e8	48 c7 c0 f6 ff
	ff ff		 mov	 rax, -10
  012ef	eb 11		 jmp	 SHORT $LN977@sre_match
$LN957@sre_match:

; 1271 :             DO_JUMP(JUMP_MIN_UNTIL_2, jump_min_until_2, ctx->pattern);

  012f1	48 98		 cdqe
  012f3	eb 0d		 jmp	 SHORT $LN977@sre_match
$LN955@sre_match:

; 1244 :                 RETURN_ERROR(SRE_ERROR_STATE);

  012f5	48 c7 c0 fe ff
	ff ff		 mov	 rax, -2
  012fc	eb 04		 jmp	 SHORT $LN977@sre_match
$LN28@sre_match:

; 1410 : 
; 1411 :         default:
; 1412 :             TRACE(("|%p|%p|UNKNOWN %d\n", ctx->pattern, ctx->ptr,
; 1413 :                    ctx->pattern[-1]));
; 1414 :             RETURN_ERROR(SRE_ERROR_ILLEGAL);

  012fe	48 83 c8 ff	 or	 rax, -1
$LN977@sre_match:
  01302	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  01307	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0130c	4c 8b 64 24 60	 mov	 r12, QWORD PTR [rsp+96]

; 1427 :         case JUMP_MAX_UNTIL_2:
; 1428 :             TRACE(("|%p|%p|JUMP_MAX_UNTIL_2\n", ctx->pattern, ctx->ptr));
; 1429 :             goto jump_max_until_2;
; 1430 :         case JUMP_MAX_UNTIL_3:
; 1431 :             TRACE(("|%p|%p|JUMP_MAX_UNTIL_3\n", ctx->pattern, ctx->ptr));
; 1432 :             goto jump_max_until_3;
; 1433 :         case JUMP_MIN_UNTIL_2:
; 1434 :             TRACE(("|%p|%p|JUMP_MIN_UNTIL_2\n", ctx->pattern, ctx->ptr));
; 1435 :             goto jump_min_until_2;
; 1436 :         case JUMP_MIN_UNTIL_3:
; 1437 :             TRACE(("|%p|%p|JUMP_MIN_UNTIL_3\n", ctx->pattern, ctx->ptr));
; 1438 :             goto jump_min_until_3;
; 1439 :         case JUMP_BRANCH:
; 1440 :             TRACE(("|%p|%p|JUMP_BRANCH\n", ctx->pattern, ctx->ptr));
; 1441 :             goto jump_branch;
; 1442 :         case JUMP_MAX_UNTIL_1:
; 1443 :             TRACE(("|%p|%p|JUMP_MAX_UNTIL_1\n", ctx->pattern, ctx->ptr));
; 1444 :             goto jump_max_until_1;
; 1445 :         case JUMP_MIN_UNTIL_1:
; 1446 :             TRACE(("|%p|%p|JUMP_MIN_UNTIL_1\n", ctx->pattern, ctx->ptr));
; 1447 :             goto jump_min_until_1;
; 1448 :         case JUMP_REPEAT:
; 1449 :             TRACE(("|%p|%p|JUMP_REPEAT\n", ctx->pattern, ctx->ptr));
; 1450 :             goto jump_repeat;
; 1451 :         case JUMP_REPEAT_ONE_1:
; 1452 :             TRACE(("|%p|%p|JUMP_REPEAT_ONE_1\n", ctx->pattern, ctx->ptr));
; 1453 :             goto jump_repeat_one_1;
; 1454 :         case JUMP_REPEAT_ONE_2:
; 1455 :             TRACE(("|%p|%p|JUMP_REPEAT_ONE_2\n", ctx->pattern, ctx->ptr));
; 1456 :             goto jump_repeat_one_2;
; 1457 :         case JUMP_MIN_REPEAT_ONE:
; 1458 :             TRACE(("|%p|%p|JUMP_MIN_REPEAT_ONE\n", ctx->pattern, ctx->ptr));
; 1459 :             goto jump_min_repeat_one;
; 1460 :         case JUMP_ASSERT:
; 1461 :             TRACE(("|%p|%p|JUMP_ASSERT\n", ctx->pattern, ctx->ptr));
; 1462 :             goto jump_assert;
; 1463 :         case JUMP_ASSERT_NOT:
; 1464 :             TRACE(("|%p|%p|JUMP_ASSERT_NOT\n", ctx->pattern, ctx->ptr));
; 1465 :             goto jump_assert_not;
; 1466 :         case JUMP_NONE:
; 1467 :             TRACE(("|%p|%p|RETURN %" PY_FORMAT_SIZE_T "d\n", ctx->pattern,
; 1468 :                    ctx->ptr, ret));
; 1469 :             break;
; 1470 :     }
; 1471 : 
; 1472 :     return ret; /* should never get here */
; 1473 : }

  01311	48 83 c4 20	 add	 rsp, 32			; 00000020H
  01315	41 5f		 pop	 r15
  01317	41 5e		 pop	 r14
  01319	41 5d		 pop	 r13
  0131b	5d		 pop	 rbp
  0131c	5b		 pop	 rbx
  0131d	c3		 ret	 0
  0131e	66 90		 npad	 2
$LN973@sre_match:
  01320	00 00 00 00	 DD	 $LL30@sre_match
  01324	00 00 00 00	 DD	 $LN678@sre_match
  01328	00 00 00 00	 DD	 $LN663@sre_match
  0132c	00 00 00 00	 DD	 $LN657@sre_match
  01330	00 00 00 00	 DD	 $LN85@sre_match
  01334	00 00 00 00	 DD	 $LN55@sre_match
  01338	00 00 00 00	 DD	 $LN675@sre_match
  0133c	00 00 00 00	 DD	 $LL626@sre_match
  01340	00 00 00 00	 DD	 $LN28@sre_match
  01344	00 00 00 00	 DD	 $LN669@sre_match
  01348	00 00 00 00	 DD	 $LN28@sre_match
  0134c	00 00 00 00	 DD	 $LN28@sre_match
  01350	00 00 00 00	 DD	 $LN127@sre_match
  01354	00 00 00 00	 DD	 $LN90@sre_match
  01358	00 00 00 00	 DD	 $LN108@sre_match
  0135c	00 00 00 00	 DD	 $LN652@sre_match
  01360	00 00 00 00	 DD	 $LN634@sre_match
  01364	00 00 00 00	 DD	 $LN628@sre_match
  01368	00 00 00 00	 DD	 $LN628@sre_match
  0136c	00 00 00 00	 DD	 $LN690@sre_match
  01370	00 00 00 00	 DD	 $LN646@sre_match
  01374	00 00 00 00	 DD	 $LN695@sre_match
  01378	00 00 00 00	 DD	 $LN360@sre_match
  0137c	00 00 00 00	 DD	 $LN230@sre_match
  01380	00 00 00 00	 DD	 $LN684@sre_match
  01384	00 00 00 00	 DD	 $LN640@sre_match
  01388	00 00 00 00	 DD	 $LN28@sre_match
  0138c	00 00 00 00	 DD	 $LN28@sre_match
  01390	00 00 00 00	 DD	 $LN390@sre_match
  01394	00 00 00 00	 DD	 $LN550@sre_match
  01398	00 00 00 00	 DD	 $LN28@sre_match
  0139c	00 00 00 00	 DD	 $LN461@sre_match
$LN972@sre_match:
  013a0	00 00 00 00	 DD	 $jump_min_until_1$21441
  013a4	00 00 00 00	 DD	 $jump_max_until_2$21342
  013a8	00 00 00 00	 DD	 $jump_max_until_3$21398
  013ac	00 00 00 00	 DD	 $jump_min_until_1$21441
  013b0	00 00 00 00	 DD	 $jump_min_until_2$21477
  013b4	00 00 00 00	 DD	 $jump_min_until_3$21529
  013b8	00 00 00 00	 DD	 $jump_repeat$21232
  013bc	00 00 00 00	 DD	 $jump_repeat_one_1$21063
  013c0	00 00 00 00	 DD	 $jump_repeat_one_2$21101
  013c4	00 00 00 00	 DD	 $jump_min_repeat_one$21176
  013c8	00 00 00 00	 DD	 $jump_branch$20956
  013cc	00 00 00 00	 DD	 $jump_assert$21633
  013d0	00 00 00 00	 DD	 $jump_assert_not$21668
sre_match ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sre_search DD imagerel sre_search
	DD	imagerel sre_search+655
	DD	imagerel $unwind$sre_search
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sre_search DD 091501H
	DD	0f0114215H
	DD	0d00de00fH
	DD	07009c00bH
	DD	050076008H
	DD	03006H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT sre_search
_TEXT	SEGMENT
flags$1$ = 112
state$ = 112
pattern$ = 120
prefix_len$1$ = 128
prefix_skip$1$ = 136
sre_search PROC						; COMDAT

; 1477 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	41 57		 push	 r15
  00011	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1478 :     char* ptr = (char*)state->start;
; 1479 :     char* end = (char*)state->end;

  00015	48 8b 69 18	 mov	 rbp, QWORD PTR [rcx+24]
  00019	48 8b 59 10	 mov	 rbx, QWORD PTR [rcx+16]

; 1480 :     Py_ssize_t status = 0;

  0001d	33 f6		 xor	 esi, esi

; 1481 :     Py_ssize_t prefix_len = 0;
; 1482 :     Py_ssize_t prefix_skip = 0;
; 1483 :     SRE_CODE* prefix = NULL;
; 1484 :     SRE_CODE* charset = NULL;
; 1485 :     SRE_CODE* overlap = NULL;
; 1486 :     int flags = 0;
; 1487 : 
; 1488 :     if (pattern[0] == SRE_OP_INFO) {

  0001f	83 3a 11	 cmp	 DWORD PTR [rdx], 17
  00022	4c 8b c2	 mov	 r8, rdx
  00025	48 8b f9	 mov	 rdi, rcx
  00028	4c 8b ed	 mov	 r13, rbp
  0002b	44 8b ce	 mov	 r9d, esi
  0002e	48 89 b4 24 80
	00 00 00	 mov	 QWORD PTR prefix_len$1$[rsp], rsi
  00036	44 8b d6	 mov	 r10d, esi
  00039	48 89 b4 24 88
	00 00 00	 mov	 QWORD PTR prefix_skip$1$[rsp], rsi
  00041	44 8b f6	 mov	 r14d, esi
  00044	44 8b e6	 mov	 r12d, esi
  00047	44 8b fe	 mov	 r15d, esi
  0004a	44 8b de	 mov	 r11d, esi
  0004d	89 74 24 70	 mov	 DWORD PTR flags$1$[rsp], esi
  00051	0f 85 2a 01 00
	00		 jne	 $LN32@sre_search

; 1489 :         /* optimization info block */
; 1490 :         /* <INFO> <1=skip> <2=flags> <3=min> <4=max> <5=prefix info>  */
; 1491 : 
; 1492 :         flags = pattern[2];
; 1493 : 
; 1494 :         if (pattern[3] > 1) {

  00057	8b 42 0c	 mov	 eax, DWORD PTR [rdx+12]
  0005a	44 8b 5a 08	 mov	 r11d, DWORD PTR [rdx+8]
  0005e	44 89 5c 24 70	 mov	 DWORD PTR flags$1$[rsp], r11d
  00063	83 f8 01	 cmp	 eax, 1
  00066	76 15		 jbe	 SHORT $LN36@sre_search

; 1495 :             /* adjust end point (but make sure we leave at least one
; 1496 :                character in there, so literal search will work) */
; 1497 :             end -= (pattern[3]-1) * state->charsize;

  00068	48 63 49 3c	 movsxd	 rcx, DWORD PTR [rcx+60]
  0006c	ff c8		 dec	 eax
  0006e	0f af c1	 imul	 eax, ecx
  00071	4c 2b e8	 sub	 r13, rax

; 1498 :             if (end <= ptr)

  00074	4c 3b eb	 cmp	 r13, rbx
  00077	77 04		 ja	 SHORT $LN36@sre_search

; 1499 :                 end = ptr + state->charsize;

  00079	4c 8d 2c 0b	 lea	 r13, QWORD PTR [rbx+rcx]
$LN36@sre_search:

; 1500 :         }
; 1501 : 
; 1502 :         if (flags & SRE_INFO_PREFIX) {

  0007d	41 f6 c3 01	 test	 r11b, 1
  00081	74 23		 je	 SHORT $LN35@sre_search

; 1503 :             /* pattern starts with a known prefix */
; 1504 :             /* <length> <skip> <prefix data> <overlap data> */
; 1505 :             prefix_len = pattern[5];

  00083	44 8b 4a 14	 mov	 r9d, DWORD PTR [rdx+20]

; 1506 :             prefix_skip = pattern[6];

  00087	44 8b 52 18	 mov	 r10d, DWORD PTR [rdx+24]

; 1507 :             prefix = pattern + 7;

  0008b	4c 8d 72 1c	 lea	 r14, QWORD PTR [rdx+28]
  0008f	4c 89 8c 24 80
	00 00 00	 mov	 QWORD PTR prefix_len$1$[rsp], r9
  00097	4c 89 94 24 88
	00 00 00	 mov	 QWORD PTR prefix_skip$1$[rsp], r10

; 1508 :             overlap = prefix + prefix_len - 1;

  0009f	4f 8d 7c 8e fc	 lea	 r15, QWORD PTR [r14+r9*4-4]
  000a4	eb 0a		 jmp	 SHORT $LN33@sre_search
$LN35@sre_search:

; 1509 :         } else if (flags & SRE_INFO_CHARSET)

  000a6	41 f6 c3 04	 test	 r11b, 4
  000aa	74 04		 je	 SHORT $LN33@sre_search

; 1510 :             /* pattern starts with a character from a known set */
; 1511 :             /* <charset> */
; 1512 :             charset = pattern + 5;

  000ac	4c 8d 62 14	 lea	 r12, QWORD PTR [rdx+20]
$LN33@sre_search:

; 1513 : 
; 1514 :         pattern += 1 + pattern[1];

  000b0	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  000b3	ff c0		 inc	 eax
  000b5	4c 8d 04 82	 lea	 r8, QWORD PTR [rdx+rax*4]
  000b9	4c 89 44 24 78	 mov	 QWORD PTR pattern$[rsp], r8

; 1515 :     }
; 1516 : 
; 1517 :     TRACE(("prefix = %p %" PY_FORMAT_SIZE_T "d %" PY_FORMAT_SIZE_T "d\n",
; 1518 :            prefix, prefix_len, prefix_skip));
; 1519 :     TRACE(("charset = %p\n", charset));
; 1520 : 
; 1521 : #if defined(USE_FAST_SEARCH)
; 1522 :     if (prefix_len > 1) {

  000be	49 83 f9 01	 cmp	 r9, 1
  000c2	0f 8e b9 00 00
	00		 jle	 $LN32@sre_search

; 1523 :         /* pattern starts with a known prefix.  use the overlap
; 1524 :            table to skip forward as fast as we possibly can */
; 1525 :         Py_ssize_t i = 0;
; 1526 :         end = (char *)state->end;
; 1527 :         while (ptr < end) {

  000c8	48 3b dd	 cmp	 rbx, rbp
  000cb	0f 83 d8 00 00
	00		 jae	 $LN62@sre_search
$LL31@sre_search:

; 1528 :             for (;;) {
; 1529 :                 if ((SRE_CODE) SRE_CHARGET(state, ptr, 0) != prefix[i]) {

  000d1	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  000d4	48 8d 04 b5 00
	00 00 00	 lea	 rax, QWORD PTR [rsi*4]
  000dc	42 3b 0c 30	 cmp	 ecx, DWORD PTR [rax+r14]
  000e0	74 17		 je	 SHORT $LN27@sre_search
$LL29@sre_search:

; 1530 :                     if (!i)

  000e2	48 85 f6	 test	 rsi, rsi
  000e5	74 77		 je	 SHORT $LN23@sre_search

; 1531 :                         break;
; 1532 :                     else
; 1533 :                         i = overlap[i];

  000e7	42 8b 34 38	 mov	 esi, DWORD PTR [rax+r15]
  000eb	48 8d 04 b5 00
	00 00 00	 lea	 rax, QWORD PTR [rsi*4]
  000f3	42 3b 0c 30	 cmp	 ecx, DWORD PTR [rax+r14]
  000f7	75 e9		 jne	 SHORT $LL29@sre_search
$LN27@sre_search:

; 1534 :                 } else {
; 1535 :                     if (++i == prefix_len) {

  000f9	48 ff c6	 inc	 rsi
  000fc	49 3b f1	 cmp	 rsi, r9
  000ff	75 5d		 jne	 SHORT $LN23@sre_search

; 1536 :                         /* found a potential match */
; 1537 :                         TRACE(("|%p|%p|SEARCH SCAN\n", pattern, ptr));
; 1538 :                         state->start = ptr - (prefix_len - 1) * state->charsize;

  00101	48 63 57 3c	 movsxd	 rdx, DWORD PTR [rdi+60]
  00105	49 8d 49 ff	 lea	 rcx, QWORD PTR [r9-1]
  00109	48 8b c3	 mov	 rax, rbx
  0010c	48 0f af ca	 imul	 rcx, rdx
  00110	48 2b c1	 sub	 rax, rcx

; 1539 :                         state->ptr = ptr - (prefix_len - prefix_skip - 1) * state->charsize;

  00113	49 8b c9	 mov	 rcx, r9
  00116	49 2b ca	 sub	 rcx, r10
  00119	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax
  0011d	48 8b c3	 mov	 rax, rbx
  00120	48 ff c9	 dec	 rcx
  00123	48 0f af ca	 imul	 rcx, rdx
  00127	48 2b c1	 sub	 rax, rcx
  0012a	48 89 07	 mov	 QWORD PTR [rdi], rax

; 1540 :                         if (flags & SRE_INFO_LITERAL)

  0012d	41 f6 c3 02	 test	 r11b, 2
  00131	75 44		 jne	 SHORT $LN49@sre_search

; 1542 :                         status = SRE_MATCH(state, pattern + 2*prefix_skip);

  00133	4b 8d 14 d0	 lea	 rdx, QWORD PTR [r8+r10*8]
  00137	48 8b cf	 mov	 rcx, rdi
  0013a	e8 00 00 00 00	 call	 sre_match

; 1543 :                         if (status != 0)

  0013f	48 85 c0	 test	 rax, rax
  00142	0f 85 36 01 00
	00		 jne	 $LN39@sre_search

; 1544 :                             return status;
; 1545 :                         /* close but no cigar -- try again */
; 1546 :                         i = overlap[i];

  00148	41 8b 34 b7	 mov	 esi, DWORD PTR [r15+rsi*4]
  0014c	4c 8b 44 24 78	 mov	 r8, QWORD PTR pattern$[rsp]
  00151	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR prefix_len$1$[rsp]
  00159	44 8b 5c 24 70	 mov	 r11d, DWORD PTR flags$1$[rsp]
$LN23@sre_search:

; 1547 :                     }
; 1548 :                     break;
; 1549 :                 }
; 1550 :             }
; 1551 :             ptr += state->charsize;

  0015e	48 63 47 3c	 movsxd	 rax, DWORD PTR [rdi+60]
  00162	48 03 d8	 add	 rbx, rax
  00165	48 3b dd	 cmp	 rbx, rbp
  00168	73 3f		 jae	 SHORT $LN62@sre_search

; 1523 :         /* pattern starts with a known prefix.  use the overlap
; 1524 :            table to skip forward as fast as we possibly can */
; 1525 :         Py_ssize_t i = 0;
; 1526 :         end = (char *)state->end;
; 1527 :         while (ptr < end) {

  0016a	4c 8b 94 24 88
	00 00 00	 mov	 r10, QWORD PTR prefix_skip$1$[rsp]
  00172	e9 5a ff ff ff	 jmp	 $LL31@sre_search
$LN49@sre_search:

; 1541 :                             return 1; /* we got all of it */

  00177	b8 01 00 00 00	 mov	 eax, 1
  0017c	e9 fd 00 00 00	 jmp	 $LN39@sre_search
$LN32@sre_search:

; 1554 :     }
; 1555 : #endif
; 1556 : 
; 1557 :     if (pattern[0] == SRE_OP_LITERAL) {

  00181	41 83 38 13	 cmp	 DWORD PTR [r8], 19
  00185	75 66		 jne	 SHORT $LN20@sre_search

; 1558 :         /* pattern starts with a literal character.  this is used
; 1559 :            for short prefixes, and if fast search is disabled */
; 1560 :         SRE_CODE chr = pattern[1];

  00187	45 8b 60 04	 mov	 r12d, DWORD PTR [r8+4]
  0018b	0f 1f 44 00 00	 npad	 5
$LL19@sre_search:

; 1561 :         end = (char*)state->end;
; 1562 :         for (;;) {
; 1563 :             while (ptr < end && (SRE_CODE) SRE_CHARGET(state, ptr, 0) != chr)

  00190	48 3b dd	 cmp	 rbx, rbp
  00193	73 14		 jae	 SHORT $LN62@sre_search
$LL17@sre_search:
  00195	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00198	41 3b c4	 cmp	 eax, r12d
  0019b	74 13		 je	 SHORT $LN16@sre_search

; 1564 :                 ptr += state->charsize;

  0019d	48 63 47 3c	 movsxd	 rax, DWORD PTR [rdi+60]
  001a1	48 03 d8	 add	 rbx, rax
  001a4	48 3b dd	 cmp	 rbx, rbp
  001a7	72 ec		 jb	 SHORT $LL17@sre_search
$LN62@sre_search:

; 1552 :         }
; 1553 :         return 0;

  001a9	33 c0		 xor	 eax, eax
  001ab	e9 ce 00 00 00	 jmp	 $LN39@sre_search
$LN16@sre_search:

; 1565 :             if (ptr >= end)

  001b0	48 3b dd	 cmp	 rbx, rbp
  001b3	73 f4		 jae	 SHORT $LN62@sre_search

; 1566 :                 return 0;
; 1567 :             TRACE(("|%p|%p|SEARCH LITERAL\n", pattern, ptr));
; 1568 :             state->start = ptr;
; 1569 :             ptr += state->charsize;

  001b5	48 63 47 3c	 movsxd	 rax, DWORD PTR [rdi+60]
  001b9	48 89 5f 10	 mov	 QWORD PTR [rdi+16], rbx
  001bd	48 03 d8	 add	 rbx, rax

; 1570 :             state->ptr = ptr;

  001c0	48 89 1f	 mov	 QWORD PTR [rdi], rbx

; 1571 :             if (flags & SRE_INFO_LITERAL)

  001c3	41 f6 c3 02	 test	 r11b, 2
  001c7	75 ae		 jne	 SHORT $LN49@sre_search

; 1572 :                 return 1; /* we got all of it */
; 1573 :             status = SRE_MATCH(state, pattern + 2);

  001c9	49 8d 50 08	 lea	 rdx, QWORD PTR [r8+8]
  001cd	48 8b cf	 mov	 rcx, rdi
  001d0	e8 00 00 00 00	 call	 sre_match
  001d5	48 8b f0	 mov	 rsi, rax

; 1574 :             if (status != 0)

  001d8	48 85 c0	 test	 rax, rax
  001db	0f 85 9a 00 00
	00		 jne	 $LN63@sre_search

; 1575 :                 break;
; 1576 :         }

  001e1	4c 8b 44 24 78	 mov	 r8, QWORD PTR pattern$[rsp]
  001e6	44 8b 5c 24 70	 mov	 r11d, DWORD PTR flags$1$[rsp]
  001eb	eb a3		 jmp	 SHORT $LL19@sre_search
$LN20@sre_search:

; 1577 :     } else if (charset) {

  001ed	4d 85 e4	 test	 r12, r12
  001f0	74 55		 je	 SHORT $LN47@sre_search
  001f2	4c 8b 6c 24 78	 mov	 r13, QWORD PTR pattern$[rsp]
$LL10@sre_search:

; 1578 :         /* pattern starts with a character from a known set */
; 1579 :         end = (char*)state->end;
; 1580 :         for (;;) {
; 1581 :             while (ptr < end && !SRE_CHARSET(charset, SRE_CHARGET(state, ptr, 0)))

  001f7	48 3b dd	 cmp	 rbx, rbp
  001fa	73 ad		 jae	 SHORT $LN62@sre_search
  001fc	0f 1f 40 00	 npad	 4
$LL8@sre_search:
  00200	0f b6 13	 movzx	 edx, BYTE PTR [rbx]
  00203	49 8b cc	 mov	 rcx, r12
  00206	e8 00 00 00 00	 call	 sre_charset
  0020b	85 c0		 test	 eax, eax
  0020d	75 10		 jne	 SHORT $LN7@sre_search

; 1582 :                 ptr += state->charsize;

  0020f	48 63 47 3c	 movsxd	 rax, DWORD PTR [rdi+60]
  00213	48 03 d8	 add	 rbx, rax
  00216	48 3b dd	 cmp	 rbx, rbp
  00219	72 e5		 jb	 SHORT $LL8@sre_search

; 1552 :         }
; 1553 :         return 0;

  0021b	33 c0		 xor	 eax, eax
  0021d	eb 5f		 jmp	 SHORT $LN39@sre_search
$LN7@sre_search:

; 1583 :             if (ptr >= end)

  0021f	48 3b dd	 cmp	 rbx, rbp
  00222	73 85		 jae	 SHORT $LN62@sre_search

; 1584 :                 return 0;
; 1585 :             TRACE(("|%p|%p|SEARCH CHARSET\n", pattern, ptr));
; 1586 :             state->start = ptr;
; 1587 :             state->ptr = ptr;
; 1588 :             status = SRE_MATCH(state, pattern);

  00224	49 8b d5	 mov	 rdx, r13
  00227	48 8b cf	 mov	 rcx, rdi
  0022a	48 89 5f 10	 mov	 QWORD PTR [rdi+16], rbx
  0022e	48 89 1f	 mov	 QWORD PTR [rdi], rbx
  00231	e8 00 00 00 00	 call	 sre_match
  00236	48 8b f0	 mov	 rsi, rax

; 1589 :             if (status != 0)

  00239	48 85 c0	 test	 rax, rax
  0023c	75 3d		 jne	 SHORT $LN63@sre_search

; 1590 :                 break;
; 1591 :             ptr += state->charsize;

  0023e	48 63 47 3c	 movsxd	 rax, DWORD PTR [rdi+60]
  00242	48 03 d8	 add	 rbx, rax

; 1592 :         }

  00245	eb b0		 jmp	 SHORT $LL10@sre_search
$LN47@sre_search:

; 1593 :     } else
; 1594 :         /* general case */
; 1595 :         while (ptr <= end) {

  00247	49 3b dd	 cmp	 rbx, r13
  0024a	77 2f		 ja	 SHORT $LN63@sre_search
  0024c	0f 1f 40 00	 npad	 4
$LL3@sre_search:

; 1596 :             TRACE(("|%p|%p|SEARCH\n", pattern, ptr));
; 1597 :             state->start = state->ptr = ptr;
; 1598 :             ptr += state->charsize;

  00250	48 63 47 3c	 movsxd	 rax, DWORD PTR [rdi+60]
  00254	48 89 1f	 mov	 QWORD PTR [rdi], rbx
  00257	48 89 5f 10	 mov	 QWORD PTR [rdi+16], rbx

; 1599 :             status = SRE_MATCH(state, pattern);

  0025b	49 8b d0	 mov	 rdx, r8
  0025e	48 8b cf	 mov	 rcx, rdi
  00261	48 03 d8	 add	 rbx, rax
  00264	e8 00 00 00 00	 call	 sre_match
  00269	48 8b f0	 mov	 rsi, rax

; 1600 :             if (status != 0)

  0026c	48 85 c0	 test	 rax, rax
  0026f	75 0a		 jne	 SHORT $LN63@sre_search

; 1593 :     } else
; 1594 :         /* general case */
; 1595 :         while (ptr <= end) {

  00271	4c 8b 44 24 78	 mov	 r8, QWORD PTR pattern$[rsp]
  00276	49 3b dd	 cmp	 rbx, r13
  00279	76 d5		 jbe	 SHORT $LL3@sre_search
$LN63@sre_search:

; 1601 :                 break;
; 1602 :         }
; 1603 : 
; 1604 :     return status;

  0027b	48 8b c6	 mov	 rax, rsi
$LN39@sre_search:

; 1605 : }

  0027e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00282	41 5f		 pop	 r15
  00284	41 5e		 pop	 r14
  00286	41 5d		 pop	 r13
  00288	41 5c		 pop	 r12
  0028a	5f		 pop	 rdi
  0028b	5e		 pop	 rsi
  0028c	5d		 pop	 rbp
  0028d	5b		 pop	 rbx
  0028e	c3		 ret	 0
sre_search ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sre_uat DD imagerel sre_uat
	DD	imagerel sre_uat+2396
	DD	imagerel $unwind$sre_uat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sre_uat DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT sre_uat
_TEXT	SEGMENT
state$ = 48
ptr$ = 56
at$ = 64
sre_uat	PROC						; COMDAT

; 308  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001a	48 8b da	 mov	 rbx, rdx
  0001d	48 8b f1	 mov	 rsi, rcx

; 309  :     /* check if pointer is at given position */
; 310  : 
; 311  :     Py_ssize_t thisp, thatp;
; 312  : 
; 313  :     switch (at) {

  00020	41 83 f8 0b	 cmp	 r8d, 11
  00024	0f 87 e5 08 00
	00		 ja	 $LN18@sre_uat
  0002a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:__ImageBase
  00031	41 8b c0	 mov	 eax, r8d
  00034	41 8b 84 81 00
	00 00 00	 mov	 eax, DWORD PTR $LN281@sre_uat[r9+rax*4]
  0003c	49 03 c1	 add	 rax, r9
  0003f	ff e0		 jmp	 rax
$LN17@sre_uat:

; 314  : 
; 315  :     case SRE_AT_BEGINNING:
; 316  :     case SRE_AT_BEGINNING_STRING:
; 317  :         return ((void*) ptr == state->beginning);

  00041	33 ff		 xor	 edi, edi
  00043	48 3b 51 08	 cmp	 rdx, QWORD PTR [rcx+8]
  00047	40 0f 94 c7	 sete	 dil
  0004b	8b c7		 mov	 eax, edi
  0004d	e9 bf 08 00 00	 jmp	 $LN20@sre_uat
$LN16@sre_uat:

; 318  : 
; 319  :     case SRE_AT_BEGINNING_LINE:
; 320  :         return ((void*) ptr == state->beginning ||
; 321  :                 SRE_IS_LINEBREAK((int) SRE_CHARGET(state, ptr, -1)));

  00052	48 3b 51 08	 cmp	 rdx, QWORD PTR [rcx+8]
  00056	74 51		 je	 SHORT $LN32@sre_uat
  00058	8b 41 3c	 mov	 eax, DWORD PTR [rcx+60]
  0005b	83 f8 01	 cmp	 eax, 1
  0005e	75 06		 jne	 SHORT $LN24@sre_uat
  00060	0f b6 4a ff	 movzx	 ecx, BYTE PTR [rdx-1]
  00064	eb 0e		 jmp	 SHORT $LN23@sre_uat
$LN24@sre_uat:
  00066	83 f8 02	 cmp	 eax, 2
  00069	75 06		 jne	 SHORT $LN22@sre_uat
  0006b	0f b7 4a fe	 movzx	 ecx, WORD PTR [rdx-2]
  0006f	eb 03		 jmp	 SHORT $LN23@sre_uat
$LN22@sre_uat:
  00071	8b 4a fc	 mov	 ecx, DWORD PTR [rdx-4]
$LN23@sre_uat:
  00074	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  0007a	0f 8d 8e 00 00
	00		 jge	 $LN275@sre_uat
  00080	83 f8 01	 cmp	 eax, 1
  00083	75 06		 jne	 SHORT $LN28@sre_uat
  00085	0f b6 42 ff	 movzx	 eax, BYTE PTR [rdx-1]
  00089	eb 0e		 jmp	 SHORT $LN27@sre_uat
$LN28@sre_uat:
  0008b	83 f8 02	 cmp	 eax, 2
  0008e	75 06		 jne	 SHORT $LN26@sre_uat
  00090	0f b7 42 fe	 movzx	 eax, WORD PTR [rdx-2]
  00094	eb 03		 jmp	 SHORT $LN27@sre_uat
$LN26@sre_uat:
  00096	8b 42 fc	 mov	 eax, DWORD PTR [rdx-4]
$LN27@sre_uat:
  00099	48 98		 cdqe
  0009b	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  000a4	83 e1 04	 and	 ecx, 4
  000a7	74 65		 je	 SHORT $LN275@sre_uat
$LN32@sre_uat:
  000a9	bf 01 00 00 00	 mov	 edi, 1
  000ae	8b c7		 mov	 eax, edi
  000b0	e9 5c 08 00 00	 jmp	 $LN20@sre_uat
$LN15@sre_uat:

; 322  : 
; 323  :     case SRE_AT_END:
; 324  :         return (((void*) (ptr+state->charsize) == state->end &&
; 325  :                  SRE_IS_LINEBREAK((int) SRE_CHARGET(state, ptr, 0))) ||
; 326  :                 ((void*) ptr == state->end));

  000b5	48 63 49 3c	 movsxd	 rcx, DWORD PTR [rcx+60]
  000b9	48 8b 56 18	 mov	 rdx, QWORD PTR [rsi+24]
  000bd	48 8d 04 0b	 lea	 rax, QWORD PTR [rbx+rcx]
  000c1	48 3b c2	 cmp	 rax, rdx
  000c4	75 43		 jne	 SHORT $LN44@sre_uat
  000c6	83 f9 01	 cmp	 ecx, 1
  000c9	75 05		 jne	 SHORT $LN36@sre_uat
  000cb	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  000ce	eb 0c		 jmp	 SHORT $LN35@sre_uat
$LN36@sre_uat:
  000d0	83 f9 02	 cmp	 ecx, 2
  000d3	75 05		 jne	 SHORT $LN34@sre_uat
  000d5	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  000d8	eb 02		 jmp	 SHORT $LN35@sre_uat
$LN34@sre_uat:
  000da	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN35@sre_uat:
  000dc	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  000e1	7d 26		 jge	 SHORT $LN44@sre_uat
  000e3	83 f9 01	 cmp	 ecx, 1
  000e6	75 05		 jne	 SHORT $LN40@sre_uat
  000e8	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  000eb	eb 0c		 jmp	 SHORT $LN39@sre_uat
$LN40@sre_uat:
  000ed	83 f9 02	 cmp	 ecx, 2
  000f0	75 05		 jne	 SHORT $LN38@sre_uat
  000f2	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  000f5	eb 02		 jmp	 SHORT $LN39@sre_uat
$LN38@sre_uat:
  000f7	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN39@sre_uat:
  000f9	48 98		 cdqe
  000fb	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  00104	83 e1 04	 and	 ecx, 4
  00107	75 a0		 jne	 SHORT $LN32@sre_uat
$LN44@sre_uat:
  00109	48 3b da	 cmp	 rbx, rdx
  0010c	74 9b		 je	 SHORT $LN32@sre_uat
$LN275@sre_uat:
  0010e	33 ff		 xor	 edi, edi
  00110	8b c7		 mov	 eax, edi
  00112	e9 fa 07 00 00	 jmp	 $LN20@sre_uat
$LN14@sre_uat:

; 327  : 
; 328  :     case SRE_AT_END_LINE:
; 329  :         return ((void*) ptr == state->end ||
; 330  :                 SRE_IS_LINEBREAK((int) SRE_CHARGET(state, ptr, 0)));

  00117	48 3b 51 18	 cmp	 rdx, QWORD PTR [rcx+24]
  0011b	74 8c		 je	 SHORT $LN32@sre_uat
  0011d	8b 41 3c	 mov	 eax, DWORD PTR [rcx+60]
  00120	83 f8 01	 cmp	 eax, 1
  00123	75 05		 jne	 SHORT $LN49@sre_uat
  00125	0f b6 0a	 movzx	 ecx, BYTE PTR [rdx]
  00128	eb 0c		 jmp	 SHORT $LN48@sre_uat
$LN49@sre_uat:
  0012a	83 f8 02	 cmp	 eax, 2
  0012d	75 05		 jne	 SHORT $LN47@sre_uat
  0012f	0f b7 0a	 movzx	 ecx, WORD PTR [rdx]
  00132	eb 02		 jmp	 SHORT $LN48@sre_uat
$LN47@sre_uat:
  00134	8b 0a		 mov	 ecx, DWORD PTR [rdx]
$LN48@sre_uat:
  00136	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  0013c	7d 2a		 jge	 SHORT $LN276@sre_uat
  0013e	83 f8 01	 cmp	 eax, 1
  00141	75 05		 jne	 SHORT $LN53@sre_uat
  00143	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00146	eb 0c		 jmp	 SHORT $LN52@sre_uat
$LN53@sre_uat:
  00148	83 f8 02	 cmp	 eax, 2
  0014b	75 05		 jne	 SHORT $LN51@sre_uat
  0014d	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  00150	eb 02		 jmp	 SHORT $LN52@sre_uat
$LN51@sre_uat:
  00152	8b 02		 mov	 eax, DWORD PTR [rdx]
$LN52@sre_uat:
  00154	48 98		 cdqe
  00156	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  0015f	83 e1 04	 and	 ecx, 4
  00162	0f 85 41 ff ff
	ff		 jne	 $LN32@sre_uat
$LN276@sre_uat:
  00168	33 ff		 xor	 edi, edi
  0016a	8b c7		 mov	 eax, edi
  0016c	e9 a0 07 00 00	 jmp	 $LN20@sre_uat
$LN13@sre_uat:

; 331  : 
; 332  :     case SRE_AT_END_STRING:
; 333  :         return ((void*) ptr == state->end);

  00171	33 ff		 xor	 edi, edi
  00173	48 3b 51 18	 cmp	 rdx, QWORD PTR [rcx+24]
  00177	40 0f 94 c7	 sete	 dil
  0017b	8b c7		 mov	 eax, edi
  0017d	e9 8f 07 00 00	 jmp	 $LN20@sre_uat
$LN12@sre_uat:

; 334  : 
; 335  :     case SRE_AT_BOUNDARY:
; 336  :         if (state->beginning == state->end)

  00182	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00186	48 8b 51 18	 mov	 rdx, QWORD PTR [rcx+24]
  0018a	48 3b c2	 cmp	 rax, rdx

; 337  :             return 0;

  0018d	0f 84 7c 07 00
	00		 je	 $LN18@sre_uat

; 338  :         thatp = ((void*) ptr > state->beginning) ?
; 339  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, -1)) : 0;

  00193	33 ff		 xor	 edi, edi
  00195	48 3b d8	 cmp	 rbx, rax
  00198	76 69		 jbe	 SHORT $LN69@sre_uat
  0019a	8b 41 3c	 mov	 eax, DWORD PTR [rcx+60]
  0019d	83 f8 01	 cmp	 eax, 1
  001a0	75 06		 jne	 SHORT $LN61@sre_uat
  001a2	0f b6 4b ff	 movzx	 ecx, BYTE PTR [rbx-1]
  001a6	eb 0e		 jmp	 SHORT $LN60@sre_uat
$LN61@sre_uat:
  001a8	83 f8 02	 cmp	 eax, 2
  001ab	75 06		 jne	 SHORT $LN59@sre_uat
  001ad	0f b7 4b fe	 movzx	 ecx, WORD PTR [rbx-2]
  001b1	eb 03		 jmp	 SHORT $LN60@sre_uat
$LN59@sre_uat:
  001b3	8b 4b fc	 mov	 ecx, DWORD PTR [rbx-4]
$LN60@sre_uat:
  001b6	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  001bc	7d 45		 jge	 SHORT $LN69@sre_uat
  001be	83 f8 01	 cmp	 eax, 1
  001c1	75 14		 jne	 SHORT $LN65@sre_uat
  001c3	0f b6 43 ff	 movzx	 eax, BYTE PTR [rbx-1]
  001c7	48 98		 cdqe
  001c9	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  001d2	83 e1 10	 and	 ecx, 16
  001d5	eb 2e		 jmp	 SHORT $LN70@sre_uat
$LN65@sre_uat:
  001d7	83 f8 02	 cmp	 eax, 2
  001da	75 14		 jne	 SHORT $LN63@sre_uat
  001dc	0f b7 43 fe	 movzx	 eax, WORD PTR [rbx-2]
  001e0	48 98		 cdqe
  001e2	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  001eb	83 e1 10	 and	 ecx, 16
  001ee	eb 15		 jmp	 SHORT $LN70@sre_uat
$LN63@sre_uat:
  001f0	8b 43 fc	 mov	 eax, DWORD PTR [rbx-4]
  001f3	48 98		 cdqe
  001f5	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  001fe	83 e1 10	 and	 ecx, 16
  00201	eb 02		 jmp	 SHORT $LN70@sre_uat
$LN69@sre_uat:
  00203	8b cf		 mov	 ecx, edi
$LN70@sre_uat:
  00205	4c 63 c1	 movsxd	 r8, ecx

; 340  :         thisp = ((void*) ptr < state->end) ?
; 341  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  00208	48 3b da	 cmp	 rbx, rdx
  0020b	0f 83 90 00 00
	00		 jae	 $LN81@sre_uat
  00211	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  00214	83 f8 01	 cmp	 eax, 1
  00217	75 05		 jne	 SHORT $LN73@sre_uat
  00219	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  0021c	eb 0c		 jmp	 SHORT $LN72@sre_uat
$LN73@sre_uat:
  0021e	83 f8 02	 cmp	 eax, 2
  00221	75 05		 jne	 SHORT $LN71@sre_uat
  00223	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  00226	eb 02		 jmp	 SHORT $LN72@sre_uat
$LN71@sre_uat:
  00228	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN72@sre_uat:
  0022a	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  00230	7d 6f		 jge	 SHORT $LN81@sre_uat
  00232	83 f8 01	 cmp	 eax, 1
  00235	75 22		 jne	 SHORT $LN77@sre_uat
  00237	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  0023a	48 98		 cdqe
  0023c	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  00245	83 e1 10	 and	 ecx, 16

; 342  :         return thisp != thatp;

  00248	48 63 c1	 movsxd	 rax, ecx
  0024b	49 3b c0	 cmp	 rax, r8
  0024e	40 0f 95 c7	 setne	 dil
  00252	8b c7		 mov	 eax, edi
  00254	e9 b8 06 00 00	 jmp	 $LN20@sre_uat
$LN77@sre_uat:

; 340  :         thisp = ((void*) ptr < state->end) ?
; 341  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  00259	83 f8 02	 cmp	 eax, 2
  0025c	75 22		 jne	 SHORT $LN75@sre_uat
  0025e	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  00261	48 98		 cdqe
  00263	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  0026c	83 e1 10	 and	 ecx, 16

; 342  :         return thisp != thatp;

  0026f	48 63 c1	 movsxd	 rax, ecx
  00272	49 3b c0	 cmp	 rax, r8
  00275	40 0f 95 c7	 setne	 dil
  00279	8b c7		 mov	 eax, edi
  0027b	e9 91 06 00 00	 jmp	 $LN20@sre_uat
$LN75@sre_uat:

; 340  :         thisp = ((void*) ptr < state->end) ?
; 341  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  00280	8b 03		 mov	 eax, DWORD PTR [rbx]
  00282	48 98		 cdqe
  00284	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  0028d	83 e1 10	 and	 ecx, 16

; 342  :         return thisp != thatp;

  00290	48 63 c1	 movsxd	 rax, ecx
  00293	49 3b c0	 cmp	 rax, r8
  00296	40 0f 95 c7	 setne	 dil
  0029a	8b c7		 mov	 eax, edi
  0029c	e9 70 06 00 00	 jmp	 $LN20@sre_uat
$LN81@sre_uat:

; 340  :         thisp = ((void*) ptr < state->end) ?
; 341  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  002a1	8b cf		 mov	 ecx, edi

; 342  :         return thisp != thatp;

  002a3	48 63 c1	 movsxd	 rax, ecx
  002a6	49 3b c0	 cmp	 rax, r8
  002a9	40 0f 95 c7	 setne	 dil
  002ad	8b c7		 mov	 eax, edi
  002af	e9 5d 06 00 00	 jmp	 $LN20@sre_uat
$LN10@sre_uat:

; 343  : 
; 344  :     case SRE_AT_NON_BOUNDARY:
; 345  :         if (state->beginning == state->end)

  002b4	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  002b8	48 8b 51 18	 mov	 rdx, QWORD PTR [rcx+24]
  002bc	48 3b c2	 cmp	 rax, rdx

; 346  :             return 0;

  002bf	0f 84 4a 06 00
	00		 je	 $LN18@sre_uat

; 347  :         thatp = ((void*) ptr > state->beginning) ?
; 348  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, -1)) : 0;

  002c5	33 ff		 xor	 edi, edi
  002c7	48 3b d8	 cmp	 rbx, rax
  002ca	76 69		 jbe	 SHORT $LN93@sre_uat
  002cc	8b 41 3c	 mov	 eax, DWORD PTR [rcx+60]
  002cf	83 f8 01	 cmp	 eax, 1
  002d2	75 06		 jne	 SHORT $LN85@sre_uat
  002d4	0f b6 4b ff	 movzx	 ecx, BYTE PTR [rbx-1]
  002d8	eb 0e		 jmp	 SHORT $LN84@sre_uat
$LN85@sre_uat:
  002da	83 f8 02	 cmp	 eax, 2
  002dd	75 06		 jne	 SHORT $LN83@sre_uat
  002df	0f b7 4b fe	 movzx	 ecx, WORD PTR [rbx-2]
  002e3	eb 03		 jmp	 SHORT $LN84@sre_uat
$LN83@sre_uat:
  002e5	8b 4b fc	 mov	 ecx, DWORD PTR [rbx-4]
$LN84@sre_uat:
  002e8	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  002ee	7d 45		 jge	 SHORT $LN93@sre_uat
  002f0	83 f8 01	 cmp	 eax, 1
  002f3	75 14		 jne	 SHORT $LN89@sre_uat
  002f5	0f b6 43 ff	 movzx	 eax, BYTE PTR [rbx-1]
  002f9	48 98		 cdqe
  002fb	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  00304	83 e1 10	 and	 ecx, 16
  00307	eb 2e		 jmp	 SHORT $LN94@sre_uat
$LN89@sre_uat:
  00309	83 f8 02	 cmp	 eax, 2
  0030c	75 14		 jne	 SHORT $LN87@sre_uat
  0030e	0f b7 43 fe	 movzx	 eax, WORD PTR [rbx-2]
  00312	48 98		 cdqe
  00314	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  0031d	83 e1 10	 and	 ecx, 16
  00320	eb 15		 jmp	 SHORT $LN94@sre_uat
$LN87@sre_uat:
  00322	8b 43 fc	 mov	 eax, DWORD PTR [rbx-4]
  00325	48 98		 cdqe
  00327	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  00330	83 e1 10	 and	 ecx, 16
  00333	eb 02		 jmp	 SHORT $LN94@sre_uat
$LN93@sre_uat:
  00335	8b cf		 mov	 ecx, edi
$LN94@sre_uat:
  00337	4c 63 c1	 movsxd	 r8, ecx

; 349  :         thisp = ((void*) ptr < state->end) ?
; 350  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  0033a	48 3b da	 cmp	 rbx, rdx
  0033d	0f 83 90 00 00
	00		 jae	 $LN105@sre_uat
  00343	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  00346	83 f8 01	 cmp	 eax, 1
  00349	75 05		 jne	 SHORT $LN97@sre_uat
  0034b	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  0034e	eb 0c		 jmp	 SHORT $LN96@sre_uat
$LN97@sre_uat:
  00350	83 f8 02	 cmp	 eax, 2
  00353	75 05		 jne	 SHORT $LN95@sre_uat
  00355	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  00358	eb 02		 jmp	 SHORT $LN96@sre_uat
$LN95@sre_uat:
  0035a	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN96@sre_uat:
  0035c	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  00362	7d 6f		 jge	 SHORT $LN105@sre_uat
  00364	83 f8 01	 cmp	 eax, 1
  00367	75 22		 jne	 SHORT $LN101@sre_uat
  00369	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  0036c	48 98		 cdqe
  0036e	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  00377	83 e1 10	 and	 ecx, 16

; 351  :         return thisp == thatp;

  0037a	48 63 c1	 movsxd	 rax, ecx
  0037d	49 3b c0	 cmp	 rax, r8
  00380	40 0f 94 c7	 sete	 dil
  00384	8b c7		 mov	 eax, edi
  00386	e9 86 05 00 00	 jmp	 $LN20@sre_uat
$LN101@sre_uat:

; 349  :         thisp = ((void*) ptr < state->end) ?
; 350  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  0038b	83 f8 02	 cmp	 eax, 2
  0038e	75 22		 jne	 SHORT $LN99@sre_uat
  00390	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  00393	48 98		 cdqe
  00395	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  0039e	83 e1 10	 and	 ecx, 16

; 351  :         return thisp == thatp;

  003a1	48 63 c1	 movsxd	 rax, ecx
  003a4	49 3b c0	 cmp	 rax, r8
  003a7	40 0f 94 c7	 sete	 dil
  003ab	8b c7		 mov	 eax, edi
  003ad	e9 5f 05 00 00	 jmp	 $LN20@sre_uat
$LN99@sre_uat:

; 349  :         thisp = ((void*) ptr < state->end) ?
; 350  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  003b2	8b 03		 mov	 eax, DWORD PTR [rbx]
  003b4	48 98		 cdqe
  003b6	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  003bf	83 e1 10	 and	 ecx, 16

; 351  :         return thisp == thatp;

  003c2	48 63 c1	 movsxd	 rax, ecx
  003c5	49 3b c0	 cmp	 rax, r8
  003c8	40 0f 94 c7	 sete	 dil
  003cc	8b c7		 mov	 eax, edi
  003ce	e9 3e 05 00 00	 jmp	 $LN20@sre_uat
$LN105@sre_uat:

; 349  :         thisp = ((void*) ptr < state->end) ?
; 350  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  003d3	8b cf		 mov	 ecx, edi

; 351  :         return thisp == thatp;

  003d5	48 63 c1	 movsxd	 rax, ecx
  003d8	49 3b c0	 cmp	 rax, r8
  003db	40 0f 94 c7	 sete	 dil
  003df	8b c7		 mov	 eax, edi
  003e1	e9 2b 05 00 00	 jmp	 $LN20@sre_uat
$LN8@sre_uat:

; 352  : 
; 353  :     case SRE_AT_LOC_BOUNDARY:
; 354  :         if (state->beginning == state->end)

  003e6	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  003ea	48 3b 41 18	 cmp	 rax, QWORD PTR [rcx+24]

; 355  :             return 0;

  003ee	0f 84 1b 05 00
	00		 je	 $LN18@sre_uat

; 356  :         thatp = ((void*) ptr > state->beginning) ?
; 357  :             SRE_LOC_IS_WORD((int) SRE_CHARGET(state, ptr, -1)) : 0;

  003f4	33 ff		 xor	 edi, edi
  003f6	8d 6f 01	 lea	 ebp, QWORD PTR [rdi+1]
  003f9	48 3b d0	 cmp	 rdx, rax
  003fc	76 69		 jbe	 SHORT $LN123@sre_uat
  003fe	8b 41 3c	 mov	 eax, DWORD PTR [rcx+60]
  00401	3b c5		 cmp	 eax, ebp
  00403	75 06		 jne	 SHORT $LN109@sre_uat
  00405	0f b6 4a ff	 movzx	 ecx, BYTE PTR [rdx-1]
  00409	eb 0e		 jmp	 SHORT $LN108@sre_uat
$LN109@sre_uat:
  0040b	83 f8 02	 cmp	 eax, 2
  0040e	75 06		 jne	 SHORT $LN107@sre_uat
  00410	0f b7 4a fe	 movzx	 ecx, WORD PTR [rdx-2]
  00414	eb 03		 jmp	 SHORT $LN108@sre_uat
$LN107@sre_uat:
  00416	8b 4a fc	 mov	 ecx, DWORD PTR [rdx-4]
$LN108@sre_uat:
  00419	f7 c1 00 ff ff
	ff		 test	 ecx, -256		; ffffffffffffff00H
  0041f	75 22		 jne	 SHORT $LN277@sre_uat
  00421	3b c5		 cmp	 eax, ebp
  00423	75 06		 jne	 SHORT $LN113@sre_uat
  00425	0f b6 4a ff	 movzx	 ecx, BYTE PTR [rdx-1]
  00429	eb 0e		 jmp	 SHORT $LN112@sre_uat
$LN113@sre_uat:
  0042b	83 f8 02	 cmp	 eax, 2
  0042e	75 06		 jne	 SHORT $LN111@sre_uat
  00430	0f b7 4a fe	 movzx	 ecx, WORD PTR [rdx-2]
  00434	eb 03		 jmp	 SHORT $LN112@sre_uat
$LN111@sre_uat:
  00436	8b 4a fc	 mov	 ecx, DWORD PTR [rdx-4]
$LN112@sre_uat:
  00439	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalnum
  0043f	85 c0		 test	 eax, eax
  00441	75 20		 jne	 SHORT $LN121@sre_uat
$LN277@sre_uat:
  00443	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  00446	3b c5		 cmp	 eax, ebp
  00448	75 06		 jne	 SHORT $LN119@sre_uat
  0044a	0f b6 43 ff	 movzx	 eax, BYTE PTR [rbx-1]
  0044e	eb 0e		 jmp	 SHORT $LN118@sre_uat
$LN119@sre_uat:
  00450	83 f8 02	 cmp	 eax, 2
  00453	75 06		 jne	 SHORT $LN117@sre_uat
  00455	0f b7 43 fe	 movzx	 eax, WORD PTR [rbx-2]
  00459	eb 03		 jmp	 SHORT $LN118@sre_uat
$LN117@sre_uat:
  0045b	8b 43 fc	 mov	 eax, DWORD PTR [rbx-4]
$LN118@sre_uat:
  0045e	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00461	75 04		 jne	 SHORT $LN123@sre_uat
$LN121@sre_uat:
  00463	8b c5		 mov	 eax, ebp
  00465	eb 02		 jmp	 SHORT $LN124@sre_uat
$LN123@sre_uat:
  00467	8b c7		 mov	 eax, edi
$LN124@sre_uat:
  00469	4c 63 e0	 movsxd	 r12, eax

; 358  :         thisp = ((void*) ptr < state->end) ?
; 359  :             SRE_LOC_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  0046c	48 3b 5e 18	 cmp	 rbx, QWORD PTR [rsi+24]
  00470	73 5c		 jae	 SHORT $LN141@sre_uat
  00472	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  00475	3b c5		 cmp	 eax, ebp
  00477	75 05		 jne	 SHORT $LN127@sre_uat
  00479	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  0047c	eb 0c		 jmp	 SHORT $LN126@sre_uat
$LN127@sre_uat:
  0047e	83 f8 02	 cmp	 eax, 2
  00481	75 05		 jne	 SHORT $LN125@sre_uat
  00483	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  00486	eb 02		 jmp	 SHORT $LN126@sre_uat
$LN125@sre_uat:
  00488	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN126@sre_uat:
  0048a	f7 c1 00 ff ff
	ff		 test	 ecx, -256		; ffffffffffffff00H
  00490	75 1f		 jne	 SHORT $LN278@sre_uat
  00492	3b c5		 cmp	 eax, ebp
  00494	75 05		 jne	 SHORT $LN131@sre_uat
  00496	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  00499	eb 0c		 jmp	 SHORT $LN130@sre_uat
$LN131@sre_uat:
  0049b	83 f8 02	 cmp	 eax, 2
  0049e	75 05		 jne	 SHORT $LN129@sre_uat
  004a0	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  004a3	eb 02		 jmp	 SHORT $LN130@sre_uat
$LN129@sre_uat:
  004a5	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN130@sre_uat:
  004a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalnum
  004ad	85 c0		 test	 eax, eax
  004af	75 1f		 jne	 SHORT $LN142@sre_uat
$LN278@sre_uat:
  004b1	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  004b4	3b c5		 cmp	 eax, ebp
  004b6	75 05		 jne	 SHORT $LN137@sre_uat
  004b8	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  004bb	eb 0c		 jmp	 SHORT $LN136@sre_uat
$LN137@sre_uat:
  004bd	83 f8 02	 cmp	 eax, 2
  004c0	75 05		 jne	 SHORT $LN135@sre_uat
  004c2	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  004c5	eb 02		 jmp	 SHORT $LN136@sre_uat
$LN135@sre_uat:
  004c7	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN136@sre_uat:
  004c9	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  004cc	74 02		 je	 SHORT $LN142@sre_uat
$LN141@sre_uat:
  004ce	8b ef		 mov	 ebp, edi
$LN142@sre_uat:

; 360  :         return thisp != thatp;

  004d0	48 63 c5	 movsxd	 rax, ebp
  004d3	49 3b c4	 cmp	 rax, r12
  004d6	40 0f 95 c7	 setne	 dil
  004da	8b c7		 mov	 eax, edi
  004dc	e9 30 04 00 00	 jmp	 $LN20@sre_uat
$LN6@sre_uat:

; 361  : 
; 362  :     case SRE_AT_LOC_NON_BOUNDARY:
; 363  :         if (state->beginning == state->end)

  004e1	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  004e5	48 3b 41 18	 cmp	 rax, QWORD PTR [rcx+24]

; 364  :             return 0;

  004e9	0f 84 20 04 00
	00		 je	 $LN18@sre_uat

; 365  :         thatp = ((void*) ptr > state->beginning) ?
; 366  :             SRE_LOC_IS_WORD((int) SRE_CHARGET(state, ptr, -1)) : 0;

  004ef	33 ff		 xor	 edi, edi
  004f1	8d 6f 01	 lea	 ebp, QWORD PTR [rdi+1]
  004f4	48 3b d0	 cmp	 rdx, rax
  004f7	76 69		 jbe	 SHORT $LN159@sre_uat
  004f9	8b 41 3c	 mov	 eax, DWORD PTR [rcx+60]
  004fc	3b c5		 cmp	 eax, ebp
  004fe	75 06		 jne	 SHORT $LN145@sre_uat
  00500	0f b6 4a ff	 movzx	 ecx, BYTE PTR [rdx-1]
  00504	eb 0e		 jmp	 SHORT $LN144@sre_uat
$LN145@sre_uat:
  00506	83 f8 02	 cmp	 eax, 2
  00509	75 06		 jne	 SHORT $LN143@sre_uat
  0050b	0f b7 4a fe	 movzx	 ecx, WORD PTR [rdx-2]
  0050f	eb 03		 jmp	 SHORT $LN144@sre_uat
$LN143@sre_uat:
  00511	8b 4a fc	 mov	 ecx, DWORD PTR [rdx-4]
$LN144@sre_uat:
  00514	f7 c1 00 ff ff
	ff		 test	 ecx, -256		; ffffffffffffff00H
  0051a	75 22		 jne	 SHORT $LN279@sre_uat
  0051c	3b c5		 cmp	 eax, ebp
  0051e	75 06		 jne	 SHORT $LN149@sre_uat
  00520	0f b6 4a ff	 movzx	 ecx, BYTE PTR [rdx-1]
  00524	eb 0e		 jmp	 SHORT $LN148@sre_uat
$LN149@sre_uat:
  00526	83 f8 02	 cmp	 eax, 2
  00529	75 06		 jne	 SHORT $LN147@sre_uat
  0052b	0f b7 4a fe	 movzx	 ecx, WORD PTR [rdx-2]
  0052f	eb 03		 jmp	 SHORT $LN148@sre_uat
$LN147@sre_uat:
  00531	8b 4a fc	 mov	 ecx, DWORD PTR [rdx-4]
$LN148@sre_uat:
  00534	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalnum
  0053a	85 c0		 test	 eax, eax
  0053c	75 20		 jne	 SHORT $LN157@sre_uat
$LN279@sre_uat:
  0053e	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  00541	3b c5		 cmp	 eax, ebp
  00543	75 06		 jne	 SHORT $LN155@sre_uat
  00545	0f b6 43 ff	 movzx	 eax, BYTE PTR [rbx-1]
  00549	eb 0e		 jmp	 SHORT $LN154@sre_uat
$LN155@sre_uat:
  0054b	83 f8 02	 cmp	 eax, 2
  0054e	75 06		 jne	 SHORT $LN153@sre_uat
  00550	0f b7 43 fe	 movzx	 eax, WORD PTR [rbx-2]
  00554	eb 03		 jmp	 SHORT $LN154@sre_uat
$LN153@sre_uat:
  00556	8b 43 fc	 mov	 eax, DWORD PTR [rbx-4]
$LN154@sre_uat:
  00559	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  0055c	75 04		 jne	 SHORT $LN159@sre_uat
$LN157@sre_uat:
  0055e	8b c5		 mov	 eax, ebp
  00560	eb 02		 jmp	 SHORT $LN160@sre_uat
$LN159@sre_uat:
  00562	8b c7		 mov	 eax, edi
$LN160@sre_uat:
  00564	4c 63 e0	 movsxd	 r12, eax

; 367  :         thisp = ((void*) ptr < state->end) ?
; 368  :             SRE_LOC_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  00567	48 3b 5e 18	 cmp	 rbx, QWORD PTR [rsi+24]
  0056b	73 5c		 jae	 SHORT $LN177@sre_uat
  0056d	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  00570	3b c5		 cmp	 eax, ebp
  00572	75 05		 jne	 SHORT $LN163@sre_uat
  00574	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  00577	eb 0c		 jmp	 SHORT $LN162@sre_uat
$LN163@sre_uat:
  00579	83 f8 02	 cmp	 eax, 2
  0057c	75 05		 jne	 SHORT $LN161@sre_uat
  0057e	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  00581	eb 02		 jmp	 SHORT $LN162@sre_uat
$LN161@sre_uat:
  00583	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN162@sre_uat:
  00585	f7 c1 00 ff ff
	ff		 test	 ecx, -256		; ffffffffffffff00H
  0058b	75 1f		 jne	 SHORT $LN280@sre_uat
  0058d	3b c5		 cmp	 eax, ebp
  0058f	75 05		 jne	 SHORT $LN167@sre_uat
  00591	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  00594	eb 0c		 jmp	 SHORT $LN166@sre_uat
$LN167@sre_uat:
  00596	83 f8 02	 cmp	 eax, 2
  00599	75 05		 jne	 SHORT $LN165@sre_uat
  0059b	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  0059e	eb 02		 jmp	 SHORT $LN166@sre_uat
$LN165@sre_uat:
  005a0	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN166@sre_uat:
  005a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalnum
  005a8	85 c0		 test	 eax, eax
  005aa	75 1f		 jne	 SHORT $LN178@sre_uat
$LN280@sre_uat:
  005ac	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  005af	3b c5		 cmp	 eax, ebp
  005b1	75 05		 jne	 SHORT $LN173@sre_uat
  005b3	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  005b6	eb 0c		 jmp	 SHORT $LN172@sre_uat
$LN173@sre_uat:
  005b8	83 f8 02	 cmp	 eax, 2
  005bb	75 05		 jne	 SHORT $LN171@sre_uat
  005bd	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  005c0	eb 02		 jmp	 SHORT $LN172@sre_uat
$LN171@sre_uat:
  005c2	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN172@sre_uat:
  005c4	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  005c7	74 02		 je	 SHORT $LN178@sre_uat
$LN177@sre_uat:
  005c9	8b ef		 mov	 ebp, edi
$LN178@sre_uat:

; 369  :         return thisp == thatp;

  005cb	48 63 c5	 movsxd	 rax, ebp
  005ce	49 3b c4	 cmp	 rax, r12
  005d1	40 0f 94 c7	 sete	 dil
  005d5	8b c7		 mov	 eax, edi
  005d7	e9 35 03 00 00	 jmp	 $LN20@sre_uat
$LN4@sre_uat:

; 370  : 
; 371  :     case SRE_AT_UNI_BOUNDARY:
; 372  :         if (state->beginning == state->end)

  005dc	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  005e0	48 3b 41 18	 cmp	 rax, QWORD PTR [rcx+24]

; 373  :             return 0;

  005e4	0f 84 25 03 00
	00		 je	 $LN18@sre_uat

; 374  :         thatp = ((void*) ptr > state->beginning) ?
; 375  :             SRE_UNI_IS_WORD((int) SRE_CHARGET(state, ptr, -1)) : 0;

  005ea	33 ff		 xor	 edi, edi
  005ec	8d 6f 01	 lea	 ebp, QWORD PTR [rdi+1]
  005ef	48 3b d0	 cmp	 rdx, rax
  005f2	0f 86 b8 00 00
	00		 jbe	 $LN201@sre_uat
  005f8	8b 41 3c	 mov	 eax, DWORD PTR [rcx+60]
  005fb	3b c5		 cmp	 eax, ebp
  005fd	75 06		 jne	 SHORT $LN181@sre_uat
  005ff	0f b6 4a ff	 movzx	 ecx, BYTE PTR [rdx-1]
  00603	eb 0e		 jmp	 SHORT $LN180@sre_uat
$LN181@sre_uat:
  00605	83 f8 02	 cmp	 eax, 2
  00608	75 06		 jne	 SHORT $LN179@sre_uat
  0060a	0f b7 4a fe	 movzx	 ecx, WORD PTR [rdx-2]
  0060e	eb 03		 jmp	 SHORT $LN180@sre_uat
$LN179@sre_uat:
  00610	8b 4a fc	 mov	 ecx, DWORD PTR [rdx-4]
$LN180@sre_uat:
  00613	e8 00 00 00 00	 call	 _PyUnicode_IsAlpha
  00618	85 c0		 test	 eax, eax
  0061a	0f 85 8c 00 00
	00		 jne	 $LN187@sre_uat
  00620	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  00623	3b c5		 cmp	 eax, ebp
  00625	75 06		 jne	 SHORT $LN185@sre_uat
  00627	0f b6 4b ff	 movzx	 ecx, BYTE PTR [rbx-1]
  0062b	eb 0e		 jmp	 SHORT $LN184@sre_uat
$LN185@sre_uat:
  0062d	83 f8 02	 cmp	 eax, 2
  00630	75 06		 jne	 SHORT $LN183@sre_uat
  00632	0f b7 4b fe	 movzx	 ecx, WORD PTR [rbx-2]
  00636	eb 03		 jmp	 SHORT $LN184@sre_uat
$LN183@sre_uat:
  00638	8b 4b fc	 mov	 ecx, DWORD PTR [rbx-4]
$LN184@sre_uat:
  0063b	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  00640	85 c0		 test	 eax, eax
  00642	75 68		 jne	 SHORT $LN187@sre_uat
  00644	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  00647	3b c5		 cmp	 eax, ebp
  00649	75 06		 jne	 SHORT $LN190@sre_uat
  0064b	0f b6 4b ff	 movzx	 ecx, BYTE PTR [rbx-1]
  0064f	eb 0e		 jmp	 SHORT $LN189@sre_uat
$LN190@sre_uat:
  00651	83 f8 02	 cmp	 eax, 2
  00654	75 06		 jne	 SHORT $LN188@sre_uat
  00656	0f b7 4b fe	 movzx	 ecx, WORD PTR [rbx-2]
  0065a	eb 03		 jmp	 SHORT $LN189@sre_uat
$LN188@sre_uat:
  0065c	8b 4b fc	 mov	 ecx, DWORD PTR [rbx-4]
$LN189@sre_uat:
  0065f	e8 00 00 00 00	 call	 _PyUnicode_IsDigit
  00664	85 c0		 test	 eax, eax
  00666	75 44		 jne	 SHORT $LN187@sre_uat
  00668	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  0066b	3b c5		 cmp	 eax, ebp
  0066d	75 06		 jne	 SHORT $LN194@sre_uat
  0066f	0f b6 4b ff	 movzx	 ecx, BYTE PTR [rbx-1]
  00673	eb 0e		 jmp	 SHORT $LN193@sre_uat
$LN194@sre_uat:
  00675	83 f8 02	 cmp	 eax, 2
  00678	75 06		 jne	 SHORT $LN192@sre_uat
  0067a	0f b7 4b fe	 movzx	 ecx, WORD PTR [rbx-2]
  0067e	eb 03		 jmp	 SHORT $LN193@sre_uat
$LN192@sre_uat:
  00680	8b 4b fc	 mov	 ecx, DWORD PTR [rbx-4]
$LN193@sre_uat:
  00683	e8 00 00 00 00	 call	 _PyUnicode_IsNumeric
  00688	85 c0		 test	 eax, eax
  0068a	75 20		 jne	 SHORT $LN187@sre_uat
  0068c	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  0068f	3b c5		 cmp	 eax, ebp
  00691	75 06		 jne	 SHORT $LN198@sre_uat
  00693	0f b6 43 ff	 movzx	 eax, BYTE PTR [rbx-1]
  00697	eb 0e		 jmp	 SHORT $LN197@sre_uat
$LN198@sre_uat:
  00699	83 f8 02	 cmp	 eax, 2
  0069c	75 06		 jne	 SHORT $LN196@sre_uat
  0069e	0f b7 43 fe	 movzx	 eax, WORD PTR [rbx-2]
  006a2	eb 03		 jmp	 SHORT $LN197@sre_uat
$LN196@sre_uat:
  006a4	8b 43 fc	 mov	 eax, DWORD PTR [rbx-4]
$LN197@sre_uat:
  006a7	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  006aa	75 04		 jne	 SHORT $LN201@sre_uat
$LN187@sre_uat:
  006ac	8b c5		 mov	 eax, ebp
  006ae	eb 02		 jmp	 SHORT $LN202@sre_uat
$LN201@sre_uat:
  006b0	8b c7		 mov	 eax, edi
$LN202@sre_uat:
  006b2	4c 63 e0	 movsxd	 r12, eax

; 376  :         thisp = ((void*) ptr < state->end) ?
; 377  :             SRE_UNI_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  006b5	48 3b 5e 18	 cmp	 rbx, QWORD PTR [rsi+24]
  006b9	0f 83 a5 00 00
	00		 jae	 $LN225@sre_uat
  006bf	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  006c2	3b c5		 cmp	 eax, ebp
  006c4	75 05		 jne	 SHORT $LN205@sre_uat
  006c6	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  006c9	eb 0c		 jmp	 SHORT $LN204@sre_uat
$LN205@sre_uat:
  006cb	83 f8 02	 cmp	 eax, 2
  006ce	75 05		 jne	 SHORT $LN203@sre_uat
  006d0	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  006d3	eb 02		 jmp	 SHORT $LN204@sre_uat
$LN203@sre_uat:
  006d5	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN204@sre_uat:
  006d7	e8 00 00 00 00	 call	 _PyUnicode_IsAlpha
  006dc	85 c0		 test	 eax, eax
  006de	0f 85 82 00 00
	00		 jne	 $LN226@sre_uat
  006e4	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  006e7	3b c5		 cmp	 eax, ebp
  006e9	75 05		 jne	 SHORT $LN209@sre_uat
  006eb	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  006ee	eb 0c		 jmp	 SHORT $LN208@sre_uat
$LN209@sre_uat:
  006f0	83 f8 02	 cmp	 eax, 2
  006f3	75 05		 jne	 SHORT $LN207@sre_uat
  006f5	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  006f8	eb 02		 jmp	 SHORT $LN208@sre_uat
$LN207@sre_uat:
  006fa	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN208@sre_uat:
  006fc	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  00701	85 c0		 test	 eax, eax
  00703	75 61		 jne	 SHORT $LN226@sre_uat
  00705	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  00708	3b c5		 cmp	 eax, ebp
  0070a	75 05		 jne	 SHORT $LN214@sre_uat
  0070c	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  0070f	eb 0c		 jmp	 SHORT $LN213@sre_uat
$LN214@sre_uat:
  00711	83 f8 02	 cmp	 eax, 2
  00714	75 05		 jne	 SHORT $LN212@sre_uat
  00716	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  00719	eb 02		 jmp	 SHORT $LN213@sre_uat
$LN212@sre_uat:
  0071b	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN213@sre_uat:
  0071d	e8 00 00 00 00	 call	 _PyUnicode_IsDigit
  00722	85 c0		 test	 eax, eax
  00724	75 40		 jne	 SHORT $LN226@sre_uat
  00726	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  00729	3b c5		 cmp	 eax, ebp
  0072b	75 05		 jne	 SHORT $LN218@sre_uat
  0072d	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  00730	eb 0c		 jmp	 SHORT $LN217@sre_uat
$LN218@sre_uat:
  00732	83 f8 02	 cmp	 eax, 2
  00735	75 05		 jne	 SHORT $LN216@sre_uat
  00737	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  0073a	eb 02		 jmp	 SHORT $LN217@sre_uat
$LN216@sre_uat:
  0073c	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN217@sre_uat:
  0073e	e8 00 00 00 00	 call	 _PyUnicode_IsNumeric
  00743	85 c0		 test	 eax, eax
  00745	75 1f		 jne	 SHORT $LN226@sre_uat
  00747	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  0074a	3b c5		 cmp	 eax, ebp
  0074c	75 05		 jne	 SHORT $LN222@sre_uat
  0074e	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00751	eb 0c		 jmp	 SHORT $LN221@sre_uat
$LN222@sre_uat:
  00753	83 f8 02	 cmp	 eax, 2
  00756	75 05		 jne	 SHORT $LN220@sre_uat
  00758	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  0075b	eb 02		 jmp	 SHORT $LN221@sre_uat
$LN220@sre_uat:
  0075d	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN221@sre_uat:
  0075f	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00762	74 02		 je	 SHORT $LN226@sre_uat
$LN225@sre_uat:
  00764	8b ef		 mov	 ebp, edi
$LN226@sre_uat:

; 378  :         return thisp != thatp;

  00766	48 63 c5	 movsxd	 rax, ebp
  00769	49 3b c4	 cmp	 rax, r12
  0076c	40 0f 95 c7	 setne	 dil
  00770	8b c7		 mov	 eax, edi
  00772	e9 9a 01 00 00	 jmp	 $LN20@sre_uat
$LN2@sre_uat:

; 379  : 
; 380  :     case SRE_AT_UNI_NON_BOUNDARY:
; 381  :         if (state->beginning == state->end)

  00777	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  0077b	48 3b 41 18	 cmp	 rax, QWORD PTR [rcx+24]

; 382  :             return 0;

  0077f	0f 84 8a 01 00
	00		 je	 $LN18@sre_uat

; 383  :         thatp = ((void*) ptr > state->beginning) ?
; 384  :             SRE_UNI_IS_WORD((int) SRE_CHARGET(state, ptr, -1)) : 0;

  00785	33 ff		 xor	 edi, edi
  00787	8d 6f 01	 lea	 ebp, QWORD PTR [rdi+1]
  0078a	48 3b d0	 cmp	 rdx, rax
  0078d	0f 86 b8 00 00
	00		 jbe	 $LN249@sre_uat
  00793	8b 41 3c	 mov	 eax, DWORD PTR [rcx+60]
  00796	3b c5		 cmp	 eax, ebp
  00798	75 06		 jne	 SHORT $LN229@sre_uat
  0079a	0f b6 4a ff	 movzx	 ecx, BYTE PTR [rdx-1]
  0079e	eb 0e		 jmp	 SHORT $LN228@sre_uat
$LN229@sre_uat:
  007a0	83 f8 02	 cmp	 eax, 2
  007a3	75 06		 jne	 SHORT $LN227@sre_uat
  007a5	0f b7 4a fe	 movzx	 ecx, WORD PTR [rdx-2]
  007a9	eb 03		 jmp	 SHORT $LN228@sre_uat
$LN227@sre_uat:
  007ab	8b 4a fc	 mov	 ecx, DWORD PTR [rdx-4]
$LN228@sre_uat:
  007ae	e8 00 00 00 00	 call	 _PyUnicode_IsAlpha
  007b3	85 c0		 test	 eax, eax
  007b5	0f 85 8c 00 00
	00		 jne	 $LN235@sre_uat
  007bb	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  007be	3b c5		 cmp	 eax, ebp
  007c0	75 06		 jne	 SHORT $LN233@sre_uat
  007c2	0f b6 4b ff	 movzx	 ecx, BYTE PTR [rbx-1]
  007c6	eb 0e		 jmp	 SHORT $LN232@sre_uat
$LN233@sre_uat:
  007c8	83 f8 02	 cmp	 eax, 2
  007cb	75 06		 jne	 SHORT $LN231@sre_uat
  007cd	0f b7 4b fe	 movzx	 ecx, WORD PTR [rbx-2]
  007d1	eb 03		 jmp	 SHORT $LN232@sre_uat
$LN231@sre_uat:
  007d3	8b 4b fc	 mov	 ecx, DWORD PTR [rbx-4]
$LN232@sre_uat:
  007d6	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  007db	85 c0		 test	 eax, eax
  007dd	75 68		 jne	 SHORT $LN235@sre_uat
  007df	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  007e2	3b c5		 cmp	 eax, ebp
  007e4	75 06		 jne	 SHORT $LN238@sre_uat
  007e6	0f b6 4b ff	 movzx	 ecx, BYTE PTR [rbx-1]
  007ea	eb 0e		 jmp	 SHORT $LN237@sre_uat
$LN238@sre_uat:
  007ec	83 f8 02	 cmp	 eax, 2
  007ef	75 06		 jne	 SHORT $LN236@sre_uat
  007f1	0f b7 4b fe	 movzx	 ecx, WORD PTR [rbx-2]
  007f5	eb 03		 jmp	 SHORT $LN237@sre_uat
$LN236@sre_uat:
  007f7	8b 4b fc	 mov	 ecx, DWORD PTR [rbx-4]
$LN237@sre_uat:
  007fa	e8 00 00 00 00	 call	 _PyUnicode_IsDigit
  007ff	85 c0		 test	 eax, eax
  00801	75 44		 jne	 SHORT $LN235@sre_uat
  00803	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  00806	3b c5		 cmp	 eax, ebp
  00808	75 06		 jne	 SHORT $LN242@sre_uat
  0080a	0f b6 4b ff	 movzx	 ecx, BYTE PTR [rbx-1]
  0080e	eb 0e		 jmp	 SHORT $LN241@sre_uat
$LN242@sre_uat:
  00810	83 f8 02	 cmp	 eax, 2
  00813	75 06		 jne	 SHORT $LN240@sre_uat
  00815	0f b7 4b fe	 movzx	 ecx, WORD PTR [rbx-2]
  00819	eb 03		 jmp	 SHORT $LN241@sre_uat
$LN240@sre_uat:
  0081b	8b 4b fc	 mov	 ecx, DWORD PTR [rbx-4]
$LN241@sre_uat:
  0081e	e8 00 00 00 00	 call	 _PyUnicode_IsNumeric
  00823	85 c0		 test	 eax, eax
  00825	75 20		 jne	 SHORT $LN235@sre_uat
  00827	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  0082a	3b c5		 cmp	 eax, ebp
  0082c	75 06		 jne	 SHORT $LN246@sre_uat
  0082e	0f b6 43 ff	 movzx	 eax, BYTE PTR [rbx-1]
  00832	eb 0e		 jmp	 SHORT $LN245@sre_uat
$LN246@sre_uat:
  00834	83 f8 02	 cmp	 eax, 2
  00837	75 06		 jne	 SHORT $LN244@sre_uat
  00839	0f b7 43 fe	 movzx	 eax, WORD PTR [rbx-2]
  0083d	eb 03		 jmp	 SHORT $LN245@sre_uat
$LN244@sre_uat:
  0083f	8b 43 fc	 mov	 eax, DWORD PTR [rbx-4]
$LN245@sre_uat:
  00842	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00845	75 04		 jne	 SHORT $LN249@sre_uat
$LN235@sre_uat:
  00847	8b c5		 mov	 eax, ebp
  00849	eb 02		 jmp	 SHORT $LN250@sre_uat
$LN249@sre_uat:
  0084b	8b c7		 mov	 eax, edi
$LN250@sre_uat:
  0084d	4c 63 e0	 movsxd	 r12, eax

; 385  :         thisp = ((void*) ptr < state->end) ?
; 386  :             SRE_UNI_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  00850	48 3b 5e 18	 cmp	 rbx, QWORD PTR [rsi+24]
  00854	0f 83 a5 00 00
	00		 jae	 $LN273@sre_uat
  0085a	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  0085d	3b c5		 cmp	 eax, ebp
  0085f	75 05		 jne	 SHORT $LN253@sre_uat
  00861	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  00864	eb 0c		 jmp	 SHORT $LN252@sre_uat
$LN253@sre_uat:
  00866	83 f8 02	 cmp	 eax, 2
  00869	75 05		 jne	 SHORT $LN251@sre_uat
  0086b	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  0086e	eb 02		 jmp	 SHORT $LN252@sre_uat
$LN251@sre_uat:
  00870	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN252@sre_uat:
  00872	e8 00 00 00 00	 call	 _PyUnicode_IsAlpha
  00877	85 c0		 test	 eax, eax
  00879	0f 85 82 00 00
	00		 jne	 $LN274@sre_uat
  0087f	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  00882	3b c5		 cmp	 eax, ebp
  00884	75 05		 jne	 SHORT $LN257@sre_uat
  00886	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  00889	eb 0c		 jmp	 SHORT $LN256@sre_uat
$LN257@sre_uat:
  0088b	83 f8 02	 cmp	 eax, 2
  0088e	75 05		 jne	 SHORT $LN255@sre_uat
  00890	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  00893	eb 02		 jmp	 SHORT $LN256@sre_uat
$LN255@sre_uat:
  00895	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN256@sre_uat:
  00897	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  0089c	85 c0		 test	 eax, eax
  0089e	75 61		 jne	 SHORT $LN274@sre_uat
  008a0	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  008a3	3b c5		 cmp	 eax, ebp
  008a5	75 05		 jne	 SHORT $LN262@sre_uat
  008a7	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  008aa	eb 0c		 jmp	 SHORT $LN261@sre_uat
$LN262@sre_uat:
  008ac	83 f8 02	 cmp	 eax, 2
  008af	75 05		 jne	 SHORT $LN260@sre_uat
  008b1	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  008b4	eb 02		 jmp	 SHORT $LN261@sre_uat
$LN260@sre_uat:
  008b6	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN261@sre_uat:
  008b8	e8 00 00 00 00	 call	 _PyUnicode_IsDigit
  008bd	85 c0		 test	 eax, eax
  008bf	75 40		 jne	 SHORT $LN274@sre_uat
  008c1	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  008c4	3b c5		 cmp	 eax, ebp
  008c6	75 05		 jne	 SHORT $LN266@sre_uat
  008c8	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  008cb	eb 0c		 jmp	 SHORT $LN265@sre_uat
$LN266@sre_uat:
  008cd	83 f8 02	 cmp	 eax, 2
  008d0	75 05		 jne	 SHORT $LN264@sre_uat
  008d2	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  008d5	eb 02		 jmp	 SHORT $LN265@sre_uat
$LN264@sre_uat:
  008d7	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN265@sre_uat:
  008d9	e8 00 00 00 00	 call	 _PyUnicode_IsNumeric
  008de	85 c0		 test	 eax, eax
  008e0	75 1f		 jne	 SHORT $LN274@sre_uat
  008e2	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  008e5	3b c5		 cmp	 eax, ebp
  008e7	75 05		 jne	 SHORT $LN270@sre_uat
  008e9	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  008ec	eb 0c		 jmp	 SHORT $LN269@sre_uat
$LN270@sre_uat:
  008ee	83 f8 02	 cmp	 eax, 2
  008f1	75 05		 jne	 SHORT $LN268@sre_uat
  008f3	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  008f6	eb 02		 jmp	 SHORT $LN269@sre_uat
$LN268@sre_uat:
  008f8	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN269@sre_uat:
  008fa	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  008fd	74 02		 je	 SHORT $LN274@sre_uat
$LN273@sre_uat:
  008ff	8b ef		 mov	 ebp, edi
$LN274@sre_uat:

; 387  :         return thisp == thatp;

  00901	48 63 cd	 movsxd	 rcx, ebp
  00904	49 3b cc	 cmp	 rcx, r12
  00907	40 0f 94 c7	 sete	 dil
  0090b	8b c7		 mov	 eax, edi
  0090d	eb 02		 jmp	 SHORT $LN20@sre_uat
$LN18@sre_uat:

; 388  : 
; 389  :     }
; 390  : 
; 391  :     return 0;

  0090f	33 c0		 xor	 eax, eax
$LN20@sre_uat:

; 392  : }

  00911	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00916	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0091b	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00920	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00925	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00929	41 5c		 pop	 r12
  0092b	c3		 ret	 0
$LN281@sre_uat:
  0092c	00 00 00 00	 DD	 $LN17@sre_uat
  00930	00 00 00 00	 DD	 $LN16@sre_uat
  00934	00 00 00 00	 DD	 $LN17@sre_uat
  00938	00 00 00 00	 DD	 $LN12@sre_uat
  0093c	00 00 00 00	 DD	 $LN10@sre_uat
  00940	00 00 00 00	 DD	 $LN15@sre_uat
  00944	00 00 00 00	 DD	 $LN14@sre_uat
  00948	00 00 00 00	 DD	 $LN13@sre_uat
  0094c	00 00 00 00	 DD	 $LN8@sre_uat
  00950	00 00 00 00	 DD	 $LN6@sre_uat
  00954	00 00 00 00	 DD	 $LN4@sre_uat
  00958	00 00 00 00	 DD	 $LN2@sre_uat
sre_uat	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sre_ucharset DD imagerel sre_ucharset
	DD	imagerel sre_ucharset+392
	DD	imagerel $unwind$sre_ucharset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sre_ucharset DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT sre_ucharset
_TEXT	SEGMENT
set$ = 48
ch$ = 56
sre_ucharset PROC					; COMDAT

; 396  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 397  :     /* check if character is a member of the given set */
; 398  : 
; 399  :     int ok = 1;
; 400  : 
; 401  :     for (;;) {
; 402  :         switch (*set++) {

  0001a	8b 01		 mov	 eax, DWORD PTR [rcx]
  0001c	8b f2		 mov	 esi, edx
  0001e	bf 01 00 00 00	 mov	 edi, 1
  00023	48 8d 59 04	 lea	 rbx, QWORD PTR [rcx+4]
  00027	83 f8 1b	 cmp	 eax, 27
  0002a	0f 87 ee 00 00
	00		 ja	 $LN1@sre_uchars
  00030	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:__ImageBase
  00037	33 ed		 xor	 ebp, ebp
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL25@sre_uchars:
  00040	41 0f b6 84 04
	00 00 00 00	 movzx	 eax, BYTE PTR $LN34@sre_uchars[r12+rax]
  00049	41 8b 8c 84 00
	00 00 00	 mov	 ecx, DWORD PTR $LN35@sre_uchars[r12+rax*4]
  00051	49 03 cc	 add	 rcx, r12
  00054	ff e1		 jmp	 rcx
$LN20@sre_uchars:

; 406  : 
; 407  :         case SRE_OP_LITERAL:
; 408  :             /* <LITERAL> <code> */
; 409  :             if (ch == set[0])

  00056	3b 33		 cmp	 esi, DWORD PTR [rbx]
  00058	0f 84 dd 00 00
	00		 je	 $LN29@sre_uchars

; 411  :             set++;

  0005e	48 83 c3 04	 add	 rbx, 4

; 412  :             break;

  00062	e9 a8 00 00 00	 jmp	 $LN5@sre_uchars
$LN18@sre_uchars:

; 413  : 
; 414  :         case SRE_OP_CATEGORY:
; 415  :             /* <CATEGORY> <code> */
; 416  :             if (sre_category(set[0], (int) ch))

  00067	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00069	8b d6		 mov	 edx, esi
  0006b	e8 00 00 00 00	 call	 sre_category
  00070	85 c0		 test	 eax, eax
  00072	0f 85 c3 00 00
	00		 jne	 $LN29@sre_uchars

; 417  :                 return ok;
; 418  :             set += 1;

  00078	48 83 c3 04	 add	 rbx, 4

; 419  :             break;

  0007c	e9 8e 00 00 00	 jmp	 $LN5@sre_uchars
$LN16@sre_uchars:

; 420  : 
; 421  :         case SRE_OP_CHARSET:
; 422  :             if (sizeof(SRE_CODE) == 2) {
; 423  :                 /* <CHARSET> <bitmap> (16 bits per code word) */
; 424  :                 if (ch < 256 && (set[ch >> 4] & (1 << (ch & 15))))
; 425  :                     return ok;
; 426  :                 set += 16;
; 427  :             }
; 428  :             else {
; 429  :                 /* <CHARSET> <bitmap> (32 bits per code word) */
; 430  :                 if (ch < 256 && (set[ch >> 5] & (1u << (ch & 31))))

  00081	81 fe 00 01 00
	00		 cmp	 esi, 256		; 00000100H
  00087	73 18		 jae	 SHORT $LN12@sre_uchars
  00089	48 8b c6	 mov	 rax, rsi
  0008c	8b ce		 mov	 ecx, esi
  0008e	48 c1 e8 05	 shr	 rax, 5
  00092	83 e1 1f	 and	 ecx, 31
  00095	8b 04 83	 mov	 eax, DWORD PTR [rbx+rax*4]
  00098	0f a3 c8	 bt	 eax, ecx
  0009b	0f 82 9a 00 00
	00		 jb	 $LN29@sre_uchars
$LN12@sre_uchars:

; 431  :                     return ok;
; 432  :                 set += 8;

  000a1	48 83 c3 20	 add	 rbx, 32			; 00000020H

; 433  :             }
; 434  :             break;

  000a5	eb 68		 jmp	 SHORT $LN5@sre_uchars
$LN11@sre_uchars:

; 435  : 
; 436  :         case SRE_OP_RANGE:
; 437  :             /* <RANGE> <lower> <upper> */
; 438  :             if (set[0] <= ch && ch <= set[1])

  000a7	39 33		 cmp	 DWORD PTR [rbx], esi
  000a9	77 09		 ja	 SHORT $LN10@sre_uchars
  000ab	3b 73 04	 cmp	 esi, DWORD PTR [rbx+4]
  000ae	0f 86 87 00 00
	00		 jbe	 $LN29@sre_uchars
$LN10@sre_uchars:

; 439  :                 return ok;
; 440  :             set += 2;

  000b4	48 83 c3 08	 add	 rbx, 8

; 441  :             break;

  000b8	eb 55		 jmp	 SHORT $LN5@sre_uchars
$LN9@sre_uchars:

; 442  : 
; 443  :         case SRE_OP_NEGATE:
; 444  :             ok = !ok;

  000ba	85 ff		 test	 edi, edi
  000bc	8b c5		 mov	 eax, ebp
  000be	0f 94 c0	 sete	 al
  000c1	8b f8		 mov	 edi, eax

; 445  :             break;

  000c3	eb 4a		 jmp	 SHORT $LN5@sre_uchars
$LN8@sre_uchars:

; 446  : 
; 447  :         case SRE_OP_BIGCHARSET:
; 448  :             /* <BIGCHARSET> <blockcount> <256 blockindices> <blocks> */
; 449  :         {
; 450  :             Py_ssize_t count, block;
; 451  :             count = *(set++);

  000c5	44 8b 03	 mov	 r8d, DWORD PTR [rbx]

; 452  : 
; 453  :             if (sizeof(SRE_CODE) == 2) {
; 454  :                 block = ((unsigned char*)set)[ch >> 8];
; 455  :                 set += 128;
; 456  :                 if (set[block*16 + ((ch & 255)>>4)] & (1 << (ch & 15)))
; 457  :                     return ok;
; 458  :                 set += count*16;
; 459  :             }
; 460  :             else {
; 461  :                 /* !(c & ~N) == (c < N+1) for any unsigned c, this avoids
; 462  :                  * warnings when c's type supports only numbers < N+1 */
; 463  :                 if (!(ch & ~65535))

  000c8	f7 c6 00 00 ff
	ff		 test	 esi, -65536		; ffff0000H
  000ce	75 0e		 jne	 SHORT $LN4@sre_uchars

; 464  :                     block = ((unsigned char*)set)[ch >> 8];

  000d0	48 8b c6	 mov	 rax, rsi
  000d3	48 c1 e8 08	 shr	 rax, 8
  000d7	0f b6 4c 18 04	 movzx	 ecx, BYTE PTR [rax+rbx+4]

; 465  :                 else

  000dc	eb 04		 jmp	 SHORT $LN3@sre_uchars
$LN4@sre_uchars:

; 466  :                     block = -1;

  000de	48 83 c9 ff	 or	 rcx, -1
$LN3@sre_uchars:

; 467  :                 set += 64;

  000e2	48 81 c3 04 01
	00 00		 add	 rbx, 260		; 00000104H

; 468  :                 if (block >=0 &&
; 469  :                     (set[block*8 + ((ch & 255)>>5)] & (1u << (ch & 31))))

  000e9	48 85 c9	 test	 rcx, rcx
  000ec	78 1a		 js	 SHORT $LN2@sre_uchars
  000ee	8b c6		 mov	 eax, esi
  000f0	48 c1 e8 05	 shr	 rax, 5
  000f4	83 e0 07	 and	 eax, 7
  000f7	48 8d 14 c8	 lea	 rdx, QWORD PTR [rax+rcx*8]
  000fb	8b ce		 mov	 ecx, esi
  000fd	8b 04 93	 mov	 eax, DWORD PTR [rbx+rdx*4]
  00100	83 e1 1f	 and	 ecx, 31
  00103	0f a3 c8	 bt	 eax, ecx
  00106	72 33		 jb	 SHORT $LN29@sre_uchars
$LN2@sre_uchars:

; 470  :                     return ok;
; 471  :                 set += count*8;

  00108	49 c1 e0 05	 shl	 r8, 5
  0010c	49 03 d8	 add	 rbx, r8
$LN5@sre_uchars:

; 397  :     /* check if character is a member of the given set */
; 398  : 
; 399  :     int ok = 1;
; 400  : 
; 401  :     for (;;) {
; 402  :         switch (*set++) {

  0010f	8b 03		 mov	 eax, DWORD PTR [rbx]
  00111	48 83 c3 04	 add	 rbx, 4
  00115	83 f8 1b	 cmp	 eax, 27
  00118	0f 86 22 ff ff
	ff		 jbe	 $LL25@sre_uchars
$LN1@sre_uchars:

; 472  :             }
; 473  :             break;
; 474  :         }
; 475  : 
; 476  :         default:
; 477  :             /* internal error -- there's not much we can do about it
; 478  :                here, so let's just pretend it didn't match... */
; 479  :             return 0;

  0011e	33 c0		 xor	 eax, eax
$LN24@sre_uchars:

; 480  :         }
; 481  :     }
; 482  : }

  00120	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00125	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0012a	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0012f	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00134	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00138	41 5c		 pop	 r12
  0013a	c3		 ret	 0
$LN29@sre_uchars:

; 410  :                 return ok;

  0013b	8b c7		 mov	 eax, edi
  0013d	eb e1		 jmp	 SHORT $LN24@sre_uchars
$LN21@sre_uchars:

; 403  : 
; 404  :         case SRE_OP_FAILURE:
; 405  :             return !ok;

  0013f	85 ff		 test	 edi, edi
  00141	40 0f 94 c5	 sete	 bpl
  00145	8b c5		 mov	 eax, ebp
  00147	eb d7		 jmp	 SHORT $LN24@sre_uchars
  00149	0f 1f 00	 npad	 3
$LN35@sre_uchars:

; 480  :         }
; 481  :     }
; 482  : }

  0014c	00 00 00 00	 DD	 $LN21@sre_uchars
  00150	00 00 00 00	 DD	 $LN18@sre_uchars
  00154	00 00 00 00	 DD	 $LN16@sre_uchars
  00158	00 00 00 00	 DD	 $LN8@sre_uchars
  0015c	00 00 00 00	 DD	 $LN20@sre_uchars
  00160	00 00 00 00	 DD	 $LN9@sre_uchars
  00164	00 00 00 00	 DD	 $LN11@sre_uchars
  00168	00 00 00 00	 DD	 $LN1@sre_uchars
$LN34@sre_uchars:
  0016c	00		 DB	 0
  0016d	07		 DB	 7
  0016e	07		 DB	 7
  0016f	07		 DB	 7
  00170	07		 DB	 7
  00171	07		 DB	 7
  00172	07		 DB	 7
  00173	07		 DB	 7
  00174	07		 DB	 7
  00175	01		 DB	 1
  00176	02		 DB	 2
  00177	03		 DB	 3
  00178	07		 DB	 7
  00179	07		 DB	 7
  0017a	07		 DB	 7
  0017b	07		 DB	 7
  0017c	07		 DB	 7
  0017d	07		 DB	 7
  0017e	07		 DB	 7
  0017f	04		 DB	 4
  00180	07		 DB	 7
  00181	07		 DB	 7
  00182	07		 DB	 7
  00183	07		 DB	 7
  00184	07		 DB	 7
  00185	07		 DB	 7
  00186	05		 DB	 5
  00187	06		 DB	 6
sre_ucharset ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sre_ucount DD imagerel sre_ucount
	DD	imagerel sre_ucount+692
	DD	imagerel $unwind$sre_ucount
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sre_ucount DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT sre_ucount
_TEXT	SEGMENT
state$ = 48
pattern$ = 56
maxcount$ = 64
sre_ucount PROC						; COMDAT

; 488  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 489  :     SRE_CODE chr;
; 490  :     char* ptr = (char *)state->ptr;
; 491  :     char* end = (char *)state->end;

  00014	48 8b 79 18	 mov	 rdi, QWORD PTR [rcx+24]
  00018	48 8b 19	 mov	 rbx, QWORD PTR [rcx]

; 492  :     Py_ssize_t i;
; 493  : 
; 494  :     /* adjust end */
; 495  :     if (maxcount < (end - ptr) / state->charsize && maxcount != SRE_MAXREPEAT)

  0001b	4c 63 49 3c	 movsxd	 r9, DWORD PTR [rcx+60]
  0001f	48 8b ea	 mov	 rbp, rdx
  00022	48 8b c7	 mov	 rax, rdi
  00025	48 8b f1	 mov	 rsi, rcx
  00028	48 2b c3	 sub	 rax, rbx
  0002b	48 99		 cdq
  0002d	49 f7 f9	 idiv	 r9
  00030	4c 3b c0	 cmp	 r8, rax
  00033	7d 14		 jge	 SHORT $LN27@sre_ucount
  00035	b8 ff ff ff ff	 mov	 eax, -1
  0003a	4c 3b c0	 cmp	 r8, rax
  0003d	74 0a		 je	 SHORT $LN27@sre_ucount

; 496  :         end = ptr + maxcount*state->charsize;

  0003f	49 8b f9	 mov	 rdi, r9
  00042	49 0f af f8	 imul	 rdi, r8
  00046	48 03 fb	 add	 rdi, rbx
$LN27@sre_ucount:

; 497  : 
; 498  :     switch (pattern[0]) {

  00049	8b 45 00	 mov	 eax, DWORD PTR [rbp]
  0004c	83 c0 fe	 add	 eax, -2			; fffffffeH
  0004f	83 f8 17	 cmp	 eax, 23
  00052	0f 87 e2 01 00
	00		 ja	 $LN66@sre_ucount
  00058	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  0005f	0f b6 84 02 00
	00 00 00	 movzx	 eax, BYTE PTR $LN76@sre_ucount[rdx+rax]
  00067	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN77@sre_ucount[rdx+rax*4]
  0006e	48 03 ca	 add	 rcx, rdx
  00071	ff e1		 jmp	 rcx
$LN60@sre_ucount:

; 499  : 
; 500  :     case SRE_OP_IN:
; 501  :         /* repeated set */
; 502  :         TRACE(("|%p|%p|COUNT IN\n", pattern, ptr));
; 503  :         while (ptr < end &&
; 504  :                SRE_CHARSET(pattern + 2, SRE_CHARGET(state, ptr, 0)))

  00073	48 3b df	 cmp	 rbx, rdi
  00076	0f 83 b6 01 00
	00		 jae	 $LN78@sre_ucount
  0007c	0f 1f 40 00	 npad	 4
$LL23@sre_ucount:
  00080	41 83 f9 01	 cmp	 r9d, 1
  00084	75 05		 jne	 SHORT $LN32@sre_ucount
  00086	0f b6 13	 movzx	 edx, BYTE PTR [rbx]
  00089	eb 0d		 jmp	 SHORT $LN31@sre_ucount
$LN32@sre_ucount:
  0008b	41 83 f9 02	 cmp	 r9d, 2
  0008f	75 05		 jne	 SHORT $LN30@sre_ucount
  00091	0f b7 13	 movzx	 edx, WORD PTR [rbx]
  00094	eb 02		 jmp	 SHORT $LN31@sre_ucount
$LN30@sre_ucount:
  00096	8b 13		 mov	 edx, DWORD PTR [rbx]
$LN31@sre_ucount:
  00098	48 8d 4d 08	 lea	 rcx, QWORD PTR [rbp+8]
  0009c	e8 00 00 00 00	 call	 sre_ucharset
  000a1	85 c0		 test	 eax, eax
  000a3	0f 84 89 01 00
	00		 je	 $LN78@sre_ucount

; 505  :             ptr += state->charsize;

  000a9	4c 63 4e 3c	 movsxd	 r9, DWORD PTR [rsi+60]
  000ad	49 03 d9	 add	 rbx, r9
  000b0	48 3b df	 cmp	 rbx, rdi
  000b3	72 cb		 jb	 SHORT $LL23@sre_ucount

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  000b5	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  000b8	48 8b c3	 mov	 rax, rbx
  000bb	e9 9d 01 00 00	 jmp	 $LN79@sre_ucount
$LN61@sre_ucount:

; 506  :         break;
; 507  : 
; 508  :     case SRE_OP_ANY:
; 509  :         /* repeated dot wildcard. */
; 510  :         TRACE(("|%p|%p|COUNT ANY\n", pattern, ptr));
; 511  :         while (ptr < end && !SRE_IS_LINEBREAK(SRE_CHARGET(state, ptr, 0)))

  000c0	48 3b df	 cmp	 rbx, rdi
  000c3	0f 83 69 01 00
	00		 jae	 $LN78@sre_ucount
  000c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL20@sre_ucount:
  000d0	41 83 f9 01	 cmp	 r9d, 1
  000d4	75 05		 jne	 SHORT $LN36@sre_ucount
  000d6	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  000d9	eb 0d		 jmp	 SHORT $LN35@sre_ucount
$LN36@sre_ucount:
  000db	41 83 f9 02	 cmp	 r9d, 2
  000df	75 05		 jne	 SHORT $LN34@sre_ucount
  000e1	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  000e4	eb 02		 jmp	 SHORT $LN35@sre_ucount
$LN34@sre_ucount:
  000e6	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN35@sre_ucount:
  000e8	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  000ed	73 29		 jae	 SHORT $LN75@sre_ucount
  000ef	41 83 f9 01	 cmp	 r9d, 1
  000f3	75 05		 jne	 SHORT $LN40@sre_ucount
  000f5	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  000f8	eb 0d		 jmp	 SHORT $LN39@sre_ucount
$LN40@sre_ucount:
  000fa	41 83 f9 02	 cmp	 r9d, 2
  000fe	75 05		 jne	 SHORT $LN38@sre_ucount
  00100	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  00103	eb 02		 jmp	 SHORT $LN39@sre_ucount
$LN38@sre_ucount:
  00105	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN39@sre_ucount:
  00107	0f be 8c 10 00
	00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+rdx]
  0010f	83 e1 04	 and	 ecx, 4
  00112	0f 85 1a 01 00
	00		 jne	 $LN78@sre_ucount
$LN75@sre_ucount:

; 512  :             ptr += state->charsize;

  00118	49 03 d9	 add	 rbx, r9
  0011b	48 3b df	 cmp	 rbx, rdi
  0011e	72 b0		 jb	 SHORT $LL20@sre_ucount

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  00120	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  00123	48 8b c3	 mov	 rax, rbx
  00126	e9 32 01 00 00	 jmp	 $LN79@sre_ucount
$LN18@sre_ucount:

; 513  :         break;
; 514  : 
; 515  :     case SRE_OP_ANY_ALL:
; 516  :         /* repeated dot wildcard.  skip to the end of the target
; 517  :            string, and backtrack from there */
; 518  :         TRACE(("|%p|%p|COUNT ANY_ALL\n", pattern, ptr));
; 519  :         ptr = end;

  0012b	48 8b df	 mov	 rbx, rdi

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  0012e	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  00131	48 8b c3	 mov	 rax, rbx
  00134	e9 24 01 00 00	 jmp	 $LN79@sre_ucount
$LN17@sre_ucount:

; 520  :         break;
; 521  : 
; 522  :     case SRE_OP_LITERAL:
; 523  :         /* repeated literal */
; 524  :         chr = pattern[1];

  00139	8b 4d 04	 mov	 ecx, DWORD PTR [rbp+4]

; 525  :         TRACE(("|%p|%p|COUNT LITERAL %d\n", pattern, ptr, chr));
; 526  :         while (ptr < end && (SRE_CODE) SRE_CHARGET(state, ptr, 0) == chr)

  0013c	48 3b df	 cmp	 rbx, rdi
  0013f	0f 83 ed 00 00
	00		 jae	 $LN78@sre_ucount
$LL16@sre_ucount:
  00145	41 83 f9 01	 cmp	 r9d, 1
  00149	75 05		 jne	 SHORT $LN46@sre_ucount
  0014b	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  0014e	eb 0d		 jmp	 SHORT $LN45@sre_ucount
$LN46@sre_ucount:
  00150	41 83 f9 02	 cmp	 r9d, 2
  00154	75 05		 jne	 SHORT $LN44@sre_ucount
  00156	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  00159	eb 02		 jmp	 SHORT $LN45@sre_ucount
$LN44@sre_ucount:
  0015b	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN45@sre_ucount:
  0015d	3b c1		 cmp	 eax, ecx
  0015f	0f 85 cd 00 00
	00		 jne	 $LN78@sre_ucount

; 527  :             ptr += state->charsize;

  00165	49 03 d9	 add	 rbx, r9
  00168	48 3b df	 cmp	 rbx, rdi
  0016b	72 d8		 jb	 SHORT $LL16@sre_ucount

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  0016d	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  00170	48 8b c3	 mov	 rax, rbx
  00173	e9 e5 00 00 00	 jmp	 $LN79@sre_ucount
$LN14@sre_ucount:

; 528  :         break;
; 529  : 
; 530  :     case SRE_OP_LITERAL_IGNORE:
; 531  :         /* repeated literal */
; 532  :         chr = pattern[1];

  00178	8b 6d 04	 mov	 ebp, DWORD PTR [rbp+4]

; 533  :         TRACE(("|%p|%p|COUNT LITERAL_IGNORE %d\n", pattern, ptr, chr));
; 534  :         while (ptr < end && (SRE_CODE) state->lower(SRE_CHARGET(state, ptr, 0)) == chr)

  0017b	48 3b df	 cmp	 rbx, rdi
  0017e	0f 83 ae 00 00
	00		 jae	 $LN78@sre_ucount
$LL13@sre_ucount:
  00184	41 83 f9 01	 cmp	 r9d, 1
  00188	75 05		 jne	 SHORT $LN50@sre_ucount
  0018a	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  0018d	eb 0d		 jmp	 SHORT $LN49@sre_ucount
$LN50@sre_ucount:
  0018f	41 83 f9 02	 cmp	 r9d, 2
  00193	75 05		 jne	 SHORT $LN48@sre_ucount
  00195	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  00198	eb 02		 jmp	 SHORT $LN49@sre_ucount
$LN48@sre_ucount:
  0019a	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN49@sre_ucount:
  0019c	ff 96 00 07 00
	00		 call	 QWORD PTR [rsi+1792]
  001a2	3b c5		 cmp	 eax, ebp
  001a4	0f 85 88 00 00
	00		 jne	 $LN78@sre_ucount

; 535  :             ptr += state->charsize;

  001aa	4c 63 4e 3c	 movsxd	 r9, DWORD PTR [rsi+60]
  001ae	49 03 d9	 add	 rbx, r9
  001b1	48 3b df	 cmp	 rbx, rdi
  001b4	72 ce		 jb	 SHORT $LL13@sre_ucount

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  001b6	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  001b9	48 8b c3	 mov	 rax, rbx
  001bc	e9 9c 00 00 00	 jmp	 $LN79@sre_ucount
$LN11@sre_ucount:

; 536  :         break;
; 537  : 
; 538  :     case SRE_OP_NOT_LITERAL:
; 539  :         /* repeated non-literal */
; 540  :         chr = pattern[1];

  001c1	8b 4d 04	 mov	 ecx, DWORD PTR [rbp+4]

; 541  :         TRACE(("|%p|%p|COUNT NOT_LITERAL %d\n", pattern, ptr, chr));
; 542  :         while (ptr < end && (SRE_CODE) SRE_CHARGET(state, ptr, 0) != chr)

  001c4	48 3b df	 cmp	 rbx, rdi
  001c7	73 69		 jae	 SHORT $LN78@sre_ucount
  001c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL10@sre_ucount:
  001d0	41 83 f9 01	 cmp	 r9d, 1
  001d4	75 05		 jne	 SHORT $LN54@sre_ucount
  001d6	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  001d9	eb 0d		 jmp	 SHORT $LN53@sre_ucount
$LN54@sre_ucount:
  001db	41 83 f9 02	 cmp	 r9d, 2
  001df	75 05		 jne	 SHORT $LN52@sre_ucount
  001e1	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  001e4	eb 02		 jmp	 SHORT $LN53@sre_ucount
$LN52@sre_ucount:
  001e6	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN53@sre_ucount:
  001e8	3b c1		 cmp	 eax, ecx
  001ea	74 46		 je	 SHORT $LN78@sre_ucount

; 543  :             ptr += state->charsize;

  001ec	49 03 d9	 add	 rbx, r9
  001ef	48 3b df	 cmp	 rbx, rdi
  001f2	72 dc		 jb	 SHORT $LL10@sre_ucount

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  001f4	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  001f7	48 8b c3	 mov	 rax, rbx
  001fa	eb 61		 jmp	 SHORT $LN79@sre_ucount
$LN8@sre_ucount:

; 544  :         break;
; 545  : 
; 546  :     case SRE_OP_NOT_LITERAL_IGNORE:
; 547  :         /* repeated non-literal */
; 548  :         chr = pattern[1];

  001fc	8b 6d 04	 mov	 ebp, DWORD PTR [rbp+4]

; 549  :         TRACE(("|%p|%p|COUNT NOT_LITERAL_IGNORE %d\n", pattern, ptr, chr));
; 550  :         while (ptr < end && (SRE_CODE) state->lower(SRE_CHARGET(state, ptr, 0)) != chr)

  001ff	48 3b df	 cmp	 rbx, rdi
  00202	73 2e		 jae	 SHORT $LN78@sre_ucount
$LL7@sre_ucount:
  00204	41 83 f9 01	 cmp	 r9d, 1
  00208	75 05		 jne	 SHORT $LN58@sre_ucount
  0020a	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  0020d	eb 0d		 jmp	 SHORT $LN57@sre_ucount
$LN58@sre_ucount:
  0020f	41 83 f9 02	 cmp	 r9d, 2
  00213	75 05		 jne	 SHORT $LN56@sre_ucount
  00215	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  00218	eb 02		 jmp	 SHORT $LN57@sre_ucount
$LN56@sre_ucount:
  0021a	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN57@sre_ucount:
  0021c	ff 96 00 07 00
	00		 call	 QWORD PTR [rsi+1792]
  00222	3b c5		 cmp	 eax, ebp
  00224	74 0c		 je	 SHORT $LN78@sre_ucount

; 551  :             ptr += state->charsize;

  00226	4c 63 4e 3c	 movsxd	 r9, DWORD PTR [rsi+60]
  0022a	49 03 d9	 add	 rbx, r9
  0022d	48 3b df	 cmp	 rbx, rdi
  00230	72 d2		 jb	 SHORT $LL7@sre_ucount
$LN78@sre_ucount:

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  00232	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  00235	48 8b c3	 mov	 rax, rbx
  00238	eb 23		 jmp	 SHORT $LN79@sre_ucount
$LN66@sre_ucount:

; 552  :         break;
; 553  : 
; 554  :     default:
; 555  :         /* repeated single character pattern */
; 556  :         TRACE(("|%p|%p|COUNT SUBPATTERN\n", pattern, ptr));
; 557  :         while ((char*) state->ptr < end) {

  0023a	48 3b df	 cmp	 rbx, rdi
  0023d	73 18		 jae	 SHORT $LN68@sre_ucount
  0023f	90		 npad	 1
$LL4@sre_ucount:

; 558  :             i = SRE_MATCH(state, pattern);

  00240	48 8b d5	 mov	 rdx, rbp
  00243	48 8b ce	 mov	 rcx, rsi
  00246	e8 00 00 00 00	 call	 sre_umatch

; 559  :             if (i < 0)

  0024b	48 85 c0	 test	 rax, rax
  0024e	78 16		 js	 SHORT $LN28@sre_ucount

; 560  :                 return i;
; 561  :             if (!i)

  00250	74 05		 je	 SHORT $LN68@sre_ucount

; 552  :         break;
; 553  : 
; 554  :     default:
; 555  :         /* repeated single character pattern */
; 556  :         TRACE(("|%p|%p|COUNT SUBPATTERN\n", pattern, ptr));
; 557  :         while ((char*) state->ptr < end) {

  00252	48 39 3e	 cmp	 QWORD PTR [rsi], rdi
  00255	72 e9		 jb	 SHORT $LL4@sre_ucount
$LN68@sre_ucount:

; 562  :                 break;
; 563  :         }
; 564  :         TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 565  :                ((char*)state->ptr - ptr)/state->charsize));
; 566  :         return ((char*)state->ptr - ptr)/state->charsize;

  00257	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0025a	48 2b c3	 sub	 rax, rbx
$LN79@sre_ucount:
  0025d	48 63 4e 3c	 movsxd	 rcx, DWORD PTR [rsi+60]
  00261	48 99		 cdq
  00263	48 f7 f9	 idiv	 rcx
$LN28@sre_ucount:

; 572  : }

  00266	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0026b	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00270	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00275	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00279	5f		 pop	 rdi
  0027a	c3		 ret	 0
  0027b	90		 npad	 1
$LN77@sre_ucount:
  0027c	00 00 00 00	 DD	 $LN61@sre_ucount
  00280	00 00 00 00	 DD	 $LN18@sre_ucount
  00284	00 00 00 00	 DD	 $LN60@sre_ucount
  00288	00 00 00 00	 DD	 $LN17@sre_ucount
  0028c	00 00 00 00	 DD	 $LN14@sre_ucount
  00290	00 00 00 00	 DD	 $LN11@sre_ucount
  00294	00 00 00 00	 DD	 $LN8@sre_ucount
  00298	00 00 00 00	 DD	 $LN66@sre_ucount
$LN76@sre_ucount:
  0029c	00		 DB	 0
  0029d	01		 DB	 1
  0029e	07		 DB	 7
  0029f	07		 DB	 7
  002a0	07		 DB	 7
  002a1	07		 DB	 7
  002a2	07		 DB	 7
  002a3	07		 DB	 7
  002a4	07		 DB	 7
  002a5	07		 DB	 7
  002a6	07		 DB	 7
  002a7	07		 DB	 7
  002a8	07		 DB	 7
  002a9	02		 DB	 2
  002aa	07		 DB	 7
  002ab	07		 DB	 7
  002ac	07		 DB	 7
  002ad	03		 DB	 3
  002ae	04		 DB	 4
  002af	07		 DB	 7
  002b0	07		 DB	 7
  002b1	07		 DB	 7
  002b2	05		 DB	 5
  002b3	06		 DB	 6
sre_ucount ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sre_umatch DD imagerel sre_umatch
	DD	imagerel sre_umatch+100
	DD	imagerel $unwind$sre_umatch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$sre_umatch DD imagerel sre_umatch+100
	DD	imagerel sre_umatch+5364
	DD	imagerel $chain$3$sre_umatch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$sre_umatch DD imagerel sre_umatch+5364
	DD	imagerel sre_umatch+5544
	DD	imagerel $chain$5$sre_umatch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$sre_umatch DD 080021H
	DD	04c400H
	DD	0d7400H
	DD	0c6400H
	DD	0b5400H
	DD	imagerel sre_umatch
	DD	imagerel sre_umatch+100
	DD	imagerel $unwind$sre_umatch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$sre_umatch DD 081821H
	DD	04c418H
	DD	0d740fH
	DD	0c640aH
	DD	0b5405H
	DD	imagerel sre_umatch
	DD	imagerel sre_umatch+100
	DD	imagerel $unwind$sre_umatch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sre_umatch DD 050c01H
	DD	0f008420cH
	DD	0d004e006H
	DD	03002H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT sre_umatch
_TEXT	SEGMENT
sigcount$1$ = 80
state$ = 80
pattern$ = 88
sre_umatch PROC						; COMDAT

; 782  : {

  00000	40 53		 push	 rbx
  00002	41 55		 push	 r13
  00004	41 56		 push	 r14
  00006	41 57		 push	 r15
  00008	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 783  :     char* end = (char*)state->end;
; 784  :     Py_ssize_t alloc_pos, ctx_pos = -1;
; 785  :     Py_ssize_t i, ret = 0;
; 786  :     Py_ssize_t jump;
; 787  :     unsigned int sigcount=0;
; 788  : 
; 789  :     SRE_MATCH_CONTEXT* ctx;
; 790  :     SRE_MATCH_CONTEXT* nextctx;
; 791  : 
; 792  :     TRACE(("|%p|%p|ENTER\n", pattern, state->ptr));
; 793  : 
; 794  :     DATA_ALLOC(SRE_MATCH_CONTEXT, ctx);

  0000c	4c 8b b9 a0 06
	00 00		 mov	 r15, QWORD PTR [rcx+1696]
  00013	48 8b 81 98 06
	00 00		 mov	 rax, QWORD PTR [rcx+1688]
  0001a	4c 8b 71 18	 mov	 r14, QWORD PTR [rcx+24]
  0001e	45 33 d2	 xor	 r10d, r10d
  00021	49 2b c7	 sub	 rax, r15
  00024	48 8b da	 mov	 rbx, rdx
  00027	4c 8b e9	 mov	 r13, rcx
  0002a	44 89 54 24 50	 mov	 DWORD PTR sigcount$1$[rsp], r10d
  0002f	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00033	73 20		 jae	 SHORT $LN709@sre_umatch
  00035	41 8d 52 40	 lea	 edx, QWORD PTR [r10+64]
  00039	e8 00 00 00 00	 call	 data_stack_grow
  0003e	85 c0		 test	 eax, eax
  00040	79 0e		 jns	 SHORT $LN1039@sre_umatch
  00042	48 98		 cdqe

; 1427 :         case JUMP_MAX_UNTIL_2:
; 1428 :             TRACE(("|%p|%p|JUMP_MAX_UNTIL_2\n", ctx->pattern, ctx->ptr));
; 1429 :             goto jump_max_until_2;
; 1430 :         case JUMP_MAX_UNTIL_3:
; 1431 :             TRACE(("|%p|%p|JUMP_MAX_UNTIL_3\n", ctx->pattern, ctx->ptr));
; 1432 :             goto jump_max_until_3;
; 1433 :         case JUMP_MIN_UNTIL_2:
; 1434 :             TRACE(("|%p|%p|JUMP_MIN_UNTIL_2\n", ctx->pattern, ctx->ptr));
; 1435 :             goto jump_min_until_2;
; 1436 :         case JUMP_MIN_UNTIL_3:
; 1437 :             TRACE(("|%p|%p|JUMP_MIN_UNTIL_3\n", ctx->pattern, ctx->ptr));
; 1438 :             goto jump_min_until_3;
; 1439 :         case JUMP_BRANCH:
; 1440 :             TRACE(("|%p|%p|JUMP_BRANCH\n", ctx->pattern, ctx->ptr));
; 1441 :             goto jump_branch;
; 1442 :         case JUMP_MAX_UNTIL_1:
; 1443 :             TRACE(("|%p|%p|JUMP_MAX_UNTIL_1\n", ctx->pattern, ctx->ptr));
; 1444 :             goto jump_max_until_1;
; 1445 :         case JUMP_MIN_UNTIL_1:
; 1446 :             TRACE(("|%p|%p|JUMP_MIN_UNTIL_1\n", ctx->pattern, ctx->ptr));
; 1447 :             goto jump_min_until_1;
; 1448 :         case JUMP_REPEAT:
; 1449 :             TRACE(("|%p|%p|JUMP_REPEAT\n", ctx->pattern, ctx->ptr));
; 1450 :             goto jump_repeat;
; 1451 :         case JUMP_REPEAT_ONE_1:
; 1452 :             TRACE(("|%p|%p|JUMP_REPEAT_ONE_1\n", ctx->pattern, ctx->ptr));
; 1453 :             goto jump_repeat_one_1;
; 1454 :         case JUMP_REPEAT_ONE_2:
; 1455 :             TRACE(("|%p|%p|JUMP_REPEAT_ONE_2\n", ctx->pattern, ctx->ptr));
; 1456 :             goto jump_repeat_one_2;
; 1457 :         case JUMP_MIN_REPEAT_ONE:
; 1458 :             TRACE(("|%p|%p|JUMP_MIN_REPEAT_ONE\n", ctx->pattern, ctx->ptr));
; 1459 :             goto jump_min_repeat_one;
; 1460 :         case JUMP_ASSERT:
; 1461 :             TRACE(("|%p|%p|JUMP_ASSERT\n", ctx->pattern, ctx->ptr));
; 1462 :             goto jump_assert;
; 1463 :         case JUMP_ASSERT_NOT:
; 1464 :             TRACE(("|%p|%p|JUMP_ASSERT_NOT\n", ctx->pattern, ctx->ptr));
; 1465 :             goto jump_assert_not;
; 1466 :         case JUMP_NONE:
; 1467 :             TRACE(("|%p|%p|RETURN %" PY_FORMAT_SIZE_T "d\n", ctx->pattern,
; 1468 :                    ctx->ptr, ret));
; 1469 :             break;
; 1470 :     }
; 1471 : 
; 1472 :     return ret; /* should never get here */
; 1473 : }

  00044	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00048	41 5f		 pop	 r15
  0004a	41 5e		 pop	 r14
  0004c	41 5d		 pop	 r13
  0004e	5b		 pop	 rbx
  0004f	c3		 ret	 0
$LN1039@sre_umatch:

; 979  :                 DO_JUMP(JUMP_BRANCH, jump_branch, ctx->pattern+1);

  00050	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
$LN709@sre_umatch:

; 783  :     char* end = (char*)state->end;
; 784  :     Py_ssize_t alloc_pos, ctx_pos = -1;
; 785  :     Py_ssize_t i, ret = 0;
; 786  :     Py_ssize_t jump;
; 787  :     unsigned int sigcount=0;
; 788  : 
; 789  :     SRE_MATCH_CONTEXT* ctx;
; 790  :     SRE_MATCH_CONTEXT* nextctx;
; 791  : 
; 792  :     TRACE(("|%p|%p|ENTER\n", pattern, state->ptr));
; 793  : 
; 794  :     DATA_ALLOC(SRE_MATCH_CONTEXT, ctx);

  00055	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  0005c	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H
  00064	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp
  00069	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  0006e	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi
  00073	49 8d 3c 07	 lea	 rdi, QWORD PTR [r15+rax]
  00077	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12

; 795  :     ctx->last_ctx_pos = -1;
; 796  :     ctx->jump = JUMP_NONE;
; 797  :     ctx->pattern = pattern;
; 798  :     ctx_pos = alloc_pos;

  0007c	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:__ImageBase
  00083	48 c7 07 ff ff
	ff ff		 mov	 QWORD PTR [rdi], -1
  0008a	48 c7 47 08 00
	00 00 00	 mov	 QWORD PTR [rdi+8], 0
  00092	48 89 5f 18	 mov	 QWORD PTR [rdi+24], rbx
  00096	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$entrance$22203:

; 799  : 
; 800  : entrance:
; 801  : 
; 802  :     ctx->ptr = (char *)state->ptr;

  000a0	49 8b 4d 00	 mov	 rcx, QWORD PTR [r13]

; 803  : 
; 804  :     if (ctx->pattern[0] == SRE_OP_INFO) {

  000a4	4c 8b 47 18	 mov	 r8, QWORD PTR [rdi+24]
  000a8	48 89 4f 10	 mov	 QWORD PTR [rdi+16], rcx
  000ac	41 83 38 11	 cmp	 DWORD PTR [r8], 17
  000b0	75 2f		 jne	 SHORT $LN703@sre_umatch

; 805  :         /* optimization info block */
; 806  :         /* <INFO> <1=skip> <2=flags> <3=min> ... */
; 807  :         if (ctx->pattern[3] && (end - ctx->ptr)/state->charsize < ctx->pattern[3]) {

  000b2	45 8b 48 0c	 mov	 r9d, DWORD PTR [r8+12]
  000b6	45 85 c9	 test	 r9d, r9d
  000b9	74 18		 je	 SHORT $LN704@sre_umatch
  000bb	49 8b c6	 mov	 rax, r14
  000be	48 2b c1	 sub	 rax, rcx
  000c1	49 63 4d 3c	 movsxd	 rcx, DWORD PTR [r13+60]
  000c5	48 99		 cdq
  000c7	48 f7 f9	 idiv	 rcx
  000ca	49 3b c1	 cmp	 rax, r9

; 808  :             TRACE(("reject (got %" PY_FORMAT_SIZE_T "d chars, "
; 809  :                    "need %" PY_FORMAT_SIZE_T "d)\n",
; 810  :                    (end - ctx->ptr)/state->charsize,
; 811  :                    (Py_ssize_t) ctx->pattern[3]));
; 812  :             RETURN_FAILURE;

  000cd	0f 8c fe 07 00
	00		 jl	 $LL30@sre_umatch
$LN704@sre_umatch:

; 813  :         }
; 814  :         ctx->pattern += ctx->pattern[1] + 1;

  000d3	41 8b 40 04	 mov	 eax, DWORD PTR [r8+4]
  000d7	ff c0		 inc	 eax
  000d9	49 8d 0c 80	 lea	 rcx, QWORD PTR [r8+rax*4]
$LN1052@sre_umatch:
  000dd	48 89 4f 18	 mov	 QWORD PTR [rdi+24], rcx
$LN703@sre_umatch:

; 815  :     }
; 816  : 
; 817  :     for (;;) {
; 818  :         ++sigcount;

  000e1	41 ff c2	 inc	 r10d
  000e4	44 89 54 24 50	 mov	 DWORD PTR sigcount$1$[rsp], r10d

; 819  :         if ((0 == (sigcount & 0xfff)) && PyErr_CheckSignals())

  000e9	41 f7 c2 ff 0f
	00 00		 test	 r10d, 4095		; 00000fffH
  000f0	75 12		 jne	 SHORT $LN698@sre_umatch
  000f2	e8 00 00 00 00	 call	 PyErr_CheckSignals
  000f7	85 c0		 test	 eax, eax
  000f9	0f 85 b8 13 00
	00		 jne	 $LN1007@sre_umatch
  000ff	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
$LN698@sre_umatch:

; 821  : 
; 822  :         switch (*ctx->pattern++) {

  00104	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00108	8b 08		 mov	 ecx, DWORD PTR [rax]
  0010a	4c 8d 58 04	 lea	 r11, QWORD PTR [rax+4]
  0010e	4c 89 5f 18	 mov	 QWORD PTR [rdi+24], r11
  00112	83 f9 1f	 cmp	 ecx, 31
  00115	0f 87 b2 13 00
	00		 ja	 $LN28@sre_umatch
  0011b	8b 8c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR $LN1037@sre_umatch[rbp+rcx*4]
  00122	48 03 cd	 add	 rcx, rbp
  00125	ff e1		 jmp	 rcx
$LN695@sre_umatch:

; 823  : 
; 824  :         case SRE_OP_MARK:
; 825  :             /* set mark */
; 826  :             /* <MARK> <gid> */
; 827  :             TRACE(("|%p|%p|MARK %d\n", ctx->pattern,
; 828  :                    ctx->ptr, ctx->pattern[0]));
; 829  :             i = ctx->pattern[0];

  00127	41 8b 1b	 mov	 ebx, DWORD PTR [r11]

; 830  :             if (i & 1)

  0012a	f6 c3 01	 test	 bl, 1
  0012d	74 11		 je	 SHORT $LN694@sre_umatch

; 831  :                 state->lastindex = i/2 + 1;

  0012f	8b c3		 mov	 eax, ebx
  00131	48 99		 cdq
  00133	48 2b c2	 sub	 rax, rdx
  00136	48 d1 f8	 sar	 rax, 1
  00139	48 ff c0	 inc	 rax
  0013c	49 89 45 40	 mov	 QWORD PTR [r13+64], rax
$LN694@sre_umatch:

; 832  :             if (i > state->lastmark) {

  00140	49 8b 45 48	 mov	 rax, QWORD PTR [r13+72]
  00144	48 3b d8	 cmp	 rbx, rax
  00147	7e 22		 jle	 SHORT $LN693@sre_umatch

; 833  :                 /* state->lastmark is the highest valid index in the
; 834  :                    state->mark array.  If it is increased by more than 1,
; 835  :                    the intervening marks must be set to NULL to signal
; 836  :                    that these marks have not been encountered. */
; 837  :                 Py_ssize_t j = state->lastmark + 1;

  00149	48 ff c0	 inc	 rax

; 838  :                 while (j < i)

  0014c	48 3b c3	 cmp	 rax, rbx
  0014f	7d 16		 jge	 SHORT $LN692@sre_umatch

; 833  :                 /* state->lastmark is the highest valid index in the
; 834  :                    state->mark array.  If it is increased by more than 1,
; 835  :                    the intervening marks must be set to NULL to signal
; 836  :                    that these marks have not been encountered. */
; 837  :                 Py_ssize_t j = state->lastmark + 1;

  00151	4c 8b c3	 mov	 r8, rbx
  00154	49 8d 4c c5 50	 lea	 rcx, QWORD PTR [r13+rax*8+80]
  00159	33 d2		 xor	 edx, edx
  0015b	4c 2b c0	 sub	 r8, rax
  0015e	49 c1 e0 03	 shl	 r8, 3
  00162	e8 00 00 00 00	 call	 memset
$LN692@sre_umatch:

; 839  :                     state->mark[j++] = NULL;
; 840  :                 state->lastmark = i;

  00167	49 89 5d 48	 mov	 QWORD PTR [r13+72], rbx
$LN693@sre_umatch:

; 841  :             }
; 842  :             state->mark[i] = ctx->ptr;

  0016b	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  0016f	49 89 44 dd 50	 mov	 QWORD PTR [r13+rbx*8+80], rax
$LN670@sre_umatch:

; 843  :             ctx->pattern++;

  00174	48 83 47 18 04	 add	 QWORD PTR [rdi+24], 4

; 844  :             break;

  00179	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  0017e	e9 5e ff ff ff	 jmp	 $LN703@sre_umatch
$LN690@sre_umatch:

; 845  : 
; 846  :         case SRE_OP_LITERAL:
; 847  :             /* match literal string */
; 848  :             /* <LITERAL> <code> */
; 849  :             TRACE(("|%p|%p|LITERAL %d\n", ctx->pattern,
; 850  :                    ctx->ptr, *ctx->pattern));
; 851  :             if (ctx->ptr >= end || (SRE_CODE) SRE_CHARGET(state, ctx->ptr, 0) != ctx->pattern[0])

  00183	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00187	49 3b ce	 cmp	 rcx, r14
  0018a	0f 83 41 07 00
	00		 jae	 $LL30@sre_umatch
  00190	41 8b 45 3c	 mov	 eax, DWORD PTR [r13+60]
  00194	83 f8 01	 cmp	 eax, 1
  00197	75 05		 jne	 SHORT $LN722@sre_umatch
  00199	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  0019c	eb 0c		 jmp	 SHORT $LN721@sre_umatch
$LN722@sre_umatch:
  0019e	83 f8 02	 cmp	 eax, 2
  001a1	75 05		 jne	 SHORT $LN720@sre_umatch
  001a3	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  001a6	eb 02		 jmp	 SHORT $LN721@sre_umatch
$LN720@sre_umatch:
  001a8	8b 01		 mov	 eax, DWORD PTR [rcx]
$LN721@sre_umatch:
  001aa	41 3b 03	 cmp	 eax, DWORD PTR [r11]
  001ad	0f 85 1e 07 00
	00		 jne	 $LL30@sre_umatch
$LN1047@sre_umatch:

; 852  :                 RETURN_FAILURE;
; 853  :             ctx->pattern++;

  001b3	49 8d 43 04	 lea	 rax, QWORD PTR [r11+4]
  001b7	48 89 47 18	 mov	 QWORD PTR [rdi+24], rax
$LN653@sre_umatch:

; 854  :             ctx->ptr += state->charsize;

  001bb	49 63 45 3c	 movsxd	 rax, DWORD PTR [r13+60]
  001bf	48 03 c1	 add	 rax, rcx
  001c2	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 855  :             break;

  001c6	e9 16 ff ff ff	 jmp	 $LN703@sre_umatch
$LN684@sre_umatch:

; 856  : 
; 857  :         case SRE_OP_NOT_LITERAL:
; 858  :             /* match anything that is not literal character */
; 859  :             /* <NOT_LITERAL> <code> */
; 860  :             TRACE(("|%p|%p|NOT_LITERAL %d\n", ctx->pattern,
; 861  :                    ctx->ptr, *ctx->pattern));
; 862  :             if (ctx->ptr >= end || (SRE_CODE) SRE_CHARGET(state, ctx->ptr, 0) == ctx->pattern[0])

  001cb	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  001cf	49 3b ce	 cmp	 rcx, r14
  001d2	0f 83 f9 06 00
	00		 jae	 $LL30@sre_umatch
  001d8	41 8b 45 3c	 mov	 eax, DWORD PTR [r13+60]
  001dc	83 f8 01	 cmp	 eax, 1
  001df	75 05		 jne	 SHORT $LN726@sre_umatch
  001e1	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  001e4	eb 0c		 jmp	 SHORT $LN725@sre_umatch
$LN726@sre_umatch:
  001e6	83 f8 02	 cmp	 eax, 2
  001e9	75 05		 jne	 SHORT $LN724@sre_umatch
  001eb	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  001ee	eb 02		 jmp	 SHORT $LN725@sre_umatch
$LN724@sre_umatch:
  001f0	8b 01		 mov	 eax, DWORD PTR [rcx]
$LN725@sre_umatch:
  001f2	41 3b 03	 cmp	 eax, DWORD PTR [r11]

; 864  :             ctx->pattern++;
; 865  :             ctx->ptr += state->charsize;
; 866  :             break;

  001f5	75 bc		 jne	 SHORT $LN1047@sre_umatch

; 863  :                 RETURN_FAILURE;

  001f7	e9 d5 06 00 00	 jmp	 $LL30@sre_umatch
$LN675@sre_umatch:

; 867  : 
; 868  :         case SRE_OP_SUCCESS:
; 869  :             /* end of pattern */
; 870  :             TRACE(("|%p|%p|SUCCESS\n", ctx->pattern, ctx->ptr));
; 871  :             state->ptr = ctx->ptr;
; 872  :             RETURN_SUCCESS;
; 873  : 
; 874  :         case SRE_OP_AT:
; 875  :             /* match at given position */
; 876  :             /* <AT> <code> */
; 877  :             TRACE(("|%p|%p|AT %d\n", ctx->pattern, ctx->ptr, *ctx->pattern));
; 878  :             if (!SRE_AT(state, ctx->ptr, *ctx->pattern))

  001fc	45 8b 03	 mov	 r8d, DWORD PTR [r11]
  001ff	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  00203	49 8b cd	 mov	 rcx, r13
  00206	e8 00 00 00 00	 call	 sre_uat
  0020b	85 c0		 test	 eax, eax
  0020d	0f 85 61 ff ff
	ff		 jne	 $LN670@sre_umatch

; 879  :                 RETURN_FAILURE;

  00213	e9 b9 06 00 00	 jmp	 $LL30@sre_umatch
$LN669@sre_umatch:

; 880  :             ctx->pattern++;
; 881  :             break;
; 882  : 
; 883  :         case SRE_OP_CATEGORY:
; 884  :             /* match at given category */
; 885  :             /* <CATEGORY> <code> */
; 886  :             TRACE(("|%p|%p|CATEGORY %d\n", ctx->pattern,
; 887  :                    ctx->ptr, *ctx->pattern));
; 888  :             if (ctx->ptr >= end || !sre_category(ctx->pattern[0], SRE_CHARGET(state, ctx->ptr, 0)))

  00218	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  0021c	49 3b c6	 cmp	 rax, r14
  0021f	0f 83 ac 06 00
	00		 jae	 $LL30@sre_umatch
  00225	41 8b 4d 3c	 mov	 ecx, DWORD PTR [r13+60]
  00229	83 f9 01	 cmp	 ecx, 1
  0022c	75 05		 jne	 SHORT $LN730@sre_umatch
  0022e	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00231	eb 0c		 jmp	 SHORT $LN729@sre_umatch
$LN730@sre_umatch:
  00233	83 f9 02	 cmp	 ecx, 2
  00236	75 05		 jne	 SHORT $LN728@sre_umatch
  00238	0f b7 10	 movzx	 edx, WORD PTR [rax]
  0023b	eb 02		 jmp	 SHORT $LN729@sre_umatch
$LN728@sre_umatch:
  0023d	8b 10		 mov	 edx, DWORD PTR [rax]
$LN729@sre_umatch:
  0023f	41 8b 0b	 mov	 ecx, DWORD PTR [r11]
  00242	e8 00 00 00 00	 call	 sre_category
  00247	85 c0		 test	 eax, eax
  00249	0f 84 82 06 00
	00		 je	 $LL30@sre_umatch
$LN1049@sre_umatch:

; 889  :                 RETURN_FAILURE;
; 890  :             ctx->pattern++;

  0024f	48 83 47 18 04	 add	 QWORD PTR [rdi+24], 4

; 891  :             ctx->ptr += state->charsize;

  00254	49 63 45 3c	 movsxd	 rax, DWORD PTR [r13+60]

; 892  :             break;

  00258	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  0025d	48 01 47 10	 add	 QWORD PTR [rdi+16], rax
  00261	e9 7b fe ff ff	 jmp	 $LN703@sre_umatch
$LN663@sre_umatch:

; 893  : 
; 894  :         case SRE_OP_ANY:
; 895  :             /* match anything (except a newline) */
; 896  :             /* <ANY> */
; 897  :             TRACE(("|%p|%p|ANY\n", ctx->pattern, ctx->ptr));
; 898  :                 if (ctx->ptr >= end || SRE_IS_LINEBREAK(SRE_CHARGET(state, ctx->ptr, 0)))

  00266	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  0026a	49 3b d6	 cmp	 rdx, r14
  0026d	0f 83 5e 06 00
	00		 jae	 $LL30@sre_umatch
  00273	4d 63 45 3c	 movsxd	 r8, DWORD PTR [r13+60]
  00277	41 83 f8 01	 cmp	 r8d, 1
  0027b	75 05		 jne	 SHORT $LN734@sre_umatch
  0027d	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00280	eb 0d		 jmp	 SHORT $LN733@sre_umatch
$LN734@sre_umatch:
  00282	41 83 f8 02	 cmp	 r8d, 2
  00286	75 05		 jne	 SHORT $LN732@sre_umatch
  00288	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  0028b	eb 02		 jmp	 SHORT $LN733@sre_umatch
$LN732@sre_umatch:
  0028d	8b 02		 mov	 eax, DWORD PTR [rdx]
$LN733@sre_umatch:
  0028f	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00294	73 29		 jae	 SHORT $LN1035@sre_umatch
  00296	41 83 f8 01	 cmp	 r8d, 1
  0029a	75 05		 jne	 SHORT $LN738@sre_umatch
  0029c	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  0029f	eb 0d		 jmp	 SHORT $LN737@sre_umatch
$LN738@sre_umatch:
  002a1	41 83 f8 02	 cmp	 r8d, 2
  002a5	75 05		 jne	 SHORT $LN736@sre_umatch
  002a7	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  002aa	eb 02		 jmp	 SHORT $LN737@sre_umatch
$LN736@sre_umatch:
  002ac	8b 02		 mov	 eax, DWORD PTR [rdx]
$LN737@sre_umatch:
  002ae	0f be 8c 28 00
	00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+rbp]
  002b6	83 e1 04	 and	 ecx, 4
  002b9	0f 85 12 06 00
	00		 jne	 $LL30@sre_umatch
$LN1035@sre_umatch:

; 899  :                     RETURN_FAILURE;
; 900  :             ctx->ptr += state->charsize;

  002bf	4a 8d 04 02	 lea	 rax, QWORD PTR [rdx+r8]
  002c3	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax
  002c7	e9 15 fe ff ff	 jmp	 $LN703@sre_umatch
$LN657@sre_umatch:

; 901  :             break;
; 902  : 
; 903  :         case SRE_OP_ANY_ALL:
; 904  :             /* match anything */
; 905  :             /* <ANY_ALL> */
; 906  :             TRACE(("|%p|%p|ANY_ALL\n", ctx->pattern, ctx->ptr));
; 907  :             if (ctx->ptr >= end)

  002cc	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  002d0	49 3b ce	 cmp	 rcx, r14
  002d3	0f 82 e2 fe ff
	ff		 jb	 $LN653@sre_umatch

; 908  :                 RETURN_FAILURE;

  002d9	e9 f3 05 00 00	 jmp	 $LL30@sre_umatch
$LN652@sre_umatch:

; 909  :             ctx->ptr += state->charsize;
; 910  :             break;
; 911  : 
; 912  :         case SRE_OP_IN:
; 913  :             /* match set member (or non_member) */
; 914  :             /* <IN> <skip> <set> */
; 915  :             TRACE(("|%p|%p|IN\n", ctx->pattern, ctx->ptr));
; 916  :                 if (ctx->ptr >= end || !SRE_CHARSET(ctx->pattern + 1, SRE_CHARGET(state, ctx->ptr, 0)))

  002de	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  002e2	49 3b c6	 cmp	 rax, r14
  002e5	0f 83 e6 05 00
	00		 jae	 $LL30@sre_umatch
  002eb	41 8b 4d 3c	 mov	 ecx, DWORD PTR [r13+60]
  002ef	83 f9 01	 cmp	 ecx, 1
  002f2	75 05		 jne	 SHORT $LN744@sre_umatch
  002f4	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  002f7	eb 0c		 jmp	 SHORT $LN743@sre_umatch
$LN744@sre_umatch:
  002f9	83 f9 02	 cmp	 ecx, 2
  002fc	75 05		 jne	 SHORT $LN742@sre_umatch
  002fe	0f b7 10	 movzx	 edx, WORD PTR [rax]
  00301	eb 02		 jmp	 SHORT $LN743@sre_umatch
$LN742@sre_umatch:
  00303	8b 10		 mov	 edx, DWORD PTR [rax]
$LN743@sre_umatch:
  00305	49 8d 4b 04	 lea	 rcx, QWORD PTR [r11+4]
  00309	e8 00 00 00 00	 call	 sre_ucharset
  0030e	85 c0		 test	 eax, eax
  00310	0f 84 bb 05 00
	00		 je	 $LL30@sre_umatch

; 917  :                     RETURN_FAILURE;
; 918  :             ctx->pattern += ctx->pattern[0];

  00316	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]

; 919  :             ctx->ptr += state->charsize;
; 920  :             break;

  0031a	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  0031f	8b 01		 mov	 eax, DWORD PTR [rcx]
  00321	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  00325	48 89 4f 18	 mov	 QWORD PTR [rdi+24], rcx
  00329	49 63 45 3c	 movsxd	 rax, DWORD PTR [r13+60]
  0032d	48 01 47 10	 add	 QWORD PTR [rdi+16], rax
  00331	e9 ab fd ff ff	 jmp	 $LN703@sre_umatch
$LN646@sre_umatch:

; 921  : 
; 922  :         case SRE_OP_LITERAL_IGNORE:
; 923  :             TRACE(("|%p|%p|LITERAL_IGNORE %d\n",
; 924  :                    ctx->pattern, ctx->ptr, ctx->pattern[0]));
; 925  :             if (ctx->ptr >= end ||
; 926  :                 state->lower(SRE_CHARGET(state, ctx->ptr, 0)) != state->lower(*ctx->pattern))

  00336	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  0033a	49 3b c6	 cmp	 rax, r14
  0033d	0f 83 8e 05 00
	00		 jae	 $LL30@sre_umatch
  00343	41 8b 4d 3c	 mov	 ecx, DWORD PTR [r13+60]
  00347	83 f9 01	 cmp	 ecx, 1
  0034a	75 05		 jne	 SHORT $LN748@sre_umatch
  0034c	0f b6 30	 movzx	 esi, BYTE PTR [rax]
  0034f	eb 0c		 jmp	 SHORT $LN747@sre_umatch
$LN748@sre_umatch:
  00351	83 f9 02	 cmp	 ecx, 2
  00354	75 05		 jne	 SHORT $LN746@sre_umatch
  00356	0f b7 30	 movzx	 esi, WORD PTR [rax]
  00359	eb 02		 jmp	 SHORT $LN747@sre_umatch
$LN746@sre_umatch:
  0035b	8b 30		 mov	 esi, DWORD PTR [rax]
$LN747@sre_umatch:
  0035d	41 8b 0b	 mov	 ecx, DWORD PTR [r11]
  00360	41 ff 95 00 07
	00 00		 call	 QWORD PTR [r13+1792]
  00367	8b ce		 mov	 ecx, esi
  00369	8b d8		 mov	 ebx, eax
  0036b	41 ff 95 00 07
	00 00		 call	 QWORD PTR [r13+1792]
  00372	3b c3		 cmp	 eax, ebx

; 928  :             ctx->pattern++;
; 929  :             ctx->ptr += state->charsize;
; 930  :             break;

  00374	0f 84 d5 fe ff
	ff		 je	 $LN1049@sre_umatch

; 927  :                 RETURN_FAILURE;

  0037a	e9 52 05 00 00	 jmp	 $LL30@sre_umatch
$LN640@sre_umatch:

; 931  : 
; 932  :         case SRE_OP_NOT_LITERAL_IGNORE:
; 933  :             TRACE(("|%p|%p|NOT_LITERAL_IGNORE %d\n",
; 934  :                    ctx->pattern, ctx->ptr, *ctx->pattern));
; 935  :             if (ctx->ptr >= end ||
; 936  :                 state->lower(SRE_CHARGET(state, ctx->ptr, 0)) == state->lower(*ctx->pattern))

  0037f	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00383	49 3b c6	 cmp	 rax, r14
  00386	0f 83 45 05 00
	00		 jae	 $LL30@sre_umatch
  0038c	41 8b 4d 3c	 mov	 ecx, DWORD PTR [r13+60]
  00390	83 f9 01	 cmp	 ecx, 1
  00393	75 05		 jne	 SHORT $LN752@sre_umatch
  00395	0f b6 30	 movzx	 esi, BYTE PTR [rax]
  00398	eb 0c		 jmp	 SHORT $LN751@sre_umatch
$LN752@sre_umatch:
  0039a	83 f9 02	 cmp	 ecx, 2
  0039d	75 05		 jne	 SHORT $LN750@sre_umatch
  0039f	0f b7 30	 movzx	 esi, WORD PTR [rax]
  003a2	eb 02		 jmp	 SHORT $LN751@sre_umatch
$LN750@sre_umatch:
  003a4	8b 30		 mov	 esi, DWORD PTR [rax]
$LN751@sre_umatch:
  003a6	41 8b 0b	 mov	 ecx, DWORD PTR [r11]
  003a9	41 ff 95 00 07
	00 00		 call	 QWORD PTR [r13+1792]
  003b0	8b ce		 mov	 ecx, esi
  003b2	8b d8		 mov	 ebx, eax
  003b4	41 ff 95 00 07
	00 00		 call	 QWORD PTR [r13+1792]
  003bb	3b c3		 cmp	 eax, ebx

; 938  :             ctx->pattern++;
; 939  :             ctx->ptr += state->charsize;
; 940  :             break;

  003bd	0f 85 8c fe ff
	ff		 jne	 $LN1049@sre_umatch

; 937  :                 RETURN_FAILURE;

  003c3	e9 09 05 00 00	 jmp	 $LL30@sre_umatch
$LN634@sre_umatch:

; 941  : 
; 942  :         case SRE_OP_IN_IGNORE:
; 943  :             TRACE(("|%p|%p|IN_IGNORE\n", ctx->pattern, ctx->ptr));
; 944  :             if (ctx->ptr >= end
; 945  :                 || !SRE_CHARSET(ctx->pattern+1,
; 946  :                                 (SRE_CODE)state->lower(SRE_CHARGET(state, ctx->ptr, 0))))

  003c8	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  003cc	49 3b c6	 cmp	 rax, r14
  003cf	0f 83 fc 04 00
	00		 jae	 $LL30@sre_umatch
  003d5	41 8b 4d 3c	 mov	 ecx, DWORD PTR [r13+60]
  003d9	83 f9 01	 cmp	 ecx, 1
  003dc	75 05		 jne	 SHORT $LN756@sre_umatch
  003de	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  003e1	eb 0c		 jmp	 SHORT $LN755@sre_umatch
$LN756@sre_umatch:
  003e3	83 f9 02	 cmp	 ecx, 2
  003e6	75 05		 jne	 SHORT $LN754@sre_umatch
  003e8	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  003eb	eb 02		 jmp	 SHORT $LN755@sre_umatch
$LN754@sre_umatch:
  003ed	8b 08		 mov	 ecx, DWORD PTR [rax]
$LN755@sre_umatch:
  003ef	41 ff 95 00 07
	00 00		 call	 QWORD PTR [r13+1792]
  003f6	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  003fa	48 83 c1 04	 add	 rcx, 4
  003fe	8b d0		 mov	 edx, eax
  00400	e8 00 00 00 00	 call	 sre_ucharset
  00405	85 c0		 test	 eax, eax
  00407	0f 84 c4 04 00
	00		 je	 $LL30@sre_umatch

; 947  :                 RETURN_FAILURE;
; 948  :             ctx->pattern += ctx->pattern[0];

  0040d	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00411	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  00416	8b 01		 mov	 eax, DWORD PTR [rcx]
  00418	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  0041c	48 89 4f 18	 mov	 QWORD PTR [rdi+24], rcx
  00420	49 63 45 3c	 movsxd	 rax, DWORD PTR [r13+60]
  00424	48 01 47 10	 add	 QWORD PTR [rdi+16], rax
  00428	e9 b4 fc ff ff	 jmp	 $LN703@sre_umatch
$LN628@sre_umatch:

; 949  :             ctx->ptr += state->charsize;
; 950  :             break;
; 951  : 
; 952  :         case SRE_OP_JUMP:
; 953  :         case SRE_OP_INFO:
; 954  :             /* jump forward */
; 955  :             /* <JUMP> <offset> */
; 956  :             TRACE(("|%p|%p|JUMP %d\n", ctx->pattern,
; 957  :                    ctx->ptr, ctx->pattern[0]));
; 958  :             ctx->pattern += ctx->pattern[0];

  0042d	41 8b 03	 mov	 eax, DWORD PTR [r11]
  00430	49 8d 0c 83	 lea	 rcx, QWORD PTR [r11+rax*4]

; 959  :             break;

  00434	e9 a4 fc ff ff	 jmp	 $LN1052@sre_umatch
  00439	0f 1f 80 00 00
	00 00		 npad	 7
$LL626@sre_umatch:

; 960  : 
; 961  :         case SRE_OP_BRANCH:
; 962  :             /* alternation */
; 963  :             /* <BRANCH> <0=skip> code <JUMP> ... <NULL> */
; 964  :             TRACE(("|%p|%p|BRANCH\n", ctx->pattern, ctx->ptr));
; 965  :             LASTMARK_SAVE();

  00440	49 8b 5d 48	 mov	 rbx, QWORD PTR [r13+72]
  00444	48 89 5f 28	 mov	 QWORD PTR [rdi+40], rbx
  00448	49 8b 45 40	 mov	 rax, QWORD PTR [r13+64]
  0044c	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax

; 966  :             ctx->u.rep = state->repeat;

  00450	49 8b 85 f8 06
	00 00		 mov	 rax, QWORD PTR [r13+1784]
  00457	48 89 47 38	 mov	 QWORD PTR [rdi+56], rax

; 967  :             if (ctx->u.rep)

  0045b	48 85 c0	 test	 rax, rax
  0045e	0f 84 c6 07 00
	00		 je	 $LN609@sre_umatch

; 968  :                 MARK_PUSH(ctx->lastmark);

  00464	48 85 db	 test	 rbx, rbx
  00467	0f 8e bd 07 00
	00		 jle	 $LN609@sre_umatch
  0046d	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  00474	48 8d 34 dd 08
	00 00 00	 lea	 rsi, QWORD PTR [rbx*8+8]
  0047c	49 2b 85 a0 06
	00 00		 sub	 rax, QWORD PTR [r13+1696]
  00483	48 3b f0	 cmp	 rsi, rax
  00486	76 24		 jbe	 SHORT $LN610@sre_umatch
  00488	48 8b d6	 mov	 rdx, rsi
  0048b	49 8b cd	 mov	 rcx, r13
  0048e	e8 00 00 00 00	 call	 data_stack_grow
  00493	85 c0		 test	 eax, eax
  00495	0f 88 25 10 00
	00		 js	 $LN1021@sre_umatch
  0049b	49 83 ff ff	 cmp	 r15, -1
  0049f	74 0b		 je	 SHORT $LN610@sre_umatch
  004a1	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  004a8	49 8d 3c 07	 lea	 rdi, QWORD PTR [r15+rax]
$LN610@sre_umatch:
  004ac	49 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR [r13+1680]
  004b3	49 8d 55 50	 lea	 rdx, QWORD PTR [r13+80]
  004b7	4c 8b c6	 mov	 r8, rsi
  004ba	49 03 8d a0 06
	00 00		 add	 rcx, QWORD PTR [r13+1696]
  004c1	e8 00 00 00 00	 call	 memcpy
  004c6	4c 8d 1c dd 08
	00 00 00	 lea	 r11, QWORD PTR [rbx*8+8]
  004ce	4d 01 9d a0 06
	00 00		 add	 QWORD PTR [r13+1696], r11

; 969  :             for (; ctx->pattern[0]; ctx->pattern += ctx->pattern[0]) {

  004d5	e9 50 07 00 00	 jmp	 $LN609@sre_umatch
$LN550@sre_umatch:

; 993  : 
; 994  :         case SRE_OP_REPEAT_ONE:
; 995  :             /* match repeated sequence (maximizing regexp) */
; 996  : 
; 997  :             /* this operator only works if the repeated item is
; 998  :                exactly one character wide, and we're not already
; 999  :                collecting backtracking points.  for other cases,
; 1000 :                use the MAX_REPEAT operator */
; 1001 : 
; 1002 :             /* <REPEAT_ONE> <skip> <1=min> <2=max> item <SUCCESS> tail */
; 1003 : 
; 1004 :             TRACE(("|%p|%p|REPEAT_ONE %d %d\n", ctx->pattern, ctx->ptr,
; 1005 :                    ctx->pattern[1], ctx->pattern[2]));
; 1006 : 
; 1007 :             if ((Py_ssize_t) ctx->pattern[1] > (end - ctx->ptr) / state->charsize)

  004da	49 63 4d 3c	 movsxd	 rcx, DWORD PTR [r13+60]
  004de	4c 8b 47 10	 mov	 r8, QWORD PTR [rdi+16]
  004e2	49 8b c6	 mov	 rax, r14
  004e5	49 2b c0	 sub	 rax, r8
  004e8	48 99		 cdq
  004ea	48 f7 f9	 idiv	 rcx
  004ed	41 8b 4b 04	 mov	 ecx, DWORD PTR [r11+4]
  004f1	48 3b c8	 cmp	 rcx, rax

; 1008 :                 RETURN_FAILURE; /* cannot match */

  004f4	0f 8f d7 03 00
	00		 jg	 $LL30@sre_umatch

; 1009 : 
; 1010 :             state->ptr = ctx->ptr;

  004fa	4d 89 45 00	 mov	 QWORD PTR [r13], r8

; 1011 : 
; 1012 :             ret = SRE_COUNT(state, ctx->pattern+3, ctx->pattern[2]);

  004fe	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  00502	49 8b cd	 mov	 rcx, r13
  00505	44 8b 42 08	 mov	 r8d, DWORD PTR [rdx+8]
  00509	48 83 c2 0c	 add	 rdx, 12
  0050d	e8 00 00 00 00	 call	 sre_ucount

; 1013 :             RETURN_ON_ERROR(ret);

  00512	48 85 c0	 test	 rax, rax
  00515	0f 88 b6 0f 00
	00		 js	 $LN1043@sre_umatch

; 1014 :             DATA_LOOKUP_AT(SRE_MATCH_CONTEXT, ctx, ctx_pos);

  0051b	49 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR [r13+1680]

; 1015 :             ctx->count = ret;

  00522	49 89 44 0f 20	 mov	 QWORD PTR [r15+rcx+32], rax

; 1016 :             ctx->ptr += state->charsize * ctx->count;
; 1017 : 
; 1018 :             /* when we arrive here, count contains the number of
; 1019 :                matches, and ctx->ptr points to the tail of the target
; 1020 :                string.  check if the rest of the pattern matches,
; 1021 :                and backtrack if not. */
; 1022 : 
; 1023 :             if (ctx->count < (Py_ssize_t) ctx->pattern[1])

  00527	49 8b 54 0f 18	 mov	 rdx, QWORD PTR [r15+rcx+24]
  0052c	49 8d 3c 0f	 lea	 rdi, QWORD PTR [r15+rcx]
  00530	49 63 4d 3c	 movsxd	 rcx, DWORD PTR [r13+60]
  00534	48 0f af c8	 imul	 rcx, rax
  00538	48 01 4f 10	 add	 QWORD PTR [rdi+16], rcx
  0053c	8b 4a 04	 mov	 ecx, DWORD PTR [rdx+4]
  0053f	4c 8b 47 10	 mov	 r8, QWORD PTR [rdi+16]
  00543	48 3b c1	 cmp	 rax, rcx

; 1024 :                 RETURN_FAILURE;

  00546	0f 8c 85 03 00
	00		 jl	 $LL30@sre_umatch

; 1025 : 
; 1026 :             if (ctx->pattern[ctx->pattern[0]] == SRE_OP_SUCCESS) {

  0054c	8b 02		 mov	 eax, DWORD PTR [rdx]
  0054e	83 3c 82 01	 cmp	 DWORD PTR [rdx+rax*4], 1
  00552	75 0e		 jne	 SHORT $LN527@sre_umatch

; 1027 :                 /* tail is empty.  we're finished */
; 1028 :                 state->ptr = ctx->ptr;

  00554	4d 89 45 00	 mov	 QWORD PTR [r13], r8

; 1029 :                 RETURN_SUCCESS;

  00558	bb 01 00 00 00	 mov	 ebx, 1
  0055d	e9 71 03 00 00	 jmp	 $exit$22210
$LN527@sre_umatch:

; 1030 :             }
; 1031 : 
; 1032 :             LASTMARK_SAVE();

  00562	49 8b 45 48	 mov	 rax, QWORD PTR [r13+72]
  00566	48 89 47 28	 mov	 QWORD PTR [rdi+40], rax
  0056a	49 8b 45 40	 mov	 rax, QWORD PTR [r13+64]
  0056e	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax

; 1033 : 
; 1034 :             if (ctx->pattern[ctx->pattern[0]] == SRE_OP_LITERAL) {

  00572	8b 02		 mov	 eax, DWORD PTR [rdx]
  00574	83 3c 82 13	 cmp	 DWORD PTR [rdx+rax*4], 19
  00578	0f 85 35 09 00
	00		 jne	 $LN490@sre_umatch

; 1035 :                 /* tail starts with a literal. skip positions where
; 1036 :                    the rest of the pattern cannot possibly match */
; 1037 :                 ctx->u.chr = ctx->pattern[ctx->pattern[0]+1];

  0057e	ff c0		 inc	 eax
  00580	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00583	89 47 38	 mov	 DWORD PTR [rdi+56], eax
  00586	e9 22 08 00 00	 jmp	 $LN522@sre_umatch
$LN461@sre_umatch:

; 1074 :                 }
; 1075 :             }
; 1076 :             RETURN_FAILURE;
; 1077 : 
; 1078 :         case SRE_OP_MIN_REPEAT_ONE:
; 1079 :             /* match repeated sequence (minimizing regexp) */
; 1080 : 
; 1081 :             /* this operator only works if the repeated item is
; 1082 :                exactly one character wide, and we're not already
; 1083 :                collecting backtracking points.  for other cases,
; 1084 :                use the MIN_REPEAT operator */
; 1085 : 
; 1086 :             /* <MIN_REPEAT_ONE> <skip> <1=min> <2=max> item <SUCCESS> tail */
; 1087 : 
; 1088 :             TRACE(("|%p|%p|MIN_REPEAT_ONE %d %d\n", ctx->pattern, ctx->ptr,
; 1089 :                    ctx->pattern[1], ctx->pattern[2]));
; 1090 : 
; 1091 :             if ((Py_ssize_t) ctx->pattern[1] > (end - ctx->ptr) / state->charsize)

  0058b	49 63 4d 3c	 movsxd	 rcx, DWORD PTR [r13+60]
  0058f	4c 8b 47 10	 mov	 r8, QWORD PTR [rdi+16]
  00593	49 8b c6	 mov	 rax, r14
  00596	49 2b c0	 sub	 rax, r8
  00599	48 99		 cdq
  0059b	48 f7 f9	 idiv	 rcx
  0059e	41 8b 4b 04	 mov	 ecx, DWORD PTR [r11+4]
  005a2	48 3b c8	 cmp	 rcx, rax

; 1092 :                 RETURN_FAILURE; /* cannot match */

  005a5	0f 8f 26 03 00
	00		 jg	 $LL30@sre_umatch

; 1093 : 
; 1094 :             state->ptr = ctx->ptr;

  005ab	4d 89 45 00	 mov	 QWORD PTR [r13], r8

; 1095 : 
; 1096 :             if (ctx->pattern[1] == 0)

  005af	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  005b3	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  005b6	85 c0		 test	 eax, eax
  005b8	75 0a		 jne	 SHORT $LN455@sre_umatch

; 1097 :                 ctx->count = 0;

  005ba	48 c7 47 20 00
	00 00 00	 mov	 QWORD PTR [rdi+32], 0

; 1098 :             else {

  005c2	eb 47		 jmp	 SHORT $LN454@sre_umatch
$LN455@sre_umatch:

; 1099 :                 /* count using pattern min as the maximum */
; 1100 :                 ret = SRE_COUNT(state, ctx->pattern+3, ctx->pattern[1]);

  005c4	4c 8b c0	 mov	 r8, rax
  005c7	48 83 c2 0c	 add	 rdx, 12
  005cb	49 8b cd	 mov	 rcx, r13
  005ce	e8 00 00 00 00	 call	 sre_ucount
  005d3	4c 8b d8	 mov	 r11, rax

; 1101 :                 RETURN_ON_ERROR(ret);

  005d6	48 85 c0	 test	 rax, rax
  005d9	0f 88 f2 0e 00
	00		 js	 $LN1043@sre_umatch

; 1102 :                 DATA_LOOKUP_AT(SRE_MATCH_CONTEXT, ctx, ctx_pos);

  005df	49 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR [r13+1680]
  005e6	49 8d 3c 0f	 lea	 rdi, QWORD PTR [r15+rcx]

; 1103 :                 if (ret < (Py_ssize_t) ctx->pattern[1])

  005ea	49 8b 4c 0f 18	 mov	 rcx, QWORD PTR [r15+rcx+24]
  005ef	8b 51 04	 mov	 edx, DWORD PTR [rcx+4]
  005f2	48 3b c2	 cmp	 rax, rdx

; 1104 :                     /* didn't match minimum number of times */
; 1105 :                     RETURN_FAILURE;

  005f5	0f 8c d6 02 00
	00		 jl	 $LL30@sre_umatch

; 1106 :                 /* advance past minimum matches of repeat */
; 1107 :                 ctx->count = ret;

  005fb	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 1108 :                 ctx->ptr += state->charsize * ctx->count;

  005ff	49 63 45 3c	 movsxd	 rax, DWORD PTR [r13+60]
  00603	49 0f af c3	 imul	 rax, r11
  00607	48 01 47 10	 add	 QWORD PTR [rdi+16], rax
$LN454@sre_umatch:

; 1109 :             }
; 1110 : 
; 1111 :             if (ctx->pattern[ctx->pattern[0]] == SRE_OP_SUCCESS) {

  0060b	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  0060f	8b 01		 mov	 eax, DWORD PTR [rcx]
  00611	83 3c 81 01	 cmp	 DWORD PTR [rcx+rax*4], 1
  00615	75 19		 jne	 SHORT $LL434@sre_umatch
$LN678@sre_umatch:

; 1112 :                 /* tail is empty.  we're finished */
; 1113 :                 state->ptr = ctx->ptr;

  00617	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 1114 :                 RETURN_SUCCESS;

  0061b	bb 01 00 00 00	 mov	 ebx, 1
  00620	49 89 45 00	 mov	 QWORD PTR [r13], rax
  00624	e9 aa 02 00 00	 jmp	 $exit$22210
  00629	0f 1f 80 00 00
	00 00		 npad	 7
$LL434@sre_umatch:

; 1115 : 
; 1116 :             } else {
; 1117 :                 /* general case */
; 1118 :                 LASTMARK_SAVE();

  00630	49 8b 45 48	 mov	 rax, QWORD PTR [r13+72]
  00634	48 89 47 28	 mov	 QWORD PTR [rdi+40], rax
  00638	49 8b 45 40	 mov	 rax, QWORD PTR [r13+64]
  0063c	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax
  00640	e9 5b 09 00 00	 jmp	 $LN431@sre_umatch
$LN390@sre_umatch:

; 1138 :                 }
; 1139 :             }
; 1140 :             RETURN_FAILURE;
; 1141 : 
; 1142 :         case SRE_OP_REPEAT:
; 1143 :             /* create repeat context.  all the hard work is done
; 1144 :                by the UNTIL operator (MAX_UNTIL, MIN_UNTIL) */
; 1145 :             /* <REPEAT> <skip> <1=min> <2=max> item <UNTIL> tail */
; 1146 :             TRACE(("|%p|%p|REPEAT %d %d\n", ctx->pattern, ctx->ptr,
; 1147 :                    ctx->pattern[1], ctx->pattern[2]));
; 1148 : 
; 1149 :             /* install new repeat context */
; 1150 :             ctx->u.rep = (SRE_REPEAT*) PyObject_MALLOC(sizeof(*ctx->u.rep));

  00645	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0064a	e8 00 00 00 00	 call	 PyObject_Malloc
  0064f	48 89 47 38	 mov	 QWORD PTR [rdi+56], rax

; 1151 :             if (!ctx->u.rep) {

  00653	48 85 c0	 test	 rax, rax
  00656	0f 85 02 0a 00
	00		 jne	 $LN385@sre_umatch

; 1152 :                 PyErr_NoMemory();

  0065c	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1153 :                 RETURN_FAILURE;

  00661	e9 6b 02 00 00	 jmp	 $LL30@sre_umatch
$LN127@sre_umatch:

; 1301 : 
; 1302 :         case SRE_OP_GROUPREF:
; 1303 :             /* match backreference */
; 1304 :             TRACE(("|%p|%p|GROUPREF %d\n", ctx->pattern,
; 1305 :                    ctx->ptr, ctx->pattern[0]));
; 1306 :             i = ctx->pattern[0];
; 1307 :             {
; 1308 :                 Py_ssize_t groupref = i+i;

  00666	41 8b 03	 mov	 eax, DWORD PTR [r11]
  00669	48 03 c0	 add	 rax, rax

; 1309 :                 if (groupref >= state->lastmark) {

  0066c	49 3b 45 48	 cmp	 rax, QWORD PTR [r13+72]

; 1310 :                     RETURN_FAILURE;

  00670	0f 8d 5b 02 00
	00		 jge	 $LL30@sre_umatch

; 1311 :                 } else {
; 1312 :                     char* p = (char*) state->mark[groupref];

  00676	4d 8b 4c c5 50	 mov	 r9, QWORD PTR [r13+rax*8+80]

; 1313 :                     char* e = (char*) state->mark[groupref+1];

  0067b	4d 8b 54 c5 58	 mov	 r10, QWORD PTR [r13+rax*8+88]

; 1314 :                     if (!p || !e || e < p)

  00680	4d 85 c9	 test	 r9, r9
  00683	0f 84 48 02 00
	00		 je	 $LL30@sre_umatch
  00689	4d 85 d2	 test	 r10, r10
  0068c	0f 84 3f 02 00
	00		 je	 $LL30@sre_umatch
  00692	4d 3b ca	 cmp	 r9, r10
  00695	0f 87 36 02 00
	00		 ja	 $LL30@sre_umatch

; 1315 :                         RETURN_FAILURE;
; 1316 :                     while (p < e) {

  0069b	73 5f		 jae	 SHORT $LN114@sre_umatch
  0069d	0f 1f 00	 npad	 3
$LL115@sre_umatch:

; 1317 :                         if (ctx->ptr >= end ||
; 1318 :                             SRE_CHARGET(state, ctx->ptr, 0) != SRE_CHARGET(state, p, 0))

  006a0	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  006a4	49 3b d6	 cmp	 rdx, r14
  006a7	0f 83 24 02 00
	00		 jae	 $LL30@sre_umatch
  006ad	49 63 4d 3c	 movsxd	 rcx, DWORD PTR [r13+60]
  006b1	83 f9 01	 cmp	 ecx, 1
  006b4	75 06		 jne	 SHORT $LN772@sre_umatch
  006b6	44 0f b6 02	 movzx	 r8d, BYTE PTR [rdx]
  006ba	eb 0e		 jmp	 SHORT $LN771@sre_umatch
$LN772@sre_umatch:
  006bc	83 f9 02	 cmp	 ecx, 2
  006bf	75 06		 jne	 SHORT $LN770@sre_umatch
  006c1	44 0f b7 02	 movzx	 r8d, WORD PTR [rdx]
  006c5	eb 03		 jmp	 SHORT $LN771@sre_umatch
$LN770@sre_umatch:
  006c7	44 8b 02	 mov	 r8d, DWORD PTR [rdx]
$LN771@sre_umatch:
  006ca	83 f9 01	 cmp	 ecx, 1
  006cd	75 06		 jne	 SHORT $LN776@sre_umatch
  006cf	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  006d3	eb 0e		 jmp	 SHORT $LN775@sre_umatch
$LN776@sre_umatch:
  006d5	83 f9 02	 cmp	 ecx, 2
  006d8	75 06		 jne	 SHORT $LN774@sre_umatch
  006da	41 0f b7 01	 movzx	 eax, WORD PTR [r9]
  006de	eb 03		 jmp	 SHORT $LN775@sre_umatch
$LN774@sre_umatch:
  006e0	41 8b 01	 mov	 eax, DWORD PTR [r9]
$LN775@sre_umatch:
  006e3	44 3b c0	 cmp	 r8d, eax
  006e6	0f 85 e5 01 00
	00		 jne	 $LL30@sre_umatch

; 1319 :                             RETURN_FAILURE;
; 1320 :                         p += state->charsize;
; 1321 :                         ctx->ptr += state->charsize;

  006ec	48 8d 04 0a	 lea	 rax, QWORD PTR [rdx+rcx]
  006f0	4c 03 c9	 add	 r9, rcx
  006f3	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax
  006f7	4d 3b ca	 cmp	 r9, r10
  006fa	72 a4		 jb	 SHORT $LL115@sre_umatch
$LN114@sre_umatch:

; 892  :             break;

  006fc	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]

; 1322 :                     }
; 1323 :                 }
; 1324 :             }
; 1325 :             ctx->pattern++;

  00701	49 8d 43 04	 lea	 rax, QWORD PTR [r11+4]
  00705	48 89 47 18	 mov	 QWORD PTR [rdi+24], rax
  00709	e9 d3 f9 ff ff	 jmp	 $LN703@sre_umatch
$LN108@sre_umatch:

; 1326 :             break;
; 1327 : 
; 1328 :         case SRE_OP_GROUPREF_IGNORE:
; 1329 :             /* match backreference */
; 1330 :             TRACE(("|%p|%p|GROUPREF_IGNORE %d\n", ctx->pattern,
; 1331 :                    ctx->ptr, ctx->pattern[0]));
; 1332 :             i = ctx->pattern[0];
; 1333 :             {
; 1334 :                 Py_ssize_t groupref = i+i;

  0070e	41 8b 03	 mov	 eax, DWORD PTR [r11]
  00711	48 03 c0	 add	 rax, rax

; 1335 :                 if (groupref >= state->lastmark) {

  00714	49 3b 45 48	 cmp	 rax, QWORD PTR [r13+72]

; 1336 :                     RETURN_FAILURE;

  00718	0f 8d b3 01 00
	00		 jge	 $LL30@sre_umatch

; 1337 :                 } else {
; 1338 :                     char* p = (char*) state->mark[groupref];

  0071e	49 8b 74 c5 50	 mov	 rsi, QWORD PTR [r13+rax*8+80]

; 1339 :                     char* e = (char*) state->mark[groupref+1];

  00723	4d 8b 64 c5 58	 mov	 r12, QWORD PTR [r13+rax*8+88]

; 1340 :                     if (!p || !e || e < p)

  00728	48 85 f6	 test	 rsi, rsi
  0072b	0f 84 a0 01 00
	00		 je	 $LL30@sre_umatch
  00731	4d 85 e4	 test	 r12, r12
  00734	0f 84 97 01 00
	00		 je	 $LL30@sre_umatch
  0073a	49 3b f4	 cmp	 rsi, r12
  0073d	0f 87 8e 01 00
	00		 ja	 $LL30@sre_umatch

; 1341 :                         RETURN_FAILURE;
; 1342 :                     while (p < e) {

  00743	0f 83 2b fa ff
	ff		 jae	 $LN670@sre_umatch
  00749	0f 1f 80 00 00
	00 00		 npad	 7
$LL97@sre_umatch:

; 1343 :                         if (ctx->ptr >= end ||
; 1344 :                             state->lower(SRE_CHARGET(state, ctx->ptr, 0)) !=
; 1345 :                             state->lower(SRE_CHARGET(state, p, 0)))

  00750	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00754	49 3b c6	 cmp	 rax, r14
  00757	73 77		 jae	 SHORT $LL93@sre_umatch
  00759	41 8b 4d 3c	 mov	 ecx, DWORD PTR [r13+60]
  0075d	83 f9 01	 cmp	 ecx, 1
  00760	75 05		 jne	 SHORT $LN780@sre_umatch
  00762	0f b6 28	 movzx	 ebp, BYTE PTR [rax]
  00765	eb 0c		 jmp	 SHORT $LN779@sre_umatch
$LN780@sre_umatch:
  00767	83 f9 02	 cmp	 ecx, 2
  0076a	75 05		 jne	 SHORT $LN778@sre_umatch
  0076c	0f b7 28	 movzx	 ebp, WORD PTR [rax]
  0076f	eb 02		 jmp	 SHORT $LN779@sre_umatch
$LN778@sre_umatch:
  00771	8b 28		 mov	 ebp, DWORD PTR [rax]
$LN779@sre_umatch:
  00773	83 f9 01	 cmp	 ecx, 1
  00776	75 05		 jne	 SHORT $LN784@sre_umatch
  00778	0f b6 0e	 movzx	 ecx, BYTE PTR [rsi]
  0077b	eb 0c		 jmp	 SHORT $LN783@sre_umatch
$LN784@sre_umatch:
  0077d	83 f9 02	 cmp	 ecx, 2
  00780	75 05		 jne	 SHORT $LN782@sre_umatch
  00782	0f b7 0e	 movzx	 ecx, WORD PTR [rsi]
  00785	eb 02		 jmp	 SHORT $LN783@sre_umatch
$LN782@sre_umatch:
  00787	8b 0e		 mov	 ecx, DWORD PTR [rsi]
$LN783@sre_umatch:
  00789	41 ff 95 00 07
	00 00		 call	 QWORD PTR [r13+1792]
  00790	8b cd		 mov	 ecx, ebp
  00792	8b d8		 mov	 ebx, eax
  00794	41 ff 95 00 07
	00 00		 call	 QWORD PTR [r13+1792]
  0079b	3b c3		 cmp	 eax, ebx
  0079d	75 31		 jne	 SHORT $LL93@sre_umatch

; 1347 :                         p += state->charsize;

  0079f	49 63 45 3c	 movsxd	 rax, DWORD PTR [r13+60]

; 1348 :                         ctx->ptr += state->charsize;

  007a3	48 01 47 10	 add	 QWORD PTR [rdi+16], rax
  007a7	48 03 f0	 add	 rsi, rax
  007aa	49 3b f4	 cmp	 rsi, r12
  007ad	72 a1		 jb	 SHORT $LL97@sre_umatch

; 844  :             break;

  007af	48 83 47 18 04	 add	 QWORD PTR [rdi+24], 4
  007b4	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]

; 1122 :                     DO_JUMP(JUMP_MIN_REPEAT_ONE,jump_min_repeat_one,
; 1123 :                             ctx->pattern+ctx->pattern[0]);

  007b9	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:__ImageBase
  007c0	e9 1c f9 ff ff	 jmp	 $LN703@sre_umatch
  007c5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL93@sre_umatch:

; 1346 :                             RETURN_FAILURE;

  007d0	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:__ImageBase
  007d7	e9 f5 00 00 00	 jmp	 $LL30@sre_umatch
$LN90@sre_umatch:

; 1349 :                     }
; 1350 :                 }
; 1351 :             }
; 1352 :             ctx->pattern++;
; 1353 :             break;
; 1354 : 
; 1355 :         case SRE_OP_GROUPREF_EXISTS:
; 1356 :             TRACE(("|%p|%p|GROUPREF_EXISTS %d\n", ctx->pattern,
; 1357 :                    ctx->ptr, ctx->pattern[0]));
; 1358 :             /* <GROUPREF_EXISTS> <group> <skip> codeyes <JUMP> codeno ... */
; 1359 :             i = ctx->pattern[0];
; 1360 :             {
; 1361 :                 Py_ssize_t groupref = i+i;

  007dc	41 8b 03	 mov	 eax, DWORD PTR [r11]
  007df	48 03 c0	 add	 rax, rax

; 1362 :                 if (groupref >= state->lastmark) {

  007e2	49 3b 45 48	 cmp	 rax, QWORD PTR [r13+72]
  007e6	7c 0d		 jl	 SHORT $LN89@sre_umatch
$LN86@sre_umatch:

; 1363 :                     ctx->pattern += ctx->pattern[1];

  007e8	41 8b 43 04	 mov	 eax, DWORD PTR [r11+4]
  007ec	49 8d 0c 83	 lea	 rcx, QWORD PTR [r11+rax*4]

; 1364 :                     break;

  007f0	e9 e8 f8 ff ff	 jmp	 $LN1052@sre_umatch
$LN89@sre_umatch:

; 1365 :                 } else {
; 1366 :                     SRE_CHAR* p = (SRE_CHAR*) state->mark[groupref];

  007f5	49 8b 54 c5 50	 mov	 rdx, QWORD PTR [r13+rax*8+80]

; 1367 :                     SRE_CHAR* e = (SRE_CHAR*) state->mark[groupref+1];

  007fa	49 8b 4c c5 58	 mov	 rcx, QWORD PTR [r13+rax*8+88]

; 1368 :                     if (!p || !e || e < p) {

  007ff	48 85 d2	 test	 rdx, rdx
  00802	74 e4		 je	 SHORT $LN86@sre_umatch
  00804	48 85 c9	 test	 rcx, rcx
  00807	74 df		 je	 SHORT $LN86@sre_umatch
  00809	48 3b ca	 cmp	 rcx, rdx
  0080c	72 da		 jb	 SHORT $LN86@sre_umatch

; 1369 :                         ctx->pattern += ctx->pattern[1];
; 1370 :                         break;
; 1371 :                     }
; 1372 :                 }
; 1373 :             }
; 1374 :             ctx->pattern += 2;

  0080e	49 8d 43 08	 lea	 rax, QWORD PTR [r11+8]
  00812	48 89 47 18	 mov	 QWORD PTR [rdi+24], rax

; 1375 :             break;

  00816	e9 c6 f8 ff ff	 jmp	 $LN703@sre_umatch
$LN85@sre_umatch:

; 1376 : 
; 1377 :         case SRE_OP_ASSERT:
; 1378 :             /* assert subpattern */
; 1379 :             /* <ASSERT> <skip> <back> <pattern> */
; 1380 :             TRACE(("|%p|%p|ASSERT %d\n", ctx->pattern,
; 1381 :                    ctx->ptr, ctx->pattern[1]));
; 1382 :             state->ptr = ctx->ptr - state->charsize * ctx->pattern[1];

  0081b	41 8b 4b 04	 mov	 ecx, DWORD PTR [r11+4]
  0081f	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00823	41 0f af 4d 3c	 imul	 ecx, DWORD PTR [r13+60]
  00828	48 2b c1	 sub	 rax, rcx
  0082b	49 89 45 00	 mov	 QWORD PTR [r13], rax

; 1383 :             if (state->ptr < state->beginning)

  0082f	49 3b 45 08	 cmp	 rax, QWORD PTR [r13+8]
  00833	0f 82 98 00 00
	00		 jb	 $LL30@sre_umatch

; 1384 :                 RETURN_FAILURE;
; 1385 :             DO_JUMP(JUMP_ASSERT, jump_assert, ctx->pattern+2);

  00839	49 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [r13+1696]
  00840	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  00847	48 2b c3	 sub	 rax, rbx
  0084a	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  0084e	73 26		 jae	 SHORT $LN72@sre_umatch
  00850	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00855	49 8b cd	 mov	 rcx, r13
  00858	e8 00 00 00 00	 call	 data_stack_grow
  0085d	85 c0		 test	 eax, eax
  0085f	0f 88 5b 0c 00
	00		 js	 $LN1021@sre_umatch
  00865	49 83 ff ff	 cmp	 r15, -1
  00869	74 0b		 je	 SHORT $LN72@sre_umatch
  0086b	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  00872	49 8d 3c 07	 lea	 rdi, QWORD PTR [r15+rax]
$LN72@sre_umatch:
  00876	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  0087d	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H
  00885	48 c7 44 03 08
	0c 00 00 00	 mov	 QWORD PTR [rbx+rax+8], 12
  0088e	48 8d 0c 03	 lea	 rcx, QWORD PTR [rbx+rax]
  00892	e9 da 08 00 00	 jmp	 $LN1054@sre_umatch
$LN55@sre_umatch:

; 1387 :             ctx->pattern += ctx->pattern[0];
; 1388 :             break;
; 1389 : 
; 1390 :         case SRE_OP_ASSERT_NOT:
; 1391 :             /* assert not subpattern */
; 1392 :             /* <ASSERT_NOT> <skip> <back> <pattern> */
; 1393 :             TRACE(("|%p|%p|ASSERT_NOT %d\n", ctx->pattern,
; 1394 :                    ctx->ptr, ctx->pattern[1]));
; 1395 :             state->ptr = ctx->ptr - state->charsize * ctx->pattern[1];

  00897	41 8b 4b 04	 mov	 ecx, DWORD PTR [r11+4]
  0089b	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  0089f	41 0f af 4d 3c	 imul	 ecx, DWORD PTR [r13+60]
  008a4	48 2b c1	 sub	 rax, rcx
  008a7	49 89 45 00	 mov	 QWORD PTR [r13], rax

; 1396 :             if (state->ptr >= state->beginning) {

  008ab	49 3b 45 08	 cmp	 rax, QWORD PTR [r13+8]
  008af	0f 83 63 08 00
	00		 jae	 $LN1011@sre_umatch
$LN32@sre_umatch:

; 1400 :                     RETURN_FAILURE;
; 1401 :                 }
; 1402 :             }
; 1403 :             ctx->pattern += ctx->pattern[0];

  008b5	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]

; 1415 :         }
; 1416 :     }

  008b9	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  008be	8b 01		 mov	 eax, DWORD PTR [rcx]
  008c0	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  008c4	e9 14 f8 ff ff	 jmp	 $LN1052@sre_umatch
$LN1058@sre_umatch:

; 1299 :             state->ptr = ctx->ptr;

  008c9	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  008cd	49 89 45 00	 mov	 QWORD PTR [r13], rax
$LL30@sre_umatch:

; 1404 :             break;
; 1405 : 
; 1406 :         case SRE_OP_FAILURE:
; 1407 :             /* immediate failure */
; 1408 :             TRACE(("|%p|%p|FAILURE\n", ctx->pattern, ctx->ptr));
; 1409 :             RETURN_FAILURE;

  008d1	33 db		 xor	 ebx, ebx
$exit$22210:

; 1417 : 
; 1418 : exit:
; 1419 :     ctx_pos = ctx->last_ctx_pos;

  008d3	4c 8b 3f	 mov	 r15, QWORD PTR [rdi]

; 1420 :     jump = ctx->jump;

  008d6	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]

; 1421 :     DATA_POP_DISCARD(ctx);

  008da	49 83 85 a0 06
	00 00 c0	 add	 QWORD PTR [r13+1696], -64 ; ffffffffffffffc0H
  008e2	49 8b 95 a0 06
	00 00		 mov	 rdx, QWORD PTR [r13+1696]

; 1422 :     if (ctx_pos == -1)

  008e9	49 83 ff ff	 cmp	 r15, -1
  008ed	0f 84 63 07 00
	00		 je	 $LN991@sre_umatch

; 1424 :     DATA_LOOKUP_AT(SRE_MATCH_CONTEXT, ctx, ctx_pos);

  008f3	4d 8b 8d 90 06
	00 00		 mov	 r9, QWORD PTR [r13+1680]

; 1425 : 
; 1426 :     switch (jump) {

  008fa	48 ff c8	 dec	 rax
  008fd	4b 8d 3c 39	 lea	 rdi, QWORD PTR [r9+r15]
  00901	48 83 f8 0c	 cmp	 rax, 12
  00905	0f 87 4b 07 00
	00		 ja	 $LN991@sre_umatch
  0090b	8b 84 85 00 00
	00 00		 mov	 eax, DWORD PTR $LN1036@sre_umatch[rbp+rax*4]
  00912	48 03 c5	 add	 rax, rbp
  00915	ff e0		 jmp	 rax
$jump_max_until_2$22765:

; 1217 :                 DATA_POP(&ctx->u.rep->last_ptr);

  00917	4a 8b 44 0a f8	 mov	 rax, QWORD PTR [rdx+r9-8]
  0091c	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00920	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  00924	49 83 85 a0 06
	00 00 f8	 add	 QWORD PTR [r13+1696], -8
  0092c	49 8b 95 a0 06
	00 00		 mov	 rdx, QWORD PTR [r13+1696]

; 1218 :                 if (ret) {

  00933	48 85 db	 test	 rbx, rbx
  00936	0f 85 79 02 00
	00		 jne	 $LN1063@sre_umatch

; 1219 :                     MARK_POP_DISCARD(ctx->lastmark);
; 1220 :                     RETURN_ON_ERROR(ret);
; 1221 :                     RETURN_SUCCESS;
; 1222 :                 }
; 1223 :                 MARK_POP(ctx->lastmark);

  0093c	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  00940	48 85 c9	 test	 rcx, rcx
  00943	7e 39		 jle	 SHORT $LN262@sre_umatch
  00945	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  0094c	48 c1 e1 03	 shl	 rcx, 3
  00950	48 2b c1	 sub	 rax, rcx
  00953	4c 8d 41 08	 lea	 r8, QWORD PTR [rcx+8]
  00957	49 8d 4d 50	 lea	 rcx, QWORD PTR [r13+80]
  0095b	48 8d 54 10 f8	 lea	 rdx, QWORD PTR [rax+rdx-8]
  00960	e8 00 00 00 00	 call	 memcpy
  00965	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  00969	48 c7 c0 f8 ff
	ff ff		 mov	 rax, -8
  00970	48 c1 e1 03	 shl	 rcx, 3
  00974	48 2b c1	 sub	 rax, rcx
  00977	49 01 85 a0 06
	00 00		 add	 QWORD PTR [r13+1696], rax
$LN262@sre_umatch:

; 1224 :                 LASTMARK_RESTORE();

  0097e	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00982	49 89 45 48	 mov	 QWORD PTR [r13+72], rax
  00986	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  0098a	49 89 45 40	 mov	 QWORD PTR [r13+64], rax

; 1225 :                 ctx->u.rep->count = ctx->count-1;

  0098e	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  00992	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00996	48 ff c9	 dec	 rcx
  00999	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1226 :                 state->ptr = ctx->ptr;

  0099c	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  009a0	49 89 45 00	 mov	 QWORD PTR [r13], rax
$LN328@sre_umatch:

; 1227 :             }
; 1228 : 
; 1229 :             /* cannot match more repeated items here.  make sure the
; 1230 :                tail matches */
; 1231 :             state->repeat = ctx->u.rep->prev;

  009a4	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]

; 1232 :             DO_JUMP(JUMP_MAX_UNTIL_3, jump_max_until_3, ctx->pattern);

  009a8	49 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [r13+1696]
  009af	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  009b3	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  009ba	48 2b c3	 sub	 rax, rbx
  009bd	49 89 8d f8 06
	00 00		 mov	 QWORD PTR [r13+1784], rcx
  009c4	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  009c8	73 26		 jae	 SHORT $LN249@sre_umatch
  009ca	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  009cf	49 8b cd	 mov	 rcx, r13
  009d2	e8 00 00 00 00	 call	 data_stack_grow
  009d7	85 c0		 test	 eax, eax
  009d9	0f 88 e1 0a 00
	00		 js	 $LN1021@sre_umatch
  009df	49 83 ff ff	 cmp	 r15, -1
  009e3	74 0b		 je	 SHORT $LN249@sre_umatch
  009e5	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  009ec	49 8d 3c 07	 lea	 rdi, QWORD PTR [r15+rax]
$LN249@sre_umatch:
  009f0	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  009f7	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H

; 1397 :                 DO_JUMP(JUMP_ASSERT_NOT, jump_assert_not, ctx->pattern+2);

  009ff	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  00a04	48 8d 0c 03	 lea	 rcx, QWORD PTR [rbx+rax]
  00a08	4c 89 39	 mov	 QWORD PTR [rcx], r15
  00a0b	48 c7 41 08 03
	00 00 00	 mov	 QWORD PTR [rcx+8], 3
  00a13	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00a17	48 8b f9	 mov	 rdi, rcx
  00a1a	4c 8b fb	 mov	 r15, rbx
  00a1d	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
  00a21	e9 7a f6 ff ff	 jmp	 $entrance$22203
$jump_max_until_3$22821:

; 1233 :             RETURN_ON_SUCCESS(ret);

  00a26	48 85 db	 test	 rbx, rbx
  00a29	0f 88 27 06 00
	00		 js	 $LN991@sre_umatch
  00a2f	0f 8f a4 01 00
	00		 jg	 $LN1060@sre_umatch

; 1234 :             state->repeat = ctx->u.rep;

  00a35	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00a39	49 89 85 f8 06
	00 00		 mov	 QWORD PTR [r13+1784], rax

; 1235 :             state->ptr = ctx->ptr;
; 1236 :             RETURN_FAILURE;

  00a40	e9 84 fe ff ff	 jmp	 $LN1058@sre_umatch
$jump_min_until_2$22900:

; 1272 :             if (ret) {

  00a45	48 85 db	 test	 rbx, rbx

; 1273 :                 RETURN_ON_ERROR(ret);
; 1274 :                 RETURN_SUCCESS;

  00a48	0f 85 85 01 00
	00		 jne	 $LN1059@sre_umatch

; 1275 :             }
; 1276 : 
; 1277 :             state->repeat = ctx->u.rep;

  00a4e	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00a52	49 89 85 f8 06
	00 00		 mov	 QWORD PTR [r13+1784], rax

; 1278 :             state->ptr = ctx->ptr;

  00a59	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00a5d	49 89 45 00	 mov	 QWORD PTR [r13], rax

; 1279 : 
; 1280 :             LASTMARK_RESTORE();

  00a61	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00a65	49 89 45 48	 mov	 QWORD PTR [r13+72], rax
  00a69	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  00a6d	49 89 45 40	 mov	 QWORD PTR [r13+64], rax

; 1281 : 
; 1282 :             if ((ctx->count >= (Py_ssize_t) ctx->u.rep->pattern[2]
; 1283 :                 && ctx->u.rep->pattern[2] != SRE_MAXREPEAT) ||
; 1284 :                 state->ptr == ctx->u.rep->last_ptr)

  00a71	48 8b 57 38	 mov	 rdx, QWORD PTR [rdi+56]
  00a75	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00a79	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00a7c	48 39 4f 20	 cmp	 QWORD PTR [rdi+32], rcx
  00a80	7c 09		 jl	 SHORT $LN168@sre_umatch
  00a82	83 f9 ff	 cmp	 ecx, -1			; ffffffffH
  00a85	0f 85 46 fe ff
	ff		 jne	 $LL30@sre_umatch
$LN168@sre_umatch:
  00a8b	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
  00a8f	49 39 45 00	 cmp	 QWORD PTR [r13], rax
  00a93	0f 84 38 fe ff
	ff		 je	 $LL30@sre_umatch

; 1285 :                 RETURN_FAILURE;
; 1286 : 
; 1287 :             ctx->u.rep->count = ctx->count;

  00a99	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00a9d	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00aa1	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1288 :             /* zero-width match protection */
; 1289 :             DATA_PUSH(&ctx->u.rep->last_ptr);

  00aa4	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  00aab	49 2b 85 a0 06
	00 00		 sub	 rax, QWORD PTR [r13+1696]
  00ab2	48 83 f8 08	 cmp	 rax, 8
  00ab6	73 20		 jae	 SHORT $LN156@sre_umatch
  00ab8	ba 08 00 00 00	 mov	 edx, 8
  00abd	49 8b cd	 mov	 rcx, r13
  00ac0	e8 00 00 00 00	 call	 data_stack_grow
  00ac5	85 c0		 test	 eax, eax
  00ac7	0f 88 f3 09 00
	00		 js	 $LN1021@sre_umatch
  00acd	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  00ad4	49 8d 3c 07	 lea	 rdi, QWORD PTR [r15+rax]
$LN156@sre_umatch:
  00ad8	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00adc	49 8b 95 a0 06
	00 00		 mov	 rdx, QWORD PTR [r13+1696]
  00ae3	49 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR [r13+1680]
  00aea	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00aee	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax
  00af2	49 83 85 a0 06
	00 00 08	 add	 QWORD PTR [r13+1696], 8

; 1290 :             ctx->u.rep->last_ptr = state->ptr;

  00afa	49 8b 45 00	 mov	 rax, QWORD PTR [r13]
  00afe	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00b02	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1291 :             DO_JUMP(JUMP_MIN_UNTIL_3,jump_min_until_3,
; 1292 :                     ctx->u.rep->pattern+3);

  00b06	49 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [r13+1696]
  00b0d	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  00b14	48 2b c3	 sub	 rax, rbx
  00b17	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00b1b	73 20		 jae	 SHORT $LN147@sre_umatch
  00b1d	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00b22	49 8b cd	 mov	 rcx, r13
  00b25	e8 00 00 00 00	 call	 data_stack_grow
  00b2a	85 c0		 test	 eax, eax
  00b2c	0f 88 8e 09 00
	00		 js	 $LN1021@sre_umatch
  00b32	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  00b39	49 8d 3c 07	 lea	 rdi, QWORD PTR [r15+rax]
$LN147@sre_umatch:
  00b3d	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  00b44	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H
  00b4c	48 c7 44 03 08
	06 00 00 00	 mov	 QWORD PTR [rbx+rax+8], 6
  00b55	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]
$LN1057@sre_umatch:

; 1397 :                 DO_JUMP(JUMP_ASSERT_NOT, jump_assert_not, ctx->pattern+2);

  00b59	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  00b5e	4c 89 3a	 mov	 QWORD PTR [rdx], r15
  00b61	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00b65	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00b69	48 8b fa	 mov	 rdi, rdx
  00b6c	4c 8b fb	 mov	 r15, rbx
  00b6f	48 83 c1 0c	 add	 rcx, 12
  00b73	48 89 4a 18	 mov	 QWORD PTR [rdx+24], rcx
  00b77	e9 24 f5 ff ff	 jmp	 $entrance$22203
$jump_min_until_3$22952:

; 1293 :             DATA_POP(&ctx->u.rep->last_ptr);

  00b7c	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00b80	4a 8b 44 0a f8	 mov	 rax, QWORD PTR [rdx+r9-8]
  00b85	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  00b89	49 83 85 a0 06
	00 00 f8	 add	 QWORD PTR [r13+1696], -8

; 1294 :             if (ret) {

  00b91	48 85 db	 test	 rbx, rbx

; 1295 :                 RETURN_ON_ERROR(ret);
; 1296 :                 RETURN_SUCCESS;

  00b94	75 3d		 jne	 SHORT $LN1059@sre_umatch
$LN130@sre_umatch:

; 1297 :             }
; 1298 :             ctx->u.rep->count = ctx->count-1;

  00b96	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  00b9a	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00b9e	48 ff c9	 dec	 rcx
  00ba1	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1300 :             RETURN_FAILURE;

  00ba4	e9 20 fd ff ff	 jmp	 $LN1058@sre_umatch
$jump_branch$22377:

; 980  :                 if (ret) {

  00ba9	48 85 db	 test	 rbx, rbx
  00bac	74 35		 je	 SHORT $LN573@sre_umatch

; 981  :                     if (ctx->u.rep)

  00bae	48 83 7f 38 00	 cmp	 QWORD PTR [rdi+56], 0
  00bb3	74 1b		 je	 SHORT $LN587@sre_umatch
$LN1063@sre_umatch:

; 982  :                         MARK_POP_DISCARD(ctx->lastmark);

  00bb5	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00bb9	48 85 c0	 test	 rax, rax
  00bbc	7e 12		 jle	 SHORT $LN587@sre_umatch
  00bbe	48 c1 e0 03	 shl	 rax, 3
  00bc2	48 2b d0	 sub	 rdx, rax
  00bc5	48 83 ea 08	 sub	 rdx, 8
  00bc9	49 89 95 a0 06
	00 00		 mov	 QWORD PTR [r13+1696], rdx
$LN587@sre_umatch:

; 983  :                     RETURN_ON_ERROR(ret);

  00bd0	48 85 db	 test	 rbx, rbx
$LN1059@sre_umatch:
  00bd3	0f 88 7d 04 00
	00		 js	 $LN991@sre_umatch
$LN1060@sre_umatch:

; 984  :                     RETURN_SUCCESS;

  00bd9	bb 01 00 00 00	 mov	 ebx, 1
  00bde	e9 f0 fc ff ff	 jmp	 $exit$22210
$LN573@sre_umatch:

; 985  :                 }
; 986  :                 if (ctx->u.rep)

  00be3	48 83 7f 38 00	 cmp	 QWORD PTR [rdi+56], 0
  00be8	74 22		 je	 SHORT $LN569@sre_umatch

; 987  :                     MARK_POP_KEEP(ctx->lastmark);

  00bea	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00bee	48 85 c0	 test	 rax, rax
  00bf1	7e 19		 jle	 SHORT $LN569@sre_umatch
  00bf3	48 c1 e0 03	 shl	 rax, 3
  00bf7	49 8d 4d 50	 lea	 rcx, QWORD PTR [r13+80]
  00bfb	48 2b d0	 sub	 rdx, rax
  00bfe	4c 8d 40 08	 lea	 r8, QWORD PTR [rax+8]
  00c02	4a 8d 54 0a f8	 lea	 rdx, QWORD PTR [rdx+r9-8]
  00c07	e8 00 00 00 00	 call	 memcpy
$LN569@sre_umatch:

; 988  :                 LASTMARK_RESTORE();

  00c0c	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00c10	49 89 45 48	 mov	 QWORD PTR [r13+72], rax
  00c14	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  00c18	49 89 45 40	 mov	 QWORD PTR [r13+64], rax
$LN608@sre_umatch:

; 969  :             for (; ctx->pattern[0]; ctx->pattern += ctx->pattern[0]) {

  00c1c	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00c20	8b 01		 mov	 eax, DWORD PTR [rcx]
  00c22	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  00c26	48 89 4f 18	 mov	 QWORD PTR [rdi+24], rcx
$LN609@sre_umatch:
  00c2a	4c 8b 47 18	 mov	 r8, QWORD PTR [rdi+24]
  00c2e	41 83 38 00	 cmp	 DWORD PTR [r8], 0
  00c32	0f 84 ea 00 00
	00		 je	 $LN607@sre_umatch

; 970  :                 if (ctx->pattern[1] == SRE_OP_LITERAL &&
; 971  :                     (ctx->ptr >= end ||
; 972  :                      (SRE_CODE) SRE_CHARGET(state, ctx->ptr, 0) != ctx->pattern[2]))

  00c38	41 8b 50 04	 mov	 edx, DWORD PTR [r8+4]
  00c3c	83 fa 13	 cmp	 edx, 19
  00c3f	75 29		 jne	 SHORT $LN606@sre_umatch
  00c41	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00c45	49 3b c6	 cmp	 rax, r14
  00c48	73 d2		 jae	 SHORT $LN608@sre_umatch
  00c4a	41 8b 4d 3c	 mov	 ecx, DWORD PTR [r13+60]
  00c4e	83 f9 01	 cmp	 ecx, 1
  00c51	75 05		 jne	 SHORT $LN760@sre_umatch
  00c53	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00c56	eb 0c		 jmp	 SHORT $LN759@sre_umatch
$LN760@sre_umatch:
  00c58	83 f9 02	 cmp	 ecx, 2
  00c5b	75 05		 jne	 SHORT $LN758@sre_umatch
  00c5d	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  00c60	eb 02		 jmp	 SHORT $LN759@sre_umatch
$LN758@sre_umatch:
  00c62	8b 08		 mov	 ecx, DWORD PTR [rax]
$LN759@sre_umatch:
  00c64	41 3b 48 08	 cmp	 ecx, DWORD PTR [r8+8]

; 973  :                     continue;

  00c68	75 b2		 jne	 SHORT $LN608@sre_umatch
$LN606@sre_umatch:

; 974  :                 if (ctx->pattern[1] == SRE_OP_IN &&
; 975  :                     (ctx->ptr >= end ||
; 976  :                      !SRE_CHARSET(ctx->pattern + 3, (SRE_CODE) SRE_CHARGET(state, ctx->ptr, 0))))

  00c6a	83 fa 0f	 cmp	 edx, 15
  00c6d	75 34		 jne	 SHORT $LN604@sre_umatch
  00c6f	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00c73	49 3b c6	 cmp	 rax, r14
  00c76	73 a4		 jae	 SHORT $LN608@sre_umatch
  00c78	41 8b 4d 3c	 mov	 ecx, DWORD PTR [r13+60]
  00c7c	83 f9 01	 cmp	 ecx, 1
  00c7f	75 05		 jne	 SHORT $LN764@sre_umatch
  00c81	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00c84	eb 0c		 jmp	 SHORT $LN763@sre_umatch
$LN764@sre_umatch:
  00c86	83 f9 02	 cmp	 ecx, 2
  00c89	75 05		 jne	 SHORT $LN762@sre_umatch
  00c8b	0f b7 10	 movzx	 edx, WORD PTR [rax]
  00c8e	eb 02		 jmp	 SHORT $LN763@sre_umatch
$LN762@sre_umatch:
  00c90	8b 10		 mov	 edx, DWORD PTR [rax]
$LN763@sre_umatch:
  00c92	49 8d 48 0c	 lea	 rcx, QWORD PTR [r8+12]
  00c96	e8 00 00 00 00	 call	 sre_ucharset
  00c9b	85 c0		 test	 eax, eax
  00c9d	0f 84 79 ff ff
	ff		 je	 $LN608@sre_umatch
$LN604@sre_umatch:

; 977  :                     continue;
; 978  :                 state->ptr = ctx->ptr;

  00ca3	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 979  :                 DO_JUMP(JUMP_BRANCH, jump_branch, ctx->pattern+1);

  00ca7	49 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [r13+1696]
  00cae	49 89 45 00	 mov	 QWORD PTR [r13], rax
  00cb2	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  00cb9	48 2b c3	 sub	 rax, rbx
  00cbc	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00cc0	73 26		 jae	 SHORT $LN594@sre_umatch
  00cc2	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00cc7	49 8b cd	 mov	 rcx, r13
  00cca	e8 00 00 00 00	 call	 data_stack_grow
  00ccf	85 c0		 test	 eax, eax
  00cd1	0f 88 e9 07 00
	00		 js	 $LN1021@sre_umatch
  00cd7	49 83 ff ff	 cmp	 r15, -1
  00cdb	74 0b		 je	 SHORT $LN594@sre_umatch
  00cdd	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  00ce4	49 8d 3c 07	 lea	 rdi, QWORD PTR [r15+rax]
$LN594@sre_umatch:
  00ce8	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  00cef	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H
  00cf7	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  00cfc	48 8d 0c 03	 lea	 rcx, QWORD PTR [rbx+rax]
  00d00	4c 89 39	 mov	 QWORD PTR [rcx], r15
  00d03	48 c7 41 08 0b
	00 00 00	 mov	 QWORD PTR [rcx+8], 11
  00d0b	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00d0f	48 83 c0 04	 add	 rax, 4
  00d13	4c 8b fb	 mov	 r15, rbx
  00d16	48 8b f9	 mov	 rdi, rcx
  00d19	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
  00d1d	e9 7e f3 ff ff	 jmp	 $entrance$22203
$LN607@sre_umatch:

; 989  :             }
; 990  :             if (ctx->u.rep)

  00d22	48 83 7f 38 00	 cmp	 QWORD PTR [rdi+56], 0
  00d27	0f 84 a4 fb ff
	ff		 je	 $LL30@sre_umatch

; 991  :                 MARK_POP_DISCARD(ctx->lastmark);

  00d2d	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00d31	48 85 c0	 test	 rax, rax
  00d34	0f 8e 97 fb ff
	ff		 jle	 $LL30@sre_umatch
  00d3a	48 c1 e0 03	 shl	 rax, 3
  00d3e	48 c7 c1 f8 ff
	ff ff		 mov	 rcx, -8
  00d45	48 2b c8	 sub	 rcx, rax
  00d48	49 01 8d a0 06
	00 00		 add	 QWORD PTR [r13+1696], rcx

; 992  :             RETURN_FAILURE;

  00d4f	e9 7d fb ff ff	 jmp	 $LL30@sre_umatch
$jump_min_until_1$22864:
$jump_max_until_1$22695:

; 1258 :                 if (ret) {

  00d54	48 85 db	 test	 rbx, rbx
  00d57	0f 84 39 fe ff
	ff		 je	 $LN130@sre_umatch

; 1259 :                     RETURN_ON_ERROR(ret);
; 1260 :                     RETURN_SUCCESS;

  00d5d	e9 71 fe ff ff	 jmp	 $LN1059@sre_umatch
$jump_repeat$22655:

; 1163 :             state->repeat = ctx->u.rep->prev;

  00d62	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00d66	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00d6a	49 89 8d f8 06
	00 00		 mov	 QWORD PTR [r13+1784], rcx

; 1164 :             PyObject_FREE(ctx->u.rep);

  00d71	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00d75	e8 00 00 00 00	 call	 PyObject_Free

; 1165 : 
; 1166 :             if (ret) {

  00d7a	48 85 db	 test	 rbx, rbx
  00d7d	0f 84 4e fb ff
	ff		 je	 $LL30@sre_umatch

; 1167 :                 RETURN_ON_ERROR(ret);
; 1168 :                 RETURN_SUCCESS;

  00d83	e9 4b fe ff ff	 jmp	 $LN1059@sre_umatch
$jump_repeat_one_1$22486:

; 1050 :                     if (ret) {

  00d88	48 85 db	 test	 rbx, rbx

; 1051 :                         RETURN_ON_ERROR(ret);
; 1052 :                         RETURN_SUCCESS;

  00d8b	0f 85 42 fe ff
	ff		 jne	 $LN1059@sre_umatch

; 1053 :                     }
; 1054 : 
; 1055 :                     LASTMARK_RESTORE();

  00d91	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00d95	49 89 45 48	 mov	 QWORD PTR [r13+72], rax
  00d99	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  00d9d	49 89 45 40	 mov	 QWORD PTR [r13+64], rax

; 1056 : 
; 1057 :                     ctx->ptr -= state->charsize;

  00da1	49 63 45 3c	 movsxd	 rax, DWORD PTR [r13+60]
  00da5	48 29 47 10	 sub	 QWORD PTR [rdi+16], rax

; 1058 :                     ctx->count--;

  00da9	48 ff 4f 20	 dec	 QWORD PTR [rdi+32]
$LN522@sre_umatch:

; 1038 :                 for (;;) {
; 1039 :                     while (ctx->count >= (Py_ssize_t) ctx->pattern[1] &&
; 1040 :                            (ctx->ptr >= end ||
; 1041 :                             SRE_CHARGET(state, ctx->ptr, 0) != ctx->u.chr)) {

  00dad	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  00db1	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  00db4	48 39 47 20	 cmp	 QWORD PTR [rdi+32], rax
  00db8	7c 46		 jl	 SHORT $LN1038@sre_umatch
  00dba	66 0f 1f 44 00
	00		 npad	 6
$LL520@sre_umatch:
  00dc0	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00dc4	49 3b ce	 cmp	 rcx, r14
  00dc7	73 1f		 jae	 SHORT $LN518@sre_umatch
  00dc9	41 8b 45 3c	 mov	 eax, DWORD PTR [r13+60]
  00dcd	83 f8 01	 cmp	 eax, 1
  00dd0	75 05		 jne	 SHORT $LN768@sre_umatch
  00dd2	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00dd5	eb 0c		 jmp	 SHORT $LN767@sre_umatch
$LN768@sre_umatch:
  00dd7	83 f8 02	 cmp	 eax, 2
  00dda	75 05		 jne	 SHORT $LN766@sre_umatch
  00ddc	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00ddf	eb 02		 jmp	 SHORT $LN767@sre_umatch
$LN766@sre_umatch:
  00de1	8b 01		 mov	 eax, DWORD PTR [rcx]
$LN767@sre_umatch:
  00de3	3b 47 38	 cmp	 eax, DWORD PTR [rdi+56]
  00de6	74 18		 je	 SHORT $LN1038@sre_umatch
$LN518@sre_umatch:

; 1042 :                         ctx->ptr -= state->charsize;

  00de8	49 63 45 3c	 movsxd	 rax, DWORD PTR [r13+60]

; 1043 :                         ctx->count--;

  00dec	48 ff 4f 20	 dec	 QWORD PTR [rdi+32]
  00df0	48 2b c8	 sub	 rcx, rax
  00df3	48 89 4f 10	 mov	 QWORD PTR [rdi+16], rcx
  00df7	8b 4a 04	 mov	 ecx, DWORD PTR [rdx+4]
  00dfa	48 39 4f 20	 cmp	 QWORD PTR [rdi+32], rcx
  00dfe	7d c0		 jge	 SHORT $LL520@sre_umatch
$LN1038@sre_umatch:

; 1044 :                     }
; 1045 :                     if (ctx->count < (Py_ssize_t) ctx->pattern[1])

  00e00	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  00e03	48 39 47 20	 cmp	 QWORD PTR [rdi+32], rax
  00e07	0f 8c c4 fa ff
	ff		 jl	 $LL30@sre_umatch

; 1046 :                         break;
; 1047 :                     state->ptr = ctx->ptr;

  00e0d	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 1048 :                     DO_JUMP(JUMP_REPEAT_ONE_1, jump_repeat_one_1,
; 1049 :                             ctx->pattern+ctx->pattern[0]);

  00e11	49 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [r13+1696]
  00e18	49 89 45 00	 mov	 QWORD PTR [r13], rax
  00e1c	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  00e23	48 2b c3	 sub	 rax, rbx
  00e26	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00e2a	73 26		 jae	 SHORT $LN508@sre_umatch
  00e2c	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00e31	49 8b cd	 mov	 rcx, r13
  00e34	e8 00 00 00 00	 call	 data_stack_grow
  00e39	85 c0		 test	 eax, eax
  00e3b	0f 88 7f 06 00
	00		 js	 $LN1021@sre_umatch
  00e41	49 83 ff ff	 cmp	 r15, -1
  00e45	74 0b		 je	 SHORT $LN508@sre_umatch
  00e47	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  00e4e	49 8d 3c 07	 lea	 rdi, QWORD PTR [r15+rax]
$LN508@sre_umatch:
  00e52	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  00e59	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H

; 1397 :                 DO_JUMP(JUMP_ASSERT_NOT, jump_assert_not, ctx->pattern+2);

  00e61	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  00e66	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]
  00e6a	4c 89 3a	 mov	 QWORD PTR [rdx], r15
  00e6d	48 c7 42 08 08
	00 00 00	 mov	 QWORD PTR [rdx+8], 8
  00e75	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00e79	8b 01		 mov	 eax, DWORD PTR [rcx]
  00e7b	48 8b fa	 mov	 rdi, rdx
  00e7e	4c 8b fb	 mov	 r15, rbx
  00e81	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  00e85	48 89 4a 18	 mov	 QWORD PTR [rdx+24], rcx
  00e89	e9 12 f2 ff ff	 jmp	 $entrance$22203
$jump_repeat_one_2$22524:

; 1067 :                     if (ret) {

  00e8e	48 85 db	 test	 rbx, rbx

; 1068 :                         RETURN_ON_ERROR(ret);
; 1069 :                         RETURN_SUCCESS;

  00e91	0f 85 3c fd ff
	ff		 jne	 $LN1059@sre_umatch

; 1070 :                     }
; 1071 :                     ctx->ptr -= state->charsize;

  00e97	49 63 45 3c	 movsxd	 rax, DWORD PTR [r13+60]
  00e9b	48 29 47 10	 sub	 QWORD PTR [rdi+16], rax

; 1072 :                     ctx->count--;
; 1073 :                     LASTMARK_RESTORE();

  00e9f	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00ea3	48 ff 4f 20	 dec	 QWORD PTR [rdi+32]
  00ea7	49 89 45 48	 mov	 QWORD PTR [r13+72], rax
  00eab	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  00eaf	49 89 45 40	 mov	 QWORD PTR [r13+64], rax
$LN490@sre_umatch:

; 1059 :                 }
; 1060 : 
; 1061 :             } else {
; 1062 :                 /* general case */
; 1063 :                 while (ctx->count >= (Py_ssize_t) ctx->pattern[1]) {

  00eb3	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00eb7	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  00eba	48 39 4f 20	 cmp	 QWORD PTR [rdi+32], rcx
  00ebe	0f 8c 0d fa ff
	ff		 jl	 $LL30@sre_umatch

; 1064 :                     state->ptr = ctx->ptr;

  00ec4	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 1065 :                     DO_JUMP(JUMP_REPEAT_ONE_2, jump_repeat_one_2,
; 1066 :                             ctx->pattern+ctx->pattern[0]);

  00ec8	49 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [r13+1696]
  00ecf	49 89 45 00	 mov	 QWORD PTR [r13], rax
  00ed3	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  00eda	48 2b c3	 sub	 rax, rbx
  00edd	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00ee1	73 26		 jae	 SHORT $LN480@sre_umatch
  00ee3	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00ee8	49 8b cd	 mov	 rcx, r13
  00eeb	e8 00 00 00 00	 call	 data_stack_grow
  00ef0	85 c0		 test	 eax, eax
  00ef2	0f 88 c8 05 00
	00		 js	 $LN1021@sre_umatch
  00ef8	49 83 ff ff	 cmp	 r15, -1
  00efc	74 0b		 je	 SHORT $LN480@sre_umatch
  00efe	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  00f05	49 8d 3c 07	 lea	 rdi, QWORD PTR [r15+rax]
$LN480@sre_umatch:
  00f09	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  00f10	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H

; 1397 :                 DO_JUMP(JUMP_ASSERT_NOT, jump_assert_not, ctx->pattern+2);

  00f18	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  00f1d	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]
  00f21	4c 89 3a	 mov	 QWORD PTR [rdx], r15
  00f24	48 c7 42 08 09
	00 00 00	 mov	 QWORD PTR [rdx+8], 9
  00f2c	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00f30	8b 01		 mov	 eax, DWORD PTR [rcx]
  00f32	48 8b fa	 mov	 rdi, rdx
  00f35	4c 8b fb	 mov	 r15, rbx
  00f38	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  00f3c	48 89 4a 18	 mov	 QWORD PTR [rdx+24], rcx
  00f40	e9 5b f1 ff ff	 jmp	 $entrance$22203
$jump_min_repeat_one$22599:

; 1124 :                     if (ret) {

  00f45	48 85 db	 test	 rbx, rbx

; 1125 :                         RETURN_ON_ERROR(ret);
; 1126 :                         RETURN_SUCCESS;

  00f48	0f 85 85 fc ff
	ff		 jne	 $LN1059@sre_umatch

; 1127 :                     }
; 1128 :                     state->ptr = ctx->ptr;

  00f4e	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 1129 :                     ret = SRE_COUNT(state, ctx->pattern+3, 1);

  00f52	44 8d 43 01	 lea	 r8d, QWORD PTR [rbx+1]
  00f56	49 8b cd	 mov	 rcx, r13
  00f59	49 89 45 00	 mov	 QWORD PTR [r13], rax
  00f5d	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  00f61	48 83 c2 0c	 add	 rdx, 12
  00f65	e8 00 00 00 00	 call	 sre_ucount

; 1130 :                     RETURN_ON_ERROR(ret);

  00f6a	48 85 c0	 test	 rax, rax
  00f6d	0f 88 5e 05 00
	00		 js	 $LN1043@sre_umatch

; 1131 :                     DATA_LOOKUP_AT(SRE_MATCH_CONTEXT, ctx, ctx_pos);

  00f73	49 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR [r13+1680]
  00f7a	49 8d 3c 0f	 lea	 rdi, QWORD PTR [r15+rcx]

; 1132 :                     if (ret == 0)

  00f7e	0f 84 4d f9 ff
	ff		 je	 $LL30@sre_umatch

; 1133 :                         break;
; 1134 :                     assert(ret == 1);
; 1135 :                     ctx->ptr += state->charsize;

  00f84	49 63 45 3c	 movsxd	 rax, DWORD PTR [r13+60]
  00f88	48 01 47 10	 add	 QWORD PTR [rdi+16], rax

; 1136 :                     ctx->count++;
; 1137 :                     LASTMARK_RESTORE();

  00f8c	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00f90	48 ff 47 20	 inc	 QWORD PTR [rdi+32]
  00f94	49 89 45 48	 mov	 QWORD PTR [r13+72], rax
  00f98	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  00f9c	49 89 45 40	 mov	 QWORD PTR [r13+64], rax
$LN431@sre_umatch:

; 1119 :                 while ((Py_ssize_t)ctx->pattern[2] == SRE_MAXREPEAT
; 1120 :                        || ctx->count <= (Py_ssize_t)ctx->pattern[2]) {

  00fa0	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00fa4	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00fa7	83 f9 ff	 cmp	 ecx, -1			; ffffffffH
  00faa	74 0a		 je	 SHORT $LN1005@sre_umatch
  00fac	48 39 4f 20	 cmp	 QWORD PTR [rdi+32], rcx
  00fb0	0f 8f 1b f9 ff
	ff		 jg	 $LL30@sre_umatch
$LN1005@sre_umatch:

; 1121 :                     state->ptr = ctx->ptr;

  00fb6	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 1122 :                     DO_JUMP(JUMP_MIN_REPEAT_ONE,jump_min_repeat_one,
; 1123 :                             ctx->pattern+ctx->pattern[0]);

  00fba	49 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [r13+1696]
  00fc1	49 89 45 00	 mov	 QWORD PTR [r13], rax
  00fc5	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  00fcc	48 2b c3	 sub	 rax, rbx
  00fcf	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00fd3	73 26		 jae	 SHORT $LN420@sre_umatch
  00fd5	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00fda	49 8b cd	 mov	 rcx, r13
  00fdd	e8 00 00 00 00	 call	 data_stack_grow
  00fe2	85 c0		 test	 eax, eax
  00fe4	0f 88 d6 04 00
	00		 js	 $LN1021@sre_umatch
  00fea	49 83 ff ff	 cmp	 r15, -1
  00fee	74 0b		 je	 SHORT $LN420@sre_umatch
  00ff0	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  00ff7	49 8d 3c 07	 lea	 rdi, QWORD PTR [r15+rax]
$LN420@sre_umatch:
  00ffb	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  01002	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H

; 1397 :                 DO_JUMP(JUMP_ASSERT_NOT, jump_assert_not, ctx->pattern+2);

  0100a	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  0100f	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]
  01013	4c 89 3a	 mov	 QWORD PTR [rdx], r15
  01016	48 c7 42 08 0a
	00 00 00	 mov	 QWORD PTR [rdx+8], 10
  0101e	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  01022	8b 01		 mov	 eax, DWORD PTR [rcx]
  01024	48 8b fa	 mov	 rdi, rdx
  01027	4c 8b fb	 mov	 r15, rbx
  0102a	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  0102e	48 89 4a 18	 mov	 QWORD PTR [rdx+24], rcx
  01032	e9 69 f0 ff ff	 jmp	 $entrance$22203
$jump_assert$23064:

; 1386 :             RETURN_ON_FAILURE(ret);

  01037	48 85 db	 test	 rbx, rbx
  0103a	78 1a		 js	 SHORT $LN991@sre_umatch
  0103c	0f 85 73 f8 ff
	ff		 jne	 $LN32@sre_umatch
  01042	e9 8a f8 ff ff	 jmp	 $LL30@sre_umatch
$jump_assert_not$23099:

; 1398 :                 if (ret) {

  01047	48 85 db	 test	 rbx, rbx
  0104a	0f 84 65 f8 ff
	ff		 je	 $LN32@sre_umatch

; 1399 :                     RETURN_ON_ERROR(ret);

  01050	0f 89 7b f8 ff
	ff		 jns	 $LL30@sre_umatch
$LN991@sre_umatch:

; 1423 :         return ret;

  01056	48 8b c3	 mov	 rax, rbx
  01059	e9 73 04 00 00	 jmp	 $LN1043@sre_umatch
$LN385@sre_umatch:

; 1154 :             }
; 1155 :             ctx->u.rep->count = -1;

  0105e	48 c7 00 ff ff
	ff ff		 mov	 QWORD PTR [rax], -1

; 1156 :             ctx->u.rep->pattern = ctx->pattern;

  01065	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  01069	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  0106d	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1157 :             ctx->u.rep->prev = state->repeat;

  01071	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  01075	49 8b 85 f8 06
	00 00		 mov	 rax, QWORD PTR [r13+1784]
  0107c	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 1158 :             ctx->u.rep->last_ptr = NULL;

  01080	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  01084	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 1159 :             state->repeat = ctx->u.rep;

  0108c	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]

; 1160 : 
; 1161 :             state->ptr = ctx->ptr;
; 1162 :             DO_JUMP(JUMP_REPEAT, jump_repeat, ctx->pattern+ctx->pattern[0]);

  01090	49 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [r13+1696]
  01097	49 89 85 f8 06
	00 00		 mov	 QWORD PTR [r13+1784], rax
  0109e	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  010a2	49 89 45 00	 mov	 QWORD PTR [r13], rax
  010a6	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  010ad	48 2b c3	 sub	 rax, rbx
  010b0	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  010b4	73 26		 jae	 SHORT $LN376@sre_umatch
  010b6	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  010bb	49 8b cd	 mov	 rcx, r13
  010be	e8 00 00 00 00	 call	 data_stack_grow
  010c3	85 c0		 test	 eax, eax
  010c5	0f 88 f5 03 00
	00		 js	 $LN1021@sre_umatch
  010cb	49 83 ff ff	 cmp	 r15, -1
  010cf	74 0b		 je	 SHORT $LN376@sre_umatch
  010d1	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  010d8	49 8d 3c 07	 lea	 rdi, QWORD PTR [r15+rax]
$LN376@sre_umatch:
  010dc	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  010e3	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H

; 1397 :                 DO_JUMP(JUMP_ASSERT_NOT, jump_assert_not, ctx->pattern+2);

  010eb	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  010f0	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]
  010f4	4c 89 3a	 mov	 QWORD PTR [rdx], r15
  010f7	48 c7 42 08 07
	00 00 00	 mov	 QWORD PTR [rdx+8], 7
  010ff	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  01103	8b 01		 mov	 eax, DWORD PTR [rcx]
  01105	48 8b fa	 mov	 rdi, rdx
  01108	4c 8b fb	 mov	 r15, rbx
  0110b	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  0110f	48 89 4a 18	 mov	 QWORD PTR [rdx+24], rcx
  01113	e9 88 ef ff ff	 jmp	 $entrance$22203
$LN1011@sre_umatch:
  01118	49 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [r13+1696]
  0111f	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  01126	48 2b c3	 sub	 rax, rbx
  01129	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  0112d	73 26		 jae	 SHORT $LN45@sre_umatch
  0112f	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  01134	49 8b cd	 mov	 rcx, r13
  01137	e8 00 00 00 00	 call	 data_stack_grow
  0113c	85 c0		 test	 eax, eax
  0113e	0f 88 7c 03 00
	00		 js	 $LN1021@sre_umatch
  01144	49 83 ff ff	 cmp	 r15, -1
  01148	74 0b		 je	 SHORT $LN45@sre_umatch
  0114a	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  01151	49 8d 3c 07	 lea	 rdi, QWORD PTR [r15+rax]
$LN45@sre_umatch:
  01155	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  0115c	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H
  01164	48 c7 44 03 08
	0d 00 00 00	 mov	 QWORD PTR [rbx+rax+8], 13
  0116d	48 8d 0c 03	 lea	 rcx, QWORD PTR [rbx+rax]
$LN1054@sre_umatch:
  01171	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  01176	4c 89 39	 mov	 QWORD PTR [rcx], r15
  01179	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  0117d	48 83 c0 08	 add	 rax, 8
  01181	48 8b f9	 mov	 rdi, rcx
  01184	4c 8b fb	 mov	 r15, rbx
  01187	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
  0118b	e9 10 ef ff ff	 jmp	 $entrance$22203
$LN360@sre_umatch:

; 1169 :             }
; 1170 :             RETURN_FAILURE;
; 1171 : 
; 1172 :         case SRE_OP_MAX_UNTIL:
; 1173 :             /* maximizing repeat */
; 1174 :             /* <REPEAT> <skip> <1=min> <2=max> item <MAX_UNTIL> tail */
; 1175 : 
; 1176 :             /* FIXME: we probably need to deal with zero-width
; 1177 :                matches in here... */
; 1178 : 
; 1179 :             ctx->u.rep = state->repeat;

  01190	49 8b 85 f8 06
	00 00		 mov	 rax, QWORD PTR [r13+1784]
  01197	48 89 47 38	 mov	 QWORD PTR [rdi+56], rax

; 1180 :             if (!ctx->u.rep)

  0119b	48 85 c0	 test	 rax, rax
  0119e	0f 84 20 03 00
	00		 je	 $LN1019@sre_umatch

; 1181 :                 RETURN_ERROR(SRE_ERROR_STATE);
; 1182 : 
; 1183 :             state->ptr = ctx->ptr;

  011a4	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  011a8	49 89 45 00	 mov	 QWORD PTR [r13], rax

; 1184 : 
; 1185 :             ctx->count = ctx->u.rep->count+1;

  011ac	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  011b0	4c 8b 00	 mov	 r8, QWORD PTR [rax]

; 1186 : 
; 1187 :             TRACE(("|%p|%p|MAX_UNTIL %" PY_FORMAT_SIZE_T "d\n", ctx->pattern,
; 1188 :                    ctx->ptr, ctx->count));
; 1189 : 
; 1190 :             if (ctx->count < (Py_ssize_t) ctx->u.rep->pattern[1]) {

  011b3	48 8b d0	 mov	 rdx, rax
  011b6	49 ff c0	 inc	 r8
  011b9	4c 89 47 20	 mov	 QWORD PTR [rdi+32], r8
  011bd	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  011c1	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  011c4	4c 3b c1	 cmp	 r8, rcx
  011c7	7d 61		 jge	 SHORT $LN329@sre_umatch

; 1191 :                 /* not enough matches */
; 1192 :                 ctx->u.rep->count = ctx->count;

  011c9	4c 89 02	 mov	 QWORD PTR [rdx], r8

; 1193 :                 DO_JUMP(JUMP_MAX_UNTIL_1, jump_max_until_1,
; 1194 :                         ctx->u.rep->pattern+3);

  011cc	49 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [r13+1696]
  011d3	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  011da	48 2b c3	 sub	 rax, rbx
  011dd	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  011e1	73 26		 jae	 SHORT $LN345@sre_umatch
  011e3	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  011e8	49 8b cd	 mov	 rcx, r13
  011eb	e8 00 00 00 00	 call	 data_stack_grow
  011f0	85 c0		 test	 eax, eax
  011f2	0f 88 c8 02 00
	00		 js	 $LN1021@sre_umatch
  011f8	49 83 ff ff	 cmp	 r15, -1
  011fc	74 0b		 je	 SHORT $LN345@sre_umatch
  011fe	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  01205	49 8d 3c 07	 lea	 rdi, QWORD PTR [r15+rax]
$LN345@sre_umatch:
  01209	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  01210	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H
  01218	48 c7 44 03 08
	01 00 00 00	 mov	 QWORD PTR [rbx+rax+8], 1
  01221	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]
  01225	e9 2f f9 ff ff	 jmp	 $LN1057@sre_umatch
$LN329@sre_umatch:

; 1195 :                 if (ret) {
; 1196 :                     RETURN_ON_ERROR(ret);
; 1197 :                     RETURN_SUCCESS;
; 1198 :                 }
; 1199 :                 ctx->u.rep->count = ctx->count-1;
; 1200 :                 state->ptr = ctx->ptr;
; 1201 :                 RETURN_FAILURE;
; 1202 :             }
; 1203 : 
; 1204 :             if ((ctx->count < (Py_ssize_t) ctx->u.rep->pattern[2] ||
; 1205 :                 ctx->u.rep->pattern[2] == SRE_MAXREPEAT) &&
; 1206 :                 state->ptr != ctx->u.rep->last_ptr) {

  0122a	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  0122d	4c 3b c1	 cmp	 r8, rcx
  01230	7c 09		 jl	 SHORT $LN327@sre_umatch
  01232	83 f9 ff	 cmp	 ecx, -1			; ffffffffH
  01235	0f 85 69 f7 ff
	ff		 jne	 $LN328@sre_umatch
$LN327@sre_umatch:
  0123b	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
  0123f	49 39 45 00	 cmp	 QWORD PTR [r13], rax
  01243	0f 84 5b f7 ff
	ff		 je	 $LN328@sre_umatch

; 1207 :                 /* we may have enough matches, but if we can
; 1208 :                    match another item, do so */
; 1209 :                 ctx->u.rep->count = ctx->count;

  01249	4c 89 02	 mov	 QWORD PTR [rdx], r8

; 1210 :                 LASTMARK_SAVE();

  0124c	49 8b 5d 48	 mov	 rbx, QWORD PTR [r13+72]
  01250	48 89 5f 28	 mov	 QWORD PTR [rdi+40], rbx
  01254	49 8b 45 40	 mov	 rax, QWORD PTR [r13+64]
  01258	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax

; 1211 :                 MARK_PUSH(ctx->lastmark);

  0125c	48 85 db	 test	 rbx, rbx
  0125f	7e 68		 jle	 SHORT $LN317@sre_umatch
  01261	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  01268	48 8d 34 dd 08
	00 00 00	 lea	 rsi, QWORD PTR [rbx*8+8]
  01270	49 2b 85 a0 06
	00 00		 sub	 rax, QWORD PTR [r13+1696]
  01277	48 3b f0	 cmp	 rsi, rax
  0127a	76 24		 jbe	 SHORT $LN311@sre_umatch
  0127c	48 8b d6	 mov	 rdx, rsi
  0127f	49 8b cd	 mov	 rcx, r13
  01282	e8 00 00 00 00	 call	 data_stack_grow
  01287	85 c0		 test	 eax, eax
  01289	0f 88 31 02 00
	00		 js	 $LN1021@sre_umatch
  0128f	49 83 ff ff	 cmp	 r15, -1
  01293	74 0b		 je	 SHORT $LN311@sre_umatch
  01295	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  0129c	49 8d 3c 07	 lea	 rdi, QWORD PTR [r15+rax]
$LN311@sre_umatch:
  012a0	49 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR [r13+1680]
  012a7	49 8d 55 50	 lea	 rdx, QWORD PTR [r13+80]
  012ab	4c 8b c6	 mov	 r8, rsi
  012ae	49 03 8d a0 06
	00 00		 add	 rcx, QWORD PTR [r13+1696]
  012b5	e8 00 00 00 00	 call	 memcpy
  012ba	4c 8d 1c dd 08
	00 00 00	 lea	 r11, QWORD PTR [rbx*8+8]
  012c2	4d 01 9d a0 06
	00 00		 add	 QWORD PTR [r13+1696], r11
$LN317@sre_umatch:

; 1212 :                 /* zero-width match protection */
; 1213 :                 DATA_PUSH(&ctx->u.rep->last_ptr);

  012c9	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  012d0	49 2b 85 a0 06
	00 00		 sub	 rax, QWORD PTR [r13+1696]
  012d7	48 83 f8 08	 cmp	 rax, 8
  012db	73 26		 jae	 SHORT $LN302@sre_umatch
  012dd	ba 08 00 00 00	 mov	 edx, 8
  012e2	49 8b cd	 mov	 rcx, r13
  012e5	e8 00 00 00 00	 call	 data_stack_grow
  012ea	85 c0		 test	 eax, eax
  012ec	0f 88 ce 01 00
	00		 js	 $LN1021@sre_umatch
  012f2	49 83 ff ff	 cmp	 r15, -1
  012f6	74 0b		 je	 SHORT $LN302@sre_umatch
  012f8	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  012ff	49 8d 3c 07	 lea	 rdi, QWORD PTR [r15+rax]
$LN302@sre_umatch:
  01303	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  01307	49 8b 95 a0 06
	00 00		 mov	 rdx, QWORD PTR [r13+1696]
  0130e	49 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR [r13+1680]
  01315	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  01319	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax
  0131d	49 83 85 a0 06
	00 00 08	 add	 QWORD PTR [r13+1696], 8

; 1214 :                 ctx->u.rep->last_ptr = state->ptr;

  01325	49 8b 45 00	 mov	 rax, QWORD PTR [r13]
  01329	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  0132d	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1215 :                 DO_JUMP(JUMP_MAX_UNTIL_2, jump_max_until_2,
; 1216 :                         ctx->u.rep->pattern+3);

  01331	49 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [r13+1696]
  01338	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  0133f	48 2b c3	 sub	 rax, rbx
  01342	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  01346	73 26		 jae	 SHORT $LN293@sre_umatch
  01348	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0134d	49 8b cd	 mov	 rcx, r13
  01350	e8 00 00 00 00	 call	 data_stack_grow
  01355	85 c0		 test	 eax, eax
  01357	0f 88 63 01 00
	00		 js	 $LN1021@sre_umatch
  0135d	49 83 ff ff	 cmp	 r15, -1
  01361	74 0b		 je	 SHORT $LN293@sre_umatch
  01363	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  0136a	49 8d 3c 07	 lea	 rdi, QWORD PTR [r15+rax]
$LN293@sre_umatch:
  0136e	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  01375	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H
  0137d	48 c7 44 03 08
	02 00 00 00	 mov	 QWORD PTR [rbx+rax+8], 2
  01386	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]
  0138a	e9 ca f7 ff ff	 jmp	 $LN1057@sre_umatch
$LN230@sre_umatch:

; 1237 : 
; 1238 :         case SRE_OP_MIN_UNTIL:
; 1239 :             /* minimizing repeat */
; 1240 :             /* <REPEAT> <skip> <1=min> <2=max> item <MIN_UNTIL> tail */
; 1241 : 
; 1242 :             ctx->u.rep = state->repeat;

  0138f	49 8b 85 f8 06
	00 00		 mov	 rax, QWORD PTR [r13+1784]
  01396	48 89 47 38	 mov	 QWORD PTR [rdi+56], rax

; 1243 :             if (!ctx->u.rep)

  0139a	48 85 c0	 test	 rax, rax
  0139d	0f 84 21 01 00
	00		 je	 $LN1019@sre_umatch

; 1245 : 
; 1246 :             state->ptr = ctx->ptr;

  013a3	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  013a7	49 89 45 00	 mov	 QWORD PTR [r13], rax

; 1247 : 
; 1248 :             ctx->count = ctx->u.rep->count+1;

  013ab	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  013af	48 8b 10	 mov	 rdx, QWORD PTR [rax]

; 1249 : 
; 1250 :             TRACE(("|%p|%p|MIN_UNTIL %" PY_FORMAT_SIZE_T "d %p\n", ctx->pattern,
; 1251 :                    ctx->ptr, ctx->count, ctx->u.rep->pattern));
; 1252 : 
; 1253 :             if (ctx->count < (Py_ssize_t) ctx->u.rep->pattern[1]) {

  013b2	4c 8b c0	 mov	 r8, rax
  013b5	48 ff c2	 inc	 rdx
  013b8	48 89 57 20	 mov	 QWORD PTR [rdi+32], rdx
  013bc	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  013c0	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  013c3	48 3b d1	 cmp	 rdx, rcx
  013c6	7d 61		 jge	 SHORT $LN199@sre_umatch

; 1254 :                 /* not enough matches */
; 1255 :                 ctx->u.rep->count = ctx->count;

  013c8	49 89 10	 mov	 QWORD PTR [r8], rdx

; 1256 :                 DO_JUMP(JUMP_MIN_UNTIL_1, jump_min_until_1,
; 1257 :                         ctx->u.rep->pattern+3);

  013cb	49 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [r13+1696]
  013d2	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  013d9	48 2b c3	 sub	 rax, rbx
  013dc	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  013e0	73 26		 jae	 SHORT $LN215@sre_umatch
  013e2	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  013e7	49 8b cd	 mov	 rcx, r13
  013ea	e8 00 00 00 00	 call	 data_stack_grow
  013ef	85 c0		 test	 eax, eax
  013f1	0f 88 c9 00 00
	00		 js	 $LN1021@sre_umatch
  013f7	49 83 ff ff	 cmp	 r15, -1
  013fb	74 0b		 je	 SHORT $LN215@sre_umatch
  013fd	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  01404	49 8d 3c 07	 lea	 rdi, QWORD PTR [r15+rax]
$LN215@sre_umatch:
  01408	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  0140f	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H
  01417	48 c7 44 03 08
	04 00 00 00	 mov	 QWORD PTR [rbx+rax+8], 4
  01420	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]
  01424	e9 30 f7 ff ff	 jmp	 $LN1057@sre_umatch
$LN199@sre_umatch:

; 1261 :                 }
; 1262 :                 ctx->u.rep->count = ctx->count-1;
; 1263 :                 state->ptr = ctx->ptr;
; 1264 :                 RETURN_FAILURE;
; 1265 :             }
; 1266 : 
; 1267 :             LASTMARK_SAVE();

  01429	49 8b 45 48	 mov	 rax, QWORD PTR [r13+72]
  0142d	48 89 47 28	 mov	 QWORD PTR [rdi+40], rax
  01431	49 8b 45 40	 mov	 rax, QWORD PTR [r13+64]
  01435	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax

; 1268 : 
; 1269 :             /* see if the tail matches */
; 1270 :             state->repeat = ctx->u.rep->prev;

  01439	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]

; 1271 :             DO_JUMP(JUMP_MIN_UNTIL_2, jump_min_until_2, ctx->pattern);

  0143d	49 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [r13+1696]
  01444	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  01448	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  0144f	48 2b c3	 sub	 rax, rbx
  01452	49 89 8d f8 06
	00 00		 mov	 QWORD PTR [r13+1784], rcx
  01459	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  0145d	73 22		 jae	 SHORT $LN187@sre_umatch
  0145f	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  01464	49 8b cd	 mov	 rcx, r13
  01467	e8 00 00 00 00	 call	 data_stack_grow
  0146c	85 c0		 test	 eax, eax
  0146e	78 50		 js	 SHORT $LN1021@sre_umatch
  01470	49 83 ff ff	 cmp	 r15, -1
  01474	74 0b		 je	 SHORT $LN187@sre_umatch
  01476	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  0147d	49 8d 3c 07	 lea	 rdi, QWORD PTR [r15+rax]
$LN187@sre_umatch:
  01481	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  01488	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H

; 1397 :                 DO_JUMP(JUMP_ASSERT_NOT, jump_assert_not, ctx->pattern+2);

  01490	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  01495	48 8d 0c 03	 lea	 rcx, QWORD PTR [rbx+rax]
  01499	4c 89 39	 mov	 QWORD PTR [rcx], r15
  0149c	48 c7 41 08 05
	00 00 00	 mov	 QWORD PTR [rcx+8], 5
  014a4	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  014a8	48 8b f9	 mov	 rdi, rcx
  014ab	4c 8b fb	 mov	 r15, rbx
  014ae	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
  014b2	e9 e9 eb ff ff	 jmp	 $entrance$22203
$LN1007@sre_umatch:

; 820  :             RETURN_ERROR(SRE_ERROR_INTERRUPTED);

  014b7	48 c7 c0 f6 ff
	ff ff		 mov	 rax, -10
  014be	eb 11		 jmp	 SHORT $LN1043@sre_umatch
$LN1021@sre_umatch:

; 1271 :             DO_JUMP(JUMP_MIN_UNTIL_2, jump_min_until_2, ctx->pattern);

  014c0	48 98		 cdqe
  014c2	eb 0d		 jmp	 SHORT $LN1043@sre_umatch
$LN1019@sre_umatch:

; 1244 :                 RETURN_ERROR(SRE_ERROR_STATE);

  014c4	48 c7 c0 fe ff
	ff ff		 mov	 rax, -2
  014cb	eb 04		 jmp	 SHORT $LN1043@sre_umatch
$LN28@sre_umatch:

; 1410 : 
; 1411 :         default:
; 1412 :             TRACE(("|%p|%p|UNKNOWN %d\n", ctx->pattern, ctx->ptr,
; 1413 :                    ctx->pattern[-1]));
; 1414 :             RETURN_ERROR(SRE_ERROR_ILLEGAL);

  014cd	48 83 c8 ff	 or	 rax, -1
$LN1043@sre_umatch:
  014d1	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  014d6	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  014db	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  014e0	4c 8b 64 24 20	 mov	 r12, QWORD PTR [rsp+32]

; 1427 :         case JUMP_MAX_UNTIL_2:
; 1428 :             TRACE(("|%p|%p|JUMP_MAX_UNTIL_2\n", ctx->pattern, ctx->ptr));
; 1429 :             goto jump_max_until_2;
; 1430 :         case JUMP_MAX_UNTIL_3:
; 1431 :             TRACE(("|%p|%p|JUMP_MAX_UNTIL_3\n", ctx->pattern, ctx->ptr));
; 1432 :             goto jump_max_until_3;
; 1433 :         case JUMP_MIN_UNTIL_2:
; 1434 :             TRACE(("|%p|%p|JUMP_MIN_UNTIL_2\n", ctx->pattern, ctx->ptr));
; 1435 :             goto jump_min_until_2;
; 1436 :         case JUMP_MIN_UNTIL_3:
; 1437 :             TRACE(("|%p|%p|JUMP_MIN_UNTIL_3\n", ctx->pattern, ctx->ptr));
; 1438 :             goto jump_min_until_3;
; 1439 :         case JUMP_BRANCH:
; 1440 :             TRACE(("|%p|%p|JUMP_BRANCH\n", ctx->pattern, ctx->ptr));
; 1441 :             goto jump_branch;
; 1442 :         case JUMP_MAX_UNTIL_1:
; 1443 :             TRACE(("|%p|%p|JUMP_MAX_UNTIL_1\n", ctx->pattern, ctx->ptr));
; 1444 :             goto jump_max_until_1;
; 1445 :         case JUMP_MIN_UNTIL_1:
; 1446 :             TRACE(("|%p|%p|JUMP_MIN_UNTIL_1\n", ctx->pattern, ctx->ptr));
; 1447 :             goto jump_min_until_1;
; 1448 :         case JUMP_REPEAT:
; 1449 :             TRACE(("|%p|%p|JUMP_REPEAT\n", ctx->pattern, ctx->ptr));
; 1450 :             goto jump_repeat;
; 1451 :         case JUMP_REPEAT_ONE_1:
; 1452 :             TRACE(("|%p|%p|JUMP_REPEAT_ONE_1\n", ctx->pattern, ctx->ptr));
; 1453 :             goto jump_repeat_one_1;
; 1454 :         case JUMP_REPEAT_ONE_2:
; 1455 :             TRACE(("|%p|%p|JUMP_REPEAT_ONE_2\n", ctx->pattern, ctx->ptr));
; 1456 :             goto jump_repeat_one_2;
; 1457 :         case JUMP_MIN_REPEAT_ONE:
; 1458 :             TRACE(("|%p|%p|JUMP_MIN_REPEAT_ONE\n", ctx->pattern, ctx->ptr));
; 1459 :             goto jump_min_repeat_one;
; 1460 :         case JUMP_ASSERT:
; 1461 :             TRACE(("|%p|%p|JUMP_ASSERT\n", ctx->pattern, ctx->ptr));
; 1462 :             goto jump_assert;
; 1463 :         case JUMP_ASSERT_NOT:
; 1464 :             TRACE(("|%p|%p|JUMP_ASSERT_NOT\n", ctx->pattern, ctx->ptr));
; 1465 :             goto jump_assert_not;
; 1466 :         case JUMP_NONE:
; 1467 :             TRACE(("|%p|%p|RETURN %" PY_FORMAT_SIZE_T "d\n", ctx->pattern,
; 1468 :                    ctx->ptr, ret));
; 1469 :             break;
; 1470 :     }
; 1471 : 
; 1472 :     return ret; /* should never get here */
; 1473 : }

  014e5	48 83 c4 28	 add	 rsp, 40			; 00000028H
  014e9	41 5f		 pop	 r15
  014eb	41 5e		 pop	 r14
  014ed	41 5d		 pop	 r13
  014ef	5b		 pop	 rbx
  014f0	c3		 ret	 0
  014f1	0f 1f 00	 npad	 3
$LN1037@sre_umatch:
  014f4	00 00 00 00	 DD	 $LL30@sre_umatch
  014f8	00 00 00 00	 DD	 $LN678@sre_umatch
  014fc	00 00 00 00	 DD	 $LN663@sre_umatch
  01500	00 00 00 00	 DD	 $LN657@sre_umatch
  01504	00 00 00 00	 DD	 $LN85@sre_umatch
  01508	00 00 00 00	 DD	 $LN55@sre_umatch
  0150c	00 00 00 00	 DD	 $LN675@sre_umatch
  01510	00 00 00 00	 DD	 $LL626@sre_umatch
  01514	00 00 00 00	 DD	 $LN28@sre_umatch
  01518	00 00 00 00	 DD	 $LN669@sre_umatch
  0151c	00 00 00 00	 DD	 $LN28@sre_umatch
  01520	00 00 00 00	 DD	 $LN28@sre_umatch
  01524	00 00 00 00	 DD	 $LN127@sre_umatch
  01528	00 00 00 00	 DD	 $LN90@sre_umatch
  0152c	00 00 00 00	 DD	 $LN108@sre_umatch
  01530	00 00 00 00	 DD	 $LN652@sre_umatch
  01534	00 00 00 00	 DD	 $LN634@sre_umatch
  01538	00 00 00 00	 DD	 $LN628@sre_umatch
  0153c	00 00 00 00	 DD	 $LN628@sre_umatch
  01540	00 00 00 00	 DD	 $LN690@sre_umatch
  01544	00 00 00 00	 DD	 $LN646@sre_umatch
  01548	00 00 00 00	 DD	 $LN695@sre_umatch
  0154c	00 00 00 00	 DD	 $LN360@sre_umatch
  01550	00 00 00 00	 DD	 $LN230@sre_umatch
  01554	00 00 00 00	 DD	 $LN684@sre_umatch
  01558	00 00 00 00	 DD	 $LN640@sre_umatch
  0155c	00 00 00 00	 DD	 $LN28@sre_umatch
  01560	00 00 00 00	 DD	 $LN28@sre_umatch
  01564	00 00 00 00	 DD	 $LN390@sre_umatch
  01568	00 00 00 00	 DD	 $LN550@sre_umatch
  0156c	00 00 00 00	 DD	 $LN28@sre_umatch
  01570	00 00 00 00	 DD	 $LN461@sre_umatch
$LN1036@sre_umatch:
  01574	00 00 00 00	 DD	 $jump_min_until_1$22864
  01578	00 00 00 00	 DD	 $jump_max_until_2$22765
  0157c	00 00 00 00	 DD	 $jump_max_until_3$22821
  01580	00 00 00 00	 DD	 $jump_min_until_1$22864
  01584	00 00 00 00	 DD	 $jump_min_until_2$22900
  01588	00 00 00 00	 DD	 $jump_min_until_3$22952
  0158c	00 00 00 00	 DD	 $jump_repeat$22655
  01590	00 00 00 00	 DD	 $jump_repeat_one_1$22486
  01594	00 00 00 00	 DD	 $jump_repeat_one_2$22524
  01598	00 00 00 00	 DD	 $jump_min_repeat_one$22599
  0159c	00 00 00 00	 DD	 $jump_branch$22377
  015a0	00 00 00 00	 DD	 $jump_assert$23064
  015a4	00 00 00 00	 DD	 $jump_assert_not$23099
sre_umatch ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sre_usearch DD imagerel sre_usearch
	DD	imagerel sre_usearch+703
	DD	imagerel $unwind$sre_usearch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sre_usearch DD 091501H
	DD	0f0114215H
	DD	0d00de00fH
	DD	07009c00bH
	DD	050076008H
	DD	03006H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT sre_usearch
_TEXT	SEGMENT
flags$1$ = 112
state$ = 112
pattern$ = 120
prefix_len$1$ = 128
prefix_skip$1$ = 136
sre_usearch PROC					; COMDAT

; 1477 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	41 57		 push	 r15
  00011	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1478 :     char* ptr = (char*)state->start;
; 1479 :     char* end = (char*)state->end;

  00015	48 8b 69 18	 mov	 rbp, QWORD PTR [rcx+24]
  00019	48 8b 59 10	 mov	 rbx, QWORD PTR [rcx+16]

; 1480 :     Py_ssize_t status = 0;

  0001d	33 ff		 xor	 edi, edi

; 1481 :     Py_ssize_t prefix_len = 0;
; 1482 :     Py_ssize_t prefix_skip = 0;
; 1483 :     SRE_CODE* prefix = NULL;
; 1484 :     SRE_CODE* charset = NULL;
; 1485 :     SRE_CODE* overlap = NULL;
; 1486 :     int flags = 0;
; 1487 : 
; 1488 :     if (pattern[0] == SRE_OP_INFO) {

  0001f	83 3a 11	 cmp	 DWORD PTR [rdx], 17
  00022	4c 8b d2	 mov	 r10, rdx
  00025	48 8b f1	 mov	 rsi, rcx
  00028	4c 8b e5	 mov	 r12, rbp
  0002b	44 8b c7	 mov	 r8d, edi
  0002e	48 89 bc 24 80
	00 00 00	 mov	 QWORD PTR prefix_len$1$[rsp], rdi
  00036	44 8b cf	 mov	 r9d, edi
  00039	48 89 bc 24 88
	00 00 00	 mov	 QWORD PTR prefix_skip$1$[rsp], rdi
  00041	44 8b ff	 mov	 r15d, edi
  00044	44 8b ef	 mov	 r13d, edi
  00047	44 8b f7	 mov	 r14d, edi
  0004a	44 8b df	 mov	 r11d, edi
  0004d	89 7c 24 70	 mov	 DWORD PTR flags$1$[rsp], edi
  00051	0f 85 31 01 00
	00		 jne	 $LN32@sre_usearc

; 1489 :         /* optimization info block */
; 1490 :         /* <INFO> <1=skip> <2=flags> <3=min> <4=max> <5=prefix info>  */
; 1491 : 
; 1492 :         flags = pattern[2];
; 1493 : 
; 1494 :         if (pattern[3] > 1) {

  00057	8b 42 0c	 mov	 eax, DWORD PTR [rdx+12]
  0005a	44 8b 5a 08	 mov	 r11d, DWORD PTR [rdx+8]
  0005e	44 89 5c 24 70	 mov	 DWORD PTR flags$1$[rsp], r11d
  00063	83 f8 01	 cmp	 eax, 1
  00066	76 15		 jbe	 SHORT $LN36@sre_usearc

; 1495 :             /* adjust end point (but make sure we leave at least one
; 1496 :                character in there, so literal search will work) */
; 1497 :             end -= (pattern[3]-1) * state->charsize;

  00068	48 63 49 3c	 movsxd	 rcx, DWORD PTR [rcx+60]
  0006c	ff c8		 dec	 eax
  0006e	0f af c1	 imul	 eax, ecx
  00071	4c 2b e0	 sub	 r12, rax

; 1498 :             if (end <= ptr)

  00074	4c 3b e3	 cmp	 r12, rbx
  00077	77 04		 ja	 SHORT $LN36@sre_usearc

; 1499 :                 end = ptr + state->charsize;

  00079	4c 8d 24 0b	 lea	 r12, QWORD PTR [rbx+rcx]
$LN36@sre_usearc:

; 1500 :         }
; 1501 : 
; 1502 :         if (flags & SRE_INFO_PREFIX) {

  0007d	41 f6 c3 01	 test	 r11b, 1
  00081	74 23		 je	 SHORT $LN35@sre_usearc

; 1503 :             /* pattern starts with a known prefix */
; 1504 :             /* <length> <skip> <prefix data> <overlap data> */
; 1505 :             prefix_len = pattern[5];

  00083	44 8b 42 14	 mov	 r8d, DWORD PTR [rdx+20]

; 1506 :             prefix_skip = pattern[6];

  00087	44 8b 4a 18	 mov	 r9d, DWORD PTR [rdx+24]

; 1507 :             prefix = pattern + 7;

  0008b	4c 8d 7a 1c	 lea	 r15, QWORD PTR [rdx+28]
  0008f	4c 89 84 24 80
	00 00 00	 mov	 QWORD PTR prefix_len$1$[rsp], r8
  00097	4c 89 8c 24 88
	00 00 00	 mov	 QWORD PTR prefix_skip$1$[rsp], r9

; 1508 :             overlap = prefix + prefix_len - 1;

  0009f	4f 8d 74 87 fc	 lea	 r14, QWORD PTR [r15+r8*4-4]
  000a4	eb 0a		 jmp	 SHORT $LN33@sre_usearc
$LN35@sre_usearc:

; 1509 :         } else if (flags & SRE_INFO_CHARSET)

  000a6	41 f6 c3 04	 test	 r11b, 4
  000aa	74 04		 je	 SHORT $LN33@sre_usearc

; 1510 :             /* pattern starts with a character from a known set */
; 1511 :             /* <charset> */
; 1512 :             charset = pattern + 5;

  000ac	4c 8d 6a 14	 lea	 r13, QWORD PTR [rdx+20]
$LN33@sre_usearc:

; 1513 : 
; 1514 :         pattern += 1 + pattern[1];

  000b0	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  000b3	ff c0		 inc	 eax
  000b5	4c 8d 14 82	 lea	 r10, QWORD PTR [rdx+rax*4]
  000b9	4c 89 54 24 78	 mov	 QWORD PTR pattern$[rsp], r10

; 1515 :     }
; 1516 : 
; 1517 :     TRACE(("prefix = %p %" PY_FORMAT_SIZE_T "d %" PY_FORMAT_SIZE_T "d\n",
; 1518 :            prefix, prefix_len, prefix_skip));
; 1519 :     TRACE(("charset = %p\n", charset));
; 1520 : 
; 1521 : #if defined(USE_FAST_SEARCH)
; 1522 :     if (prefix_len > 1) {

  000be	49 83 f8 01	 cmp	 r8, 1
  000c2	0f 8e c0 00 00
	00		 jle	 $LN32@sre_usearc

; 1523 :         /* pattern starts with a known prefix.  use the overlap
; 1524 :            table to skip forward as fast as we possibly can */
; 1525 :         Py_ssize_t i = 0;
; 1526 :         end = (char *)state->end;
; 1527 :         while (ptr < end) {

  000c8	48 3b dd	 cmp	 rbx, rbp
  000cb	0f 83 f2 00 00
	00		 jae	 $LN74@sre_usearc
$LL31@sre_usearc:
  000d1	48 63 56 3c	 movsxd	 rdx, DWORD PTR [rsi+60]
$LL29@sre_usearc:

; 1528 :             for (;;) {
; 1529 :                 if ((SRE_CODE) SRE_CHARGET(state, ptr, 0) != prefix[i]) {

  000d5	83 fa 01	 cmp	 edx, 1
  000d8	75 05		 jne	 SHORT $LN43@sre_usearc
  000da	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  000dd	eb 0c		 jmp	 SHORT $LN42@sre_usearc
$LN43@sre_usearc:
  000df	83 fa 02	 cmp	 edx, 2
  000e2	75 05		 jne	 SHORT $LN41@sre_usearc
  000e4	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  000e7	eb 02		 jmp	 SHORT $LN42@sre_usearc
$LN41@sre_usearc:
  000e9	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN42@sre_usearc:
  000eb	48 8d 0c bd 00
	00 00 00	 lea	 rcx, QWORD PTR [rdi*4]
  000f3	42 3b 04 39	 cmp	 eax, DWORD PTR [rcx+r15]
  000f7	74 0b		 je	 SHORT $LN27@sre_usearc

; 1530 :                     if (!i)

  000f9	48 85 ff	 test	 rdi, rdi
  000fc	74 67		 je	 SHORT $LN23@sre_usearc

; 1531 :                         break;
; 1532 :                     else
; 1533 :                         i = overlap[i];

  000fe	42 8b 3c 31	 mov	 edi, DWORD PTR [rcx+r14]

; 1547 :                     }
; 1548 :                     break;
; 1549 :                 }
; 1550 :             }

  00102	eb d1		 jmp	 SHORT $LL29@sre_usearc
$LN27@sre_usearc:

; 1534 :                 } else {
; 1535 :                     if (++i == prefix_len) {

  00104	48 ff c7	 inc	 rdi
  00107	49 3b f8	 cmp	 rdi, r8
  0010a	75 59		 jne	 SHORT $LN23@sre_usearc

; 1536 :                         /* found a potential match */
; 1537 :                         TRACE(("|%p|%p|SEARCH SCAN\n", pattern, ptr));
; 1538 :                         state->start = ptr - (prefix_len - 1) * state->charsize;

  0010c	49 8d 48 ff	 lea	 rcx, QWORD PTR [r8-1]
  00110	48 8b c3	 mov	 rax, rbx
  00113	48 0f af ca	 imul	 rcx, rdx
  00117	48 2b c1	 sub	 rax, rcx

; 1539 :                         state->ptr = ptr - (prefix_len - prefix_skip - 1) * state->charsize;

  0011a	49 8b c8	 mov	 rcx, r8
  0011d	49 2b c9	 sub	 rcx, r9
  00120	48 89 46 10	 mov	 QWORD PTR [rsi+16], rax
  00124	48 8b c3	 mov	 rax, rbx
  00127	48 ff c9	 dec	 rcx
  0012a	48 0f af ca	 imul	 rcx, rdx
  0012e	48 2b c1	 sub	 rax, rcx
  00131	48 89 06	 mov	 QWORD PTR [rsi], rax

; 1540 :                         if (flags & SRE_INFO_LITERAL)

  00134	41 f6 c3 02	 test	 r11b, 2
  00138	75 44		 jne	 SHORT $LN61@sre_usearc

; 1542 :                         status = SRE_MATCH(state, pattern + 2*prefix_skip);

  0013a	4b 8d 14 ca	 lea	 rdx, QWORD PTR [r10+r9*8]
  0013e	48 8b ce	 mov	 rcx, rsi
  00141	e8 00 00 00 00	 call	 sre_umatch

; 1543 :                         if (status != 0)

  00146	48 85 c0	 test	 rax, rax
  00149	0f 85 5f 01 00
	00		 jne	 $LN39@sre_usearc

; 1544 :                             return status;
; 1545 :                         /* close but no cigar -- try again */
; 1546 :                         i = overlap[i];

  0014f	41 8b 3c be	 mov	 edi, DWORD PTR [r14+rdi*4]
  00153	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR prefix_len$1$[rsp]
  0015b	4c 8b 54 24 78	 mov	 r10, QWORD PTR pattern$[rsp]
  00160	44 8b 5c 24 70	 mov	 r11d, DWORD PTR flags$1$[rsp]
$LN23@sre_usearc:

; 1551 :             ptr += state->charsize;

  00165	48 63 46 3c	 movsxd	 rax, DWORD PTR [rsi+60]
  00169	48 03 d8	 add	 rbx, rax
  0016c	48 3b dd	 cmp	 rbx, rbp
  0016f	73 52		 jae	 SHORT $LN74@sre_usearc

; 1523 :         /* pattern starts with a known prefix.  use the overlap
; 1524 :            table to skip forward as fast as we possibly can */
; 1525 :         Py_ssize_t i = 0;
; 1526 :         end = (char *)state->end;
; 1527 :         while (ptr < end) {

  00171	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR prefix_skip$1$[rsp]
  00179	e9 53 ff ff ff	 jmp	 $LL31@sre_usearc
$LN61@sre_usearc:

; 1541 :                             return 1; /* we got all of it */

  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	e9 26 01 00 00	 jmp	 $LN39@sre_usearc
$LN32@sre_usearc:

; 1554 :     }
; 1555 : #endif
; 1556 : 
; 1557 :     if (pattern[0] == SRE_OP_LITERAL) {

  00188	41 83 3a 13	 cmp	 DWORD PTR [r10], 19
  0018c	75 75		 jne	 SHORT $LN20@sre_usearc

; 1558 :         /* pattern starts with a literal character.  this is used
; 1559 :            for short prefixes, and if fast search is disabled */
; 1560 :         SRE_CODE chr = pattern[1];

  0018e	45 8b 62 04	 mov	 r12d, DWORD PTR [r10+4]
$LL19@sre_usearc:

; 1561 :         end = (char*)state->end;
; 1562 :         for (;;) {
; 1563 :             while (ptr < end && (SRE_CODE) SRE_CHARGET(state, ptr, 0) != chr)

  00192	48 3b dd	 cmp	 rbx, rbp
  00195	73 2c		 jae	 SHORT $LN74@sre_usearc
  00197	48 63 4e 3c	 movsxd	 rcx, DWORD PTR [rsi+60]
  0019b	0f 1f 44 00 00	 npad	 5
$LL17@sre_usearc:
  001a0	83 f9 01	 cmp	 ecx, 1
  001a3	75 05		 jne	 SHORT $LN47@sre_usearc
  001a5	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  001a8	eb 0c		 jmp	 SHORT $LN46@sre_usearc
$LN47@sre_usearc:
  001aa	83 f9 02	 cmp	 ecx, 2
  001ad	75 05		 jne	 SHORT $LN45@sre_usearc
  001af	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  001b2	eb 02		 jmp	 SHORT $LN46@sre_usearc
$LN45@sre_usearc:
  001b4	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN46@sre_usearc:
  001b6	41 3b c4	 cmp	 eax, r12d
  001b9	74 0f		 je	 SHORT $LN16@sre_usearc

; 1564 :                 ptr += state->charsize;

  001bb	48 03 d9	 add	 rbx, rcx
  001be	48 3b dd	 cmp	 rbx, rbp
  001c1	72 dd		 jb	 SHORT $LL17@sre_usearc
$LN74@sre_usearc:

; 1552 :         }
; 1553 :         return 0;

  001c3	33 c0		 xor	 eax, eax
  001c5	e9 e4 00 00 00	 jmp	 $LN39@sre_usearc
$LN16@sre_usearc:

; 1565 :             if (ptr >= end)

  001ca	48 3b dd	 cmp	 rbx, rbp
  001cd	73 f4		 jae	 SHORT $LN74@sre_usearc

; 1566 :                 return 0;
; 1567 :             TRACE(("|%p|%p|SEARCH LITERAL\n", pattern, ptr));
; 1568 :             state->start = ptr;

  001cf	48 89 5e 10	 mov	 QWORD PTR [rsi+16], rbx

; 1569 :             ptr += state->charsize;

  001d3	48 03 d9	 add	 rbx, rcx

; 1570 :             state->ptr = ptr;

  001d6	48 89 1e	 mov	 QWORD PTR [rsi], rbx

; 1571 :             if (flags & SRE_INFO_LITERAL)

  001d9	41 f6 c3 02	 test	 r11b, 2
  001dd	75 9f		 jne	 SHORT $LN61@sre_usearc

; 1572 :                 return 1; /* we got all of it */
; 1573 :             status = SRE_MATCH(state, pattern + 2);

  001df	49 8d 52 08	 lea	 rdx, QWORD PTR [r10+8]
  001e3	48 8b ce	 mov	 rcx, rsi
  001e6	e8 00 00 00 00	 call	 sre_umatch
  001eb	48 8b f8	 mov	 rdi, rax

; 1574 :             if (status != 0)

  001ee	48 85 c0	 test	 rax, rax
  001f1	0f 85 b4 00 00
	00		 jne	 $LN75@sre_usearc

; 1575 :                 break;
; 1576 :         }

  001f7	4c 8b 54 24 78	 mov	 r10, QWORD PTR pattern$[rsp]
  001fc	44 8b 5c 24 70	 mov	 r11d, DWORD PTR flags$1$[rsp]
  00201	eb 8f		 jmp	 SHORT $LL19@sre_usearc
$LN20@sre_usearc:

; 1577 :     } else if (charset) {

  00203	4d 85 ed	 test	 r13, r13
  00206	74 6e		 je	 SHORT $LN59@sre_usearc
  00208	4c 8b 64 24 78	 mov	 r12, QWORD PTR pattern$[rsp]
  0020d	0f 1f 00	 npad	 3
$LL10@sre_usearc:

; 1578 :         /* pattern starts with a character from a known set */
; 1579 :         end = (char*)state->end;
; 1580 :         for (;;) {
; 1581 :             while (ptr < end && !SRE_CHARSET(charset, SRE_CHARGET(state, ptr, 0)))

  00210	48 3b dd	 cmp	 rbx, rbp
  00213	73 ae		 jae	 SHORT $LN74@sre_usearc
$LL8@sre_usearc:
  00215	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  00218	83 f8 01	 cmp	 eax, 1
  0021b	75 05		 jne	 SHORT $LN51@sre_usearc
  0021d	0f b6 13	 movzx	 edx, BYTE PTR [rbx]
  00220	eb 0c		 jmp	 SHORT $LN50@sre_usearc
$LN51@sre_usearc:
  00222	83 f8 02	 cmp	 eax, 2
  00225	75 05		 jne	 SHORT $LN49@sre_usearc
  00227	0f b7 13	 movzx	 edx, WORD PTR [rbx]
  0022a	eb 02		 jmp	 SHORT $LN50@sre_usearc
$LN49@sre_usearc:
  0022c	8b 13		 mov	 edx, DWORD PTR [rbx]
$LN50@sre_usearc:
  0022e	49 8b cd	 mov	 rcx, r13
  00231	e8 00 00 00 00	 call	 sre_ucharset
  00236	85 c0		 test	 eax, eax
  00238	75 10		 jne	 SHORT $LN7@sre_usearc

; 1582 :                 ptr += state->charsize;

  0023a	48 63 46 3c	 movsxd	 rax, DWORD PTR [rsi+60]
  0023e	48 03 d8	 add	 rbx, rax
  00241	48 3b dd	 cmp	 rbx, rbp
  00244	72 cf		 jb	 SHORT $LL8@sre_usearc

; 1552 :         }
; 1553 :         return 0;

  00246	33 c0		 xor	 eax, eax
  00248	eb 64		 jmp	 SHORT $LN39@sre_usearc
$LN7@sre_usearc:

; 1583 :             if (ptr >= end)

  0024a	48 3b dd	 cmp	 rbx, rbp
  0024d	0f 83 70 ff ff
	ff		 jae	 $LN74@sre_usearc

; 1584 :                 return 0;
; 1585 :             TRACE(("|%p|%p|SEARCH CHARSET\n", pattern, ptr));
; 1586 :             state->start = ptr;
; 1587 :             state->ptr = ptr;
; 1588 :             status = SRE_MATCH(state, pattern);

  00253	49 8b d4	 mov	 rdx, r12
  00256	48 8b ce	 mov	 rcx, rsi
  00259	48 89 5e 10	 mov	 QWORD PTR [rsi+16], rbx
  0025d	48 89 1e	 mov	 QWORD PTR [rsi], rbx
  00260	e8 00 00 00 00	 call	 sre_umatch
  00265	48 8b f8	 mov	 rdi, rax

; 1589 :             if (status != 0)

  00268	48 85 c0	 test	 rax, rax
  0026b	75 3e		 jne	 SHORT $LN75@sre_usearc

; 1590 :                 break;
; 1591 :             ptr += state->charsize;

  0026d	48 63 46 3c	 movsxd	 rax, DWORD PTR [rsi+60]
  00271	48 03 d8	 add	 rbx, rax

; 1592 :         }

  00274	eb 9a		 jmp	 SHORT $LL10@sre_usearc
$LN59@sre_usearc:

; 1593 :     } else
; 1594 :         /* general case */
; 1595 :         while (ptr <= end) {

  00276	49 3b dc	 cmp	 rbx, r12
  00279	77 30		 ja	 SHORT $LN75@sre_usearc
  0027b	0f 1f 44 00 00	 npad	 5
$LL3@sre_usearc:

; 1596 :             TRACE(("|%p|%p|SEARCH\n", pattern, ptr));
; 1597 :             state->start = state->ptr = ptr;
; 1598 :             ptr += state->charsize;

  00280	48 63 46 3c	 movsxd	 rax, DWORD PTR [rsi+60]
  00284	48 89 1e	 mov	 QWORD PTR [rsi], rbx
  00287	48 89 5e 10	 mov	 QWORD PTR [rsi+16], rbx

; 1599 :             status = SRE_MATCH(state, pattern);

  0028b	49 8b d2	 mov	 rdx, r10
  0028e	48 8b ce	 mov	 rcx, rsi
  00291	48 03 d8	 add	 rbx, rax
  00294	e8 00 00 00 00	 call	 sre_umatch
  00299	48 8b f8	 mov	 rdi, rax

; 1600 :             if (status != 0)

  0029c	48 85 c0	 test	 rax, rax
  0029f	75 0a		 jne	 SHORT $LN75@sre_usearc

; 1593 :     } else
; 1594 :         /* general case */
; 1595 :         while (ptr <= end) {

  002a1	4c 8b 54 24 78	 mov	 r10, QWORD PTR pattern$[rsp]
  002a6	49 3b dc	 cmp	 rbx, r12
  002a9	76 d5		 jbe	 SHORT $LL3@sre_usearc
$LN75@sre_usearc:

; 1601 :                 break;
; 1602 :         }
; 1603 : 
; 1604 :     return status;

  002ab	48 8b c7	 mov	 rax, rdi
$LN39@sre_usearc:

; 1605 : }

  002ae	48 83 c4 28	 add	 rsp, 40			; 00000028H
  002b2	41 5f		 pop	 r15
  002b4	41 5e		 pop	 r14
  002b6	41 5d		 pop	 r13
  002b8	41 5c		 pop	 r12
  002ba	5f		 pop	 rdi
  002bb	5e		 pop	 rsi
  002bc	5d		 pop	 rbp
  002bd	5b		 pop	 rbx
  002be	c3		 ret	 0
sre_usearch ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT sre_literal_template
_TEXT	SEGMENT
charsize$ = 8
ptr$ = 16
len$ = 24
sre_literal_template PROC				; COMDAT

; 1619 :     /* check if given string is a literal template (i.e. no escapes) */
; 1620 :     struct {
; 1621 :         int charsize;
; 1622 :     } state = {
; 1623 :         charsize
; 1624 :     };
; 1625 :     while (len-- > 0) {

  00000	4d 85 c0	 test	 r8, r8
  00003	7e 29		 jle	 SHORT $LN12@sre_litera
$LL3@sre_litera:
  00005	49 ff c8	 dec	 r8

; 1626 :         if (SRE_CHARGET((&state), ptr, 0) == '\\')

  00008	83 f9 01	 cmp	 ecx, 1
  0000b	75 05		 jne	 SHORT $LN8@sre_litera
  0000d	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00010	eb 0c		 jmp	 SHORT $LN7@sre_litera
$LN8@sre_litera:
  00012	83 f9 02	 cmp	 ecx, 2
  00015	75 05		 jne	 SHORT $LN6@sre_litera
  00017	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  0001a	eb 02		 jmp	 SHORT $LN7@sre_litera
$LN6@sre_litera:
  0001c	8b 02		 mov	 eax, DWORD PTR [rdx]
$LN7@sre_litera:
  0001e	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  00021	74 11		 je	 SHORT $LN11@sre_litera

; 1628 :         ptr += charsize;

  00023	48 63 c1	 movsxd	 rax, ecx
  00026	48 03 d0	 add	 rdx, rax
  00029	4d 85 c0	 test	 r8, r8
  0002c	7f d7		 jg	 SHORT $LL3@sre_litera
$LN12@sre_litera:

; 1629 :     }
; 1630 :     return 1;

  0002e	b8 01 00 00 00	 mov	 eax, 1

; 1631 : }

  00033	c3		 ret	 0
$LN11@sre_litera:

; 1627 :             return 0;

  00034	33 c0		 xor	 eax, eax

; 1631 : }

  00036	c3		 ret	 0
sre_literal_template ENDP
_TEXT	ENDS
EXTRN	PyLong_FromSize_t:PROC
; Function compile flags: /Ogtpy
;	COMDAT sre_codesize
_TEXT	SEGMENT
self$ = 8
unused$ = 16
sre_codesize PROC					; COMDAT

; 1636 :     return PyLong_FromSize_t(sizeof(SRE_CODE));

  00000	b9 04 00 00 00	 mov	 ecx, 4

; 1637 : }

  00005	e9 00 00 00 00	 jmp	 PyLong_FromSize_t
sre_codesize ENDP
_TEXT	ENDS
PUBLIC	??_C@_01KBJDNOO@i?$AA@				; `string'
PUBLIC	??_C@_02PDIHAGKM@ii?$AA@			; `string'
EXTRN	_Py_BuildValue_SizeT:PROC
EXTRN	_PyArg_ParseTuple_SizeT:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$sre_getlower DD imagerel sre_getlower
	DD	imagerel sre_getlower+128
	DD	imagerel $unwind$sre_getlower
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sre_getlower DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_01KBJDNOO@i?$AA@
CONST	SEGMENT
??_C@_01KBJDNOO@i?$AA@ DB 'i', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PDIHAGKM@ii?$AA@
CONST	SEGMENT
??_C@_02PDIHAGKM@ii?$AA@ DB 'ii', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT sre_getlower
_TEXT	SEGMENT
self$ = 48
args$ = 56
character$ = 64
flags$ = 72
sre_getlower PROC					; COMDAT

; 1641 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1642 :     int character, flags;
; 1643 :     if (!PyArg_ParseTuple(args, "ii", &character, &flags))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 4c 24 48	 lea	 r9, QWORD PTR flags$[rsp]
  0000c	4c 8d 44 24 40	 lea	 r8, QWORD PTR character$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02PDIHAGKM@ii?$AA@
  00018	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN3@sre_getlow

; 1644 :         return NULL;

  00021	33 c0		 xor	 eax, eax

; 1650 : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
$LN3@sre_getlow:

; 1645 :     if (flags & SRE_FLAG_LOCALE)

  00028	8b 44 24 48	 mov	 eax, DWORD PTR flags$[rsp]

; 1646 :         return Py_BuildValue("i", sre_lower_locale(character));

  0002c	8b 4c 24 40	 mov	 ecx, DWORD PTR character$[rsp]
  00030	a8 04		 test	 al, 4
  00032	74 18		 je	 SHORT $LN2@sre_getlow
  00034	e8 00 00 00 00	 call	 sre_lower_locale

; 1649 :     return Py_BuildValue("i", sre_lower(character));

  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01KBJDNOO@i?$AA@
  00040	8b d0		 mov	 edx, eax
  00042	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT

; 1650 : }

  00047	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004b	c3		 ret	 0
$LN2@sre_getlow:

; 1647 :     if (flags & SRE_FLAG_UNICODE)

  0004c	a8 20		 test	 al, 32			; 00000020H
  0004e	74 18		 je	 SHORT $LN1@sre_getlow

; 1648 :         return Py_BuildValue("i", sre_lower_unicode(character));

  00050	e8 00 00 00 00	 call	 sre_lower_unicode

; 1649 :     return Py_BuildValue("i", sre_lower(character));

  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01KBJDNOO@i?$AA@
  0005c	8b d0		 mov	 edx, eax
  0005e	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT

; 1650 : }

  00063	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00067	c3		 ret	 0
$LN1@sre_getlow:

; 1649 :     return Py_BuildValue("i", sre_lower(character));

  00068	e8 00 00 00 00	 call	 sre_lower
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01KBJDNOO@i?$AA@
  00074	8b d0		 mov	 edx, eax
  00076	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT

; 1650 : }

  0007b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007f	c3		 ret	 0
sre_getlower ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT state_reset
_TEXT	SEGMENT
state$ = 8
state_reset PROC					; COMDAT

; 1655 :     /* FIXME: dynamic! */
; 1656 :     /*memset(state->mark, 0, sizeof(*state->mark) * SRE_MARK_SIZE);*/
; 1657 : 
; 1658 :     state->lastmark = -1;

  00000	48 c7 41 48 ff
	ff ff ff	 mov	 QWORD PTR [rcx+72], -1

; 1659 :     state->lastindex = -1;

  00008	48 c7 41 40 ff
	ff ff ff	 mov	 QWORD PTR [rcx+64], -1

; 1660 : 
; 1661 :     state->repeat = NULL;

  00010	48 c7 81 f8 06
	00 00 00 00 00
	00		 mov	 QWORD PTR [rcx+1784], 0

; 1662 : 
; 1663 :     data_stack_dealloc(state);
; 1664 : }

  0001b	e9 00 00 00 00	 jmp	 data_stack_dealloc
state_reset ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@INBCANGJ@expected?5string?5or?5buffer?$AA@ ; `string'
PUBLIC	??_C@_0P@DHPONDMO@Buffer?5is?5NULL?$AA@		; `string'
PUBLIC	??_C@_0BF@IGOCMODN@buffer?5size?5mismatch?$AA@	; `string'
PUBLIC	??_C@_0BJ@DECHLKAL@buffer?5has?5negative?5size?$AA@ ; `string'
EXTRN	PyBuffer_Release:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyObject_Size:PROC
EXTRN	PyExc_TypeError:QWORD
EXTRN	_PyUnicode_Ready:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$getstring DD imagerel getstring
	DD	imagerel getstring+157
	DD	imagerel $unwind$getstring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$getstring DD imagerel getstring+157
	DD	imagerel getstring+226
	DD	imagerel $chain$0$getstring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$getstring DD imagerel getstring+226
	DD	imagerel getstring+379
	DD	imagerel $chain$2$getstring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$getstring DD imagerel getstring+379
	DD	imagerel getstring+400
	DD	imagerel $chain$3$getstring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$getstring DD imagerel getstring+400
	DD	imagerel getstring+405
	DD	imagerel $chain$5$getstring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$getstring DD imagerel getstring+405
	DD	imagerel getstring+428
	DD	imagerel $chain$6$getstring
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$getstring DD 020021H
	DD	0a7400H
	DD	imagerel getstring
	DD	imagerel getstring+157
	DD	imagerel $unwind$getstring
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$getstring DD 060021H
	DD	0a7400H
	DD	096400H
	DD	085400H
	DD	imagerel getstring
	DD	imagerel getstring+157
	DD	imagerel $unwind$getstring
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$getstring DD 021H
	DD	imagerel getstring+157
	DD	imagerel getstring+226
	DD	imagerel $chain$0$getstring
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$getstring DD 040e21H
	DD	09640eH
	DD	085405H
	DD	imagerel getstring+157
	DD	imagerel getstring+226
	DD	imagerel $chain$0$getstring
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$getstring DD 020521H
	DD	0a7405H
	DD	imagerel getstring
	DD	imagerel getstring+157
	DD	imagerel $unwind$getstring
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getstring DD 060f01H
	DD	0b340fH
	DD	0e00b320fH
	DD	0c007d009H
xdata	ENDS
;	COMDAT ??_C@_0BK@INBCANGJ@expected?5string?5or?5buffer?$AA@
CONST	SEGMENT
??_C@_0BK@INBCANGJ@expected?5string?5or?5buffer?$AA@ DB 'expected string '
	DB	'or buffer', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DHPONDMO@Buffer?5is?5NULL?$AA@
CONST	SEGMENT
??_C@_0P@DHPONDMO@Buffer?5is?5NULL?$AA@ DB 'Buffer is NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IGOCMODN@buffer?5size?5mismatch?$AA@
CONST	SEGMENT
??_C@_0BF@IGOCMODN@buffer?5size?5mismatch?$AA@ DB 'buffer size mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DECHLKAL@buffer?5has?5negative?5size?$AA@
CONST	SEGMENT
??_C@_0BJ@DECHLKAL@buffer?5has?5negative?5size?$AA@ DB 'buffer has negati'
	DB	've size', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT getstring
_TEXT	SEGMENT
string$ = 64
p_length$ = 72
p_logical_charsize$ = 80
p_charsize$ = 88
view$ = 96
getstring PROC						; COMDAT

; 1670 : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1671 :     /* given a python object, return a data pointer, a length (in
; 1672 :        characters), and a character size.  return NULL if the object
; 1673 :        is not a string (or not compatible) */
; 1674 : 
; 1675 :     PyBufferProcs *buffer;
; 1676 :     Py_ssize_t size, bytes;
; 1677 :     int charsize;
; 1678 :     void* ptr;
; 1679 : 
; 1680 :     /* Unicode objects do not support the buffer API. So, get the data
; 1681 :        directly instead. */
; 1682 :     if (PyUnicode_Check(string)) {

  0000f	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00013	4d 8b e1	 mov	 r12, r9
  00016	4d 8b e8	 mov	 r13, r8
  00019	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00023	4c 8b f2	 mov	 r14, rdx
  00026	48 8b d9	 mov	 rbx, rcx
  00029	74 72		 je	 SHORT $LN9@getstring

; 1683 :         if (PyUnicode_READY(string) == -1)

  0002b	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0002f	75 1c		 jne	 SHORT $LN8@getstring
  00031	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00036	83 f8 ff	 cmp	 eax, -1
  00039	75 12		 jne	 SHORT $LN8@getstring

; 1684 :             return NULL;

  0003b	33 c0		 xor	 eax, eax

; 1734 : }

  0003d	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	41 5e		 pop	 r14
  00048	41 5d		 pop	 r13
  0004a	41 5c		 pop	 r12
  0004c	c3		 ret	 0
$LN8@getstring:

; 1685 :         ptr = PyUnicode_DATA(string);

  0004d	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00050	a8 20		 test	 al, 32			; 00000020H
  00052	74 16		 je	 SHORT $LN16@getstring
  00054	a8 40		 test	 al, 64			; 00000040H
  00056	74 09		 je	 SHORT $LN14@getstring
  00058	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  0005f	eb 10		 jmp	 SHORT $LN17@getstring
$LN14@getstring:
  00061	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00068	eb 07		 jmp	 SHORT $LN17@getstring
$LN16@getstring:
  0006a	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN17@getstring:

; 1686 :         *p_length = PyUnicode_GET_LENGTH(string);

  00071	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00075	49 89 0e	 mov	 QWORD PTR [r14], rcx

; 1687 :         *p_charsize = PyUnicode_KIND(string);

  00078	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  0007b	c1 e9 02	 shr	 ecx, 2
  0007e	83 e1 07	 and	 ecx, 7
  00081	41 89 0c 24	 mov	 DWORD PTR [r12], ecx

; 1688 :         *p_logical_charsize = 4;

  00085	41 c7 45 00 04
	00 00 00	 mov	 DWORD PTR [r13], 4

; 1734 : }

  0008d	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00092	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00096	41 5e		 pop	 r14
  00098	41 5d		 pop	 r13
  0009a	41 5c		 pop	 r12
  0009c	c3		 ret	 0
$LN9@getstring:
  0009d	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi

; 1689 :         return ptr;
; 1690 :     }
; 1691 : 
; 1692 :     /* get pointer to byte string buffer */
; 1693 :     view->len = -1;

  000a2	48 8b 7c 24 60	 mov	 rdi, QWORD PTR view$[rsp]
  000a7	48 c7 47 10 ff
	ff ff ff	 mov	 QWORD PTR [rdi+16], -1

; 1694 :     buffer = Py_TYPE(string)->tp_as_buffer;

  000af	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  000b3	48 8b 88 f8 00
	00 00		 mov	 rcx, QWORD PTR [rax+248]

; 1695 :     if (!buffer || !buffer->bf_getbuffer ||
; 1696 :         (*buffer->bf_getbuffer)(string, view, PyBUF_SIMPLE) < 0) {

  000ba	48 85 c9	 test	 rcx, rcx
  000bd	0f 84 d2 00 00
	00		 je	 $LN6@getstring
  000c3	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  000c6	48 85 c0	 test	 rax, rax
  000c9	0f 84 c6 00 00
	00		 je	 $LN6@getstring
  000cf	45 33 c0	 xor	 r8d, r8d
  000d2	48 8b d7	 mov	 rdx, rdi
  000d5	48 8b cb	 mov	 rcx, rbx
  000d8	ff d0		 call	 rax
  000da	85 c0		 test	 eax, eax
  000dc	0f 88 b3 00 00
	00		 js	 $LN6@getstring

; 1699 :     }
; 1700 : 
; 1701 :     /* determine buffer size */
; 1702 :     bytes = view->len;

  000e2	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  000e7	48 8b 6f 10	 mov	 rbp, QWORD PTR [rdi+16]
  000eb	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi

; 1703 :     ptr = view->buf;

  000f0	48 8b 37	 mov	 rsi, QWORD PTR [rdi]

; 1704 : 
; 1705 :     if (bytes < 0) {

  000f3	48 85 ed	 test	 rbp, rbp
  000f6	79 10		 jns	 SHORT $LN5@getstring

; 1706 :         PyErr_SetString(PyExc_TypeError, "buffer has negative size");

  000f8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@DECHLKAL@buffer?5has?5negative?5size?$AA@

; 1707 :         goto err;

  00106	eb 53		 jmp	 SHORT $LN21@getstring
$LN5@getstring:

; 1708 :     }
; 1709 : 
; 1710 :     /* determine character size */
; 1711 :     size = PyObject_Size(string);

  00108	48 8b cb	 mov	 rcx, rbx
  0010b	e8 00 00 00 00	 call	 PyObject_Size

; 1712 : 
; 1713 :     if (PyBytes_Check(string) || bytes == size)

  00110	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00114	f7 81 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rcx+256], 134217728 ; 08000000H
  0011e	75 15		 jne	 SHORT $LN3@getstring
  00120	48 3b e8	 cmp	 rbp, rax
  00123	74 10		 je	 SHORT $LN3@getstring

; 1714 :         charsize = 1;
; 1715 :     else {
; 1716 :         PyErr_SetString(PyExc_TypeError, "buffer size mismatch");

  00125	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0012c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@IGOCMODN@buffer?5size?5mismatch?$AA@

; 1717 :         goto err;

  00133	eb 26		 jmp	 SHORT $LN21@getstring
$LN3@getstring:

; 1718 :     }
; 1719 : 
; 1720 :     *p_length = size;

  00135	49 89 06	 mov	 QWORD PTR [r14], rax

; 1721 :     *p_charsize = charsize;

  00138	41 c7 04 24 01
	00 00 00	 mov	 DWORD PTR [r12], 1

; 1722 :     *p_logical_charsize = charsize;

  00140	41 c7 45 00 01
	00 00 00	 mov	 DWORD PTR [r13], 1

; 1723 : 
; 1724 :     if (ptr == NULL) {

  00148	48 85 f6	 test	 rsi, rsi
  0014b	75 43		 jne	 SHORT $LN1@getstring

; 1725 :             PyErr_SetString(PyExc_ValueError,
; 1726 :                             "Buffer is NULL");

  0014d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00154	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@DHPONDMO@Buffer?5is?5NULL?$AA@
$LN21@getstring:
  0015b	e8 00 00 00 00	 call	 PyErr_SetString

; 1730 :   err:
; 1731 :     PyBuffer_Release(view);

  00160	48 8b cf	 mov	 rcx, rdi
$err$23330:
  00163	e8 00 00 00 00	 call	 PyBuffer_Release

; 1732 :     view->buf = NULL;

  00168	48 c7 07 00 00
	00 00		 mov	 QWORD PTR [rdi], 0

; 1733 :     return NULL;

  0016f	33 c0		 xor	 eax, eax
$LN20@getstring:
  00171	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00176	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
$LN18@getstring:
  0017b	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 1734 : }

  00180	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00185	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00189	41 5e		 pop	 r14
  0018b	41 5d		 pop	 r13
  0018d	41 5c		 pop	 r12
  0018f	c3		 ret	 0
$LN1@getstring:

; 1727 :             goto err;
; 1728 :     }
; 1729 :     return ptr;

  00190	48 8b c6	 mov	 rax, rsi
  00193	eb dc		 jmp	 SHORT $LN20@getstring
$LN6@getstring:

; 1697 :             PyErr_SetString(PyExc_TypeError, "expected string or buffer");

  00195	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0019c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@INBCANGJ@expected?5string?5or?5buffer?$AA@
  001a3	e8 00 00 00 00	 call	 PyErr_SetString

; 1698 :             return NULL;

  001a8	33 c0		 xor	 eax, eax
  001aa	eb cf		 jmp	 SHORT $LN18@getstring
getstring ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DC@DNNGCEHM@can?8t?5use?5a?5bytes?5pattern?5on?5a?5s@ ; `string'
PUBLIC	??_C@_0DC@EJGEMLIB@can?8t?5use?5a?5string?5pattern?5on?5a?5@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$state_init DD imagerel state_init
	DD	imagerel state_init+437
	DD	imagerel $unwind$state_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$state_init DD 0a1801H
	DD	0f6418H
	DD	0e5418H
	DD	0d3418H
	DD	0d0147218H
	DD	07010c012H
xdata	ENDS
;	COMDAT ??_C@_0DC@DNNGCEHM@can?8t?5use?5a?5bytes?5pattern?5on?5a?5s@
CONST	SEGMENT
??_C@_0DC@DNNGCEHM@can?8t?5use?5a?5bytes?5pattern?5on?5a?5s@ DB 'can''t u'
	DB	'se a bytes pattern on a string-like object', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@EJGEMLIB@can?8t?5use?5a?5string?5pattern?5on?5a?5@
CONST	SEGMENT
??_C@_0DC@EJGEMLIB@can?8t?5use?5a?5string?5pattern?5on?5a?5@ DB 'can''t u'
	DB	'se a string pattern on a bytes-like object', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_sre.c
CONST	ENDS
;	COMDAT state_init
_TEXT	SEGMENT
charsize$ = 48
length$ = 56
logical_charsize$ = 96
state$ = 96
pattern$ = 104
string$ = 112
start$ = 120
end$ = 128
state_init PROC						; COMDAT

; 1739 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00018	49 8b f8	 mov	 rdi, r8
  0001b	4c 8b ea	 mov	 r13, rdx

; 1740 :     /* prepare state object */
; 1741 : 
; 1742 :     Py_ssize_t length;
; 1743 :     int logical_charsize, charsize;
; 1744 :     void* ptr;
; 1745 : 
; 1746 :     memset(state, 0, sizeof(SRE_STATE));

  0001e	33 d2		 xor	 edx, edx
  00020	41 b8 08 07 00
	00		 mov	 r8d, 1800		; 00000708H
  00026	49 8b f1	 mov	 rsi, r9
  00029	48 8b d9	 mov	 rbx, rcx
  0002c	e8 00 00 00 00	 call	 memset

; 1747 : 
; 1748 :     state->lastmark = -1;
; 1749 :     state->lastindex = -1;
; 1750 : 
; 1751 :     state->buffer.buf = NULL;

  00031	4c 8d a3 a8 06
	00 00		 lea	 r12, QWORD PTR [rbx+1704]

; 1752 :     ptr = getstring(string, &length, &logical_charsize, &charsize, &state->buffer);

  00038	4c 8d 4c 24 30	 lea	 r9, QWORD PTR charsize$[rsp]
  0003d	4c 8d 44 24 60	 lea	 r8, QWORD PTR logical_charsize$[rsp]
  00042	48 8d 54 24 38	 lea	 rdx, QWORD PTR length$[rsp]
  00047	33 ed		 xor	 ebp, ebp
  00049	48 8b cf	 mov	 rcx, rdi
  0004c	48 c7 43 48 ff
	ff ff ff	 mov	 QWORD PTR [rbx+72], -1
  00054	48 c7 43 40 ff
	ff ff ff	 mov	 QWORD PTR [rbx+64], -1
  0005c	49 89 2c 24	 mov	 QWORD PTR [r12], rbp
  00060	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  00065	e8 00 00 00 00	 call	 getstring
  0006a	4c 8b d8	 mov	 r11, rax

; 1753 :     if (!ptr)

  0006d	48 85 c0	 test	 rax, rax
  00070	74 25		 je	 SHORT $err$23360

; 1754 :         goto err;
; 1755 : 
; 1756 :     if (logical_charsize == 1 && pattern->logical_charsize > 1) {

  00072	8b 54 24 60	 mov	 edx, DWORD PTR logical_charsize$[rsp]
  00076	83 fa 01	 cmp	 edx, 1
  00079	75 45		 jne	 SHORT $LN21@state_init
  0007b	41 39 95 a0 00
	00 00		 cmp	 DWORD PTR [r13+160], edx
  00082	7e 51		 jle	 SHORT $LN12@state_init

; 1757 :         PyErr_SetString(PyExc_TypeError,
; 1758 :                         "can't use a string pattern on a bytes-like object");

  00084	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@EJGEMLIB@can?8t?5use?5a?5string?5pattern?5on?5a?5@
$LN23@state_init:

; 1762 :         PyErr_SetString(PyExc_TypeError,
; 1763 :                         "can't use a bytes pattern on a string-like object");

  0008b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00092	e8 00 00 00 00	 call	 PyErr_SetString
$err$23360:

; 1799 :   err:
; 1800 :     if (state->buffer.buf)

  00097	49 39 2c 24	 cmp	 QWORD PTR [r12], rbp
  0009b	74 08		 je	 SHORT $LN1@state_init

; 1801 :         PyBuffer_Release(&state->buffer);

  0009d	49 8b cc	 mov	 rcx, r12
  000a0	e8 00 00 00 00	 call	 PyBuffer_Release
$LN1@state_init:

; 1802 :     return NULL;

  000a5	33 c0		 xor	 eax, eax
$LN15@state_init:

; 1803 : }

  000a7	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  000ac	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  000b1	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  000b6	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000ba	41 5d		 pop	 r13
  000bc	41 5c		 pop	 r12
  000be	5f		 pop	 rdi
  000bf	c3		 ret	 0
$LN21@state_init:

; 1759 :         goto err;
; 1760 :     }
; 1761 :     if (logical_charsize > 1 && pattern->logical_charsize == 1) {

  000c0	7e 13		 jle	 SHORT $LN12@state_init
  000c2	41 83 bd a0 00
	00 00 01	 cmp	 DWORD PTR [r13+160], 1
  000ca	75 09		 jne	 SHORT $LN12@state_init

; 1762 :         PyErr_SetString(PyExc_TypeError,
; 1763 :                         "can't use a bytes pattern on a string-like object");

  000cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@DNNGCEHM@can?8t?5use?5a?5bytes?5pattern?5on?5a?5s@
  000d3	eb b6		 jmp	 SHORT $LN23@state_init
$LN12@state_init:

; 1764 :         goto err;
; 1765 :     }
; 1766 : 
; 1767 :     /* adjust boundaries */
; 1768 :     if (start < 0)

  000d5	48 8b 44 24 38	 mov	 rax, QWORD PTR length$[rsp]
  000da	48 85 f6	 test	 rsi, rsi
  000dd	79 05		 jns	 SHORT $LN11@state_init

; 1769 :         start = 0;

  000df	48 8b f5	 mov	 rsi, rbp
  000e2	eb 07		 jmp	 SHORT $LN9@state_init
$LN11@state_init:

; 1770 :     else if (start > length)

  000e4	48 3b f0	 cmp	 rsi, rax
  000e7	48 0f 4f f0	 cmovg	 rsi, rax
$LN9@state_init:

; 1771 :         start = length;
; 1772 : 
; 1773 :     if (end < 0)

  000eb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR end$[rsp]
  000f3	48 85 c9	 test	 rcx, rcx
  000f6	78 0a		 js	 SHORT $LN6@state_init

; 1774 :         end = 0;
; 1775 :     else if (end > length)

  000f8	48 8b e9	 mov	 rbp, rcx
  000fb	48 3b c8	 cmp	 rcx, rax
  000fe	48 0f 4f e8	 cmovg	 rbp, rax
$LN6@state_init:

; 1776 :         end = length;
; 1777 : 
; 1778 :     state->logical_charsize = logical_charsize;
; 1779 :     state->charsize = charsize;

  00102	48 63 44 24 30	 movsxd	 rax, DWORD PTR charsize$[rsp]
  00107	89 53 38	 mov	 DWORD PTR [rbx+56], edx

; 1780 : 
; 1781 :     state->beginning = ptr;

  0010a	4c 89 5b 08	 mov	 QWORD PTR [rbx+8], r11

; 1782 : 
; 1783 :     state->start = (void*) ((char*) ptr + start * state->charsize);

  0010e	48 8b c8	 mov	 rcx, rax
  00111	89 43 3c	 mov	 DWORD PTR [rbx+60], eax
  00114	48 0f af c6	 imul	 rax, rsi
  00118	49 03 c3	 add	 rax, r11
  0011b	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 1784 :     state->end = (void*) ((char*) ptr + end * state->charsize);

  0011f	48 0f af cd	 imul	 rcx, rbp
  00123	49 03 cb	 add	 rcx, r11
  00126	48 89 4b 18	 mov	 QWORD PTR [rbx+24], rcx

; 1785 : 
; 1786 :     Py_INCREF(string);

  0012a	e8 00 00 00 00	 call	 _Py_PXCTX
  0012f	85 c0		 test	 eax, eax
  00131	75 32		 jne	 SHORT $LN18@state_init
  00133	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0013a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00141	4c 8b cf	 mov	 r9, rdi
  00144	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0014a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00152	e8 00 00 00 00	 call	 _PyParallel_Guard
  00157	85 c0		 test	 eax, eax
  00159	75 06		 jne	 SHORT $LN17@state_init
  0015b	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  0015f	74 04		 je	 SHORT $LN18@state_init
$LN17@state_init:
  00161	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN18@state_init:

; 1787 :     state->string = string;

  00165	48 89 7b 20	 mov	 QWORD PTR [rbx+32], rdi

; 1788 :     state->pos = start;

  00169	48 89 73 28	 mov	 QWORD PTR [rbx+40], rsi

; 1789 :     state->endpos = end;

  0016d	48 89 6b 30	 mov	 QWORD PTR [rbx+48], rbp

; 1790 : 
; 1791 :     if (pattern->flags & SRE_FLAG_LOCALE)

  00171	41 8b 85 90 00
	00 00		 mov	 eax, DWORD PTR [r13+144]
  00178	a8 04		 test	 al, 4
  0017a	74 16		 je	 SHORT $LN5@state_init

; 1792 :         state->lower = sre_lower_locale;

  0017c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:sre_lower_locale

; 1793 :     else if (pattern->flags & SRE_FLAG_UNICODE)

  00183	48 89 83 00 07
	00 00		 mov	 QWORD PTR [rbx+1792], rax

; 1794 :         state->lower = sre_lower_unicode;
; 1795 :     else
; 1796 :         state->lower = sre_lower;
; 1797 : 
; 1798 :     return string;

  0018a	48 8b c7	 mov	 rax, rdi
  0018d	e9 15 ff ff ff	 jmp	 $LN15@state_init
$LN5@state_init:

; 1793 :     else if (pattern->flags & SRE_FLAG_UNICODE)

  00192	a8 20		 test	 al, 32			; 00000020H
  00194	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sre_lower_unicode
  0019b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:sre_lower
  001a2	48 0f 45 c1	 cmovne	 rax, rcx
  001a6	48 89 83 00 07
	00 00		 mov	 QWORD PTR [rbx+1792], rax

; 1794 :         state->lower = sre_lower_unicode;
; 1795 :     else
; 1796 :         state->lower = sre_lower;
; 1797 : 
; 1798 :     return string;

  001ad	48 8b c7	 mov	 rax, rdi
  001b0	e9 f2 fe ff ff	 jmp	 $LN15@state_init
state_init ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$state_fini DD imagerel state_fini
	DD	imagerel state_fini+195
	DD	imagerel $unwind$state_fini
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$state_fini DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_sre.c
xdata	ENDS
;	COMDAT state_fini
_TEXT	SEGMENT
state$ = 64
state_fini PROC						; COMDAT

; 1807 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 1808 :     if (state->buffer.buf)

  0000d	48 81 c1 a8 06
	00 00		 add	 rcx, 1704		; 000006a8H
  00014	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  00018	74 05		 je	 SHORT $LN4@state_fini

; 1809 :         PyBuffer_Release(&state->buffer);

  0001a	e8 00 00 00 00	 call	 PyBuffer_Release
$LN4@state_fini:

; 1810 :     Py_XDECREF(state->string);

  0001f	48 8b 5f 20	 mov	 rbx, QWORD PTR [rdi+32]
  00023	48 85 db	 test	 rbx, rbx
  00026	0f 84 85 00 00
	00		 je	 $LN3@state_fini
  0002c	e8 00 00 00 00	 call	 _Py_PXCTX
  00031	85 c0		 test	 eax, eax
  00033	75 7c		 jne	 SHORT $LN3@state_fini
  00035	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00039	a8 20		 test	 al, 32			; 00000020H
  0003b	75 6c		 jne	 SHORT $LN12@state_fini
  0003d	84 c0		 test	 al, al
  0003f	78 68		 js	 SHORT $LN12@state_fini
  00041	a8 02		 test	 al, 2
  00043	75 6c		 jne	 SHORT $LN3@state_fini
  00045	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00049	75 66		 jne	 SHORT $LN3@state_fini
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00059	4c 8b cb	 mov	 r9, rbx
  0005c	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00062	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0006a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0006f	48 8b cb	 mov	 rcx, rbx
  00072	85 c0		 test	 eax, eax
  00074	74 17		 je	 SHORT $LN17@state_fini
  00076	e8 00 00 00 00	 call	 _Px_Dealloc

; 1811 :     data_stack_dealloc(state);

  0007b	48 8b cf	 mov	 rcx, rdi

; 1812 : }

  0007e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00083	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00087	5f		 pop	 rdi
  00088	e9 00 00 00 00	 jmp	 data_stack_dealloc

; 1810 :     Py_XDECREF(state->string);

$LN17@state_fini:
  0008d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00091	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 1811 :     data_stack_dealloc(state);

  00097	48 8b cf	 mov	 rcx, rdi

; 1812 : }

  0009a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0009f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a3	5f		 pop	 rdi
  000a4	e9 00 00 00 00	 jmp	 data_stack_dealloc

; 1810 :     Py_XDECREF(state->string);

$LN12@state_fini:
  000a9	48 8b cb	 mov	 rcx, rbx
  000ac	e8 00 00 00 00	 call	 Px_DecRef
$LN3@state_fini:

; 1811 :     data_stack_dealloc(state);

  000b1	48 8b cf	 mov	 rcx, rdi

; 1812 : }

  000b4	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000bd	5f		 pop	 rdi
  000be	e9 00 00 00 00	 jmp	 data_stack_dealloc
state_fini ENDP
_TEXT	ENDS
EXTRN	PySequence_GetSlice:PROC
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$state_getslice DD imagerel state_getslice
	DD	imagerel state_getslice+227
	DD	imagerel $unwind$state_getslice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$state_getslice DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_sre.c
xdata	ENDS
;	COMDAT state_getslice
_TEXT	SEGMENT
state$ = 64
index$ = 72
string$ = 80
empty$ = 88
state_getslice PROC					; COMDAT

; 1820 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1821 :     Py_ssize_t i, j;
; 1822 : 
; 1823 :     index = (index - 1) * 2;
; 1824 : 
; 1825 :     if (string == Py_None || index >= state->lastmark || !state->mark[index] || !state->mark[index+1]) {

  0000a	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct
  00011	49 8b d8	 mov	 rbx, r8
  00014	4c 8b d1	 mov	 r10, rcx
  00017	48 8d 54 12 fe	 lea	 rdx, QWORD PTR [rdx+rdx-2]
  0001c	4c 3b c7	 cmp	 r8, rdi
  0001f	74 50		 je	 SHORT $LN4@state_gets
  00021	48 3b 51 48	 cmp	 rdx, QWORD PTR [rcx+72]
  00025	7d 4a		 jge	 SHORT $LN4@state_gets
  00027	48 8b 44 d1 50	 mov	 rax, QWORD PTR [rcx+rdx*8+80]
  0002c	48 85 c0	 test	 rax, rax
  0002f	74 40		 je	 SHORT $LN4@state_gets
  00031	4c 8b 5c d1 58	 mov	 r11, QWORD PTR [rcx+rdx*8+88]
  00036	4d 85 db	 test	 r11, r11
  00039	74 36		 je	 SHORT $LN4@state_gets

; 1832 :         }
; 1833 :     } else {
; 1834 :         i = STATE_OFFSET(state, state->mark[index]);

  0003b	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0003f	4d 63 42 3c	 movsxd	 r8, DWORD PTR [r10+60]
  00043	48 2b c1	 sub	 rax, rcx

; 1835 :         j = STATE_OFFSET(state, state->mark[index+1]);

  00046	4c 2b d9	 sub	 r11, rcx

; 1836 :     }
; 1837 : 
; 1838 :     return PySequence_GetSlice(string, i, j);

  00049	48 8b cb	 mov	 rcx, rbx
  0004c	48 99		 cdq
  0004e	49 f7 f8	 idiv	 r8
  00051	4c 8b c8	 mov	 r9, rax
  00054	49 8b c3	 mov	 rax, r11
  00057	48 99		 cdq
  00059	49 f7 f8	 idiv	 r8
  0005c	49 8b d1	 mov	 rdx, r9
  0005f	4c 8b c0	 mov	 r8, rax

; 1839 : }

  00062	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00067	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006b	5f		 pop	 rdi
  0006c	e9 00 00 00 00	 jmp	 PySequence_GetSlice
$LN4@state_gets:

; 1826 :         if (empty)

  00071	45 85 c9	 test	 r9d, r9d
  00074	74 1e		 je	 SHORT $LN3@state_gets

; 1827 :             /* want empty string */
; 1828 :             i = j = 0;

  00076	45 33 c9	 xor	 r9d, r9d

; 1836 :     }
; 1837 : 
; 1838 :     return PySequence_GetSlice(string, i, j);

  00079	48 8b cb	 mov	 rcx, rbx
  0007c	41 8b c1	 mov	 eax, r9d
  0007f	41 8b d1	 mov	 edx, r9d
  00082	44 8b c0	 mov	 r8d, eax

; 1839 : }

  00085	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0008a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008e	5f		 pop	 rdi
  0008f	e9 00 00 00 00	 jmp	 PySequence_GetSlice
$LN3@state_gets:

; 1829 :         else {
; 1830 :             Py_INCREF(Py_None);

  00094	e8 00 00 00 00	 call	 _Py_PXCTX
  00099	85 c0		 test	 eax, eax
  0009b	75 38		 jne	 SHORT $LN9@state_gets
  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000ab	4c 8b cf	 mov	 r9, rdi
  000ae	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000b4	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000bc	e8 00 00 00 00	 call	 _PyParallel_Guard
  000c1	85 c0		 test	 eax, eax
  000c3	75 09		 jne	 SHORT $LN8@state_gets
  000c5	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000cc	74 07		 je	 SHORT $LN9@state_gets
$LN8@state_gets:
  000ce	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN9@state_gets:

; 1831 :             return Py_None;

  000d5	48 8b c7	 mov	 rax, rdi

; 1839 : }

  000d8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000dd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e1	5f		 pop	 rdi
  000e2	c3		 ret	 0
state_getslice ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@LIEPNCKF@maximum?5recursion?5limit?5exceeded@ ; `string'
PUBLIC	??_C@_0CM@MJLOECCJ@internal?5error?5in?5regular?5expres@ ; `string'
EXTRN	PyExc_RuntimeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$pattern_error DD imagerel pattern_error
	DD	imagerel pattern_error+68
	DD	imagerel $unwind$pattern_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_error DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CB@LIEPNCKF@maximum?5recursion?5limit?5exceeded@
CONST	SEGMENT
??_C@_0CB@LIEPNCKF@maximum?5recursion?5limit?5exceeded@ DB 'maximum recur'
	DB	'sion limit exceeded', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@MJLOECCJ@internal?5error?5in?5regular?5expres@
CONST	SEGMENT
??_C@_0CM@MJLOECCJ@internal?5error?5in?5regular?5expres@ DB 'internal err'
	DB	'or in regular expression engine', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT pattern_error
_TEXT	SEGMENT
status$ = 48
pattern_error PROC					; COMDAT

; 1843 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1844 :     switch (status) {

  00004	83 f9 f6	 cmp	 ecx, -10
  00007	74 36		 je	 SHORT $LN2@pattern_er
  00009	83 f9 f7	 cmp	 ecx, -9
  0000c	74 2c		 je	 SHORT $LN3@pattern_er
  0000e	83 f9 fd	 cmp	 ecx, -3

; 1853 :         break;
; 1854 :     case SRE_ERROR_INTERRUPTED:
; 1855 :     /* An exception has already been raised, so let it fly */
; 1856 :         break;
; 1857 :     default:
; 1858 :         /* other error codes indicate compiler/engine bugs */
; 1859 :         PyErr_SetString(
; 1860 :             PyExc_RuntimeError,
; 1861 :             "internal error in regular expression engine"
; 1862 :             );

  00011	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00018	74 10		 je	 SHORT $LN4@pattern_er
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@MJLOECCJ@internal?5error?5in?5regular?5expres@

; 1863 :     }
; 1864 : }

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	e9 00 00 00 00	 jmp	 PyErr_SetString
$LN4@pattern_er:

; 1845 :     case SRE_ERROR_RECURSION_LIMIT:
; 1846 :         PyErr_SetString(
; 1847 :             PyExc_RuntimeError,
; 1848 :             "maximum recursion limit exceeded"
; 1849 :             );

  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@LIEPNCKF@maximum?5recursion?5limit?5exceeded@

; 1863 :     }
; 1864 : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	e9 00 00 00 00	 jmp	 PyErr_SetString
$LN3@pattern_er:

; 1850 :         break;
; 1851 :     case SRE_ERROR_MEMORY:
; 1852 :         PyErr_NoMemory();

  0003a	e8 00 00 00 00	 call	 PyErr_NoMemory
$LN2@pattern_er:

; 1863 :     }
; 1864 : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
pattern_error ENDP
_TEXT	ENDS
EXTRN	PyObject_ClearWeakRefs:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$pattern_dealloc DD imagerel pattern_dealloc
	DD	imagerel pattern_dealloc+436
	DD	imagerel $unwind$pattern_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_dealloc DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_sre.c
xdata	ENDS
;	COMDAT pattern_dealloc
_TEXT	SEGMENT
self$ = 64
pattern_dealloc PROC					; COMDAT

; 1868 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1869 :     if (self->weakreflist != NULL)

  0000a	48 83 b9 98 00
	00 00 00	 cmp	 QWORD PTR [rcx+152], 0
  00012	48 8b f9	 mov	 rdi, rcx
  00015	74 05		 je	 SHORT $LN14@pattern_de

; 1870 :         PyObject_ClearWeakRefs((PyObject *) self);

  00017	e8 00 00 00 00	 call	 PyObject_ClearWeakRefs
$LN14@pattern_de:

; 1871 :     if (self->view.buf)

  0001c	48 8d 8f a8 00
	00 00		 lea	 rcx, QWORD PTR [rdi+168]
  00023	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  00027	74 05		 je	 SHORT $LN12@pattern_de

; 1872 :         PyBuffer_Release(&self->view);

  00029	e8 00 00 00 00	 call	 PyBuffer_Release
$LN12@pattern_de:

; 1873 :     Py_XDECREF(self->pattern);

  0002e	48 8b 9f 88 00
	00 00		 mov	 rbx, QWORD PTR [rdi+136]
  00035	48 85 db	 test	 rbx, rbx
  00038	74 65		 je	 SHORT $LN11@pattern_de
  0003a	e8 00 00 00 00	 call	 _Py_PXCTX
  0003f	85 c0		 test	 eax, eax
  00041	75 5c		 jne	 SHORT $LN11@pattern_de
  00043	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00047	a8 20		 test	 al, 32			; 00000020H
  00049	75 4c		 jne	 SHORT $LN21@pattern_de
  0004b	84 c0		 test	 al, al
  0004d	78 48		 js	 SHORT $LN21@pattern_de
  0004f	a8 02		 test	 al, 2
  00051	75 4c		 jne	 SHORT $LN11@pattern_de
  00053	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00057	75 46		 jne	 SHORT $LN11@pattern_de
  00059	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00067	4c 8b cb	 mov	 r9, rbx
  0006a	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00070	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00078	e8 00 00 00 00	 call	 _PyParallel_Guard
  0007d	48 8b cb	 mov	 rcx, rbx
  00080	85 c0		 test	 eax, eax
  00082	74 07		 je	 SHORT $LN26@pattern_de
  00084	e8 00 00 00 00	 call	 _Px_Dealloc
  00089	eb 14		 jmp	 SHORT $LN11@pattern_de
$LN26@pattern_de:
  0008b	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0008f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00095	eb 08		 jmp	 SHORT $LN11@pattern_de
$LN21@pattern_de:
  00097	48 8b cb	 mov	 rcx, rbx
  0009a	e8 00 00 00 00	 call	 Px_DecRef
$LN11@pattern_de:

; 1874 :     Py_XDECREF(self->groupindex);

  0009f	48 8b 5f 78	 mov	 rbx, QWORD PTR [rdi+120]
  000a3	48 85 db	 test	 rbx, rbx
  000a6	74 65		 je	 SHORT $LN7@pattern_de
  000a8	e8 00 00 00 00	 call	 _Py_PXCTX
  000ad	85 c0		 test	 eax, eax
  000af	75 5c		 jne	 SHORT $LN7@pattern_de
  000b1	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000b5	a8 20		 test	 al, 32			; 00000020H
  000b7	75 4c		 jne	 SHORT $LN32@pattern_de
  000b9	84 c0		 test	 al, al
  000bb	78 48		 js	 SHORT $LN32@pattern_de
  000bd	a8 02		 test	 al, 2
  000bf	75 4c		 jne	 SHORT $LN7@pattern_de
  000c1	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000c5	75 46		 jne	 SHORT $LN7@pattern_de
  000c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000d5	4c 8b cb	 mov	 r9, rbx
  000d8	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000de	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000e6	e8 00 00 00 00	 call	 _PyParallel_Guard
  000eb	48 8b cb	 mov	 rcx, rbx
  000ee	85 c0		 test	 eax, eax
  000f0	74 07		 je	 SHORT $LN37@pattern_de
  000f2	e8 00 00 00 00	 call	 _Px_Dealloc
  000f7	eb 14		 jmp	 SHORT $LN7@pattern_de
$LN37@pattern_de:
  000f9	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000fd	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00103	eb 08		 jmp	 SHORT $LN7@pattern_de
$LN32@pattern_de:
  00105	48 8b cb	 mov	 rcx, rbx
  00108	e8 00 00 00 00	 call	 Px_DecRef
$LN7@pattern_de:

; 1875 :     Py_XDECREF(self->indexgroup);

  0010d	48 8b 9f 80 00
	00 00		 mov	 rbx, QWORD PTR [rdi+128]
  00114	48 85 db	 test	 rbx, rbx
  00117	0f 84 85 00 00
	00		 je	 $LN3@pattern_de
  0011d	e8 00 00 00 00	 call	 _Py_PXCTX
  00122	85 c0		 test	 eax, eax
  00124	75 7c		 jne	 SHORT $LN3@pattern_de
  00126	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0012a	a8 20		 test	 al, 32			; 00000020H
  0012c	75 6c		 jne	 SHORT $LN43@pattern_de
  0012e	84 c0		 test	 al, al
  00130	78 68		 js	 SHORT $LN43@pattern_de
  00132	a8 02		 test	 al, 2
  00134	75 6c		 jne	 SHORT $LN3@pattern_de
  00136	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0013a	75 66		 jne	 SHORT $LN3@pattern_de
  0013c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00143	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0014a	4c 8b cb	 mov	 r9, rbx
  0014d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00153	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0015b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00160	48 8b cb	 mov	 rcx, rbx
  00163	85 c0		 test	 eax, eax
  00165	74 17		 je	 SHORT $LN48@pattern_de
  00167	e8 00 00 00 00	 call	 _Px_Dealloc

; 1876 :     PyObject_DEL(self);

  0016c	48 8b cf	 mov	 rcx, rdi

; 1877 : }

  0016f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00174	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00178	5f		 pop	 rdi
  00179	e9 00 00 00 00	 jmp	 PyObject_Free

; 1875 :     Py_XDECREF(self->indexgroup);

$LN48@pattern_de:
  0017e	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00182	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 1876 :     PyObject_DEL(self);

  00188	48 8b cf	 mov	 rcx, rdi

; 1877 : }

  0018b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00190	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00194	5f		 pop	 rdi
  00195	e9 00 00 00 00	 jmp	 PyObject_Free

; 1875 :     Py_XDECREF(self->indexgroup);

$LN43@pattern_de:
  0019a	48 8b cb	 mov	 rcx, rbx
  0019d	e8 00 00 00 00	 call	 Px_DecRef
$LN3@pattern_de:

; 1876 :     PyObject_DEL(self);

  001a2	48 8b cf	 mov	 rcx, rdi

; 1877 : }

  001a5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001aa	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001ae	5f		 pop	 rdi
  001af	e9 00 00 00 00	 jmp	 PyObject_Free
pattern_dealloc ENDP
_TEXT	ENDS
EXTRN	PyObject_CallObject:PROC
EXTRN	PyObject_GetAttrString:PROC
EXTRN	PyImport_Import:PROC
EXTRN	PyUnicode_FromString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$call DD	imagerel call
	DD	imagerel call+34
	DD	imagerel $unwind$call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$call DD imagerel call+34
	DD	imagerel call+68
	DD	imagerel $chain$0$call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$call DD imagerel call+68
	DD	imagerel call+182
	DD	imagerel $chain$3$call
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$call DD 040821H
	DD	077408H
	DD	063400H
	DD	imagerel call
	DD	imagerel call+34
	DD	imagerel $unwind$call
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$call DD 020521H
	DD	063405H
	DD	imagerel call
	DD	imagerel call+34
	DD	imagerel $unwind$call
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$call DD	040a01H
	DD	08540aH
	DD	06006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT call
_TEXT	SEGMENT
module$ = 48
function$ = 56
args$ = 64
call	PROC						; COMDAT

; 1954 : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b f0	 mov	 rsi, r8
  0000d	48 8b ea	 mov	 rbp, rdx

; 1955 :     PyObject* name;
; 1956 :     PyObject* mod;
; 1957 :     PyObject* func;
; 1958 :     PyObject* result;
; 1959 : 
; 1960 :     if (!args)

  00010	4d 85 c0	 test	 r8, r8
  00013	75 0d		 jne	 SHORT $LN4@call

; 1961 :         return NULL;

  00015	33 c0		 xor	 eax, eax

; 1977 : }

  00017	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5e		 pop	 rsi
  00021	c3		 ret	 0
$LN4@call:
  00022	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 1962 :     name = PyUnicode_FromString(module);

  00027	e8 00 00 00 00	 call	 PyUnicode_FromString
  0002c	48 8b d8	 mov	 rbx, rax

; 1963 :     if (!name)

  0002f	48 85 c0	 test	 rax, rax
  00032	75 10		 jne	 SHORT $LN3@call
  00034	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1977 : }

  00039	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0003e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00042	5e		 pop	 rsi
  00043	c3		 ret	 0
$LN3@call:

; 1964 :         return NULL;
; 1965 :     mod = PyImport_Import(name);

  00044	48 8b c8	 mov	 rcx, rax
  00047	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0004c	e8 00 00 00 00	 call	 PyImport_Import

; 1966 :     Py_DECREF(name);

  00051	48 8b cb	 mov	 rcx, rbx
  00054	48 8b f8	 mov	 rdi, rax
  00057	e8 00 00 00 00	 call	 _Py_DecRef

; 1967 :     if (!mod)

  0005c	48 85 ff	 test	 rdi, rdi

; 1968 :         return NULL;

  0005f	74 1b		 je	 SHORT $LN9@call

; 1969 :     func = PyObject_GetAttrString(mod, function);

  00061	48 8b d5	 mov	 rdx, rbp
  00064	48 8b cf	 mov	 rcx, rdi
  00067	e8 00 00 00 00	 call	 PyObject_GetAttrString

; 1970 :     Py_DECREF(mod);

  0006c	48 8b cf	 mov	 rcx, rdi
  0006f	48 8b e8	 mov	 rbp, rax
  00072	e8 00 00 00 00	 call	 _Py_DecRef

; 1971 :     if (!func)

  00077	48 85 ed	 test	 rbp, rbp
  0007a	75 04		 jne	 SHORT $LN1@call
$LN9@call:

; 1972 :         return NULL;

  0007c	33 c0		 xor	 eax, eax
  0007e	eb 21		 jmp	 SHORT $LN8@call
$LN1@call:

; 1973 :     result = PyObject_CallObject(func, args);

  00080	48 8b d6	 mov	 rdx, rsi
  00083	48 8b cd	 mov	 rcx, rbp
  00086	e8 00 00 00 00	 call	 PyObject_CallObject

; 1974 :     Py_DECREF(func);

  0008b	48 8b cd	 mov	 rcx, rbp
  0008e	48 8b d8	 mov	 rbx, rax
  00091	e8 00 00 00 00	 call	 _Py_DecRef

; 1975 :     Py_DECREF(args);

  00096	48 8b ce	 mov	 rcx, rsi
  00099	e8 00 00 00 00	 call	 _Py_DecRef

; 1976 :     return result;

  0009e	48 8b c3	 mov	 rax, rbx
$LN8@call:

; 1977 : }

  000a1	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  000a6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ab	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000b0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b4	5e		 pop	 rsi
  000b5	c3		 ret	 0
call	ENDP
_TEXT	ENDS
PUBLIC	??_C@_04DFGCDGNN@join?$AA@			; `string'
EXTRN	PyTuple_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$join_list DD imagerel join_list
	DD	imagerel join_list+87
	DD	imagerel $unwind$join_list
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$join_list DD imagerel join_list+87
	DD	imagerel join_list+131
	DD	imagerel $chain$0$join_list
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$join_list DD imagerel join_list+131
	DD	imagerel join_list+237
	DD	imagerel $chain$3$join_list
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$join_list DD 040a21H
	DD	06540aH
	DD	076400H
	DD	imagerel join_list
	DD	imagerel join_list+87
	DD	imagerel $unwind$join_list
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$join_list DD 020521H
	DD	076405H
	DD	imagerel join_list
	DD	imagerel join_list+87
	DD	imagerel $unwind$join_list
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$join_list DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_04DFGCDGNN@join?$AA@
CONST	SEGMENT
??_C@_04DFGCDGNN@join?$AA@ DB 'join', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT join_list
_TEXT	SEGMENT
list$ = 48
string$ = 56
join_list PROC						; COMDAT

; 2001 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b c2	 mov	 rax, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 2002 :     /* join list elements */
; 2003 : 
; 2004 :     PyObject* joiner;
; 2005 : #if PY_VERSION_HEX >= 0x01060000
; 2006 :     PyObject* function;
; 2007 :     PyObject* args;
; 2008 : #endif
; 2009 :     PyObject* result;
; 2010 : 
; 2011 :     joiner = PySequence_GetSlice(string, 0, 0);

  00010	45 33 c0	 xor	 r8d, r8d
  00013	48 8b c8	 mov	 rcx, rax
  00016	33 d2		 xor	 edx, edx
  00018	e8 00 00 00 00	 call	 PySequence_GetSlice
  0001d	48 8b f8	 mov	 rdi, rax

; 2012 :     if (!joiner)

  00020	48 85 c0	 test	 rax, rax
  00023	75 0b		 jne	 SHORT $LN4@join_list

; 2045 : }

  00025	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5f		 pop	 rdi
  0002f	c3		 ret	 0
$LN4@join_list:

; 2013 :         return NULL;
; 2014 : 
; 2015 :     if (PyList_GET_SIZE(list) == 0) {

  00030	48 83 7b 60 00	 cmp	 QWORD PTR [rbx+96], 0
  00035	75 16		 jne	 SHORT $LN3@join_list

; 2016 :         Py_DECREF(list);

  00037	48 8b cb	 mov	 rcx, rbx
  0003a	e8 00 00 00 00	 call	 _Py_DecRef

; 2017 :         return joiner;

  0003f	48 8b c7	 mov	 rax, rdi

; 2045 : }

  00042	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5f		 pop	 rdi
  0004c	c3		 ret	 0
$LN3@join_list:

; 2018 :     }
; 2019 : 
; 2020 : #if PY_VERSION_HEX >= 0x01060000
; 2021 :     function = PyObject_GetAttrString(joiner, "join");

  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04DFGCDGNN@join?$AA@
  00054	48 8b c8	 mov	 rcx, rax
  00057	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  0005c	e8 00 00 00 00	 call	 PyObject_GetAttrString
  00061	48 8b f0	 mov	 rsi, rax

; 2022 :     if (!function) {

  00064	48 85 c0	 test	 rax, rax
  00067	75 1a		 jne	 SHORT $LN2@join_list

; 2023 :         Py_DECREF(joiner);

  00069	48 8b cf	 mov	 rcx, rdi
  0006c	e8 00 00 00 00	 call	 _Py_DecRef
  00071	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 2024 :         return NULL;

  00076	33 c0		 xor	 eax, eax

; 2045 : }

  00078	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0007d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00081	5f		 pop	 rdi
  00082	c3		 ret	 0
$LN2@join_list:

; 2025 :     }
; 2026 :     args = PyTuple_New(1);

  00083	b9 01 00 00 00	 mov	 ecx, 1
  00088	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0008d	e8 00 00 00 00	 call	 PyTuple_New

; 2027 :     if (!args) {
; 2028 :         Py_DECREF(function);

  00092	48 8b ce	 mov	 rcx, rsi
  00095	48 8b e8	 mov	 rbp, rax
  00098	48 85 c0	 test	 rax, rax
  0009b	75 11		 jne	 SHORT $LN1@join_list
  0009d	e8 00 00 00 00	 call	 _Py_DecRef

; 2029 :         Py_DECREF(joiner);

  000a2	48 8b cf	 mov	 rcx, rdi
  000a5	e8 00 00 00 00	 call	 _Py_DecRef

; 2030 :         return NULL;

  000aa	33 c0		 xor	 eax, eax
  000ac	eb 2a		 jmp	 SHORT $LN8@join_list
$LN1@join_list:

; 2031 :     }
; 2032 :     PyTuple_SET_ITEM(args, 0, list);
; 2033 :     result = PyObject_CallObject(function, args);

  000ae	48 8b d0	 mov	 rdx, rax
  000b1	48 89 58 70	 mov	 QWORD PTR [rax+112], rbx
  000b5	e8 00 00 00 00	 call	 PyObject_CallObject

; 2034 :     Py_DECREF(args); /* also removes list */

  000ba	48 8b cd	 mov	 rcx, rbp
  000bd	48 8b d8	 mov	 rbx, rax
  000c0	e8 00 00 00 00	 call	 _Py_DecRef

; 2035 :     Py_DECREF(function);

  000c5	48 8b ce	 mov	 rcx, rsi
  000c8	e8 00 00 00 00	 call	 _Py_DecRef

; 2036 : #else
; 2037 :     result = call(
; 2038 :         "string", "join",
; 2039 :         PyTuple_Pack(2, list, joiner)
; 2040 :         );
; 2041 : #endif
; 2042 :     Py_DECREF(joiner);

  000cd	48 8b cf	 mov	 rcx, rdi
  000d0	e8 00 00 00 00	 call	 _Py_DecRef

; 2043 : 
; 2044 :     return result;

  000d5	48 8b c3	 mov	 rax, rbx
$LN8@join_list:

; 2045 : }

  000d8	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  000dd	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000e2	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000eb	5f		 pop	 rdi
  000ec	c3		 ret	 0
join_list ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@GAFMGLAD@O?$HMnn?3findall?$AA@		; `string'
EXTRN	PyList_Append:PROC
EXTRN	PyErr_Occurred:PROC
EXTRN	PyList_New:PROC
EXTRN	_PyArg_ParseTupleAndKeywords_SizeT:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$pattern_findall DD imagerel pattern_findall
	DD	imagerel pattern_findall+175
	DD	imagerel $unwind$pattern_findall
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$pattern_findall DD imagerel pattern_findall+175
	DD	imagerel pattern_findall+227
	DD	imagerel $chain$0$pattern_findall
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$pattern_findall DD imagerel pattern_findall+227
	DD	imagerel pattern_findall+907
	DD	imagerel $chain$7$pattern_findall
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$pattern_findall DD imagerel pattern_findall+907
	DD	imagerel pattern_findall+948
	DD	imagerel $chain$9$pattern_findall
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$pattern_findall DD 0c0021H
	DD	0ecf400H
	DD	0edd400H
	DD	0eec400H
	DD	0f47400H
	DD	0f36400H
	DD	0f23400H
	DD	imagerel pattern_findall
	DD	imagerel pattern_findall+175
	DD	imagerel $unwind$pattern_findall
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$pattern_findall DD 0c2d21H
	DD	0edd42dH
	DD	0eec425H
	DD	0f4741dH
	DD	0f36415H
	DD	0f2340dH
	DD	0ecf400H
	DD	imagerel pattern_findall
	DD	imagerel pattern_findall+175
	DD	imagerel $unwind$pattern_findall
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$pattern_findall DD 020821H
	DD	0ecf408H
	DD	imagerel pattern_findall
	DD	imagerel pattern_findall+175
	DD	imagerel $unwind$pattern_findall
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_findall DD 041301H
	DD	0ef0113H
	DD	05002e004H
xdata	ENDS
;	COMDAT ??_C@_0N@GAFMGLAD@O?$HMnn?3findall?$AA@
CONST	SEGMENT
??_C@_0N@GAFMGLAD@O?$HMnn?3findall?$AA@ DB 'O|nn:findall', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_sre.c
CONST	ENDS
;	COMDAT pattern_findall
_TEXT	SEGMENT
start$ = 64
end$ = 72
state$ = 80
self$ = 1936
args$ = 1944
kw$ = 1952
string$ = 1960
pattern_findall PROC					; COMDAT

; 2049 : {

  00000	40 55		 push	 rbp
  00002	41 56		 push	 r14
  00004	48 8d ac 24 88
	f9 ff ff	 lea	 rbp, QWORD PTR [rsp-1656]
  0000c	48 81 ec 78 07
	00 00		 sub	 rsp, 1912		; 00000778H
  00013	4c 8b f1	 mov	 r14, rcx
  00016	49 8b c0	 mov	 rax, r8
  00019	4c 8b d2	 mov	 r10, rdx

; 2050 :     SRE_STATE state;
; 2051 :     PyObject* list;
; 2052 :     int status;
; 2053 :     Py_ssize_t i, b, e;
; 2054 : 
; 2055 :     PyObject* string;
; 2056 :     Py_ssize_t start = 0;
; 2057 :     Py_ssize_t end = PY_SSIZE_T_MAX;

  0001c	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH

; 2058 :     static char* kwlist[] = { "source", "pos", "endpos", NULL };
; 2059 :     if (!PyArg_ParseTupleAndKeywords(args, kw, "O|nn:findall", kwlist,
; 2060 :                                      &string, &start, &end))

  00026	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??pattern_findall@@9@9
  0002d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@GAFMGLAD@O?$HMnn?3findall?$AA@
  00034	48 89 4c 24 48	 mov	 QWORD PTR end$[rsp], rcx
  00039	48 8d 4c 24 48	 lea	 rcx, QWORD PTR end$[rsp]
  0003e	48 8b d0	 mov	 rdx, rax
  00041	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00046	48 8d 4c 24 40	 lea	 rcx, QWORD PTR start$[rsp]
  0004b	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR start$[rsp], 0
  00054	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00059	48 8d 8d a8 06
	00 00		 lea	 rcx, QWORD PTR string$[rbp-256]
  00060	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00065	49 8b ca	 mov	 rcx, r10
  00068	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0006d	85 c0		 test	 eax, eax
  0006f	75 0d		 jne	 SHORT $LN25@pattern_fi
$LN72@pattern_fi:

; 2061 :         return NULL;

  00071	33 c0		 xor	 eax, eax

; 2145 : 
; 2146 : }

  00073	48 81 c4 78 07
	00 00		 add	 rsp, 1912		; 00000778H
  0007a	41 5e		 pop	 r14
  0007c	5d		 pop	 rbp
  0007d	c3		 ret	 0
$LN25@pattern_fi:

; 2062 : 
; 2063 :     string = state_init(&state, self, string, start, end);

  0007e	48 8b 44 24 48	 mov	 rax, QWORD PTR end$[rsp]
  00083	4c 8b 4c 24 40	 mov	 r9, QWORD PTR start$[rsp]
  00088	4c 8b 85 a8 06
	00 00		 mov	 r8, QWORD PTR string$[rbp-256]
  0008f	48 8d 4c 24 50	 lea	 rcx, QWORD PTR state$[rsp]
  00094	49 8b d6	 mov	 rdx, r14
  00097	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009c	e8 00 00 00 00	 call	 state_init
  000a1	48 89 85 a8 06
	00 00		 mov	 QWORD PTR string$[rbp-256], rax

; 2064 :     if (!string)

  000a8	48 85 c0	 test	 rax, rax

; 2065 :         return NULL;

  000ab	74 c4		 je	 SHORT $LN72@pattern_fi

; 2066 : 
; 2067 :     list = PyList_New(0);

  000ad	33 c9		 xor	 ecx, ecx
  000af	4c 89 bc 24 60
	07 00 00	 mov	 QWORD PTR [rsp+1888], r15
  000b7	e8 00 00 00 00	 call	 PyList_New
  000bc	4c 8b f8	 mov	 r15, rax

; 2068 :     if (!list) {

  000bf	48 85 c0	 test	 rax, rax
  000c2	75 1f		 jne	 SHORT $LN52@pattern_fi

; 2069 :         state_fini(&state);

  000c4	48 8d 4c 24 50	 lea	 rcx, QWORD PTR state$[rsp]
  000c9	e8 00 00 00 00	 call	 state_fini
  000ce	4c 8b bc 24 60
	07 00 00	 mov	 r15, QWORD PTR [rsp+1888]

; 2070 :         return NULL;

  000d6	33 c0		 xor	 eax, eax

; 2145 : 
; 2146 : }

  000d8	48 81 c4 78 07
	00 00		 add	 rsp, 1912		; 00000778H
  000df	41 5e		 pop	 r14
  000e1	5d		 pop	 rbp
  000e2	c3		 ret	 0
$LN52@pattern_fi:

; 2071 :     }
; 2072 : 
; 2073 :     while (state.start <= state.end) {

  000e3	48 8b 44 24 68	 mov	 rax, QWORD PTR state$[rsp+24]
  000e8	48 89 9c 24 90
	07 00 00	 mov	 QWORD PTR [rsp+1936], rbx
  000f0	48 89 b4 24 98
	07 00 00	 mov	 QWORD PTR [rsp+1944], rsi
  000f8	48 89 bc 24 a0
	07 00 00	 mov	 QWORD PTR [rsp+1952], rdi
  00100	4c 89 a4 24 70
	07 00 00	 mov	 QWORD PTR [rsp+1904], r12
  00108	4c 89 ac 24 68
	07 00 00	 mov	 QWORD PTR [rsp+1896], r13
  00110	48 39 44 24 60	 cmp	 QWORD PTR state$[rsp+16], rax
  00115	0f 87 28 02 00
	00		 ja	 $LN21@pattern_fi
  0011b	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct
$LL22@pattern_fi:

; 2074 : 
; 2075 :         PyObject* item;
; 2076 : 
; 2077 :         state_reset(&state);

  00122	48 8d 4c 24 50	 lea	 rcx, QWORD PTR state$[rsp]
  00127	48 c7 45 98 ff
	ff ff ff	 mov	 QWORD PTR state$[rbp-184], -1
  0012f	48 c7 45 90 ff
	ff ff ff	 mov	 QWORD PTR state$[rbp-192], -1
  00137	48 c7 85 48 06
	00 00 00 00 00
	00		 mov	 QWORD PTR state$[rbp+1528], 0
  00142	e8 00 00 00 00	 call	 data_stack_dealloc

; 2078 : 
; 2079 :         state.ptr = state.start;
; 2080 : 
; 2081 :         if (state.logical_charsize == 1) {

  00147	83 7d 88 01	 cmp	 DWORD PTR state$[rbp-200], 1
  0014b	4c 8b 5c 24 60	 mov	 r11, QWORD PTR state$[rsp+16]

; 2082 :             status = sre_search(&state, PatternObject_GetCode(self));

  00150	49 8d 96 00 01
	00 00		 lea	 rdx, QWORD PTR [r14+256]
  00157	48 8d 4c 24 50	 lea	 rcx, QWORD PTR state$[rsp]
  0015c	4c 89 5c 24 50	 mov	 QWORD PTR state$[rsp], r11
  00161	75 0a		 jne	 SHORT $LN20@pattern_fi
  00163	e8 00 00 00 00	 call	 sre_search
  00168	48 8b d8	 mov	 rbx, rax

; 2083 :         } else {

  0016b	eb 07		 jmp	 SHORT $LN19@pattern_fi
$LN20@pattern_fi:

; 2084 :             status = sre_usearch(&state, PatternObject_GetCode(self));

  0016d	e8 00 00 00 00	 call	 sre_usearch
  00172	8b d8		 mov	 ebx, eax
$LN19@pattern_fi:

; 2085 :         }
; 2086 : 
; 2087 :         if (PyErr_Occurred())

  00174	e8 00 00 00 00	 call	 PyErr_Occurred
  00179	48 85 c0	 test	 rax, rax
  0017c	0f 85 1c 02 00
	00		 jne	 $error$23603

; 2088 :             goto error;
; 2089 : 
; 2090 :         if (status <= 0) {

  00182	85 db		 test	 ebx, ebx
  00184	0f 8e 0b 02 00
	00		 jle	 $LN69@pattern_fi

; 2094 :             goto error;
; 2095 :         }
; 2096 : 
; 2097 :         /* don't bother to build a match object */
; 2098 :         switch (self->groups) {

  0018a	49 8b 4e 70	 mov	 rcx, QWORD PTR [r14+112]
  0018e	48 8b c1	 mov	 rax, rcx
  00191	48 85 c9	 test	 rcx, rcx
  00194	0f 84 1b 01 00
	00		 je	 $LN13@pattern_fi
  0019a	48 ff c8	 dec	 rax
  0019d	0f 84 b9 00 00
	00		 je	 $LN11@pattern_fi

; 2111 :         default:
; 2112 :             item = PyTuple_New(self->groups);

  001a3	e8 00 00 00 00	 call	 PyTuple_New
  001a8	4c 8b e8	 mov	 r13, rax

; 2113 :             if (!item)

  001ab	48 85 c0	 test	 rax, rax
  001ae	0f 84 ea 01 00
	00		 je	 $error$23603

; 2114 :                 goto error;
; 2115 :             for (i = 0; i < self->groups; i++) {

  001b4	33 f6		 xor	 esi, esi
  001b6	49 39 76 70	 cmp	 QWORD PTR [r14+112], rsi
  001ba	0f 8e 39 01 00
	00		 jle	 $LN12@pattern_fi
  001c0	33 ff		 xor	 edi, edi
  001c2	4c 8d 60 70	 lea	 r12, QWORD PTR [rax+112]
  001c6	48 8d 5d a8	 lea	 rbx, QWORD PTR state$[rbp-168]
  001ca	66 0f 1f 44 00
	00		 npad	 6
$LL7@pattern_fi:

; 2116 :                 PyObject* o = state_getslice(&state, i+1, string, 1);

  001d0	4c 8b 95 a8 06
	00 00		 mov	 r10, QWORD PTR string$[rbp-256]
  001d7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  001de	4c 3b d0	 cmp	 r10, rax
  001e1	74 38		 je	 SHORT $LN44@pattern_fi
  001e3	48 3b 7d 98	 cmp	 rdi, QWORD PTR state$[rbp-184]
  001e7	7d 32		 jge	 SHORT $LN44@pattern_fi
  001e9	48 8b 43 f8	 mov	 rax, QWORD PTR [rbx-8]
  001ed	48 85 c0	 test	 rax, rax
  001f0	74 29		 je	 SHORT $LN44@pattern_fi
  001f2	4c 8b 0b	 mov	 r9, QWORD PTR [rbx]
  001f5	4d 85 c9	 test	 r9, r9
  001f8	74 21		 je	 SHORT $LN44@pattern_fi
  001fa	48 8b 4c 24 58	 mov	 rcx, QWORD PTR state$[rsp+8]
  001ff	4c 63 45 8c	 movsxd	 r8, DWORD PTR state$[rbp-196]
  00203	48 2b c1	 sub	 rax, rcx
  00206	4c 2b c9	 sub	 r9, rcx
  00209	48 99		 cdq
  0020b	49 f7 f8	 idiv	 r8
  0020e	4c 8b d8	 mov	 r11, rax
  00211	49 8b c1	 mov	 rax, r9
  00214	48 99		 cdq
  00216	49 f7 f8	 idiv	 r8
  00219	eb 05		 jmp	 SHORT $LN42@pattern_fi
$LN44@pattern_fi:
  0021b	33 c0		 xor	 eax, eax
  0021d	45 33 db	 xor	 r11d, r11d
$LN42@pattern_fi:
  00220	4c 8b c0	 mov	 r8, rax
  00223	49 8b d3	 mov	 rdx, r11
  00226	49 8b ca	 mov	 rcx, r10
  00229	e8 00 00 00 00	 call	 PySequence_GetSlice

; 2117 :                 if (!o) {

  0022e	48 85 c0	 test	 rax, rax
  00231	0f 84 54 01 00
	00		 je	 $LN54@pattern_fi

; 2119 :                     goto error;
; 2120 :                 }
; 2121 :                 PyTuple_SET_ITEM(item, i, o);

  00237	49 89 04 24	 mov	 QWORD PTR [r12], rax
  0023b	48 ff c6	 inc	 rsi
  0023e	49 83 c4 08	 add	 r12, 8
  00242	48 83 c7 02	 add	 rdi, 2
  00246	48 83 c3 10	 add	 rbx, 16
  0024a	49 3b 76 70	 cmp	 rsi, QWORD PTR [r14+112]
  0024e	7c 80		 jl	 SHORT $LL7@pattern_fi

; 2122 :             }
; 2123 :             break;

  00250	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct
  00257	e9 9d 00 00 00	 jmp	 $LN12@pattern_fi
$LN11@pattern_fi:

; 2104 :                 goto error;
; 2105 :             break;
; 2106 :         case 1:
; 2107 :             item = state_getslice(&state, 1, string, 1);

  0025c	4c 8b 95 a8 06
	00 00		 mov	 r10, QWORD PTR string$[rbp-256]
  00263	4c 3b d7	 cmp	 r10, rdi
  00266	74 40		 je	 SHORT $LN33@pattern_fi
  00268	48 83 7d 98 00	 cmp	 QWORD PTR state$[rbp-184], 0
  0026d	7e 39		 jle	 SHORT $LN33@pattern_fi
  0026f	48 8b 45 a0	 mov	 rax, QWORD PTR state$[rbp-176]
  00273	48 85 c0	 test	 rax, rax
  00276	74 30		 je	 SHORT $LN33@pattern_fi
  00278	4c 8b 4d a8	 mov	 r9, QWORD PTR state$[rbp-168]
  0027c	4d 85 c9	 test	 r9, r9
  0027f	74 27		 je	 SHORT $LN33@pattern_fi
  00281	48 8b 4c 24 58	 mov	 rcx, QWORD PTR state$[rsp+8]
  00286	4c 63 45 8c	 movsxd	 r8, DWORD PTR state$[rbp-196]
  0028a	48 2b c1	 sub	 rax, rcx
  0028d	4c 2b c9	 sub	 r9, rcx
  00290	49 8b ca	 mov	 rcx, r10
  00293	48 99		 cdq
  00295	49 f7 f8	 idiv	 r8
  00298	4c 8b d8	 mov	 r11, rax
  0029b	49 8b c1	 mov	 rax, r9
  0029e	48 99		 cdq
  002a0	49 f7 f8	 idiv	 r8
  002a3	49 8b d3	 mov	 rdx, r11

; 2108 :             if (!item)
; 2109 :                 goto error;
; 2110 :             break;

  002a6	eb 3d		 jmp	 SHORT $LN71@pattern_fi

; 2104 :                 goto error;
; 2105 :             break;
; 2106 :         case 1:
; 2107 :             item = state_getslice(&state, 1, string, 1);

$LN33@pattern_fi:
  002a8	33 c0		 xor	 eax, eax
  002aa	45 33 db	 xor	 r11d, r11d
  002ad	49 8b ca	 mov	 rcx, r10
  002b0	41 8b d3	 mov	 edx, r11d

; 2108 :             if (!item)
; 2109 :                 goto error;
; 2110 :             break;

  002b3	eb 30		 jmp	 SHORT $LN71@pattern_fi
$LN13@pattern_fi:

; 2099 :         case 0:
; 2100 :             b = STATE_OFFSET(&state, state.start);

  002b5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR state$[rsp+8]
  002ba	4c 63 45 8c	 movsxd	 r8, DWORD PTR state$[rbp-196]
  002be	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp+16]
  002c3	48 2b c1	 sub	 rax, rcx
  002c6	48 99		 cdq
  002c8	49 f7 f8	 idiv	 r8
  002cb	4c 8b c8	 mov	 r9, rax

; 2101 :             e = STATE_OFFSET(&state, state.ptr);

  002ce	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  002d3	48 2b c1	 sub	 rax, rcx

; 2102 :             item = PySequence_GetSlice(string, b, e);

  002d6	48 8b 8d a8 06
	00 00		 mov	 rcx, QWORD PTR string$[rbp-256]
  002dd	48 99		 cdq
  002df	49 f7 f8	 idiv	 r8
  002e2	49 8b d1	 mov	 rdx, r9
$LN71@pattern_fi:
  002e5	4c 8b c0	 mov	 r8, rax
  002e8	e8 00 00 00 00	 call	 PySequence_GetSlice
  002ed	4c 8b e8	 mov	 r13, rax

; 2103 :             if (!item)

  002f0	48 85 c0	 test	 rax, rax
  002f3	0f 84 a5 00 00
	00		 je	 $error$23603
$LN12@pattern_fi:

; 2124 :         }
; 2125 : 
; 2126 :         status = PyList_Append(list, item);

  002f9	49 8b d5	 mov	 rdx, r13
  002fc	49 8b cf	 mov	 rcx, r15
  002ff	e8 00 00 00 00	 call	 PyList_Append

; 2127 :         Py_DECREF(item);

  00304	49 8b cd	 mov	 rcx, r13
  00307	8b d8		 mov	 ebx, eax
  00309	e8 00 00 00 00	 call	 _Py_DecRef

; 2128 :         if (status < 0)

  0030e	85 db		 test	 ebx, ebx
  00310	0f 88 88 00 00
	00		 js	 $error$23603

; 2129 :             goto error;
; 2130 : 
; 2131 :         if (state.ptr == state.start)

  00316	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  0031b	48 3b 4c 24 60	 cmp	 rcx, QWORD PTR state$[rsp+16]
  00320	75 0e		 jne	 SHORT $LN2@pattern_fi

; 2132 :             state.start = (void*) ((char*) state.ptr + state.charsize);

  00322	48 63 45 8c	 movsxd	 rax, DWORD PTR state$[rbp-196]
  00326	48 03 c1	 add	 rax, rcx
  00329	48 89 44 24 60	 mov	 QWORD PTR state$[rsp+16], rax

; 2133 :         else

  0032e	eb 08		 jmp	 SHORT $LN1@pattern_fi
$LN2@pattern_fi:

; 2134 :             state.start = state.ptr;

  00330	48 8b c1	 mov	 rax, rcx
  00333	48 89 4c 24 60	 mov	 QWORD PTR state$[rsp+16], rcx
$LN1@pattern_fi:

; 2071 :     }
; 2072 : 
; 2073 :     while (state.start <= state.end) {

  00338	48 3b 44 24 68	 cmp	 rax, QWORD PTR state$[rsp+24]
  0033d	0f 86 df fd ff
	ff		 jbe	 $LL22@pattern_fi
$LN21@pattern_fi:

; 2135 : 
; 2136 :     }
; 2137 : 
; 2138 :     state_fini(&state);

  00343	48 8d 4c 24 50	 lea	 rcx, QWORD PTR state$[rsp]
  00348	e8 00 00 00 00	 call	 state_fini

; 2139 :     return list;

  0034d	49 8b c7	 mov	 rax, r15
$LN68@pattern_fi:
  00350	4c 8b ac 24 68
	07 00 00	 mov	 r13, QWORD PTR [rsp+1896]
  00358	4c 8b a4 24 70
	07 00 00	 mov	 r12, QWORD PTR [rsp+1904]
  00360	48 8b bc 24 a0
	07 00 00	 mov	 rdi, QWORD PTR [rsp+1952]
  00368	48 8b b4 24 98
	07 00 00	 mov	 rsi, QWORD PTR [rsp+1944]
  00370	48 8b 9c 24 90
	07 00 00	 mov	 rbx, QWORD PTR [rsp+1936]
  00378	4c 8b bc 24 60
	07 00 00	 mov	 r15, QWORD PTR [rsp+1888]

; 2145 : 
; 2146 : }

  00380	48 81 c4 78 07
	00 00		 add	 rsp, 1912		; 00000778H
  00387	41 5e		 pop	 r14
  00389	5d		 pop	 rbp
  0038a	c3		 ret	 0
$LN54@pattern_fi:

; 2118 :                     Py_DECREF(item);

  0038b	49 8b cd	 mov	 rcx, r13
  0038e	e8 00 00 00 00	 call	 _Py_DecRef
  00393	eb 09		 jmp	 SHORT $error$23603
$LN69@pattern_fi:

; 2091 :             if (status == 0)

  00395	74 ac		 je	 SHORT $LN21@pattern_fi

; 2092 :                 break;
; 2093 :             pattern_error(status);

  00397	8b cb		 mov	 ecx, ebx
  00399	e8 00 00 00 00	 call	 pattern_error
$error$23603:

; 2140 : 
; 2141 : error:
; 2142 :     Py_DECREF(list);

  0039e	49 8b cf	 mov	 rcx, r15
  003a1	e8 00 00 00 00	 call	 _Py_DecRef

; 2143 :     state_fini(&state);

  003a6	48 8d 4c 24 50	 lea	 rcx, QWORD PTR state$[rsp]
  003ab	e8 00 00 00 00	 call	 state_fini

; 2144 :     return NULL;

  003b0	33 c0		 xor	 eax, eax
  003b2	eb 9c		 jmp	 SHORT $LN68@pattern_fi
pattern_findall ENDP
_TEXT	ENDS
PUBLIC	??_C@_09KFOACILG@O?$HMn?3split?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$pattern_split DD imagerel pattern_split
	DD	imagerel pattern_split+156
	DD	imagerel $unwind$pattern_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$pattern_split DD imagerel pattern_split+156
	DD	imagerel pattern_split+194
	DD	imagerel $chain$0$pattern_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$pattern_split DD imagerel pattern_split+194
	DD	imagerel pattern_split+657
	DD	imagerel $chain$4$pattern_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$pattern_split DD imagerel pattern_split+657
	DD	imagerel pattern_split+678
	DD	imagerel $chain$5$pattern_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$pattern_split DD imagerel pattern_split+678
	DD	imagerel pattern_split+771
	DD	imagerel $chain$7$pattern_split
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$pattern_split DD 0a0021H
	DD	0eae400H
	DD	0ebd400H
	DD	0f27400H
	DD	0f16400H
	DD	0f03400H
	DD	imagerel pattern_split
	DD	imagerel pattern_split+156
	DD	imagerel $unwind$pattern_split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$pattern_split DD 021H
	DD	imagerel pattern_split+156
	DD	imagerel pattern_split+194
	DD	imagerel $chain$0$pattern_split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$pattern_split DD 082521H
	DD	0eae425H
	DD	0f2741dH
	DD	0f16415H
	DD	0f03408H
	DD	imagerel pattern_split+156
	DD	imagerel pattern_split+194
	DD	imagerel $chain$0$pattern_split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$pattern_split DD 020821H
	DD	0ebd408H
	DD	imagerel pattern_split
	DD	imagerel pattern_split+156
	DD	imagerel $unwind$pattern_split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_split DD 051501H
	DD	0ec0115H
	DD	0c004f006H
	DD	05002H
xdata	ENDS
;	COMDAT ??_C@_09KFOACILG@O?$HMn?3split?$AA@
CONST	SEGMENT
??_C@_09KFOACILG@O?$HMn?3split?$AA@ DB 'O|n:split', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT pattern_split
_TEXT	SEGMENT
maxsplit$ = 48
state$ = 64
self$ = 1920
args$ = 1928
kw$ = 1936
string$ = 1944
pattern_split PROC					; COMDAT

; 2174 : {

  00000	40 55		 push	 rbp
  00002	41 54		 push	 r12
  00004	41 57		 push	 r15
  00006	48 8d ac 24 a0
	f9 ff ff	 lea	 rbp, QWORD PTR [rsp-1632]
  0000e	48 81 ec 60 07
	00 00		 sub	 rsp, 1888		; 00000760H
  00015	4c 8b e1	 mov	 r12, rcx
  00018	49 8b c0	 mov	 rax, r8
  0001b	4c 8b d2	 mov	 r10, rdx

; 2175 :     SRE_STATE state;
; 2176 :     PyObject* list;
; 2177 :     PyObject* item;
; 2178 :     int status;
; 2179 :     Py_ssize_t n;
; 2180 :     Py_ssize_t i;
; 2181 :     void* last;
; 2182 : 
; 2183 :     PyObject* string;
; 2184 :     Py_ssize_t maxsplit = 0;
; 2185 :     static char* kwlist[] = { "source", "maxsplit", NULL };
; 2186 :     if (!PyArg_ParseTupleAndKeywords(args, kw, "O|n:split", kwlist,
; 2187 :                                      &string, &maxsplit))

  0001e	48 8d 4c 24 30	 lea	 rcx, QWORD PTR maxsplit$[rsp]
  00023	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??pattern_split@@9@9
  0002a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_09KFOACILG@O?$HMn?3split?$AA@
  00031	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00036	48 8d 8d 98 06
	00 00		 lea	 rcx, QWORD PTR string$[rbp-256]
  0003d	45 33 ff	 xor	 r15d, r15d
  00040	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00045	49 8b ca	 mov	 rcx, r10
  00048	48 8b d0	 mov	 rdx, rax
  0004b	4c 89 7c 24 30	 mov	 QWORD PTR maxsplit$[rsp], r15
  00050	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00055	85 c0		 test	 eax, eax
  00057	75 0f		 jne	 SHORT $LN22@pattern_sp
$LN46@pattern_sp:

; 2188 :         return NULL;

  00059	33 c0		 xor	 eax, eax

; 2280 : 
; 2281 : }

  0005b	48 81 c4 60 07
	00 00		 add	 rsp, 1888		; 00000760H
  00062	41 5f		 pop	 r15
  00064	41 5c		 pop	 r12
  00066	5d		 pop	 rbp
  00067	c3		 ret	 0
$LN22@pattern_sp:

; 2189 : 
; 2190 :     string = state_init(&state, self, string, 0, PY_SSIZE_T_MAX);

  00068	4c 8b 85 98 06
	00 00		 mov	 r8, QWORD PTR string$[rbp-256]
  0006f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00079	48 8d 4c 24 40	 lea	 rcx, QWORD PTR state$[rsp]
  0007e	45 33 c9	 xor	 r9d, r9d
  00081	49 8b d4	 mov	 rdx, r12
  00084	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00089	e8 00 00 00 00	 call	 state_init
  0008e	48 89 85 98 06
	00 00		 mov	 QWORD PTR string$[rbp-256], rax

; 2191 :     if (!string)

  00095	48 85 c0	 test	 rax, rax

; 2192 :         return NULL;

  00098	74 bf		 je	 SHORT $LN46@pattern_sp

; 2193 : 
; 2194 :     list = PyList_New(0);

  0009a	33 c9		 xor	 ecx, ecx
  0009c	4c 89 ac 24 58
	07 00 00	 mov	 QWORD PTR [rsp+1880], r13
  000a4	e8 00 00 00 00	 call	 PyList_New
  000a9	4c 8b e8	 mov	 r13, rax

; 2195 :     if (!list) {

  000ac	48 85 c0	 test	 rax, rax
  000af	75 11		 jne	 SHORT $LN20@pattern_sp

; 2196 :         state_fini(&state);

  000b1	48 8d 4c 24 40	 lea	 rcx, QWORD PTR state$[rsp]
  000b6	e8 00 00 00 00	 call	 state_fini

; 2197 :         return NULL;

  000bb	33 c0		 xor	 eax, eax
  000bd	e9 cf 01 00 00	 jmp	 $LN40@pattern_sp
$LN20@pattern_sp:
  000c2	48 89 9c 24 80
	07 00 00	 mov	 QWORD PTR [rsp+1920], rbx

; 2198 :     }
; 2199 : 
; 2200 :     n = 0;
; 2201 :     last = state.start;

  000ca	48 8b 5c 24 50	 mov	 rbx, QWORD PTR state$[rsp+16]
  000cf	48 89 b4 24 88
	07 00 00	 mov	 QWORD PTR [rsp+1928], rsi
  000d7	48 89 bc 24 90
	07 00 00	 mov	 QWORD PTR [rsp+1936], rdi
  000df	4c 89 b4 24 50
	07 00 00	 mov	 QWORD PTR [rsp+1872], r14
  000e7	4d 8b f7	 mov	 r14, r15
  000ea	66 0f 1f 44 00
	00		 npad	 6
$LL19@pattern_sp:

; 2202 : 
; 2203 :     while (!maxsplit || n < maxsplit) {

  000f0	48 8b 44 24 30	 mov	 rax, QWORD PTR maxsplit$[rsp]
  000f5	48 85 c0	 test	 rax, rax
  000f8	74 09		 je	 SHORT $LN17@pattern_sp
  000fa	4c 3b f0	 cmp	 r14, rax
  000fd	0f 8d a3 01 00
	00		 jge	 $LN39@pattern_sp
$LN17@pattern_sp:

; 2204 : 
; 2205 :         state_reset(&state);

  00103	48 8d 4c 24 40	 lea	 rcx, QWORD PTR state$[rsp]
  00108	48 c7 45 88 ff
	ff ff ff	 mov	 QWORD PTR state$[rbp-184], -1
  00110	48 c7 45 80 ff
	ff ff ff	 mov	 QWORD PTR state$[rbp-192], -1
  00118	4c 89 bd 38 06
	00 00		 mov	 QWORD PTR state$[rbp+1528], r15
  0011f	e8 00 00 00 00	 call	 data_stack_dealloc

; 2206 : 
; 2207 :         state.ptr = state.start;
; 2208 : 
; 2209 :         if (state.logical_charsize == 1) {

  00124	83 7c 24 78 01	 cmp	 DWORD PTR state$[rsp+56], 1
  00129	4c 8b 5c 24 50	 mov	 r11, QWORD PTR state$[rsp+16]

; 2210 :             status = sre_search(&state, PatternObject_GetCode(self));

  0012e	49 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR [r12+256]
  00136	48 8d 4c 24 40	 lea	 rcx, QWORD PTR state$[rsp]
  0013b	4c 89 5c 24 40	 mov	 QWORD PTR state$[rsp], r11
  00140	75 0a		 jne	 SHORT $LN16@pattern_sp
  00142	e8 00 00 00 00	 call	 sre_search
  00147	48 8b f8	 mov	 rdi, rax

; 2211 :         } else {

  0014a	eb 07		 jmp	 SHORT $LN15@pattern_sp
$LN16@pattern_sp:

; 2212 :             status = sre_usearch(&state, PatternObject_GetCode(self));

  0014c	e8 00 00 00 00	 call	 sre_usearch
  00151	8b f8		 mov	 edi, eax
$LN15@pattern_sp:

; 2213 :         }
; 2214 : 
; 2215 :         if (PyErr_Occurred())

  00153	e8 00 00 00 00	 call	 PyErr_Occurred
  00158	48 85 c0	 test	 rax, rax
  0015b	0f 85 fc 00 00
	00		 jne	 $error$23692

; 2216 :             goto error;
; 2217 : 
; 2218 :         if (status <= 0) {

  00161	85 ff		 test	 edi, edi
  00163	0f 8e eb 00 00
	00		 jle	 $LN45@pattern_sp

; 2222 :             goto error;
; 2223 :         }
; 2224 : 
; 2225 :         if (state.start == state.ptr) {

  00169	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp+16]
  0016e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  00173	48 3b c1	 cmp	 rax, rcx
  00176	75 1d		 jne	 SHORT $LN11@pattern_sp

; 2226 :             if (last == state.end)

  00178	48 3b 5c 24 58	 cmp	 rbx, QWORD PTR state$[rsp+24]
  0017d	0f 84 23 01 00
	00		 je	 $LN39@pattern_sp

; 2227 :                 break;
; 2228 :             /* skip one character */
; 2229 :             state.start = (void*) ((char*) state.ptr + state.charsize);

  00183	48 63 44 24 7c	 movsxd	 rax, DWORD PTR state$[rsp+60]
  00188	48 03 c1	 add	 rax, rcx
  0018b	48 89 44 24 50	 mov	 QWORD PTR state$[rsp+16], rax

; 2230 :             continue;

  00190	e9 5b ff ff ff	 jmp	 $LL19@pattern_sp
$LN11@pattern_sp:

; 2231 :         }
; 2232 : 
; 2233 :         /* get segment before this match */
; 2234 :         item = PySequence_GetSlice(
; 2235 :             string, STATE_OFFSET(&state, last),
; 2236 :             STATE_OFFSET(&state, state.start)
; 2237 :             );

  00195	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp+8]
  0019a	4c 63 4c 24 7c	 movsxd	 r9, DWORD PTR state$[rsp+60]
  0019f	48 2b c1	 sub	 rax, rcx
  001a2	48 2b d9	 sub	 rbx, rcx
  001a5	48 8b 8d 98 06
	00 00		 mov	 rcx, QWORD PTR string$[rbp-256]
  001ac	48 99		 cdq
  001ae	49 f7 f9	 idiv	 r9
  001b1	4c 8b c0	 mov	 r8, rax
  001b4	48 8b c3	 mov	 rax, rbx
  001b7	48 99		 cdq
  001b9	49 f7 f9	 idiv	 r9
  001bc	48 8b d0	 mov	 rdx, rax
  001bf	e8 00 00 00 00	 call	 PySequence_GetSlice
  001c4	48 8b f8	 mov	 rdi, rax

; 2238 :         if (!item)

  001c7	48 85 c0	 test	 rax, rax
  001ca	0f 84 8d 00 00
	00		 je	 $error$23692

; 2239 :             goto error;
; 2240 :         status = PyList_Append(list, item);

  001d0	48 8b d0	 mov	 rdx, rax
  001d3	49 8b cd	 mov	 rcx, r13
  001d6	e8 00 00 00 00	 call	 PyList_Append

; 2241 :         Py_DECREF(item);

  001db	48 8b cf	 mov	 rcx, rdi
  001de	8b d8		 mov	 ebx, eax
  001e0	e8 00 00 00 00	 call	 _Py_DecRef

; 2242 :         if (status < 0)

  001e5	85 db		 test	 ebx, ebx
  001e7	78 74		 js	 SHORT $error$23692

; 2243 :             goto error;
; 2244 : 
; 2245 :         /* add groups (if any) */
; 2246 :         for (i = 0; i < self->groups; i++) {

  001e9	49 8b ff	 mov	 rdi, r15
  001ec	4d 39 7c 24 70	 cmp	 QWORD PTR [r12+112], r15
  001f1	7e 4f		 jle	 SHORT $LN5@pattern_sp
  001f3	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL7@pattern_sp:

; 2247 :             item = state_getslice(&state, i+1, string, 0);

  00200	4c 8b 85 98 06
	00 00		 mov	 r8, QWORD PTR string$[rbp-256]
  00207	48 ff c7	 inc	 rdi
  0020a	48 8d 4c 24 40	 lea	 rcx, QWORD PTR state$[rsp]
  0020f	48 8b d7	 mov	 rdx, rdi
  00212	45 33 c9	 xor	 r9d, r9d
  00215	e8 00 00 00 00	 call	 state_getslice
  0021a	48 8b f0	 mov	 rsi, rax

; 2248 :             if (!item)

  0021d	48 85 c0	 test	 rax, rax
  00220	74 3b		 je	 SHORT $error$23692

; 2249 :                 goto error;
; 2250 :             status = PyList_Append(list, item);

  00222	48 8b d0	 mov	 rdx, rax
  00225	49 8b cd	 mov	 rcx, r13
  00228	e8 00 00 00 00	 call	 PyList_Append

; 2251 :             Py_DECREF(item);

  0022d	48 8b ce	 mov	 rcx, rsi
  00230	8b d8		 mov	 ebx, eax
  00232	e8 00 00 00 00	 call	 _Py_DecRef

; 2252 :             if (status < 0)

  00237	85 db		 test	 ebx, ebx
  00239	78 22		 js	 SHORT $error$23692

; 2243 :             goto error;
; 2244 : 
; 2245 :         /* add groups (if any) */
; 2246 :         for (i = 0; i < self->groups; i++) {

  0023b	49 3b 7c 24 70	 cmp	 rdi, QWORD PTR [r12+112]
  00240	7c be		 jl	 SHORT $LL7@pattern_sp
$LN5@pattern_sp:

; 2253 :                 goto error;
; 2254 :         }
; 2255 : 
; 2256 :         n = n + 1;
; 2257 : 
; 2258 :         last = state.start = state.ptr;

  00242	48 8b 5c 24 40	 mov	 rbx, QWORD PTR state$[rsp]
  00247	49 ff c6	 inc	 r14
  0024a	48 89 5c 24 50	 mov	 QWORD PTR state$[rsp+16], rbx

; 2259 : 
; 2260 :     }

  0024f	e9 9c fe ff ff	 jmp	 $LL19@pattern_sp
$LN45@pattern_sp:

; 2219 :             if (status == 0)

  00254	74 50		 je	 SHORT $LN39@pattern_sp

; 2220 :                 break;
; 2221 :             pattern_error(status);

  00256	8b cf		 mov	 ecx, edi
  00258	e8 00 00 00 00	 call	 pattern_error
$error$23692:

; 2275 : 
; 2276 : error:
; 2277 :     Py_DECREF(list);

  0025d	49 8b cd	 mov	 rcx, r13
  00260	e8 00 00 00 00	 call	 _Py_DecRef

; 2278 :     state_fini(&state);

  00265	48 8d 4c 24 40	 lea	 rcx, QWORD PTR state$[rsp]
  0026a	e8 00 00 00 00	 call	 state_fini

; 2279 :     return NULL;

  0026f	33 c0		 xor	 eax, eax
$LN44@pattern_sp:
  00271	48 8b 9c 24 80
	07 00 00	 mov	 rbx, QWORD PTR [rsp+1920]
  00279	48 8b bc 24 90
	07 00 00	 mov	 rdi, QWORD PTR [rsp+1936]
  00281	48 8b b4 24 88
	07 00 00	 mov	 rsi, QWORD PTR [rsp+1928]
  00289	4c 8b b4 24 50
	07 00 00	 mov	 r14, QWORD PTR [rsp+1872]
$LN40@pattern_sp:
  00291	4c 8b ac 24 58
	07 00 00	 mov	 r13, QWORD PTR [rsp+1880]

; 2280 : 
; 2281 : }

  00299	48 81 c4 60 07
	00 00		 add	 rsp, 1888		; 00000760H
  002a0	41 5f		 pop	 r15
  002a2	41 5c		 pop	 r12
  002a4	5d		 pop	 rbp
  002a5	c3		 ret	 0
$LN39@pattern_sp:

; 2261 : 
; 2262 :     /* get segment following last match (even if empty) */
; 2263 :     item = PySequence_GetSlice(
; 2264 :         string, STATE_OFFSET(&state, last), state.endpos
; 2265 :         );

  002a6	48 63 4c 24 7c	 movsxd	 rcx, DWORD PTR state$[rsp+60]
  002ab	48 2b 5c 24 48	 sub	 rbx, QWORD PTR state$[rsp+8]
  002b0	4c 8b 44 24 70	 mov	 r8, QWORD PTR state$[rsp+48]
  002b5	48 8b c3	 mov	 rax, rbx
  002b8	48 99		 cdq
  002ba	48 f7 f9	 idiv	 rcx
  002bd	48 8b 8d 98 06
	00 00		 mov	 rcx, QWORD PTR string$[rbp-256]
  002c4	48 8b d0	 mov	 rdx, rax
  002c7	e8 00 00 00 00	 call	 PySequence_GetSlice
  002cc	48 8b f8	 mov	 rdi, rax

; 2266 :     if (!item)

  002cf	48 85 c0	 test	 rax, rax
  002d2	74 89		 je	 SHORT $error$23692

; 2267 :         goto error;
; 2268 :     status = PyList_Append(list, item);

  002d4	48 8b d0	 mov	 rdx, rax
  002d7	49 8b cd	 mov	 rcx, r13
  002da	e8 00 00 00 00	 call	 PyList_Append

; 2269 :     Py_DECREF(item);

  002df	48 8b cf	 mov	 rcx, rdi
  002e2	8b d8		 mov	 ebx, eax
  002e4	e8 00 00 00 00	 call	 _Py_DecRef

; 2270 :     if (status < 0)

  002e9	85 db		 test	 ebx, ebx
  002eb	0f 88 6c ff ff
	ff		 js	 $error$23692

; 2271 :         goto error;
; 2272 : 
; 2273 :     state_fini(&state);

  002f1	48 8d 4c 24 40	 lea	 rcx, QWORD PTR state$[rsp]
  002f6	e8 00 00 00 00	 call	 state_fini

; 2274 :     return list;

  002fb	49 8b c5	 mov	 rax, r13
  002fe	e9 6e ff ff ff	 jmp	 $LN44@pattern_sp
pattern_split ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@FCKMIBIP@cannot?5copy?5this?5pattern?5object?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$pattern_copy DD imagerel pattern_copy
	DD	imagerel pattern_copy+30
	DD	imagerel $unwind$pattern_copy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_copy DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CA@FCKMIBIP@cannot?5copy?5this?5pattern?5object?$AA@
CONST	SEGMENT
??_C@_0CA@FCKMIBIP@cannot?5copy?5this?5pattern?5object?$AA@ DB 'cannot co'
	DB	'py this pattern object', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT pattern_copy
_TEXT	SEGMENT
self$ = 48
unused$ = 56
pattern_copy PROC					; COMDAT

; 2495 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2496 : #ifdef USE_BUILTIN_COPY
; 2497 :     PatternObject* copy;
; 2498 :     int offset;
; 2499 : 
; 2500 :     copy = PyObject_NEW_VAR(PatternObject, &Pattern_Type, self->codesize);
; 2501 :     if (!copy)
; 2502 :         return NULL;
; 2503 : 
; 2504 :     offset = offsetof(PatternObject, groups);
; 2505 : 
; 2506 :     Py_XINCREF(self->groupindex);
; 2507 :     Py_XINCREF(self->indexgroup);
; 2508 :     Py_XINCREF(self->pattern);
; 2509 : 
; 2510 :     memcpy((char*) copy + offset, (char*) self + offset,
; 2511 :            sizeof(PatternObject) + self->codesize * sizeof(SRE_CODE) - offset);
; 2512 :     copy->weakreflist = NULL;
; 2513 : 
; 2514 :     return (PyObject*) copy;
; 2515 : #else
; 2516 :     PyErr_SetString(PyExc_TypeError, "cannot copy this pattern object");

  00004	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0000b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@FCKMIBIP@cannot?5copy?5this?5pattern?5object?$AA@
  00012	e8 00 00 00 00	 call	 PyErr_SetString

; 2517 :     return NULL;

  00017	33 c0		 xor	 eax, eax

; 2518 : #endif
; 2519 : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
pattern_copy ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@JJCFKNNG@cannot?5deepcopy?5this?5pattern?5obj@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$pattern_deepcopy DD imagerel pattern_deepcopy
	DD	imagerel pattern_deepcopy+30
	DD	imagerel $unwind$pattern_deepcopy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_deepcopy DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CE@JJCFKNNG@cannot?5deepcopy?5this?5pattern?5obj@
CONST	SEGMENT
??_C@_0CE@JJCFKNNG@cannot?5deepcopy?5this?5pattern?5obj@ DB 'cannot deepc'
	DB	'opy this pattern object', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT pattern_deepcopy
_TEXT	SEGMENT
self$ = 48
memo$ = 56
pattern_deepcopy PROC					; COMDAT

; 2523 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2524 : #ifdef USE_BUILTIN_COPY
; 2525 :     PatternObject* copy;
; 2526 : 
; 2527 :     copy = (PatternObject*) pattern_copy(self);
; 2528 :     if (!copy)
; 2529 :         return NULL;
; 2530 : 
; 2531 :     if (!deepcopy(&copy->groupindex, memo) ||
; 2532 :         !deepcopy(&copy->indexgroup, memo) ||
; 2533 :         !deepcopy(&copy->pattern, memo)) {
; 2534 :         Py_DECREF(copy);
; 2535 :         return NULL;
; 2536 :     }
; 2537 : 
; 2538 : #else
; 2539 :     PyErr_SetString(PyExc_TypeError, "cannot deepcopy this pattern object");

  00004	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0000b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@JJCFKNNG@cannot?5deepcopy?5this?5pattern?5obj@
  00012	e8 00 00 00 00	 call	 PyErr_SetString

; 2540 :     return NULL;

  00017	33 c0		 xor	 eax, eax

; 2541 : #endif
; 2542 : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
pattern_deepcopy ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _validate_charset
_TEXT	SEGMENT
code$ = 8
end$ = 16
_validate_charset PROC					; COMDAT

; 2798 : {

  00000	4c 8b ca	 mov	 r9, rdx
  00003	4c 8b c1	 mov	 r8, rcx

; 2799 :     /* Some variables are manipulated by the macros above */
; 2800 :     SRE_CODE op;
; 2801 :     SRE_CODE arg;
; 2802 :     SRE_CODE offset;
; 2803 :     int i;
; 2804 : 
; 2805 :     while (code < end) {

  00006	48 3b ca	 cmp	 rcx, rdx
  00009	0f 83 fb 00 00
	00		 jae	 $LN153@validate_c
  0000f	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:__ImageBase
$LL154@validate_c:

; 2806 :         GET_OP;

  00016	4d 3b c1	 cmp	 r8, r9
  00019	0f 83 f1 00 00
	00		 jae	 $LN200@validate_c
  0001f	41 8b 00	 mov	 eax, DWORD PTR [r8]
  00022	49 83 c0 04	 add	 r8, 4

; 2807 :         switch (op) {

  00026	83 c0 f7	 add	 eax, -9			; fffffff7H
  00029	83 f8 12	 cmp	 eax, 18
  0002c	0f 87 de 00 00
	00		 ja	 $LN200@validate_c
  00032	41 8b 8c 82 00
	00 00 00	 mov	 ecx, DWORD PTR $LN211@validate_c[r10+rax*4]
  0003a	49 03 ca	 add	 rcx, r10
  0003d	ff e1		 jmp	 rcx
  0003f	90		 npad	 1
$LL132@validate_c:

; 2808 : 
; 2809 :         case SRE_OP_NEGATE:
; 2810 :             break;
; 2811 : 
; 2812 :         case SRE_OP_LITERAL:
; 2813 :             GET_ARG;

  00040	4d 3b c1	 cmp	 r8, r9
  00043	0f 83 c7 00 00
	00		 jae	 $LN200@validate_c
  00049	49 83 c0 04	 add	 r8, 4

; 2814 :             break;

  0004d	e9 af 00 00 00	 jmp	 $LN4@validate_c
$LL115@validate_c:

; 2815 : 
; 2816 :         case SRE_OP_RANGE:
; 2817 :             GET_ARG;

  00052	4d 3b c1	 cmp	 r8, r9
  00055	0f 83 b5 00 00
	00		 jae	 $LN200@validate_c
  0005b	49 83 c0 04	 add	 r8, 4

; 2818 :             GET_ARG;

  0005f	4d 3b c1	 cmp	 r8, r9
  00062	0f 83 a8 00 00
	00		 jae	 $LN200@validate_c
  00068	49 83 c0 04	 add	 r8, 4

; 2819 :             break;

  0006c	e9 90 00 00 00	 jmp	 $LN4@validate_c
$LN83@validate_c:

; 2820 : 
; 2821 :         case SRE_OP_CHARSET:
; 2822 :             offset = 32/sizeof(SRE_CODE); /* 32-byte bitmap */
; 2823 :             if (offset > end-code)

  00071	49 8b c1	 mov	 rax, r9
  00074	49 2b c0	 sub	 rax, r8
  00077	48 83 e0 fc	 and	 rax, -4
  0007b	48 83 f8 20	 cmp	 rax, 32			; 00000020H
  0007f	0f 8c 8b 00 00
	00		 jl	 $LN200@validate_c

; 2824 :                 FAIL;
; 2825 :             code += offset;

  00085	49 83 c0 20	 add	 r8, 32			; 00000020H

; 2826 :             break;

  00089	eb 76		 jmp	 SHORT $LN4@validate_c
  0008b	0f 1f 44 00 00	 npad	 5
$LL74@validate_c:

; 2827 : 
; 2828 :         case SRE_OP_BIGCHARSET:
; 2829 :             GET_ARG; /* Number of blocks */

  00090	4d 3b c1	 cmp	 r8, r9
  00093	73 7b		 jae	 SHORT $LN200@validate_c
  00095	41 8b 10	 mov	 edx, DWORD PTR [r8]
  00098	49 83 c0 04	 add	 r8, 4

; 2830 :             offset = 256/sizeof(SRE_CODE); /* 256-byte table */
; 2831 :             if (offset > end-code)

  0009c	49 8b c1	 mov	 rax, r9
  0009f	49 2b c0	 sub	 rax, r8
  000a2	48 83 e0 fc	 and	 rax, -4
  000a6	48 3d 00 01 00
	00		 cmp	 rax, 256		; 00000100H
  000ac	7c 62		 jl	 SHORT $LN200@validate_c

; 2832 :                 FAIL;
; 2833 :             /* Make sure that each byte points to a valid block */
; 2834 :             for (i = 0; i < 256; i++) {

  000ae	33 c9		 xor	 ecx, ecx
$LL51@validate_c:

; 2835 :                 if (((unsigned char *)code)[i] >= arg)

  000b0	42 0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+r8]
  000b5	3b c2		 cmp	 eax, edx
  000b7	73 57		 jae	 SHORT $LN200@validate_c

; 2832 :                 FAIL;
; 2833 :             /* Make sure that each byte points to a valid block */
; 2834 :             for (i = 0; i < 256; i++) {

  000b9	48 ff c1	 inc	 rcx
  000bc	48 81 f9 00 01
	00 00		 cmp	 rcx, 256		; 00000100H
  000c3	7c eb		 jl	 SHORT $LL51@validate_c

; 2836 :                     FAIL;
; 2837 :             }
; 2838 :             code += offset;

  000c5	49 81 c0 00 01
	00 00		 add	 r8, 256			; 00000100H

; 2839 :             offset = arg * 32/sizeof(SRE_CODE); /* 32-byte bitmap times arg */

  000cc	c1 e2 05	 shl	 edx, 5

; 2840 :             if (offset > end-code)

  000cf	49 8b c1	 mov	 rax, r9
  000d2	c1 ea 02	 shr	 edx, 2
  000d5	49 2b c0	 sub	 rax, r8
  000d8	8b ca		 mov	 ecx, edx
  000da	48 c1 f8 02	 sar	 rax, 2
  000de	48 3b c8	 cmp	 rcx, rax
  000e1	7f 2d		 jg	 SHORT $LN200@validate_c

; 2841 :                 FAIL;
; 2842 :             code += offset;

  000e3	4d 8d 04 90	 lea	 r8, QWORD PTR [r8+rdx*4]

; 2843 :             break;

  000e7	eb 18		 jmp	 SHORT $LN4@validate_c
  000e9	0f 1f 80 00 00
	00 00		 npad	 7
$LL33@validate_c:

; 2844 : 
; 2845 :         case SRE_OP_CATEGORY:
; 2846 :             GET_ARG;

  000f0	4d 3b c1	 cmp	 r8, r9
  000f3	73 1b		 jae	 SHORT $LN200@validate_c
  000f5	41 8b 00	 mov	 eax, DWORD PTR [r8]
  000f8	49 83 c0 04	 add	 r8, 4

; 2847 :             switch (arg) {

  000fc	83 f8 11	 cmp	 eax, 17
  000ff	77 0f		 ja	 SHORT $LN200@validate_c
$LN4@validate_c:

; 2799 :     /* Some variables are manipulated by the macros above */
; 2800 :     SRE_CODE op;
; 2801 :     SRE_CODE arg;
; 2802 :     SRE_CODE offset;
; 2803 :     int i;
; 2804 : 
; 2805 :     while (code < end) {

  00101	4d 3b c1	 cmp	 r8, r9
  00104	0f 82 0c ff ff
	ff		 jb	 $LL154@validate_c
$LN153@validate_c:

; 2848 :             case SRE_CATEGORY_DIGIT:
; 2849 :             case SRE_CATEGORY_NOT_DIGIT:
; 2850 :             case SRE_CATEGORY_SPACE:
; 2851 :             case SRE_CATEGORY_NOT_SPACE:
; 2852 :             case SRE_CATEGORY_WORD:
; 2853 :             case SRE_CATEGORY_NOT_WORD:
; 2854 :             case SRE_CATEGORY_LINEBREAK:
; 2855 :             case SRE_CATEGORY_NOT_LINEBREAK:
; 2856 :             case SRE_CATEGORY_LOC_WORD:
; 2857 :             case SRE_CATEGORY_LOC_NOT_WORD:
; 2858 :             case SRE_CATEGORY_UNI_DIGIT:
; 2859 :             case SRE_CATEGORY_UNI_NOT_DIGIT:
; 2860 :             case SRE_CATEGORY_UNI_SPACE:
; 2861 :             case SRE_CATEGORY_UNI_NOT_SPACE:
; 2862 :             case SRE_CATEGORY_UNI_WORD:
; 2863 :             case SRE_CATEGORY_UNI_NOT_WORD:
; 2864 :             case SRE_CATEGORY_UNI_LINEBREAK:
; 2865 :             case SRE_CATEGORY_UNI_NOT_LINEBREAK:
; 2866 :                 break;
; 2867 :             default:
; 2868 :                 FAIL;
; 2869 :             }
; 2870 :             break;
; 2871 : 
; 2872 :         default:
; 2873 :             FAIL;
; 2874 : 
; 2875 :         }
; 2876 :     }
; 2877 : 
; 2878 :     return 1;

  0010a	b8 01 00 00 00	 mov	 eax, 1

; 2879 : }

  0010f	c3		 ret	 0
$LN200@validate_c:

; 2806 :         GET_OP;

  00110	33 c0		 xor	 eax, eax

; 2879 : }

  00112	c3		 ret	 0
  00113	90		 npad	 1
$LN211@validate_c:
  00114	00 00 00 00	 DD	 $LL33@validate_c
  00118	00 00 00 00	 DD	 $LN83@validate_c
  0011c	00 00 00 00	 DD	 $LL74@validate_c
  00120	00 00 00 00	 DD	 $LN200@validate_c
  00124	00 00 00 00	 DD	 $LN200@validate_c
  00128	00 00 00 00	 DD	 $LN200@validate_c
  0012c	00 00 00 00	 DD	 $LN200@validate_c
  00130	00 00 00 00	 DD	 $LN200@validate_c
  00134	00 00 00 00	 DD	 $LN200@validate_c
  00138	00 00 00 00	 DD	 $LN200@validate_c
  0013c	00 00 00 00	 DD	 $LL132@validate_c
  00140	00 00 00 00	 DD	 $LN200@validate_c
  00144	00 00 00 00	 DD	 $LN200@validate_c
  00148	00 00 00 00	 DD	 $LN200@validate_c
  0014c	00 00 00 00	 DD	 $LN200@validate_c
  00150	00 00 00 00	 DD	 $LN200@validate_c
  00154	00 00 00 00	 DD	 $LN200@validate_c
  00158	00 00 00 00	 DD	 $LN4@validate_c
  0015c	00 00 00 00	 DD	 $LL115@validate_c
_validate_charset ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_validate_inner DD imagerel _validate_inner
	DD	imagerel _validate_inner+39
	DD	imagerel $unwind$_validate_inner
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$_validate_inner DD imagerel _validate_inner+39
	DD	imagerel _validate_inner+1388
	DD	imagerel $chain$1$_validate_inner
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$_validate_inner DD imagerel _validate_inner+1388
	DD	imagerel _validate_inner+1472
	DD	imagerel $chain$3$_validate_inner
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$_validate_inner DD 040021H
	DD	076400H
	DD	065400H
	DD	imagerel _validate_inner
	DD	imagerel _validate_inner+39
	DD	imagerel $unwind$_validate_inner
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$_validate_inner DD 040d21H
	DD	07640dH
	DD	065405H
	DD	imagerel _validate_inner
	DD	imagerel _validate_inner+39
	DD	imagerel $unwind$_validate_inner
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_validate_inner DD 040f01H
	DD	09340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _validate_inner
_TEXT	SEGMENT
code$ = 48
end$ = 56
groups$ = 64
_validate_inner PROC					; COMDAT

; 2883 : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fa	 mov	 rdi, rdx
  00012	48 8b d9	 mov	 rbx, rcx

; 2884 :     /* Some variables are manipulated by the macros above */
; 2885 :     SRE_CODE op;
; 2886 :     SRE_CODE arg;
; 2887 :     SRE_CODE skip;
; 2888 : 
; 2889 :     VTRACE(("code=%p, end=%p\n", code, end));
; 2890 : 
; 2891 :     if (code > end)

  00015	48 3b ca	 cmp	 rcx, rdx
  00018	76 0d		 jbe	 SHORT $LN810@validate_i

; 2892 :         FAIL;

  0001a	33 c0		 xor	 eax, eax

; 3168 : }

  0001c	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5f		 pop	 rdi
  00026	c3		 ret	 0
$LN810@validate_i:
  00027	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp

; 2893 : 
; 2894 :     while (code < end) {

  0002c	48 3b ca	 cmp	 rcx, rdx
  0002f	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
$LN1134@validate_i:
  00034	0f 83 16 05 00
	00		 jae	 $LL3@validate_i
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase

; 2895 :         GET_OP;

  00041	48 3b df	 cmp	 rbx, rdi
  00044	73 38		 jae	 SHORT $LN1065@validate_i
  00046	8b 03		 mov	 eax, DWORD PTR [rbx]
  00048	48 83 c3 04	 add	 rbx, 4

; 2896 :         switch (op) {

  0004c	83 f8 1f	 cmp	 eax, 31
  0004f	77 2d		 ja	 SHORT $LN1065@validate_i
  00051	0f b6 84 02 00
	00 00 00	 movzx	 eax, BYTE PTR $LN1127@validate_i[rdx+rax]
  00059	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN1128@validate_i[rdx+rax*4]
  00060	48 03 ca	 add	 rcx, rdx
  00063	ff e1		 jmp	 rcx
$LL785@validate_i:

; 2897 : 
; 2898 :         case SRE_OP_MARK:
; 2899 :             /* We don't check whether marks are properly nested; the
; 2900 :                sre_match() code is robust even if they don't, and the worst
; 2901 :                you can get is nonsensical match results. */
; 2902 :             GET_ARG;

  00065	48 3b df	 cmp	 rbx, rdi
  00068	73 14		 jae	 SHORT $LN1065@validate_i
  0006a	8b 03		 mov	 eax, DWORD PTR [rbx]

; 2903 :             if (arg > 2*groups+1) {

  0006c	4b 8d 4c 00 01	 lea	 rcx, QWORD PTR [r8+r8+1]
  00071	48 83 c3 04	 add	 rbx, 4
  00075	48 3b c1	 cmp	 rax, rcx
  00078	0f 8e ca 04 00
	00		 jle	 $LN7@validate_i
$LN1065@validate_i:

; 2895 :         GET_OP;

  0007e	33 c0		 xor	 eax, eax
  00080	e9 d0 04 00 00	 jmp	 $LN1133@validate_i
$LL758@validate_i:

; 2904 :                 VTRACE(("arg=%d, groups=%d\n", (int)arg, (int)groups));
; 2905 :                 FAIL;
; 2906 :             }
; 2907 :             break;
; 2908 : 
; 2909 :         case SRE_OP_LITERAL:
; 2910 :         case SRE_OP_NOT_LITERAL:
; 2911 :         case SRE_OP_LITERAL_IGNORE:
; 2912 :         case SRE_OP_NOT_LITERAL_IGNORE:
; 2913 :             GET_ARG;

  00085	48 3b df	 cmp	 rbx, rdi
  00088	73 f4		 jae	 SHORT $LN1065@validate_i
  0008a	48 83 c3 04	 add	 rbx, 4
  0008e	48 3b df	 cmp	 rbx, rdi
  00091	eb a1		 jmp	 SHORT $LN1134@validate_i
$LL740@validate_i:

; 2914 :             /* The arg is just a character, nothing to check */
; 2915 :             break;
; 2916 : 
; 2917 :         case SRE_OP_SUCCESS:
; 2918 :         case SRE_OP_FAILURE:
; 2919 :             /* Nothing to check; these normally end the matching process */
; 2920 :             break;
; 2921 : 
; 2922 :         case SRE_OP_AT:
; 2923 :             GET_ARG;

  00093	48 3b df	 cmp	 rbx, rdi
  00096	73 e6		 jae	 SHORT $LN1065@validate_i
  00098	8b 03		 mov	 eax, DWORD PTR [rbx]
  0009a	48 83 c3 04	 add	 rbx, 4

; 2924 :             switch (arg) {

  0009e	83 f8 0b	 cmp	 eax, 11
  000a1	77 db		 ja	 SHORT $LN1065@validate_i

; 2893 : 
; 2894 :     while (code < end) {

  000a3	48 3b df	 cmp	 rbx, rdi
  000a6	eb 8c		 jmp	 SHORT $LN1134@validate_i
$LL712@validate_i:

; 2925 :             case SRE_AT_BEGINNING:
; 2926 :             case SRE_AT_BEGINNING_STRING:
; 2927 :             case SRE_AT_BEGINNING_LINE:
; 2928 :             case SRE_AT_END:
; 2929 :             case SRE_AT_END_LINE:
; 2930 :             case SRE_AT_END_STRING:
; 2931 :             case SRE_AT_BOUNDARY:
; 2932 :             case SRE_AT_NON_BOUNDARY:
; 2933 :             case SRE_AT_LOC_BOUNDARY:
; 2934 :             case SRE_AT_LOC_NON_BOUNDARY:
; 2935 :             case SRE_AT_UNI_BOUNDARY:
; 2936 :             case SRE_AT_UNI_NON_BOUNDARY:
; 2937 :                 break;
; 2938 :             default:
; 2939 :                 FAIL;
; 2940 :             }
; 2941 :             break;
; 2942 : 
; 2943 :         case SRE_OP_ANY:
; 2944 :         case SRE_OP_ANY_ALL:
; 2945 :             /* These have no operands */
; 2946 :             break;
; 2947 : 
; 2948 :         case SRE_OP_IN:
; 2949 :         case SRE_OP_IN_IGNORE:
; 2950 :             GET_SKIP;

  000a8	48 3b df	 cmp	 rbx, rdi
  000ab	73 d1		 jae	 SHORT $LN1065@validate_i
  000ad	44 8b 1b	 mov	 r11d, DWORD PTR [rbx]
  000b0	48 8b c7	 mov	 rax, rdi
  000b3	48 2b c3	 sub	 rax, rbx
  000b6	48 c1 f8 02	 sar	 rax, 2
  000ba	4c 3b d8	 cmp	 r11, rax
  000bd	7f bf		 jg	 SHORT $LN1065@validate_i

; 2951 :             /* Stop 1 before the end; we check the FAILURE below */
; 2952 :             if (!_validate_charset(code, code+skip-2))

  000bf	4a 8d 54 9b fc	 lea	 rdx, QWORD PTR [rbx+r11*4-4]
  000c4	48 8d 4b 04	 lea	 rcx, QWORD PTR [rbx+4]
  000c8	e8 00 00 00 00	 call	 _validate_charset
  000cd	85 c0		 test	 eax, eax
  000cf	74 ad		 je	 SHORT $LN1065@validate_i

; 2953 :                 FAIL;
; 2954 :             if (code[skip-2] != SRE_OP_FAILURE)

  000d1	41 8d 43 fe	 lea	 eax, DWORD PTR [r11-2]
  000d5	83 7c 83 04 00	 cmp	 DWORD PTR [rbx+rax*4+4], 0
  000da	75 a2		 jne	 SHORT $LN1065@validate_i

; 2955 :                 FAIL;
; 2956 :             code += skip-1;
; 2957 :             break;

  000dc	4c 8b 44 24 40	 mov	 r8, QWORD PTR groups$[rsp]
  000e1	41 8d 43 ff	 lea	 eax, DWORD PTR [r11-1]
  000e5	48 8d 5c 83 04	 lea	 rbx, QWORD PTR [rbx+rax*4+4]
  000ea	48 3b df	 cmp	 rbx, rdi
  000ed	e9 42 ff ff ff	 jmp	 $LN1134@validate_i
$LL674@validate_i:

; 2958 : 
; 2959 :         case SRE_OP_INFO:
; 2960 :             {
; 2961 :                 /* A minimal info field is
; 2962 :                    <INFO> <1=skip> <2=flags> <3=min> <4=max>;
; 2963 :                    If SRE_INFO_PREFIX or SRE_INFO_CHARSET is in the flags,
; 2964 :                    more follows. */
; 2965 :                 SRE_CODE flags, i;
; 2966 :                 SRE_CODE *newcode;
; 2967 :                 GET_SKIP;

  000f2	48 3b df	 cmp	 rbx, rdi
  000f5	73 87		 jae	 SHORT $LN1065@validate_i
  000f7	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  000f9	48 8b c7	 mov	 rax, rdi
  000fc	48 2b c3	 sub	 rax, rbx
  000ff	48 c1 f8 02	 sar	 rax, 2
  00103	48 3b c8	 cmp	 rcx, rax
  00106	0f 8f 72 ff ff
	ff		 jg	 $LN1065@validate_i
  0010c	48 83 c3 04	 add	 rbx, 4

; 2968 :                 newcode = code+skip-1;

  00110	48 8d 74 8b fc	 lea	 rsi, QWORD PTR [rbx+rcx*4-4]

; 2969 :                 GET_ARG; flags = arg;

  00115	48 3b df	 cmp	 rbx, rdi
  00118	0f 83 60 ff ff
	ff		 jae	 $LN1065@validate_i
  0011e	44 8b 03	 mov	 r8d, DWORD PTR [rbx]
  00121	48 83 c3 04	 add	 rbx, 4

; 2970 :                 GET_ARG;

  00125	48 3b df	 cmp	 rbx, rdi
  00128	0f 83 50 ff ff
	ff		 jae	 $LN1065@validate_i
  0012e	48 83 c3 04	 add	 rbx, 4

; 2971 :                 GET_ARG;

  00132	48 3b df	 cmp	 rbx, rdi
  00135	0f 83 43 ff ff
	ff		 jae	 $LN1065@validate_i
  0013b	48 83 c3 04	 add	 rbx, 4

; 2972 :                 /* Check that only valid flags are present */
; 2973 :                 if ((flags & ~(SRE_INFO_PREFIX |
; 2974 :                                SRE_INFO_LITERAL |
; 2975 :                                SRE_INFO_CHARSET)) != 0)

  0013f	41 f7 c0 f8 ff
	ff ff		 test	 r8d, -8			; fffffff8H
  00146	0f 85 32 ff ff
	ff		 jne	 $LN1065@validate_i

; 2976 :                     FAIL;
; 2977 :                 /* PREFIX and CHARSET are mutually exclusive */
; 2978 :                 if ((flags & SRE_INFO_PREFIX) &&
; 2979 :                     (flags & SRE_INFO_CHARSET))

  0014c	41 8b c0	 mov	 eax, r8d
  0014f	83 e0 01	 and	 eax, 1
  00152	74 0a		 je	 SHORT $LN593@validate_i
  00154	41 f6 c0 04	 test	 r8b, 4
  00158	0f 85 20 ff ff
	ff		 jne	 $LN1065@validate_i
$LN593@validate_i:

; 2980 :                     FAIL;
; 2981 :                 /* LITERAL implies PREFIX */
; 2982 :                 if ((flags & SRE_INFO_LITERAL) &&
; 2983 :                     !(flags & SRE_INFO_PREFIX))

  0015e	41 f6 c0 02	 test	 r8b, 2
  00162	74 08		 je	 SHORT $LN586@validate_i
  00164	85 c0		 test	 eax, eax
  00166	0f 84 12 ff ff
	ff		 je	 $LN1065@validate_i
$LN586@validate_i:

; 2984 :                     FAIL;
; 2985 :                 /* Validate the prefix */
; 2986 :                 if (flags & SRE_INFO_PREFIX) {

  0016c	85 c0		 test	 eax, eax
  0016e	74 6b		 je	 SHORT $LN582@validate_i

; 2987 :                     SRE_CODE prefix_len;
; 2988 :                     GET_ARG; prefix_len = arg;

  00170	48 3b df	 cmp	 rbx, rdi
  00173	0f 83 05 ff ff
	ff		 jae	 $LN1065@validate_i
  00179	8b 13		 mov	 edx, DWORD PTR [rbx]
  0017b	48 83 c3 04	 add	 rbx, 4

; 2989 :                     GET_ARG;

  0017f	48 3b df	 cmp	 rbx, rdi
  00182	0f 83 f6 fe ff
	ff		 jae	 $LN1065@validate_i
  00188	48 83 c3 04	 add	 rbx, 4

; 2990 :                     /* Here comes the prefix string */
; 2991 :                     if (prefix_len > newcode-code)

  0018c	48 8b c6	 mov	 rax, rsi
  0018f	48 2b c3	 sub	 rax, rbx
  00192	48 c1 f8 02	 sar	 rax, 2
  00196	48 3b d0	 cmp	 rdx, rax
  00199	0f 8f df fe ff
	ff		 jg	 $LN1065@validate_i

; 2992 :                         FAIL;
; 2993 :                     code += prefix_len;

  0019f	4c 8d 0c 95 00
	00 00 00	 lea	 r9, QWORD PTR [rdx*4]

; 2994 :                     /* And here comes the overlap table */
; 2995 :                     if (prefix_len > newcode-code)

  001a7	48 8b c6	 mov	 rax, rsi
  001aa	49 03 d9	 add	 rbx, r9
  001ad	48 2b c3	 sub	 rax, rbx
  001b0	48 c1 f8 02	 sar	 rax, 2
  001b4	48 3b d0	 cmp	 rdx, rax
  001b7	0f 8f c1 fe ff
	ff		 jg	 $LN1065@validate_i

; 2996 :                         FAIL;
; 2997 :                     /* Each overlap value should be < prefix_len */
; 2998 :                     for (i = 0; i < prefix_len; i++) {

  001bd	33 c9		 xor	 ecx, ecx
  001bf	85 d2		 test	 edx, edx
  001c1	74 15		 je	 SHORT $LN533@validate_i
  001c3	48 8b c3	 mov	 rax, rbx
$LL535@validate_i:

; 2999 :                         if (code[i] >= prefix_len)

  001c6	39 10		 cmp	 DWORD PTR [rax], edx
  001c8	0f 83 b0 fe ff
	ff		 jae	 $LN1065@validate_i

; 2996 :                         FAIL;
; 2997 :                     /* Each overlap value should be < prefix_len */
; 2998 :                     for (i = 0; i < prefix_len; i++) {

  001ce	ff c1		 inc	 ecx
  001d0	48 83 c0 04	 add	 rax, 4
  001d4	3b ca		 cmp	 ecx, edx
  001d6	72 ee		 jb	 SHORT $LL535@validate_i
$LN533@validate_i:

; 3000 :                             FAIL;
; 3001 :                     }
; 3002 :                     code += prefix_len;

  001d8	49 03 d9	 add	 rbx, r9
$LN582@validate_i:

; 3003 :                 }
; 3004 :                 /* Validate the charset */
; 3005 :                 if (flags & SRE_INFO_CHARSET) {

  001db	41 f6 c0 04	 test	 r8b, 4
  001df	74 2e		 je	 SHORT $LN525@validate_i

; 3006 :                     if (!_validate_charset(code, newcode-1))

  001e1	48 8d 56 fc	 lea	 rdx, QWORD PTR [rsi-4]
  001e5	48 8b cb	 mov	 rcx, rbx
  001e8	e8 00 00 00 00	 call	 _validate_charset
  001ed	85 c0		 test	 eax, eax
  001ef	0f 84 89 fe ff
	ff		 je	 $LN1065@validate_i

; 3007 :                         FAIL;
; 3008 :                     if (newcode[-1] != SRE_OP_FAILURE)

  001f5	83 7e fc 00	 cmp	 DWORD PTR [rsi-4], 0
  001f9	0f 85 7f fe ff
	ff		 jne	 $LN1065@validate_i

; 3009 :                         FAIL;
; 3010 :                     code = newcode;

  001ff	4c 8b 44 24 40	 mov	 r8, QWORD PTR groups$[rsp]
  00204	48 8b de	 mov	 rbx, rsi
  00207	48 3b df	 cmp	 rbx, rdi
  0020a	e9 25 fe ff ff	 jmp	 $LN1134@validate_i
$LN525@validate_i:

; 3011 :                 }
; 3012 :                 else if (code != newcode) {

  0020f	48 3b de	 cmp	 rbx, rsi

; 3013 :                   VTRACE(("code=%p, newcode=%p\n", code, newcode));
; 3014 :                     FAIL;
; 3015 :                 }
; 3016 :             }
; 3017 :             break;

  00212	e9 26 03 00 00	 jmp	 $LN1135@validate_i
$LN499@validate_i:

; 3018 : 
; 3019 :         case SRE_OP_BRANCH:
; 3020 :             {
; 3021 :                 SRE_CODE *target = NULL;

  00217	33 ed		 xor	 ebp, ebp
  00219	0f 1f 80 00 00
	00 00		 npad	 7
$LL498@validate_i:

; 3022 :                 for (;;) {
; 3023 :                     GET_SKIP;

  00220	48 3b df	 cmp	 rbx, rdi
  00223	0f 83 55 fe ff
	ff		 jae	 $LN1065@validate_i
  00229	8b 33		 mov	 esi, DWORD PTR [rbx]
  0022b	48 8b c7	 mov	 rax, rdi
  0022e	48 2b c3	 sub	 rax, rbx
  00231	48 c1 f8 02	 sar	 rax, 2
  00235	48 3b f0	 cmp	 rsi, rax
  00238	0f 8f 40 fe ff
	ff		 jg	 $LN1065@validate_i
  0023e	48 83 c3 04	 add	 rbx, 4

; 3024 :                     if (skip == 0)

  00242	85 f6		 test	 esi, esi
  00244	0f 84 fe 02 00
	00		 je	 $LN7@validate_i

; 3025 :                         break;
; 3026 :                     /* Stop 2 before the end; we check the JUMP below */
; 3027 :                     if (!_validate_inner(code, code+skip-3, groups))

  0024a	48 8d 54 b3 f4	 lea	 rdx, QWORD PTR [rbx+rsi*4-12]
  0024f	48 8b cb	 mov	 rcx, rbx
  00252	e8 00 00 00 00	 call	 _validate_inner
  00257	85 c0		 test	 eax, eax
  00259	0f 84 1f fe ff
	ff		 je	 $LN1065@validate_i

; 3028 :                         FAIL;
; 3029 :                     code += skip-3;

  0025f	8d 46 fd	 lea	 eax, DWORD PTR [rsi-3]
  00262	48 8d 1c 83	 lea	 rbx, QWORD PTR [rbx+rax*4]

; 3030 :                     /* Check that it ends with a JUMP, and that each JUMP
; 3031 :                        has the same target */
; 3032 :                     GET_OP;

  00266	48 3b df	 cmp	 rbx, rdi
  00269	0f 83 0f fe ff
	ff		 jae	 $LN1065@validate_i
  0026f	8b 03		 mov	 eax, DWORD PTR [rbx]
  00271	48 83 c3 04	 add	 rbx, 4

; 3033 :                     if (op != SRE_OP_JUMP)

  00275	83 f8 12	 cmp	 eax, 18
  00278	0f 85 00 fe ff
	ff		 jne	 $LN1065@validate_i

; 3034 :                         FAIL;
; 3035 :                     GET_SKIP;

  0027e	48 3b df	 cmp	 rbx, rdi
  00281	0f 83 f7 fd ff
	ff		 jae	 $LN1065@validate_i
  00287	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00289	48 8b c7	 mov	 rax, rdi
  0028c	48 2b c3	 sub	 rax, rbx
  0028f	48 c1 f8 02	 sar	 rax, 2
  00293	48 3b c8	 cmp	 rcx, rax
  00296	0f 8f e2 fd ff
	ff		 jg	 $LN1065@validate_i
  0029c	48 83 c3 04	 add	 rbx, 4

; 3036 :                     if (target == NULL)

  002a0	48 85 ed	 test	 rbp, rbp
  002a3	75 0f		 jne	 SHORT $LN419@validate_i

; 3037 :                         target = code+skip-1;

  002a5	4c 8b 44 24 40	 mov	 r8, QWORD PTR groups$[rsp]
  002aa	48 8d 6c 8b fc	 lea	 rbp, QWORD PTR [rbx+rcx*4-4]
  002af	e9 6c ff ff ff	 jmp	 $LL498@validate_i
$LN419@validate_i:

; 3038 :                     else if (code+skip-1 != target)

  002b4	48 8d 44 8b fc	 lea	 rax, QWORD PTR [rbx+rcx*4-4]
  002b9	48 3b c5	 cmp	 rax, rbp
  002bc	0f 85 bc fd ff
	ff		 jne	 $LN1065@validate_i

; 3039 :                         FAIL;
; 3040 :                 }

  002c2	4c 8b 44 24 40	 mov	 r8, QWORD PTR groups$[rsp]
  002c7	e9 54 ff ff ff	 jmp	 $LL498@validate_i
  002cc	0f 1f 40 00	 npad	 4
$LL409@validate_i:

; 3041 :             }
; 3042 :             break;
; 3043 : 
; 3044 :         case SRE_OP_REPEAT_ONE:
; 3045 :         case SRE_OP_MIN_REPEAT_ONE:
; 3046 :             {
; 3047 :                 SRE_CODE min, max;
; 3048 :                 GET_SKIP;

  002d0	48 3b df	 cmp	 rbx, rdi
  002d3	0f 83 a5 fd ff
	ff		 jae	 $LN1065@validate_i
  002d9	8b 33		 mov	 esi, DWORD PTR [rbx]
  002db	48 8b c7	 mov	 rax, rdi
  002de	48 2b c3	 sub	 rax, rbx
  002e1	48 c1 f8 02	 sar	 rax, 2
  002e5	48 3b f0	 cmp	 rsi, rax
  002e8	0f 8f 90 fd ff
	ff		 jg	 $LN1065@validate_i
  002ee	48 83 c3 04	 add	 rbx, 4

; 3049 :                 GET_ARG; min = arg;

  002f2	48 3b df	 cmp	 rbx, rdi
  002f5	0f 83 83 fd ff
	ff		 jae	 $LN1065@validate_i
  002fb	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  002fd	48 83 c3 04	 add	 rbx, 4

; 3050 :                 GET_ARG; max = arg;

  00301	48 3b df	 cmp	 rbx, rdi
  00304	0f 83 74 fd ff
	ff		 jae	 $LN1065@validate_i
  0030a	8b 03		 mov	 eax, DWORD PTR [rbx]

; 3051 :                 if (min > max)

  0030c	3b c8		 cmp	 ecx, eax
  0030e	0f 87 6a fd ff
	ff		 ja	 $LN1065@validate_i

; 3052 :                     FAIL;
; 3053 :                 if (max > SRE_MAXREPEAT)

  00314	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  00317	0f 87 61 fd ff
	ff		 ja	 $LN1065@validate_i

; 3054 :                     FAIL;
; 3055 :                 if (!_validate_inner(code, code+skip-4, groups))

  0031d	48 8d 54 b3 f4	 lea	 rdx, QWORD PTR [rbx+rsi*4-12]
  00322	48 8d 4b 04	 lea	 rcx, QWORD PTR [rbx+4]
  00326	e8 00 00 00 00	 call	 _validate_inner
  0032b	85 c0		 test	 eax, eax
  0032d	0f 84 4b fd ff
	ff		 je	 $LN1065@validate_i

; 3056 :                     FAIL;
; 3057 :                 code += skip-4;

  00333	8d 46 fc	 lea	 eax, DWORD PTR [rsi-4]
  00336	48 8d 5c 83 04	 lea	 rbx, QWORD PTR [rbx+rax*4+4]

; 3058 :                 GET_OP;
; 3059 :                 if (op != SRE_OP_SUCCESS)
; 3060 :                     FAIL;
; 3061 :             }
; 3062 :             break;

  0033b	e9 eb 01 00 00	 jmp	 $LN1137@validate_i
$LL309@validate_i:

; 3063 : 
; 3064 :         case SRE_OP_REPEAT:
; 3065 :             {
; 3066 :                 SRE_CODE min, max;
; 3067 :                 GET_SKIP;

  00340	48 3b df	 cmp	 rbx, rdi
  00343	0f 83 35 fd ff
	ff		 jae	 $LN1065@validate_i
  00349	8b 33		 mov	 esi, DWORD PTR [rbx]
  0034b	48 8b c7	 mov	 rax, rdi
  0034e	48 2b c3	 sub	 rax, rbx
  00351	48 c1 f8 02	 sar	 rax, 2
  00355	48 3b f0	 cmp	 rsi, rax
  00358	0f 8f 20 fd ff
	ff		 jg	 $LN1065@validate_i
  0035e	48 83 c3 04	 add	 rbx, 4

; 3068 :                 GET_ARG; min = arg;

  00362	48 3b df	 cmp	 rbx, rdi
  00365	0f 83 13 fd ff
	ff		 jae	 $LN1065@validate_i
  0036b	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  0036d	48 83 c3 04	 add	 rbx, 4

; 3069 :                 GET_ARG; max = arg;

  00371	48 3b df	 cmp	 rbx, rdi
  00374	0f 83 04 fd ff
	ff		 jae	 $LN1065@validate_i
  0037a	8b 03		 mov	 eax, DWORD PTR [rbx]

; 3070 :                 if (min > max)

  0037c	3b c8		 cmp	 ecx, eax
  0037e	0f 87 fa fc ff
	ff		 ja	 $LN1065@validate_i

; 3071 :                     FAIL;
; 3072 :                 if (max > SRE_MAXREPEAT)

  00384	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  00387	0f 87 f1 fc ff
	ff		 ja	 $LN1065@validate_i

; 3073 :                     FAIL;
; 3074 :                 if (!_validate_inner(code, code+skip-3, groups))

  0038d	48 8d 54 b3 f8	 lea	 rdx, QWORD PTR [rbx+rsi*4-8]
  00392	48 8d 4b 04	 lea	 rcx, QWORD PTR [rbx+4]
  00396	e8 00 00 00 00	 call	 _validate_inner
  0039b	85 c0		 test	 eax, eax
  0039d	0f 84 db fc ff
	ff		 je	 $LN1065@validate_i

; 3075 :                     FAIL;
; 3076 :                 code += skip-3;

  003a3	8d 46 fd	 lea	 eax, DWORD PTR [rsi-3]
  003a6	48 8d 5c 83 04	 lea	 rbx, QWORD PTR [rbx+rax*4+4]

; 3077 :                 GET_OP;

  003ab	48 3b df	 cmp	 rbx, rdi
  003ae	0f 83 ca fc ff
	ff		 jae	 $LN1065@validate_i
  003b4	8b 03		 mov	 eax, DWORD PTR [rbx]
  003b6	48 83 c3 04	 add	 rbx, 4

; 3078 :                 if (op != SRE_OP_MAX_UNTIL && op != SRE_OP_MIN_UNTIL)

  003ba	83 f8 16	 cmp	 eax, 22
  003bd	0f 84 80 01 00
	00		 je	 $LN1131@validate_i
  003c3	83 f8 17	 cmp	 eax, 23

; 3079 :                     FAIL;
; 3080 :             }
; 3081 :             break;

  003c6	e9 72 01 00 00	 jmp	 $LN1135@validate_i
  003cb	0f 1f 44 00 00	 npad	 5
$LL209@validate_i:

; 3082 : 
; 3083 :         case SRE_OP_GROUPREF:
; 3084 :         case SRE_OP_GROUPREF_IGNORE:
; 3085 :             GET_ARG;

  003d0	48 3b df	 cmp	 rbx, rdi
  003d3	0f 83 a5 fc ff
	ff		 jae	 $LN1065@validate_i
  003d9	8b 03		 mov	 eax, DWORD PTR [rbx]
  003db	48 83 c3 04	 add	 rbx, 4

; 3086 :             if (arg >= groups)

  003df	49 3b c0	 cmp	 rax, r8
  003e2	0f 8d 96 fc ff
	ff		 jge	 $LN1065@validate_i

; 2893 : 
; 2894 :     while (code < end) {

  003e8	48 3b df	 cmp	 rbx, rdi
  003eb	e9 44 fc ff ff	 jmp	 $LN1134@validate_i
$LL185@validate_i:

; 3087 :                 FAIL;
; 3088 :             break;
; 3089 : 
; 3090 :         case SRE_OP_GROUPREF_EXISTS:
; 3091 :             /* The regex syntax for this is: '(?(group)then|else)', where
; 3092 :                'group' is either an integer group number or a group name,
; 3093 :                'then' and 'else' are sub-regexes, and 'else' is optional. */
; 3094 :             GET_ARG;

  003f0	48 3b df	 cmp	 rbx, rdi
  003f3	0f 83 85 fc ff
	ff		 jae	 $LN1065@validate_i
  003f9	8b 03		 mov	 eax, DWORD PTR [rbx]
  003fb	48 83 c3 04	 add	 rbx, 4

; 3095 :             if (arg >= groups)

  003ff	49 3b c0	 cmp	 rax, r8
  00402	0f 8d 76 fc ff
	ff		 jge	 $LN1065@validate_i

; 3096 :                 FAIL;
; 3097 :             GET_SKIP_ADJ(1);

  00408	48 3b df	 cmp	 rbx, rdi
  0040b	0f 83 6d fc ff
	ff		 jae	 $LN1065@validate_i
  00411	8b 33		 mov	 esi, DWORD PTR [rbx]
  00413	48 8b cf	 mov	 rcx, rdi
  00416	48 2b cb	 sub	 rcx, rbx
  00419	8d 6e ff	 lea	 ebp, DWORD PTR [rsi-1]
  0041c	48 c1 f9 02	 sar	 rcx, 2
  00420	48 3b e9	 cmp	 rbp, rcx
  00423	0f 8f 55 fc ff
	ff		 jg	 $LN1065@validate_i

; 3098 :             code--; /* The skip is relative to the first arg! */
; 3099 :             /* There are two possibilities here: if there is both a 'then'
; 3100 :                part and an 'else' part, the generated code looks like:
; 3101 : 
; 3102 :                GROUPREF_EXISTS
; 3103 :                <group>
; 3104 :                <skipyes>
; 3105 :                ...then part...
; 3106 :                JUMP
; 3107 :                <skipno>
; 3108 :                (<skipyes> jumps here)
; 3109 :                ...else part...
; 3110 :                (<skipno> jumps here)
; 3111 : 
; 3112 :                If there is only a 'then' part, it looks like:
; 3113 : 
; 3114 :                GROUPREF_EXISTS
; 3115 :                <group>
; 3116 :                <skip>
; 3117 :                ...then part...
; 3118 :                (<skip> jumps here)
; 3119 : 
; 3120 :                There is no direct way to decide which it is, and we don't want
; 3121 :                to allow arbitrary jumps anywhere in the code; so we just look
; 3122 :                for a JUMP opcode preceding our skip target.
; 3123 :             */
; 3124 :             if (skip >= 3 && skip-3 < end-code &&
; 3125 :                 code[skip-3] == SRE_OP_JUMP)

  00429	83 fe 03	 cmp	 esi, 3
  0042c	0f 82 7e 00 00
	00		 jb	 $LL97@validate_i
  00432	8d 46 fd	 lea	 eax, DWORD PTR [rsi-3]
  00435	8b d0		 mov	 edx, eax
  00437	48 3b d1	 cmp	 rdx, rcx
  0043a	7d 74		 jge	 SHORT $LL97@validate_i
  0043c	83 3c 83 12	 cmp	 DWORD PTR [rbx+rax*4], 18
  00440	75 6e		 jne	 SHORT $LL97@validate_i

; 3126 :             {
; 3127 :                 VTRACE(("both then and else parts present\n"));
; 3128 :                 if (!_validate_inner(code+1, code+skip-3, groups))

  00442	48 8d 54 b3 f4	 lea	 rdx, QWORD PTR [rbx+rsi*4-12]
  00447	48 8d 4b 04	 lea	 rcx, QWORD PTR [rbx+4]
  0044b	e8 00 00 00 00	 call	 _validate_inner
  00450	85 c0		 test	 eax, eax
  00452	0f 84 26 fc ff
	ff		 je	 $LN1065@validate_i

; 3129 :                     FAIL;
; 3130 :                 code += skip-2; /* Position after JUMP, at <skipno> */

  00458	8d 46 fe	 lea	 eax, DWORD PTR [rsi-2]
  0045b	48 8d 1c 83	 lea	 rbx, QWORD PTR [rbx+rax*4]

; 3131 :                 GET_SKIP;

  0045f	48 3b df	 cmp	 rbx, rdi
  00462	0f 83 16 fc ff
	ff		 jae	 $LN1065@validate_i
  00468	8b 33		 mov	 esi, DWORD PTR [rbx]
  0046a	48 8b c7	 mov	 rax, rdi
  0046d	48 2b c3	 sub	 rax, rbx
  00470	48 c1 f8 02	 sar	 rax, 2
  00474	48 3b f0	 cmp	 rsi, rax
  00477	0f 8f 01 fc ff
	ff		 jg	 $LN1065@validate_i

; 3132 :                 if (!_validate_inner(code, code+skip-1, groups))

  0047d	4c 8b 44 24 40	 mov	 r8, QWORD PTR groups$[rsp]
  00482	48 8d 14 b3	 lea	 rdx, QWORD PTR [rbx+rsi*4]
  00486	48 8d 4b 04	 lea	 rcx, QWORD PTR [rbx+4]
  0048a	e8 00 00 00 00	 call	 _validate_inner
  0048f	85 c0		 test	 eax, eax
  00491	0f 84 e7 fb ff
	ff		 je	 $LN1065@validate_i

; 3133 :                     FAIL;
; 3134 :                 code += skip-1;

  00497	4c 8b 44 24 40	 mov	 r8, QWORD PTR groups$[rsp]
  0049c	8d 46 ff	 lea	 eax, DWORD PTR [rsi-1]
  0049f	48 8d 5c 83 04	 lea	 rbx, QWORD PTR [rbx+rax*4+4]
  004a4	48 3b df	 cmp	 rbx, rdi
  004a7	e9 88 fb ff ff	 jmp	 $LN1134@validate_i
  004ac	0f 1f 40 00	 npad	 4
$LL97@validate_i:

; 3135 :             }
; 3136 :             else {
; 3137 :                 VTRACE(("only a then part present\n"));
; 3138 :                 if (!_validate_inner(code+1, code+skip-1, groups))

  004b0	48 8d 54 b3 fc	 lea	 rdx, QWORD PTR [rbx+rsi*4-4]
  004b5	48 8d 4b 04	 lea	 rcx, QWORD PTR [rbx+4]
  004b9	e8 00 00 00 00	 call	 _validate_inner
  004be	85 c0		 test	 eax, eax
  004c0	0f 84 b8 fb ff
	ff		 je	 $LN1065@validate_i

; 3139 :                     FAIL;
; 3140 :                 code += skip-1;

  004c6	4c 8b 44 24 40	 mov	 r8, QWORD PTR groups$[rsp]
  004cb	48 8d 1c ab	 lea	 rbx, QWORD PTR [rbx+rbp*4]
  004cf	48 3b df	 cmp	 rbx, rdi
  004d2	e9 5d fb ff ff	 jmp	 $LN1134@validate_i
$LL86@validate_i:

; 3141 :             }
; 3142 :             break;
; 3143 : 
; 3144 :         case SRE_OP_ASSERT:
; 3145 :         case SRE_OP_ASSERT_NOT:
; 3146 :             GET_SKIP;

  004d7	48 3b df	 cmp	 rbx, rdi
  004da	0f 83 9e fb ff
	ff		 jae	 $LN1065@validate_i
  004e0	8b 33		 mov	 esi, DWORD PTR [rbx]
  004e2	48 8b c7	 mov	 rax, rdi
  004e5	48 2b c3	 sub	 rax, rbx
  004e8	48 c1 f8 02	 sar	 rax, 2
  004ec	48 3b f0	 cmp	 rsi, rax
  004ef	0f 8f 89 fb ff
	ff		 jg	 $LN1065@validate_i
  004f5	48 83 c3 04	 add	 rbx, 4

; 3147 :             GET_ARG; /* 0 for lookahead, width for lookbehind */

  004f9	48 3b df	 cmp	 rbx, rdi
  004fc	0f 83 7c fb ff
	ff		 jae	 $LN1065@validate_i

; 3148 :             code--; /* Back up over arg to simplify math below */
; 3149 :             if (arg & 0x80000000)

  00502	f7 03 00 00 00
	80		 test	 DWORD PTR [rbx], -2147483648 ; 80000000H
  00508	0f 85 70 fb ff
	ff		 jne	 $LN1065@validate_i

; 3150 :                 FAIL; /* Width too large */
; 3151 :             /* Stop 1 before the end; we check the SUCCESS below */
; 3152 :             if (!_validate_inner(code+1, code+skip-2, groups))

  0050e	48 8d 54 b3 f8	 lea	 rdx, QWORD PTR [rbx+rsi*4-8]
  00513	48 8d 4b 04	 lea	 rcx, QWORD PTR [rbx+4]
  00517	e8 00 00 00 00	 call	 _validate_inner
  0051c	85 c0		 test	 eax, eax
  0051e	0f 84 5a fb ff
	ff		 je	 $LN1065@validate_i

; 3153 :                 FAIL;
; 3154 :             code += skip-2;

  00524	8d 46 fe	 lea	 eax, DWORD PTR [rsi-2]
  00527	48 8d 1c 83	 lea	 rbx, QWORD PTR [rbx+rax*4]
$LN1137@validate_i:

; 3155 :             GET_OP;

  0052b	48 3b df	 cmp	 rbx, rdi
  0052e	0f 83 4a fb ff
	ff		 jae	 $LN1065@validate_i
  00534	8b 03		 mov	 eax, DWORD PTR [rbx]
  00536	48 83 c3 04	 add	 rbx, 4

; 3156 :             if (op != SRE_OP_SUCCESS)

  0053a	83 f8 01	 cmp	 eax, 1
$LN1135@validate_i:
  0053d	0f 85 3b fb ff
	ff		 jne	 $LN1065@validate_i
$LN1131@validate_i:

; 2955 :                 FAIL;
; 2956 :             code += skip-1;
; 2957 :             break;

  00543	4c 8b 44 24 40	 mov	 r8, QWORD PTR groups$[rsp]
$LN7@validate_i:

; 2893 : 
; 2894 :     while (code < end) {

  00548	48 3b df	 cmp	 rbx, rdi
  0054b	e9 e4 fa ff ff	 jmp	 $LN1134@validate_i
$LL3@validate_i:

; 3157 :                 FAIL;
; 3158 :             break;
; 3159 : 
; 3160 :         default:
; 3161 :             FAIL;
; 3162 : 
; 3163 :         }
; 3164 :     }
; 3165 : 
; 3166 :     VTRACE(("okay\n"));
; 3167 :     return 1;

  00550	b8 01 00 00 00	 mov	 eax, 1
$LN1133@validate_i:
  00555	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  0055a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 3168 : }

  0055f	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00564	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00568	5f		 pop	 rdi
  00569	c3		 ret	 0
  0056a	66 90		 npad	 2
$LN1128@validate_i:
  0056c	00 00 00 00	 DD	 $LN7@validate_i
  00570	00 00 00 00	 DD	 $LL86@validate_i
  00574	00 00 00 00	 DD	 $LL740@validate_i
  00578	00 00 00 00	 DD	 $LN499@validate_i
  0057c	00 00 00 00	 DD	 $LL209@validate_i
  00580	00 00 00 00	 DD	 $LL185@validate_i
  00584	00 00 00 00	 DD	 $LL712@validate_i
  00588	00 00 00 00	 DD	 $LL674@validate_i
  0058c	00 00 00 00	 DD	 $LL758@validate_i
  00590	00 00 00 00	 DD	 $LL785@validate_i
  00594	00 00 00 00	 DD	 $LL309@validate_i
  00598	00 00 00 00	 DD	 $LL409@validate_i
  0059c	00 00 00 00	 DD	 $LN1065@validate_i
$LN1127@validate_i:
  005a0	00		 DB	 0
  005a1	00		 DB	 0
  005a2	00		 DB	 0
  005a3	00		 DB	 0
  005a4	01		 DB	 1
  005a5	01		 DB	 1
  005a6	02		 DB	 2
  005a7	03		 DB	 3
  005a8	0c		 DB	 12
  005a9	0c		 DB	 12
  005aa	0c		 DB	 12
  005ab	0c		 DB	 12
  005ac	04		 DB	 4
  005ad	05		 DB	 5
  005ae	04		 DB	 4
  005af	06		 DB	 6
  005b0	06		 DB	 6
  005b1	07		 DB	 7
  005b2	0c		 DB	 12
  005b3	08		 DB	 8
  005b4	08		 DB	 8
  005b5	09		 DB	 9
  005b6	0c		 DB	 12
  005b7	0c		 DB	 12
  005b8	08		 DB	 8
  005b9	08		 DB	 8
  005ba	0c		 DB	 12
  005bb	0c		 DB	 12
  005bc	0a		 DB	 10
  005bd	0b		 DB	 11
  005be	0c		 DB	 12
  005bf	0b		 DB	 11
_validate_inner ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _validate_outer
_TEXT	SEGMENT
code$ = 8
end$ = 16
groups$ = 24
_validate_outer PROC					; COMDAT

; 3173 :     if (groups < 0 || groups > 100 || code >= end || end[-1] != SRE_OP_SUCCESS)

  00000	49 83 f8 64	 cmp	 r8, 100			; 00000064H
  00004	77 1f		 ja	 SHORT $LN7@validate_o
  00006	48 3b ca	 cmp	 rcx, rdx
  00009	73 1a		 jae	 SHORT $LN7@validate_o
  0000b	48 83 c2 fc	 add	 rdx, -4
  0000f	83 3a 01	 cmp	 DWORD PTR [rdx], 1
  00012	75 11		 jne	 SHORT $LN7@validate_o

; 3175 :     if (groups == 0)  /* fix for simplejson */

  00014	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  00019	4d 85 c0	 test	 r8, r8
  0001c	4c 0f 44 c0	 cmove	 r8, rax

; 3176 :         groups = 100; /* 100 groups should always be safe */
; 3177 :     return _validate_inner(code, end-1, groups);
; 3178 : }

  00020	e9 00 00 00 00	 jmp	 _validate_inner
$LN7@validate_o:

; 3174 :         FAIL;

  00025	33 c0		 xor	 eax, eax

; 3176 :         groups = 100; /* 100 groups should always be safe */
; 3177 :     return _validate_inner(code, end-1, groups);
; 3178 : }

  00027	c3		 ret	 0
_validate_outer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@CBNGNFNM@invalid?5SRE?5code?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$_validate DD imagerel _validate
	DD	imagerel _validate+75
	DD	imagerel $unwind$_validate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_validate DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BB@CBNGNFNM@invalid?5SRE?5code?$AA@
CONST	SEGMENT
??_C@_0BB@CBNGNFNM@invalid?5SRE?5code?$AA@ DB 'invalid SRE code', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _validate
_TEXT	SEGMENT
self$ = 48
_validate PROC						; COMDAT

; 3182 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3183 :     if (!_validate_outer(self->code, self->code+self->codesize, self->groups))

  00004	48 8b 81 f8 00
	00 00		 mov	 rax, QWORD PTR [rcx+248]
  0000b	4c 8b 41 70	 mov	 r8, QWORD PTR [rcx+112]
  0000f	48 8d 94 81 00
	01 00 00	 lea	 rdx, QWORD PTR [rcx+rax*4+256]
  00017	48 81 c1 00 01
	00 00		 add	 rcx, 256		; 00000100H
  0001e	e8 00 00 00 00	 call	 _validate_outer
  00023	85 c0		 test	 eax, eax
  00025	75 1a		 jne	 SHORT $LN3@validate

; 3184 :     {
; 3185 :         PyErr_SetString(PyExc_RuntimeError, "invalid SRE code");

  00027	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@CBNGNFNM@invalid?5SRE?5code?$AA@
  00035	e8 00 00 00 00	 call	 PyErr_SetString

; 3186 :         return 0;

  0003a	33 c0		 xor	 eax, eax

; 3191 : }

  0003c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00040	c3		 ret	 0
$LN3@validate:

; 3187 :     }
; 3188 :     else
; 3189 :         VTRACE(("Success!\n"));
; 3190 :     return 1;

  00041	b8 01 00 00 00	 mov	 eax, 1

; 3191 : }

  00046	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004a	c3		 ret	 0
_validate ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$match_dealloc DD imagerel match_dealloc
	DD	imagerel match_dealloc+263
	DD	imagerel $unwind$match_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_dealloc DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_sre.c
xdata	ENDS
;	COMDAT match_dealloc
_TEXT	SEGMENT
self$ = 64
match_dealloc PROC					; COMDAT

; 3198 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3199 :     Py_XDECREF(self->regs);

  0000a	48 8b 59 78	 mov	 rbx, QWORD PTR [rcx+120]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	48 85 db	 test	 rbx, rbx
  00014	74 65		 je	 SHORT $LN7@match_deal
  00016	e8 00 00 00 00	 call	 _Py_PXCTX
  0001b	85 c0		 test	 eax, eax
  0001d	75 5c		 jne	 SHORT $LN7@match_deal
  0001f	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00023	a8 20		 test	 al, 32			; 00000020H
  00025	75 4c		 jne	 SHORT $LN15@match_deal
  00027	84 c0		 test	 al, al
  00029	78 48		 js	 SHORT $LN15@match_deal
  0002b	a8 02		 test	 al, 2
  0002d	75 4c		 jne	 SHORT $LN7@match_deal
  0002f	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00033	75 46		 jne	 SHORT $LN7@match_deal
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00043	4c 8b cb	 mov	 r9, rbx
  00046	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0004c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00054	e8 00 00 00 00	 call	 _PyParallel_Guard
  00059	48 8b cb	 mov	 rcx, rbx
  0005c	85 c0		 test	 eax, eax
  0005e	74 07		 je	 SHORT $LN20@match_deal
  00060	e8 00 00 00 00	 call	 _Px_Dealloc
  00065	eb 14		 jmp	 SHORT $LN7@match_deal
$LN20@match_deal:
  00067	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0006b	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00071	eb 08		 jmp	 SHORT $LN7@match_deal
$LN15@match_deal:
  00073	48 8b cb	 mov	 rcx, rbx
  00076	e8 00 00 00 00	 call	 Px_DecRef
$LN7@match_deal:

; 3200 :     Py_XDECREF(self->string);

  0007b	48 8b 5f 70	 mov	 rbx, QWORD PTR [rdi+112]
  0007f	48 85 db	 test	 rbx, rbx
  00082	74 65		 je	 SHORT $LN3@match_deal
  00084	e8 00 00 00 00	 call	 _Py_PXCTX
  00089	85 c0		 test	 eax, eax
  0008b	75 5c		 jne	 SHORT $LN3@match_deal
  0008d	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00091	a8 20		 test	 al, 32			; 00000020H
  00093	75 4c		 jne	 SHORT $LN26@match_deal
  00095	84 c0		 test	 al, al
  00097	78 48		 js	 SHORT $LN26@match_deal
  00099	a8 02		 test	 al, 2
  0009b	75 4c		 jne	 SHORT $LN3@match_deal
  0009d	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000a1	75 46		 jne	 SHORT $LN3@match_deal
  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000b1	4c 8b cb	 mov	 r9, rbx
  000b4	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000ba	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000c2	e8 00 00 00 00	 call	 _PyParallel_Guard
  000c7	48 8b cb	 mov	 rcx, rbx
  000ca	85 c0		 test	 eax, eax
  000cc	74 07		 je	 SHORT $LN31@match_deal
  000ce	e8 00 00 00 00	 call	 _Px_Dealloc
  000d3	eb 14		 jmp	 SHORT $LN3@match_deal
$LN31@match_deal:
  000d5	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000d9	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000df	eb 08		 jmp	 SHORT $LN3@match_deal
$LN26@match_deal:
  000e1	48 8b cb	 mov	 rcx, rbx
  000e4	e8 00 00 00 00	 call	 Px_DecRef
$LN3@match_deal:

; 3201 :     Py_DECREF(self->pattern);

  000e9	48 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [rdi+128]
  000f0	e8 00 00 00 00	 call	 _Py_DecRef

; 3202 :     PyObject_DEL(self);

  000f5	48 8b cf	 mov	 rcx, rdi

; 3203 : }

  000f8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000fd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00101	5f		 pop	 rdi
  00102	e9 00 00 00 00	 jmp	 PyObject_Free
match_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@OOOHFIK@no?5such?5group?$AA@		; `string'
EXTRN	PyExc_IndexError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_getslice_by_index DD imagerel match_getslice_by_index
	DD	imagerel match_getslice_by_index+121
	DD	imagerel $unwind$match_getslice_by_index
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_getslice_by_index DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0O@OOOHFIK@no?5such?5group?$AA@
CONST	SEGMENT
??_C@_0O@OOOHFIK@no?5such?5group?$AA@ DB 'no such group', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT match_getslice_by_index
_TEXT	SEGMENT
self$ = 48
index$ = 56
def$ = 64
match_getslice_by_index PROC				; COMDAT

; 3207 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	49 8b d8	 mov	 rbx, r8

; 3208 :     if (index < 0 || index >= self->groups) {

  00009	48 85 d2	 test	 rdx, rdx
  0000c	78 50		 js	 SHORT $LN3@match_gets
  0000e	48 3b 91 a0 00
	00 00		 cmp	 rdx, QWORD PTR [rcx+160]
  00015	7d 47		 jge	 SHORT $LN3@match_gets

; 3215 :     }
; 3216 : 
; 3217 :     index *= 2;
; 3218 : 
; 3219 :     if (self->string == Py_None || self->mark[index] < 0) {

  00017	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  0001b	4c 8d 04 12	 lea	 r8, QWORD PTR [rdx+rdx]
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct
  00026	48 3b c2	 cmp	 rax, rdx
  00029	74 22		 je	 SHORT $LN1@match_gets
  0002b	4a 8b 94 c1 a8
	00 00 00	 mov	 rdx, QWORD PTR [rcx+r8*8+168]
  00033	48 85 d2	 test	 rdx, rdx
  00036	78 15		 js	 SHORT $LN1@match_gets

; 3223 :     }
; 3224 : 
; 3225 :     return PySequence_GetSlice(
; 3226 :         self->string, self->mark[index], self->mark[index+1]
; 3227 :         );

  00038	4e 8b 84 c1 b0
	00 00 00	 mov	 r8, QWORD PTR [rcx+r8*8+176]
  00040	48 8b c8	 mov	 rcx, rax

; 3228 : }

  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5b		 pop	 rbx
  00048	e9 00 00 00 00	 jmp	 PySequence_GetSlice
$LN1@match_gets:

; 3220 :         /* return default value if the string or group is undefined */
; 3221 :         Py_INCREF(def);

  0004d	48 8b cb	 mov	 rcx, rbx
  00050	e8 00 00 00 00	 call	 _Py_IncRef

; 3222 :         return def;

  00055	48 8b c3	 mov	 rax, rbx

; 3228 : }

  00058	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005c	5b		 pop	 rbx
  0005d	c3		 ret	 0
$LN3@match_gets:

; 3209 :         /* raise IndexError if we were given a bad group number */
; 3210 :         PyErr_SetString(
; 3211 :             PyExc_IndexError,
; 3212 :             "no such group"
; 3213 :             );

  0005e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@OOOHFIK@no?5such?5group?$AA@
  0006c	e8 00 00 00 00	 call	 PyErr_SetString

; 3214 :         return NULL;

  00071	33 c0		 xor	 eax, eax

; 3228 : }

  00073	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00077	5b		 pop	 rbx
  00078	c3		 ret	 0
match_getslice_by_index ENDP
_TEXT	ENDS
EXTRN	PyErr_Clear:PROC
EXTRN	PyObject_GetItem:PROC
EXTRN	PyLong_AsSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_getindex DD imagerel match_getindex
	DD	imagerel match_getindex+51
	DD	imagerel $unwind$match_getindex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$match_getindex DD imagerel match_getindex+51
	DD	imagerel match_getindex+140
	DD	imagerel $chain$1$match_getindex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$match_getindex DD imagerel match_getindex+140
	DD	imagerel match_getindex+150
	DD	imagerel $chain$3$match_getindex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$match_getindex DD imagerel match_getindex+150
	DD	imagerel match_getindex+163
	DD	imagerel $chain$4$match_getindex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$match_getindex DD 020021H
	DD	047400H
	DD	imagerel match_getindex
	DD	imagerel match_getindex+51
	DD	imagerel $unwind$match_getindex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$match_getindex DD 040021H
	DD	047400H
	DD	063400H
	DD	imagerel match_getindex
	DD	imagerel match_getindex+51
	DD	imagerel $unwind$match_getindex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$match_getindex DD 041721H
	DD	063417H
	DD	047405H
	DD	imagerel match_getindex
	DD	imagerel match_getindex+51
	DD	imagerel $unwind$match_getindex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_getindex DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT match_getindex
_TEXT	SEGMENT
self$ = 48
index$ = 56
match_getindex PROC					; COMDAT

; 3232 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3233 :     Py_ssize_t i;
; 3234 : 
; 3235 :     if (index == NULL)

  00004	48 85 d2	 test	 rdx, rdx
  00007	75 07		 jne	 SHORT $LN6@match_geti

; 3236 :         /* Default value */
; 3237 :         return 0;

  00009	33 c0		 xor	 eax, eax

; 3255 : }

  0000b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0000f	c3		 ret	 0
$LN6@match_geti:

; 3238 : 
; 3239 :     if (PyLong_Check(index))

  00010	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00014	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  0001e	74 0c		 je	 SHORT $LN5@match_geti

; 3240 :         return PyLong_AsSsize_t(index);

  00020	48 8b ca	 mov	 rcx, rdx

; 3255 : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	e9 00 00 00 00	 jmp	 PyLong_AsSsize_t
$LN5@match_geti:

; 3241 : 
; 3242 :     i = -1;
; 3243 : 
; 3244 :     if (self->pattern->groupindex) {

  0002c	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]
  00033	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00038	48 83 cf ff	 or	 rdi, -1
  0003c	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  00040	48 85 c9	 test	 rcx, rcx
  00043	74 51		 je	 SHORT $LN1@match_geti

; 3245 :         index = PyObject_GetItem(self->pattern->groupindex, index);

  00045	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0004a	e8 00 00 00 00	 call	 PyObject_GetItem
  0004f	48 8b d8	 mov	 rbx, rax

; 3246 :         if (index) {

  00052	48 85 c0	 test	 rax, rax
  00055	74 35		 je	 SHORT $LN3@match_geti

; 3247 :             if (PyLong_Check(index))

  00057	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005b	f7 81 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rcx+256], 16777216 ; 01000000H
  00065	74 0b		 je	 SHORT $LN2@match_geti

; 3248 :                 i = PyLong_AsSsize_t(index);

  00067	48 8b c8	 mov	 rcx, rax
  0006a	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  0006f	48 8b f8	 mov	 rdi, rax
$LN2@match_geti:

; 3249 :             Py_DECREF(index);

  00072	48 8b cb	 mov	 rcx, rbx
  00075	e8 00 00 00 00	 call	 _Py_DecRef
  0007a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 3252 :     }
; 3253 : 
; 3254 :     return i;

  0007f	48 8b c7	 mov	 rax, rdi
  00082	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 3255 : }

  00087	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008b	c3		 ret	 0
$LN3@match_geti:

; 3250 :         } else
; 3251 :             PyErr_Clear();

  0008c	e8 00 00 00 00	 call	 PyErr_Clear
  00091	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
$LN1@match_geti:

; 3252 :     }
; 3253 : 
; 3254 :     return i;

  00096	48 8b c7	 mov	 rax, rdi
  00099	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 3255 : }

  0009e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a2	c3		 ret	 0
match_getindex ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_getslice DD imagerel match_getslice
	DD	imagerel match_getslice+45
	DD	imagerel $unwind$match_getslice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_getslice DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT match_getslice
_TEXT	SEGMENT
self$ = 48
index$ = 56
def$ = 64
match_getslice PROC					; COMDAT

; 3259 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b f8	 mov	 rdi, r8
  0000d	48 8b d9	 mov	 rbx, rcx

; 3260 :     return match_getslice_by_index(self, match_getindex(self, index), def);

  00010	e8 00 00 00 00	 call	 match_getindex
  00015	4c 8b c7	 mov	 r8, rdi
  00018	48 8b cb	 mov	 rcx, rbx
  0001b	48 8b d0	 mov	 rdx, rax

; 3261 : }

  0001e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5f		 pop	 rdi
  00028	e9 00 00 00 00	 jmp	 match_getslice_by_index
match_getslice ENDP
_TEXT	ENDS
PUBLIC	??_C@_07BBLEBFDC@_expand?$AA@			; `string'
EXTRN	PyTuple_Pack:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_expand DD imagerel match_expand
	DD	imagerel match_expand+53
	DD	imagerel $unwind$match_expand
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_expand DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_07BBLEBFDC@_expand?$AA@
CONST	SEGMENT
??_C@_07BBLEBFDC@_expand?$AA@ DB '_expand', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT match_expand
_TEXT	SEGMENT
self$ = 48
ptemplate$ = 56
match_expand PROC					; COMDAT

; 3265 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3266 :     /* delegate to Python code */
; 3267 :     return call(
; 3268 :         SRE_PY_MODULE, "_expand",
; 3269 :         PyTuple_Pack(3, self->pattern, self, ptemplate)
; 3270 :         );

  00004	4c 8b ca	 mov	 r9, rdx
  00007	48 8b 91 80 00
	00 00		 mov	 rdx, QWORD PTR [rcx+128]
  0000e	4c 8b c1	 mov	 r8, rcx
  00011	b9 03 00 00 00	 mov	 ecx, 3
  00016	e8 00 00 00 00	 call	 PyTuple_Pack
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07BBLEBFDC@_expand?$AA@
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02EPEBAFDB@re?$AA@
  00029	4c 8b c0	 mov	 r8, rax

; 3271 : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	e9 00 00 00 00	 jmp	 call
match_expand ENDP
_TEXT	ENDS
EXTRN	_Py_FalseStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_group DD imagerel match_group
	DD	imagerel match_group+189
	DD	imagerel $unwind$match_group
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_group DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0d0143218H
	DD	07010c012H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT match_group
_TEXT	SEGMENT
self$ = 64
args$ = 72
match_group PROC					; COMDAT

; 3275 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3276 :     PyObject* result;
; 3277 :     Py_ssize_t i, size;
; 3278 : 
; 3279 :     size = PyTuple_GET_SIZE(args);

  00018	48 8b 6a 60	 mov	 rbp, QWORD PTR [rdx+96]
  0001c	4c 8b e2	 mov	 r12, rdx
  0001f	4c 8b e9	 mov	 r13, rcx

; 3280 : 
; 3281 :     switch (size) {

  00022	48 8b c5	 mov	 rax, rbp
  00025	48 85 ed	 test	 rbp, rbp
  00028	74 61		 je	 SHORT $LN8@match_grou
  0002a	48 ff c8	 dec	 rax
  0002d	74 56		 je	 SHORT $LN7@match_grou

; 3288 :     default:
; 3289 :         /* fetch multiple items */
; 3290 :         result = PyTuple_New(size);

  0002f	48 8b cd	 mov	 rcx, rbp
  00032	e8 00 00 00 00	 call	 PyTuple_New
  00037	48 8b f0	 mov	 rsi, rax

; 3291 :         if (!result)

  0003a	48 85 c0	 test	 rax, rax

; 3292 :             return NULL;

  0003d	74 42		 je	 SHORT $LN17@match_grou

; 3293 :         for (i = 0; i < size; i++) {

  0003f	33 ff		 xor	 edi, edi
  00041	48 85 ed	 test	 rbp, rbp
  00044	7e 5b		 jle	 SHORT $LN9@match_grou
  00046	48 8d 58 70	 lea	 rbx, QWORD PTR [rax+112]
  0004a	4c 2b e0	 sub	 r12, rax
  0004d	0f 1f 00	 npad	 3
$LL4@match_grou:

; 3294 :             PyObject* item = match_getslice(
; 3295 :                 self, PyTuple_GET_ITEM(args, i), Py_None
; 3296 :                 );

  00050	49 8b 14 1c	 mov	 rdx, QWORD PTR [r12+rbx]
  00054	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_NoneStruct
  0005b	49 8b cd	 mov	 rcx, r13
  0005e	e8 00 00 00 00	 call	 match_getslice

; 3297 :             if (!item) {

  00063	48 85 c0	 test	 rax, rax
  00066	74 11		 je	 SHORT $LN14@match_grou

; 3300 :             }
; 3301 :             PyTuple_SET_ITEM(result, i, item);

  00068	48 ff c7	 inc	 rdi
  0006b	48 89 03	 mov	 QWORD PTR [rbx], rax
  0006e	48 83 c3 08	 add	 rbx, 8
  00072	48 3b fd	 cmp	 rdi, rbp
  00075	7c d9		 jl	 SHORT $LL4@match_grou

; 3297 :             if (!item) {

  00077	eb 28		 jmp	 SHORT $LN9@match_grou
$LN14@match_grou:

; 3298 :                 Py_DECREF(result);

  00079	48 8b ce	 mov	 rcx, rsi
  0007c	e8 00 00 00 00	 call	 _Py_DecRef
$LN17@match_grou:

; 3299 :                 return NULL;

  00081	33 c0		 xor	 eax, eax
  00083	eb 1f		 jmp	 SHORT $LN11@match_grou
$LN7@match_grou:

; 3284 :         break;
; 3285 :     case 1:
; 3286 :         result = match_getslice(self, PyTuple_GET_ITEM(args, 0), Py_None);

  00085	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]

; 3287 :         break;

  00089	eb 07		 jmp	 SHORT $LN16@match_grou
$LN8@match_grou:

; 3282 :     case 0:
; 3283 :         result = match_getslice(self, Py_False, Py_None);

  0008b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_FalseStruct
$LN16@match_grou:
  00092	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_NoneStruct
  00099	e8 00 00 00 00	 call	 match_getslice
  0009e	48 8b f0	 mov	 rsi, rax
$LN9@match_grou:

; 3302 :         }
; 3303 :         break;
; 3304 :     }
; 3305 :     return result;

  000a1	48 8b c6	 mov	 rax, rsi
$LN11@match_grou:

; 3306 : }

  000a4	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a9	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000ae	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000b3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b7	41 5d		 pop	 r13
  000b9	41 5c		 pop	 r12
  000bb	5f		 pop	 rdi
  000bc	c3		 ret	 0
match_group ENDP
_TEXT	ENDS
PUBLIC	??_C@_09PKLNFNAK@?$HMO?3groups?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_groups DD imagerel match_groups
	DD	imagerel match_groups+81
	DD	imagerel $unwind$match_groups
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$match_groups DD imagerel match_groups+81
	DD	imagerel match_groups+113
	DD	imagerel $chain$0$match_groups
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$match_groups DD imagerel match_groups+113
	DD	imagerel match_groups+208
	DD	imagerel $chain$4$match_groups
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$match_groups DD imagerel match_groups+208
	DD	imagerel match_groups+220
	DD	imagerel $chain$6$match_groups
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$match_groups DD 060021H
	DD	0a7400H
	DD	095400H
	DD	083400H
	DD	imagerel match_groups
	DD	imagerel match_groups+81
	DD	imagerel $unwind$match_groups
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$match_groups DD 060f21H
	DD	0a740fH
	DD	083405H
	DD	095400H
	DD	imagerel match_groups
	DD	imagerel match_groups+81
	DD	imagerel $unwind$match_groups
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$match_groups DD 020521H
	DD	095405H
	DD	imagerel match_groups
	DD	imagerel match_groups+81
	DD	imagerel $unwind$match_groups
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_groups DD 020601H
	DD	060025206H
xdata	ENDS
;	COMDAT ??_C@_09PKLNFNAK@?$HMO?3groups?$AA@
CONST	SEGMENT
??_C@_09PKLNFNAK@?$HMO?3groups?$AA@ DB '|O:groups', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT match_groups
_TEXT	SEGMENT
self$ = 64
args$ = 72
kw$ = 80
def$ = 88
match_groups PROC					; COMDAT

; 3310 : {

  00000	40 56		 push	 rsi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b f1	 mov	 rsi, rcx
  00009	49 8b c0	 mov	 rax, r8
  0000c	4c 8b d2	 mov	 r10, rdx

; 3311 :     PyObject* result;
; 3312 :     Py_ssize_t index;
; 3313 : 
; 3314 :     PyObject* def = Py_None;

  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct

; 3315 :     static char* kwlist[] = { "default", NULL };
; 3316 :     if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:groups", kwlist, &def))

  00016	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??match_groups@@9@9
  0001d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_09PKLNFNAK@?$HMO?3groups?$AA@
  00024	48 89 4c 24 58	 mov	 QWORD PTR def$[rsp], rcx
  00029	48 8d 4c 24 58	 lea	 rcx, QWORD PTR def$[rsp]
  0002e	48 8b d0	 mov	 rdx, rax
  00031	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00036	49 8b ca	 mov	 rcx, r10
  00039	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0003e	85 c0		 test	 eax, eax
  00040	75 08		 jne	 SHORT $LN6@match_grou@2

; 3317 :         return NULL;

  00042	33 c0		 xor	 eax, eax

; 3334 : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5e		 pop	 rsi
  00049	c3		 ret	 0
$LN6@match_grou@2:

; 3318 : 
; 3319 :     result = PyTuple_New(self->groups-1);

  0004a	48 8b 8e a0 00
	00 00		 mov	 rcx, QWORD PTR [rsi+160]
  00051	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  00056	48 ff c9	 dec	 rcx
  00059	e8 00 00 00 00	 call	 PyTuple_New
  0005e	48 8b e8	 mov	 rbp, rax

; 3320 :     if (!result)

  00061	48 85 c0	 test	 rax, rax
  00064	75 0b		 jne	 SHORT $LN5@match_grou@2
  00066	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]

; 3334 : }

  0006b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006f	5e		 pop	 rsi
  00070	c3		 ret	 0
$LN5@match_grou@2:
  00071	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 3321 :         return NULL;
; 3322 : 
; 3323 :     for (index = 1; index < self->groups; index++) {

  00076	bb 01 00 00 00	 mov	 ebx, 1
  0007b	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00080	48 3b 9e a0 00
	00 00		 cmp	 rbx, QWORD PTR [rsi+160]
  00087	7d 2f		 jge	 SHORT $LN2@match_grou@2
  00089	48 8d 78 70	 lea	 rdi, QWORD PTR [rax+112]
  0008d	0f 1f 00	 npad	 3
$LL4@match_grou@2:

; 3324 :         PyObject* item;
; 3325 :         item = match_getslice_by_index(self, index, def);

  00090	4c 8b 44 24 58	 mov	 r8, QWORD PTR def$[rsp]
  00095	48 8b d3	 mov	 rdx, rbx
  00098	48 8b ce	 mov	 rcx, rsi
  0009b	e8 00 00 00 00	 call	 match_getslice_by_index

; 3326 :         if (!item) {

  000a0	48 85 c0	 test	 rax, rax
  000a3	74 2b		 je	 SHORT $LN10@match_grou@2

; 3329 :         }
; 3330 :         PyTuple_SET_ITEM(result, index-1, item);

  000a5	48 89 07	 mov	 QWORD PTR [rdi], rax
  000a8	48 ff c3	 inc	 rbx
  000ab	48 83 c7 08	 add	 rdi, 8
  000af	48 3b 9e a0 00
	00 00		 cmp	 rbx, QWORD PTR [rsi+160]
  000b6	7c d8		 jl	 SHORT $LL4@match_grou@2
$LN2@match_grou@2:

; 3331 :     }
; 3332 : 
; 3333 :     return result;

  000b8	48 8b c5	 mov	 rax, rbp
$LN14@match_grou@2:
  000bb	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c0	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  000c5	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]

; 3334 : }

  000ca	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ce	5e		 pop	 rsi
  000cf	c3		 ret	 0
$LN10@match_grou@2:

; 3327 :             Py_DECREF(result);

  000d0	48 8b cd	 mov	 rcx, rbp
  000d3	e8 00 00 00 00	 call	 _Py_DecRef

; 3328 :             return NULL;

  000d8	33 c0		 xor	 eax, eax
  000da	eb df		 jmp	 SHORT $LN14@match_grou@2
match_groups ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@CCHOFDJE@?$HMO?3groupdict?$AA@		; `string'
EXTRN	PyDict_SetItem:PROC
EXTRN	PyMapping_Keys:PROC
EXTRN	PyDict_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$match_groupdict DD imagerel match_groupdict
	DD	imagerel match_groupdict+75
	DD	imagerel $unwind$match_groupdict
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$match_groupdict DD imagerel match_groupdict+75
	DD	imagerel match_groupdict+117
	DD	imagerel $chain$0$match_groupdict
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$match_groupdict DD imagerel match_groupdict+117
	DD	imagerel match_groupdict+366
	DD	imagerel $chain$4$match_groupdict
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$match_groupdict DD imagerel match_groupdict+366
	DD	imagerel match_groupdict+378
	DD	imagerel $chain$5$match_groupdict
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$match_groupdict DD imagerel match_groupdict+378
	DD	imagerel match_groupdict+400
	DD	imagerel $chain$7$match_groupdict
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$match_groupdict DD 0a0021H
	DD	06c400H
	DD	077400H
	DD	0c6400H
	DD	0b5400H
	DD	0a3400H
	DD	imagerel match_groupdict
	DD	imagerel match_groupdict+75
	DD	imagerel $unwind$match_groupdict
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$match_groupdict DD 021H
	DD	imagerel match_groupdict+75
	DD	imagerel match_groupdict+117
	DD	imagerel $chain$0$match_groupdict
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$match_groupdict DD 081421H
	DD	06c414H
	DD	07740fH
	DD	0c640aH
	DD	0a3405H
	DD	imagerel match_groupdict+75
	DD	imagerel match_groupdict+117
	DD	imagerel $chain$0$match_groupdict
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$match_groupdict DD 020521H
	DD	0b5405H
	DD	imagerel match_groupdict
	DD	imagerel match_groupdict+75
	DD	imagerel $unwind$match_groupdict
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_groupdict DD 020601H
	DD	0d0027206H
xdata	ENDS
;	COMDAT ??_C@_0N@CCHOFDJE@?$HMO?3groupdict?$AA@
CONST	SEGMENT
??_C@_0N@CCHOFDJE@?$HMO?3groupdict?$AA@ DB '|O:groupdict', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_sre.c
CONST	ENDS
;	COMDAT match_groupdict
_TEXT	SEGMENT
self$ = 80
args$ = 88
kw$ = 96
def$ = 104
match_groupdict PROC					; COMDAT

; 3338 : {

  00000	41 55		 push	 r13
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00006	4c 8b e9	 mov	 r13, rcx
  00009	49 8b c0	 mov	 rax, r8
  0000c	4c 8b d2	 mov	 r10, rdx

; 3339 :     PyObject* result;
; 3340 :     PyObject* keys;
; 3341 :     Py_ssize_t index;
; 3342 : 
; 3343 :     PyObject* def = Py_None;

  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct

; 3344 :     static char* kwlist[] = { "default", NULL };
; 3345 :     if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:groupdict", kwlist, &def))

  00016	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??match_groupdict@@9@9
  0001d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@CCHOFDJE@?$HMO?3groupdict?$AA@
  00024	48 89 4c 24 68	 mov	 QWORD PTR def$[rsp], rcx
  00029	48 8d 4c 24 68	 lea	 rcx, QWORD PTR def$[rsp]
  0002e	48 8b d0	 mov	 rdx, rax
  00031	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00036	49 8b ca	 mov	 rcx, r10
  00039	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0003e	85 c0		 test	 eax, eax
  00040	75 09		 jne	 SHORT $LN14@match_grou@3

; 3346 :         return NULL;

  00042	33 c0		 xor	 eax, eax

; 3382 : }

  00044	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00048	41 5d		 pop	 r13
  0004a	c3		 ret	 0
$LN14@match_grou@3:
  0004b	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp

; 3347 : 
; 3348 :     result = PyDict_New();

  00050	e8 00 00 00 00	 call	 PyDict_New
  00055	48 8b e8	 mov	 rbp, rax

; 3349 :     if (!result || !self->pattern->groupindex)

  00058	48 85 c0	 test	 rax, rax
  0005b	0f 84 0d 01 00
	00		 je	 $LN33@match_grou@3
  00061	49 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR [r13+128]
  00068	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  0006c	48 85 c9	 test	 rcx, rcx
  0006f	0f 84 f9 00 00
	00		 je	 $LN33@match_grou@3

; 3350 :         return result;
; 3351 : 
; 3352 :     keys = PyMapping_Keys(self->pattern->groupindex);

  00075	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  0007a	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  0007f	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00084	4c 89 64 24 30	 mov	 QWORD PTR [rsp+48], r12
  00089	e8 00 00 00 00	 call	 PyMapping_Keys
  0008e	48 8b f8	 mov	 rdi, rax

; 3353 :     if (!keys)

  00091	48 85 c0	 test	 rax, rax
  00094	0f 84 b6 00 00
	00		 je	 $LN3@match_grou@3

; 3354 :         goto failed;
; 3355 : 
; 3356 :     for (index = 0; index < PyList_GET_SIZE(keys); index++) {

  0009a	33 f6		 xor	 esi, esi
  0009c	48 39 70 60	 cmp	 QWORD PTR [rax+96], rsi
  000a0	7e 4a		 jle	 SHORT $LN8@match_grou@3
$LL10@match_grou@3:

; 3357 :         int status;
; 3358 :         PyObject* key;
; 3359 :         PyObject* value;
; 3360 :         key = PyList_GET_ITEM(keys, index);

  000a2	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  000a6	48 8b 1c f1	 mov	 rbx, QWORD PTR [rcx+rsi*8]

; 3361 :         if (!key)

  000aa	48 85 db	 test	 rbx, rbx
  000ad	74 52		 je	 SHORT $failed$25202

; 3362 :             goto failed;
; 3363 :         value = match_getslice(self, key, def);

  000af	4c 8b 44 24 68	 mov	 r8, QWORD PTR def$[rsp]
  000b4	48 8b d3	 mov	 rdx, rbx
  000b7	49 8b cd	 mov	 rcx, r13
  000ba	e8 00 00 00 00	 call	 match_getslice
  000bf	4c 8b e0	 mov	 r12, rax

; 3364 :         if (!value) {

  000c2	48 85 c0	 test	 rax, rax
  000c5	74 32		 je	 SHORT $LN30@match_grou@3

; 3366 :             goto failed;
; 3367 :         }
; 3368 :         status = PyDict_SetItem(result, key, value);

  000c7	4c 8b c0	 mov	 r8, rax
  000ca	48 8b d3	 mov	 rdx, rbx
  000cd	48 8b cd	 mov	 rcx, rbp
  000d0	e8 00 00 00 00	 call	 PyDict_SetItem

; 3369 :         Py_DECREF(value);

  000d5	49 8b cc	 mov	 rcx, r12
  000d8	8b d8		 mov	 ebx, eax
  000da	e8 00 00 00 00	 call	 _Py_DecRef

; 3370 :         if (status < 0)

  000df	85 db		 test	 ebx, ebx
  000e1	78 1e		 js	 SHORT $failed$25202

; 3354 :         goto failed;
; 3355 : 
; 3356 :     for (index = 0; index < PyList_GET_SIZE(keys); index++) {

  000e3	48 ff c6	 inc	 rsi
  000e6	48 3b 77 60	 cmp	 rsi, QWORD PTR [rdi+96]
  000ea	7c b6		 jl	 SHORT $LL10@match_grou@3
$LN8@match_grou@3:

; 3371 :             goto failed;
; 3372 :     }
; 3373 : 
; 3374 :     Py_DECREF(keys);

  000ec	48 8b cf	 mov	 rcx, rdi
  000ef	e8 00 00 00 00	 call	 _Py_DecRef

; 3375 : 
; 3376 :     return result;

  000f4	48 8b c5	 mov	 rax, rbp
  000f7	eb 61		 jmp	 SHORT $LN37@match_grou@3
$LN30@match_grou@3:

; 3365 :             Py_DECREF(key);

  000f9	48 8b cb	 mov	 rcx, rbx
  000fc	e8 00 00 00 00	 call	 _Py_DecRef
$failed$25202:

; 3377 : 
; 3378 : failed:
; 3379 :     Py_XDECREF(keys);

  00101	e8 00 00 00 00	 call	 _Py_PXCTX
  00106	85 c0		 test	 eax, eax
  00108	75 46		 jne	 SHORT $LN3@match_grou@3
  0010a	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0010e	a8 20		 test	 al, 32			; 00000020H
  00110	75 74		 jne	 SHORT $LN21@match_grou@3
  00112	84 c0		 test	 al, al
  00114	78 70		 js	 SHORT $LN21@match_grou@3
  00116	a8 02		 test	 al, 2
  00118	75 36		 jne	 SHORT $LN3@match_grou@3
  0011a	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0011e	75 30		 jne	 SHORT $LN3@match_grou@3
  00120	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0012e	4c 8b cf	 mov	 r9, rdi
  00131	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00137	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0013f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00144	48 8b cf	 mov	 rcx, rdi
  00147	85 c0		 test	 eax, eax
  00149	74 2f		 je	 SHORT $LN26@match_grou@3
  0014b	e8 00 00 00 00	 call	 _Px_Dealloc
$LN3@match_grou@3:

; 3380 :     Py_DECREF(result);

  00150	48 8b cd	 mov	 rcx, rbp
  00153	e8 00 00 00 00	 call	 _Py_DecRef

; 3381 :     return NULL;

  00158	33 c0		 xor	 eax, eax
$LN37@match_grou@3:
  0015a	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  0015f	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00164	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00169	4c 8b 64 24 30	 mov	 r12, QWORD PTR [rsp+48]
$LN33@match_grou@3:
  0016e	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]

; 3382 : }

  00173	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00177	41 5d		 pop	 r13
  00179	c3		 ret	 0

; 3377 : 
; 3378 : failed:
; 3379 :     Py_XDECREF(keys);

$LN26@match_grou@3:
  0017a	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0017e	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00184	eb ca		 jmp	 SHORT $LN3@match_grou@3
$LN21@match_grou@3:
  00186	48 8b cf	 mov	 rcx, rdi
  00189	e8 00 00 00 00	 call	 Px_DecRef
  0018e	eb c0		 jmp	 SHORT $LN3@match_grou@3
match_groupdict ENDP
_TEXT	ENDS
EXTRN	PyLong_FromSsize_t:PROC
EXTRN	PyArg_UnpackTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_start DD imagerel match_start
	DD	imagerel match_start+135
	DD	imagerel $unwind$match_start
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_start DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT match_start
_TEXT	SEGMENT
self$ = 64
args$ = 72
index_$ = 80
match_start PROC					; COMDAT

; 3386 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx

; 3387 :     Py_ssize_t index;
; 3388 : 
; 3389 :     PyObject* index_ = NULL;
; 3390 :     if (!PyArg_UnpackTuple(args, "start", 0, 1, &index_))

  0000c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR index_$[rsp]
  00011	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05FAGFPHJG@start?$AA@
  0001d	41 b9 01 00 00
	00		 mov	 r9d, 1
  00023	48 8b c8	 mov	 rcx, rax
  00026	45 33 c0	 xor	 r8d, r8d
  00029	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR index_$[rsp], 0
  00032	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  00037	85 c0		 test	 eax, eax

; 3391 :         return NULL;

  00039	74 44		 je	 SHORT $LN6@match_star

; 3392 : 
; 3393 :     index = match_getindex(self, index_);

  0003b	48 8b 54 24 50	 mov	 rdx, QWORD PTR index_$[rsp]
  00040	48 8b cb	 mov	 rcx, rbx
  00043	e8 00 00 00 00	 call	 match_getindex

; 3394 : 
; 3395 :     if (index < 0 || index >= self->groups) {

  00048	48 85 c0	 test	 rax, rax
  0004b	78 1f		 js	 SHORT $LN1@match_star
  0004d	48 3b 83 a0 00
	00 00		 cmp	 rax, QWORD PTR [rbx+160]
  00054	7d 16		 jge	 SHORT $LN1@match_star

; 3401 :     }
; 3402 : 
; 3403 :     /* mark is -1 if group is undefined */
; 3404 :     return PyLong_FromSsize_t(self->mark[index*2]);

  00056	48 03 c0	 add	 rax, rax
  00059	48 8b 8c c3 a8
	00 00 00	 mov	 rcx, QWORD PTR [rbx+rax*8+168]
  00061	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 3405 : }

  00066	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006a	5b		 pop	 rbx
  0006b	c3		 ret	 0
$LN1@match_star:

; 3396 :         PyErr_SetString(
; 3397 :             PyExc_IndexError,
; 3398 :             "no such group"
; 3399 :             );

  0006c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@OOOHFIK@no?5such?5group?$AA@
  0007a	e8 00 00 00 00	 call	 PyErr_SetString
$LN6@match_star:

; 3400 :         return NULL;

  0007f	33 c0		 xor	 eax, eax

; 3405 : }

  00081	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00085	5b		 pop	 rbx
  00086	c3		 ret	 0
match_start ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_end DD imagerel match_end
	DD	imagerel match_end+135
	DD	imagerel $unwind$match_end
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_end DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT match_end
_TEXT	SEGMENT
self$ = 64
args$ = 72
index_$ = 80
match_end PROC						; COMDAT

; 3409 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx

; 3410 :     Py_ssize_t index;
; 3411 : 
; 3412 :     PyObject* index_ = NULL;
; 3413 :     if (!PyArg_UnpackTuple(args, "end", 0, 1, &index_))

  0000c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR index_$[rsp]
  00011	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03JBJLGPFL@end?$AA@
  0001d	41 b9 01 00 00
	00		 mov	 r9d, 1
  00023	48 8b c8	 mov	 rcx, rax
  00026	45 33 c0	 xor	 r8d, r8d
  00029	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR index_$[rsp], 0
  00032	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  00037	85 c0		 test	 eax, eax

; 3414 :         return NULL;

  00039	74 44		 je	 SHORT $LN6@match_end

; 3415 : 
; 3416 :     index = match_getindex(self, index_);

  0003b	48 8b 54 24 50	 mov	 rdx, QWORD PTR index_$[rsp]
  00040	48 8b cb	 mov	 rcx, rbx
  00043	e8 00 00 00 00	 call	 match_getindex

; 3417 : 
; 3418 :     if (index < 0 || index >= self->groups) {

  00048	48 85 c0	 test	 rax, rax
  0004b	78 1f		 js	 SHORT $LN1@match_end
  0004d	48 3b 83 a0 00
	00 00		 cmp	 rax, QWORD PTR [rbx+160]
  00054	7d 16		 jge	 SHORT $LN1@match_end

; 3424 :     }
; 3425 : 
; 3426 :     /* mark is -1 if group is undefined */
; 3427 :     return PyLong_FromSsize_t(self->mark[index*2+1]);

  00056	48 8d 48 0b	 lea	 rcx, QWORD PTR [rax+11]
  0005a	48 03 c9	 add	 rcx, rcx
  0005d	48 8b 0c cb	 mov	 rcx, QWORD PTR [rbx+rcx*8]
  00061	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 3428 : }

  00066	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006a	5b		 pop	 rbx
  0006b	c3		 ret	 0
$LN1@match_end:

; 3419 :         PyErr_SetString(
; 3420 :             PyExc_IndexError,
; 3421 :             "no such group"
; 3422 :             );

  0006c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@OOOHFIK@no?5such?5group?$AA@
  0007a	e8 00 00 00 00	 call	 PyErr_SetString
$LN6@match_end:

; 3423 :         return NULL;

  0007f	33 c0		 xor	 eax, eax

; 3428 : }

  00081	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00085	5b		 pop	 rbx
  00086	c3		 ret	 0
match_end ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_pair DD	imagerel _pair
	DD	imagerel _pair+118
	DD	imagerel $unwind$_pair
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_pair DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _pair
_TEXT	SEGMENT
i1$ = 48
i2$ = 56
_pair	PROC						; COMDAT

; 3432 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f9	 mov	 rdi, rcx

; 3433 :     PyObject* pair;
; 3434 :     PyObject* item;
; 3435 : 
; 3436 :     pair = PyTuple_New(2);

  00012	b9 02 00 00 00	 mov	 ecx, 2
  00017	48 8b f2	 mov	 rsi, rdx
  0001a	e8 00 00 00 00	 call	 PyTuple_New
  0001f	48 8b d8	 mov	 rbx, rax

; 3437 :     if (!pair)

  00022	48 85 c0	 test	 rax, rax

; 3438 :         return NULL;

  00025	74 3d		 je	 SHORT $LN6@pair

; 3439 : 
; 3440 :     item = PyLong_FromSsize_t(i1);

  00027	48 8b cf	 mov	 rcx, rdi
  0002a	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 3441 :     if (!item)

  0002f	48 85 c0	 test	 rax, rax
  00032	74 28		 je	 SHORT $error$25265

; 3442 :         goto error;
; 3443 :     PyTuple_SET_ITEM(pair, 0, item);
; 3444 : 
; 3445 :     item = PyLong_FromSsize_t(i2);

  00034	48 8b ce	 mov	 rcx, rsi
  00037	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax
  0003b	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 3446 :     if (!item)

  00040	48 85 c0	 test	 rax, rax
  00043	74 17		 je	 SHORT $error$25265

; 3447 :         goto error;
; 3448 :     PyTuple_SET_ITEM(pair, 1, item);

  00045	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax

; 3449 : 
; 3450 :     return pair;

  00049	48 8b c3	 mov	 rax, rbx

; 3454 :     return NULL;
; 3455 : }

  0004c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00051	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00056	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005a	5f		 pop	 rdi
  0005b	c3		 ret	 0
$error$25265:

; 3451 : 
; 3452 :   error:
; 3453 :     Py_DECREF(pair);

  0005c	48 8b cb	 mov	 rcx, rbx
  0005f	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@pair:

; 3454 :     return NULL;
; 3455 : }

  00064	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00069	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0006e	33 c0		 xor	 eax, eax
  00070	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00074	5f		 pop	 rdi
  00075	c3		 ret	 0
_pair	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_span DD imagerel match_span
	DD	imagerel match_span+146
	DD	imagerel $unwind$match_span
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_span DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT match_span
_TEXT	SEGMENT
self$ = 64
args$ = 72
index_$ = 80
match_span PROC						; COMDAT

; 3459 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx

; 3460 :     Py_ssize_t index;
; 3461 : 
; 3462 :     PyObject* index_ = NULL;
; 3463 :     if (!PyArg_UnpackTuple(args, "span", 0, 1, &index_))

  0000c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR index_$[rsp]
  00011	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04FOPLNFFP@span?$AA@
  0001d	41 b9 01 00 00
	00		 mov	 r9d, 1
  00023	48 8b c8	 mov	 rcx, rax
  00026	45 33 c0	 xor	 r8d, r8d
  00029	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR index_$[rsp], 0
  00032	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  00037	85 c0		 test	 eax, eax

; 3464 :         return NULL;

  00039	74 4f		 je	 SHORT $LN6@match_span

; 3465 : 
; 3466 :     index = match_getindex(self, index_);

  0003b	48 8b 54 24 50	 mov	 rdx, QWORD PTR index_$[rsp]
  00040	48 8b cb	 mov	 rcx, rbx
  00043	e8 00 00 00 00	 call	 match_getindex

; 3467 : 
; 3468 :     if (index < 0 || index >= self->groups) {

  00048	48 85 c0	 test	 rax, rax
  0004b	78 2a		 js	 SHORT $LN1@match_span
  0004d	48 3b 83 a0 00
	00 00		 cmp	 rax, QWORD PTR [rbx+160]
  00054	7d 21		 jge	 SHORT $LN1@match_span

; 3474 :     }
; 3475 : 
; 3476 :     /* marks are -1 if group is undefined */
; 3477 :     return _pair(self->mark[index*2], self->mark[index*2+1]);

  00056	48 8d 50 0b	 lea	 rdx, QWORD PTR [rax+11]
  0005a	48 03 c0	 add	 rax, rax
  0005d	48 8b 8c c3 a8
	00 00 00	 mov	 rcx, QWORD PTR [rbx+rax*8+168]
  00065	48 03 d2	 add	 rdx, rdx
  00068	48 8b 14 d3	 mov	 rdx, QWORD PTR [rbx+rdx*8]
  0006c	e8 00 00 00 00	 call	 _pair

; 3478 : }

  00071	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00075	5b		 pop	 rbx
  00076	c3		 ret	 0
$LN1@match_span:

; 3469 :         PyErr_SetString(
; 3470 :             PyExc_IndexError,
; 3471 :             "no such group"
; 3472 :             );

  00077	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  0007e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@OOOHFIK@no?5such?5group?$AA@
  00085	e8 00 00 00 00	 call	 PyErr_SetString
$LN6@match_span:

; 3473 :         return NULL;

  0008a	33 c0		 xor	 eax, eax

; 3478 : }

  0008c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00090	5b		 pop	 rbx
  00091	c3		 ret	 0
match_span ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$match_regs DD imagerel match_regs
	DD	imagerel match_regs+39
	DD	imagerel $unwind$match_regs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$match_regs DD imagerel match_regs+39
	DD	imagerel match_regs+295
	DD	imagerel $chain$5$match_regs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$match_regs DD imagerel match_regs+295
	DD	imagerel match_regs+315
	DD	imagerel $chain$7$match_regs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$match_regs DD 0c0021H
	DD	06f400H
	DD	07e400H
	DD	08c400H
	DD	0e7400H
	DD	0d6400H
	DD	0c5400H
	DD	imagerel match_regs
	DD	imagerel match_regs+39
	DD	imagerel $unwind$match_regs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$match_regs DD 0c2021H
	DD	06f420H
	DD	07e41bH
	DD	08c414H
	DD	0e740fH
	DD	0d640aH
	DD	0c5405H
	DD	imagerel match_regs
	DD	imagerel match_regs+39
	DD	imagerel $unwind$match_regs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_regs DD 030801H
	DD	0d0048208H
	DD	03002H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_sre.c
xdata	ENDS
;	COMDAT match_regs
_TEXT	SEGMENT
self$ = 96
match_regs PROC						; COMDAT

; 3482 : {

  00000	40 53		 push	 rbx
  00002	41 55		 push	 r13
  00004	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00008	4c 8b e9	 mov	 r13, rcx

; 3483 :     PyObject* regs;
; 3484 :     PyObject* item;
; 3485 :     Py_ssize_t index;
; 3486 : 
; 3487 :     regs = PyTuple_New(self->groups);

  0000b	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00012	e8 00 00 00 00	 call	 PyTuple_New
  00017	48 8b d8	 mov	 rbx, rax

; 3488 :     if (!regs)

  0001a	48 85 c0	 test	 rax, rax
  0001d	75 08		 jne	 SHORT $LN5@match_regs

; 3504 : }

  0001f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00023	41 5d		 pop	 r13
  00025	5b		 pop	 rbx
  00026	c3		 ret	 0
$LN5@match_regs:
  00027	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  0002c	48 89 74 24 68	 mov	 QWORD PTR [rsp+104], rsi
  00031	48 89 7c 24 70	 mov	 QWORD PTR [rsp+112], rdi
  00036	4c 89 64 24 40	 mov	 QWORD PTR [rsp+64], r12

; 3489 :         return NULL;
; 3490 : 
; 3491 :     for (index = 0; index < self->groups; index++) {

  0003b	33 ed		 xor	 ebp, ebp
  0003d	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  00042	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15
  00047	49 39 ad a0 00
	00 00		 cmp	 QWORD PTR [r13+160], rbp
  0004e	7e 6f		 jle	 SHORT $LN2@match_regs
  00050	4c 8d 60 70	 lea	 r12, QWORD PTR [rax+112]
  00054	49 8d b5 a8 00
	00 00		 lea	 rsi, QWORD PTR [r13+168]
  0005b	0f 1f 44 00 00	 npad	 5
$LL4@match_regs:

; 3492 :         item = _pair(self->mark[index*2], self->mark[index*2+1]);

  00060	4c 8b 7e 08	 mov	 r15, QWORD PTR [rsi+8]
  00064	4c 8b 36	 mov	 r14, QWORD PTR [rsi]
  00067	b9 02 00 00 00	 mov	 ecx, 2
  0006c	e8 00 00 00 00	 call	 PyTuple_New
  00071	48 8b f8	 mov	 rdi, rax
  00074	48 85 c0	 test	 rax, rax
  00077	0f 84 b2 00 00
	00		 je	 $LN18@match_regs
  0007d	49 8b ce	 mov	 rcx, r14
  00080	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  00085	48 85 c0	 test	 rax, rax
  00088	0f 84 99 00 00
	00		 je	 $error$28680
  0008e	49 8b cf	 mov	 rcx, r15
  00091	48 89 47 70	 mov	 QWORD PTR [rdi+112], rax
  00095	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  0009a	48 85 c0	 test	 rax, rax
  0009d	0f 84 84 00 00
	00		 je	 $error$28680
  000a3	48 89 47 78	 mov	 QWORD PTR [rdi+120], rax

; 3496 :         }
; 3497 :         PyTuple_SET_ITEM(regs, index, item);

  000a7	49 89 3c 24	 mov	 QWORD PTR [r12], rdi
  000ab	48 ff c5	 inc	 rbp
  000ae	49 83 c4 08	 add	 r12, 8
  000b2	48 83 c6 10	 add	 rsi, 16
  000b6	49 3b ad a0 00
	00 00		 cmp	 rbp, QWORD PTR [r13+160]
  000bd	7c a1		 jl	 SHORT $LL4@match_regs
$LN2@match_regs:

; 3498 :     }
; 3499 : 
; 3500 :     Py_INCREF(regs);

  000bf	e8 00 00 00 00	 call	 _Py_PXCTX
  000c4	85 c0		 test	 eax, eax
  000c6	75 32		 jne	 SHORT $LN14@match_regs
  000c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000d6	4c 8b cb	 mov	 r9, rbx
  000d9	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000df	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000e7	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ec	85 c0		 test	 eax, eax
  000ee	75 06		 jne	 SHORT $LN13@match_regs
  000f0	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000f4	74 04		 je	 SHORT $LN14@match_regs
$LN13@match_regs:
  000f6	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN14@match_regs:

; 3501 :     self->regs = regs;

  000fa	49 89 5d 78	 mov	 QWORD PTR [r13+120], rbx

; 3502 : 
; 3503 :     return regs;

  000fe	48 8b c3	 mov	 rax, rbx
$LN27@match_regs:
  00101	4c 8b 74 24 38	 mov	 r14, QWORD PTR [rsp+56]
  00106	4c 8b 64 24 40	 mov	 r12, QWORD PTR [rsp+64]
  0010b	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]
  00110	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00115	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  0011a	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]

; 3504 : }

  0011f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00123	41 5d		 pop	 r13
  00125	5b		 pop	 rbx
  00126	c3		 ret	 0

; 3492 :         item = _pair(self->mark[index*2], self->mark[index*2+1]);

$error$28680:
  00127	48 8b cf	 mov	 rcx, rdi
  0012a	e8 00 00 00 00	 call	 _Py_DecRef
$LN18@match_regs:

; 3493 :         if (!item) {
; 3494 :             Py_DECREF(regs);

  0012f	48 8b cb	 mov	 rcx, rbx
  00132	e8 00 00 00 00	 call	 _Py_DecRef

; 3495 :             return NULL;

  00137	33 c0		 xor	 eax, eax
  00139	eb c6		 jmp	 SHORT $LN27@match_regs
match_regs ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@OLIFHLDD@cannot?5copy?5this?5match?5object?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_copy DD imagerel match_copy
	DD	imagerel match_copy+30
	DD	imagerel $unwind$match_copy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_copy DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BO@OLIFHLDD@cannot?5copy?5this?5match?5object?$AA@
CONST	SEGMENT
??_C@_0BO@OLIFHLDD@cannot?5copy?5this?5match?5object?$AA@ DB 'cannot copy'
	DB	' this match object', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT match_copy
_TEXT	SEGMENT
self$ = 48
unused$ = 56
match_copy PROC						; COMDAT

; 3508 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3509 : #ifdef USE_BUILTIN_COPY
; 3510 :     MatchObject* copy;
; 3511 :     Py_ssize_t slots, offset;
; 3512 : 
; 3513 :     slots = 2 * (self->pattern->groups+1);
; 3514 : 
; 3515 :     copy = PyObject_NEW_VAR(MatchObject, &Match_Type, slots);
; 3516 :     if (!copy)
; 3517 :         return NULL;
; 3518 : 
; 3519 :     /* this value a constant, but any compiler should be able to
; 3520 :        figure that out all by itself */
; 3521 :     offset = offsetof(MatchObject, string);
; 3522 : 
; 3523 :     Py_XINCREF(self->pattern);
; 3524 :     Py_XINCREF(self->string);
; 3525 :     Py_XINCREF(self->regs);
; 3526 : 
; 3527 :     memcpy((char*) copy + offset, (char*) self + offset,
; 3528 :            sizeof(MatchObject) + slots * sizeof(Py_ssize_t) - offset);
; 3529 : 
; 3530 :     return (PyObject*) copy;
; 3531 : #else
; 3532 :     PyErr_SetString(PyExc_TypeError, "cannot copy this match object");

  00004	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0000b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@OLIFHLDD@cannot?5copy?5this?5match?5object?$AA@
  00012	e8 00 00 00 00	 call	 PyErr_SetString

; 3533 :     return NULL;

  00017	33 c0		 xor	 eax, eax

; 3534 : #endif
; 3535 : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
match_copy ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@MMIEPIHE@cannot?5deepcopy?5this?5match?5objec@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_deepcopy DD imagerel match_deepcopy
	DD	imagerel match_deepcopy+30
	DD	imagerel $unwind$match_deepcopy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_deepcopy DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CC@MMIEPIHE@cannot?5deepcopy?5this?5match?5objec@
CONST	SEGMENT
??_C@_0CC@MMIEPIHE@cannot?5deepcopy?5this?5match?5objec@ DB 'cannot deepc'
	DB	'opy this match object', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT match_deepcopy
_TEXT	SEGMENT
self$ = 48
memo$ = 56
match_deepcopy PROC					; COMDAT

; 3539 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3540 : #ifdef USE_BUILTIN_COPY
; 3541 :     MatchObject* copy;
; 3542 : 
; 3543 :     copy = (MatchObject*) match_copy(self);
; 3544 :     if (!copy)
; 3545 :         return NULL;
; 3546 : 
; 3547 :     if (!deepcopy((PyObject**) &copy->pattern, memo) ||
; 3548 :         !deepcopy(&copy->string, memo) ||
; 3549 :         !deepcopy(&copy->regs, memo)) {
; 3550 :         Py_DECREF(copy);
; 3551 :         return NULL;
; 3552 :     }
; 3553 : 
; 3554 : #else
; 3555 :     PyErr_SetString(PyExc_TypeError, "cannot deepcopy this match object");

  00004	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0000b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@MMIEPIHE@cannot?5deepcopy?5this?5match?5objec@
  00012	e8 00 00 00 00	 call	 PyErr_SetString

; 3556 :     return NULL;

  00017	33 c0		 xor	 eax, eax

; 3557 : #endif
; 3558 : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
match_deepcopy ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$match_lastindex_get DD imagerel match_lastindex_get
	DD	imagerel match_lastindex_get+106
	DD	imagerel $unwind$match_lastindex_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_lastindex_get DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_sre.c
xdata	ENDS
;	COMDAT match_lastindex_get
_TEXT	SEGMENT
self$ = 64
match_lastindex_get PROC				; COMDAT

; 3615 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3616 :     if (self->lastindex >= 0)

  00004	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  0000b	48 85 c9	 test	 rcx, rcx
  0000e	78 09		 js	 SHORT $LN1@match_last

; 3620 : }

  00010	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00014	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
$LN1@match_last:

; 3617 :         return PyLong_FromSsize_t(self->lastindex);
; 3618 :     Py_INCREF(Py_None);

  00019	e8 00 00 00 00	 call	 _Py_PXCTX
  0001e	85 c0		 test	 eax, eax
  00020	75 3c		 jne	 SHORT $LN5@match_last
  00022	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00037	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0003d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00045	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004a	85 c0		 test	 eax, eax
  0004c	75 09		 jne	 SHORT $LN4@match_last
  0004e	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00055	74 07		 je	 SHORT $LN5@match_last
$LN4@match_last:
  00057	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN5@match_last:

; 3619 :     return Py_None;

  0005e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 3620 : }

  00065	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00069	c3		 ret	 0
match_lastindex_get ENDP
_TEXT	ENDS
EXTRN	PySequence_GetItem:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$match_lastgroup_get DD imagerel match_lastgroup_get
	DD	imagerel match_lastgroup_get+134
	DD	imagerel $unwind$match_lastgroup_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_lastgroup_get DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_sre.c
xdata	ENDS
;	COMDAT match_lastgroup_get
_TEXT	SEGMENT
self$ = 64
match_lastgroup_get PROC				; COMDAT

; 3624 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3625 :     if (self->pattern->indexgroup && self->lastindex >= 0) {

  00004	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]
  0000b	4c 8b 80 80 00
	00 00		 mov	 r8, QWORD PTR [rax+128]
  00012	4d 85 c0	 test	 r8, r8
  00015	74 1e		 je	 SHORT $LN2@match_last@2
  00017	48 8b 91 98 00
	00 00		 mov	 rdx, QWORD PTR [rcx+152]
  0001e	48 85 d2	 test	 rdx, rdx
  00021	78 12		 js	 SHORT $LN2@match_last@2

; 3626 :         PyObject* result = PySequence_GetItem(
; 3627 :             self->pattern->indexgroup, self->lastindex
; 3628 :             );

  00023	49 8b c8	 mov	 rcx, r8
  00026	e8 00 00 00 00	 call	 PySequence_GetItem

; 3629 :         if (result)

  0002b	48 85 c0	 test	 rax, rax

; 3630 :             return result;

  0002e	75 51		 jne	 SHORT $LN3@match_last@2

; 3631 :         PyErr_Clear();

  00030	e8 00 00 00 00	 call	 PyErr_Clear
$LN2@match_last@2:

; 3632 :     }
; 3633 :     Py_INCREF(Py_None);

  00035	e8 00 00 00 00	 call	 _Py_PXCTX
  0003a	85 c0		 test	 eax, eax
  0003c	75 3c		 jne	 SHORT $LN6@match_last@2
  0003e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00053	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00059	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00061	e8 00 00 00 00	 call	 _PyParallel_Guard
  00066	85 c0		 test	 eax, eax
  00068	75 09		 jne	 SHORT $LN5@match_last@2
  0006a	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00071	74 07		 je	 SHORT $LN6@match_last@2
$LN5@match_last@2:
  00073	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN6@match_last@2:

; 3634 :     return Py_None;

  0007a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN3@match_last@2:

; 3635 : }

  00081	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00085	c3		 ret	 0
match_lastgroup_get ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$match_regs_get DD imagerel match_regs_get
	DD	imagerel match_regs_get+111
	DD	imagerel $unwind$match_regs_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_regs_get DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_sre.c
xdata	ENDS
;	COMDAT match_regs_get
_TEXT	SEGMENT
self$ = 64
match_regs_get PROC					; COMDAT

; 3639 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3640 :     if (self->regs) {

  0000a	48 8b 59 78	 mov	 rbx, QWORD PTR [rcx+120]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	48 85 db	 test	 rbx, rbx
  00014	74 4a		 je	 SHORT $LN2@match_regs@2

; 3641 :         Py_INCREF(self->regs);

  00016	e8 00 00 00 00	 call	 _Py_PXCTX
  0001b	85 c0		 test	 eax, eax
  0001d	75 32		 jne	 SHORT $LN6@match_regs@2
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0002d	4c 8b cb	 mov	 r9, rbx
  00030	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00036	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0003e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00043	85 c0		 test	 eax, eax
  00045	75 06		 jne	 SHORT $LN5@match_regs@2
  00047	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0004b	74 04		 je	 SHORT $LN6@match_regs@2
$LN5@match_regs@2:
  0004d	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN6@match_regs@2:

; 3642 :         return self->regs;

  00051	48 8b 47 78	 mov	 rax, QWORD PTR [rdi+120]

; 3643 :     } else
; 3644 :         return match_regs(self);
; 3645 : }

  00055	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0005a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005e	5f		 pop	 rdi
  0005f	c3		 ret	 0
$LN2@match_regs@2:
  00060	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00065	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00069	5f		 pop	 rdi
  0006a	e9 00 00 00 00	 jmp	 match_regs
match_regs_get ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$pattern_new_match DD imagerel pattern_new_match
	DD	imagerel pattern_new_match+29
	DD	imagerel $unwind$pattern_new_match
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$pattern_new_match DD imagerel pattern_new_match+29
	DD	imagerel pattern_new_match+139
	DD	imagerel $chain$0$pattern_new_match
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$pattern_new_match DD imagerel pattern_new_match+139
	DD	imagerel pattern_new_match+513
	DD	imagerel $chain$3$pattern_new_match
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$pattern_new_match DD imagerel pattern_new_match+513
	DD	imagerel pattern_new_match+623
	DD	imagerel $chain$4$pattern_new_match
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$pattern_new_match DD 021H
	DD	imagerel pattern_new_match
	DD	imagerel pattern_new_match+29
	DD	imagerel $unwind$pattern_new_match
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$pattern_new_match DD 040521H
	DD	085405H
	DD	096400H
	DD	imagerel pattern_new_match
	DD	imagerel pattern_new_match+29
	DD	imagerel $unwind$pattern_new_match
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$pattern_new_match DD 020521H
	DD	096405H
	DD	imagerel pattern_new_match
	DD	imagerel pattern_new_match+29
	DD	imagerel $unwind$pattern_new_match
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_new_match DD 040a01H
	DD	0a340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_sre.c
xdata	ENDS
;	COMDAT pattern_new_match
_TEXT	SEGMENT
pattern$ = 64
state$ = 72
status$ = 80
pattern_new_match PROC					; COMDAT

; 3700 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	48 8b f9	 mov	 rdi, rcx

; 3701 :     /* create match object (from state object) */
; 3702 : 
; 3703 :     MatchObject* match;
; 3704 :     Py_ssize_t i, j;
; 3705 :     char* base;
; 3706 :     int n;
; 3707 : 
; 3708 :     if (status > 0) {

  00010	45 85 c0	 test	 r8d, r8d
  00013	0f 8e e8 01 00
	00		 jle	 $LN30@pattern_ne

; 3709 : 
; 3710 :         /* create match object (with room for extra group marks) */
; 3711 :         /* coverity[ampersand_in_size] */
; 3712 :         match = PyObject_NEW_VAR(MatchObject, &Match_Type,
; 3713 :                                  2*(pattern->groups+1));

  00019	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  0001d	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00022	48 8d 74 00 02	 lea	 rsi, QWORD PTR [rax+rax+2]
  00027	e8 00 00 00 00	 call	 _Py_PXCTX
  0002c	85 c0		 test	 eax, eax
  0002e	74 11		 je	 SHORT $LN12@pattern_ne
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Match_Type
  00037	48 8b d6	 mov	 rdx, rsi
  0003a	e8 00 00 00 00	 call	 _PxObject_NewVar
  0003f	eb 32		 jmp	 SHORT $LN31@pattern_ne
$LN12@pattern_ne:
  00041	48 8b 0d 80 00
	00 00		 mov	 rcx, QWORD PTR Match_Type+128
  00048	48 8b 05 78 00
	00 00		 mov	 rax, QWORD PTR Match_Type+120
  0004f	48 0f af ce	 imul	 rcx, rsi
  00053	48 8d 4c 01 07	 lea	 rcx, QWORD PTR [rcx+rax+7]
  00058	48 83 e1 f8	 and	 rcx, -8
  0005c	e8 00 00 00 00	 call	 PyObject_Malloc
  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Match_Type
  00068	4c 8b c6	 mov	 r8, rsi
  0006b	48 8b c8	 mov	 rcx, rax
  0006e	e8 00 00 00 00	 call	 PyObject_InitVar
$LN31@pattern_ne:
  00073	48 8b f0	 mov	 rsi, rax

; 3714 :         if (!match)

  00076	48 85 c0	 test	 rax, rax
  00079	75 10		 jne	 SHORT $LN8@pattern_ne
  0007b	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 3758 :     return NULL;
; 3759 : }

  00080	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00085	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00089	5f		 pop	 rdi
  0008a	c3		 ret	 0
$LN8@pattern_ne:
  0008b	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp

; 3715 :             return NULL;
; 3716 : 
; 3717 :         Py_INCREF(pattern);

  00090	e8 00 00 00 00	 call	 _Py_PXCTX
  00095	85 c0		 test	 eax, eax
  00097	75 32		 jne	 SHORT $LN16@pattern_ne
  00099	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000a7	4c 8b cf	 mov	 r9, rdi
  000aa	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000b0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000b8	e8 00 00 00 00	 call	 _PyParallel_Guard
  000bd	85 c0		 test	 eax, eax
  000bf	75 06		 jne	 SHORT $LN15@pattern_ne
  000c1	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  000c5	74 04		 je	 SHORT $LN16@pattern_ne
$LN15@pattern_ne:
  000c7	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN16@pattern_ne:

; 3718 :         match->pattern = pattern;

  000cb	48 89 be 80 00
	00 00		 mov	 QWORD PTR [rsi+128], rdi

; 3719 : 
; 3720 :         Py_INCREF(state->string);

  000d2	48 8b 6b 20	 mov	 rbp, QWORD PTR [rbx+32]
  000d6	e8 00 00 00 00	 call	 _Py_PXCTX
  000db	85 c0		 test	 eax, eax
  000dd	75 32		 jne	 SHORT $LN20@pattern_ne
  000df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000ed	4c 8b cd	 mov	 r9, rbp
  000f0	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000f6	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000fe	e8 00 00 00 00	 call	 _PyParallel_Guard
  00103	85 c0		 test	 eax, eax
  00105	75 06		 jne	 SHORT $LN19@pattern_ne
  00107	f6 45 20 20	 test	 BYTE PTR [rbp+32], 32	; 00000020H
  0010b	74 04		 je	 SHORT $LN20@pattern_ne
$LN19@pattern_ne:
  0010d	48 ff 45 50	 inc	 QWORD PTR [rbp+80]
$LN20@pattern_ne:

; 3721 :         match->string = state->string;

  00111	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]

; 3722 : 
; 3723 :         match->regs = NULL;

  00115	45 33 c9	 xor	 r9d, r9d
  00118	48 89 46 70	 mov	 QWORD PTR [rsi+112], rax
  0011c	4c 89 4e 78	 mov	 QWORD PTR [rsi+120], r9

; 3724 :         match->groups = pattern->groups+1;

  00120	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]
  00124	48 ff c0	 inc	 rax
  00127	48 89 86 a0 00
	00 00		 mov	 QWORD PTR [rsi+160], rax

; 3725 : 
; 3726 :         /* fill in group slices */
; 3727 : 
; 3728 :         base = (char*) state->beginning;

  0012e	4c 8b 5b 08	 mov	 r11, QWORD PTR [rbx+8]

; 3729 :         n = state->charsize;
; 3730 : 
; 3731 :         match->mark[0] = ((char*) state->start - base) / n;

  00132	48 63 6b 3c	 movsxd	 rbp, DWORD PTR [rbx+60]
  00136	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0013a	49 2b c3	 sub	 rax, r11
  0013d	48 99		 cdq
  0013f	48 f7 fd	 idiv	 rbp
  00142	48 89 86 a8 00
	00 00		 mov	 QWORD PTR [rsi+168], rax

; 3732 :         match->mark[1] = ((char*) state->ptr - base) / n;

  00149	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0014c	49 2b c3	 sub	 rax, r11
  0014f	48 99		 cdq
  00151	48 f7 fd	 idiv	 rbp
  00154	48 89 86 b0 00
	00 00		 mov	 QWORD PTR [rsi+176], rax

; 3733 : 
; 3734 :         for (i = j = 0; i < pattern->groups; i++, j+=2)

  0015b	4c 39 4f 70	 cmp	 QWORD PTR [rdi+112], r9
  0015f	7e 67		 jle	 SHORT $LN5@pattern_ne
  00161	4c 8b d6	 mov	 r10, rsi
  00164	41 b8 01 00 00
	00		 mov	 r8d, 1
  0016a	48 8d 4b 58	 lea	 rcx, QWORD PTR [rbx+88]
  0016e	4c 2b d3	 sub	 r10, rbx
$LL7@pattern_ne:

; 3735 :             if (j+1 <= state->lastmark && state->mark[j] && state->mark[j+1]) {

  00171	4c 3b 43 48	 cmp	 r8, QWORD PTR [rbx+72]
  00175	7f 2e		 jg	 SHORT $LN4@pattern_ne
  00177	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]
  0017b	48 85 c0	 test	 rax, rax
  0017e	74 25		 je	 SHORT $LN4@pattern_ne
  00180	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  00184	74 1f		 je	 SHORT $LN4@pattern_ne

; 3736 :                 match->mark[j+2] = ((char*) state->mark[j] - base) / n;

  00186	49 2b c3	 sub	 rax, r11
  00189	48 99		 cdq
  0018b	48 f7 fd	 idiv	 rbp
  0018e	49 89 44 0a 60	 mov	 QWORD PTR [r10+rcx+96], rax

; 3737 :                 match->mark[j+3] = ((char*) state->mark[j+1] - base) / n;

  00193	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00196	49 2b c3	 sub	 rax, r11
  00199	48 99		 cdq
  0019b	48 f7 fd	 idiv	 rbp
  0019e	49 89 44 0a 68	 mov	 QWORD PTR [r10+rcx+104], rax

; 3738 :             } else

  001a3	eb 12		 jmp	 SHORT $LN6@pattern_ne
$LN4@pattern_ne:

; 3739 :                 match->mark[j+2] = match->mark[j+3] = -1; /* undefined */

  001a5	49 c7 44 0a 68
	ff ff ff ff	 mov	 QWORD PTR [r10+rcx+104], -1
  001ae	49 c7 44 0a 60
	ff ff ff ff	 mov	 QWORD PTR [r10+rcx+96], -1
$LN6@pattern_ne:

; 3733 : 
; 3734 :         for (i = j = 0; i < pattern->groups; i++, j+=2)

  001b7	49 ff c1	 inc	 r9
  001ba	48 83 c1 10	 add	 rcx, 16
  001be	49 83 c0 02	 add	 r8, 2
  001c2	4c 3b 4f 70	 cmp	 r9, QWORD PTR [rdi+112]
  001c6	7c a9		 jl	 SHORT $LL7@pattern_ne
$LN5@pattern_ne:

; 3740 : 
; 3741 :         match->pos = state->pos;

  001c8	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  001cc	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  001d1	48 89 86 88 00
	00 00		 mov	 QWORD PTR [rsi+136], rax

; 3742 :         match->endpos = state->endpos;

  001d8	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  001dc	48 89 86 90 00
	00 00		 mov	 QWORD PTR [rsi+144], rax

; 3743 : 
; 3744 :         match->lastindex = state->lastindex;

  001e3	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  001e7	48 89 86 98 00
	00 00		 mov	 QWORD PTR [rsi+152], rax

; 3745 : 
; 3746 :         return (PyObject*) match;

  001ee	48 8b c6	 mov	 rax, rsi
  001f1	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 3758 :     return NULL;
; 3759 : }

  001f6	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  001fb	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001ff	5f		 pop	 rdi
  00200	c3		 ret	 0
$LN30@pattern_ne:

; 3747 : 
; 3748 :     } else if (status == 0) {

  00201	75 57		 jne	 SHORT $LN1@pattern_ne

; 3749 : 
; 3750 :         /* no match */
; 3751 :         Py_INCREF(Py_None);

  00203	e8 00 00 00 00	 call	 _Py_PXCTX
  00208	85 c0		 test	 eax, eax
  0020a	75 3c		 jne	 SHORT $LN24@pattern_ne
  0020c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00213	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0021a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00221	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00227	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0022f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00234	85 c0		 test	 eax, eax
  00236	75 09		 jne	 SHORT $LN23@pattern_ne
  00238	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0023f	74 07		 je	 SHORT $LN24@pattern_ne
$LN23@pattern_ne:
  00241	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN24@pattern_ne:

; 3752 :         return Py_None;

  00248	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 3758 :     return NULL;
; 3759 : }

  0024f	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00254	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00258	5f		 pop	 rdi
  00259	c3		 ret	 0
$LN1@pattern_ne:

; 3753 : 
; 3754 :     }
; 3755 : 
; 3756 :     /* internal error */
; 3757 :     pattern_error(status);

  0025a	41 8b c8	 mov	 ecx, r8d
  0025d	e8 00 00 00 00	 call	 pattern_error

; 3758 :     return NULL;
; 3759 : }

  00262	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00267	33 c0		 xor	 eax, eax
  00269	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0026d	5f		 pop	 rdi
  0026e	c3		 ret	 0
pattern_new_match ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$scanner_dealloc DD imagerel scanner_dealloc
	DD	imagerel scanner_dealloc+186
	DD	imagerel $unwind$scanner_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$scanner_dealloc DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_sre.c
xdata	ENDS
;	COMDAT scanner_dealloc
_TEXT	SEGMENT
self$ = 64
scanner_dealloc PROC					; COMDAT

; 3767 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 3768 :     state_fini(&self->state);

  0000d	48 83 c1 68	 add	 rcx, 104		; 00000068H
  00011	e8 00 00 00 00	 call	 state_fini

; 3769 :     Py_XDECREF(self->pattern);

  00016	48 8b 5f 60	 mov	 rbx, QWORD PTR [rdi+96]
  0001a	48 85 db	 test	 rbx, rbx
  0001d	0f 84 85 00 00
	00		 je	 $LN3@scanner_de
  00023	e8 00 00 00 00	 call	 _Py_PXCTX
  00028	85 c0		 test	 eax, eax
  0002a	75 7c		 jne	 SHORT $LN3@scanner_de
  0002c	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00030	a8 20		 test	 al, 32			; 00000020H
  00032	75 6c		 jne	 SHORT $LN11@scanner_de
  00034	84 c0		 test	 al, al
  00036	78 68		 js	 SHORT $LN11@scanner_de
  00038	a8 02		 test	 al, 2
  0003a	75 6c		 jne	 SHORT $LN3@scanner_de
  0003c	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00040	75 66		 jne	 SHORT $LN3@scanner_de
  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00050	4c 8b cb	 mov	 r9, rbx
  00053	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00059	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00061	e8 00 00 00 00	 call	 _PyParallel_Guard
  00066	48 8b cb	 mov	 rcx, rbx
  00069	85 c0		 test	 eax, eax
  0006b	74 17		 je	 SHORT $LN16@scanner_de
  0006d	e8 00 00 00 00	 call	 _Px_Dealloc

; 3770 :     PyObject_DEL(self);

  00072	48 8b cf	 mov	 rcx, rdi

; 3771 : }

  00075	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0007a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007e	5f		 pop	 rdi
  0007f	e9 00 00 00 00	 jmp	 PyObject_Free

; 3769 :     Py_XDECREF(self->pattern);

$LN16@scanner_de:
  00084	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00088	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 3770 :     PyObject_DEL(self);

  0008e	48 8b cf	 mov	 rcx, rdi

; 3771 : }

  00091	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00096	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009a	5f		 pop	 rdi
  0009b	e9 00 00 00 00	 jmp	 PyObject_Free

; 3769 :     Py_XDECREF(self->pattern);

$LN11@scanner_de:
  000a0	48 8b cb	 mov	 rcx, rbx
  000a3	e8 00 00 00 00	 call	 Px_DecRef
$LN3@scanner_de:

; 3770 :     PyObject_DEL(self);

  000a8	48 8b cf	 mov	 rcx, rdi

; 3771 : }

  000ab	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b4	5f		 pop	 rdi
  000b5	e9 00 00 00 00	 jmp	 PyObject_Free
scanner_dealloc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$scanner_match DD imagerel scanner_match
	DD	imagerel scanner_match+224
	DD	imagerel $unwind$scanner_match
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$scanner_match DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT scanner_match
_TEXT	SEGMENT
self$ = 48
unused$ = 56
scanner_match PROC					; COMDAT

; 3775 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f9	 mov	 rdi, rcx

; 3776 :     SRE_STATE* state = &self->state;
; 3777 :     PyObject* match;
; 3778 :     int status;
; 3779 : 
; 3780 :     state_reset(state);

  00012	48 c7 81 b0 00
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rcx+176], -1
  0001d	48 c7 81 a8 00
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rcx+168], -1
  00028	48 c7 81 60 07
	00 00 00 00 00
	00		 mov	 QWORD PTR [rcx+1888], 0
  00033	48 83 c1 68	 add	 rcx, 104		; 00000068H
  00037	e8 00 00 00 00	 call	 data_stack_dealloc

; 3781 : 
; 3782 :     state->ptr = state->start;

  0003c	48 8b 47 78	 mov	 rax, QWORD PTR [rdi+120]

; 3783 : 
; 3784 :     if (state->logical_charsize == 1) {
; 3785 :         status = sre_match(state, PatternObject_GetCode(self->pattern));

  00040	48 8d 4f 68	 lea	 rcx, QWORD PTR [rdi+104]
  00044	48 89 47 68	 mov	 QWORD PTR [rdi+104], rax
  00048	48 8b 57 60	 mov	 rdx, QWORD PTR [rdi+96]
  0004c	48 81 c2 00 01
	00 00		 add	 rdx, 256		; 00000100H
  00053	83 bf a0 00 00
	00 01		 cmp	 DWORD PTR [rdi+160], 1
  0005a	75 0a		 jne	 SHORT $LN6@scanner_ma
  0005c	e8 00 00 00 00	 call	 sre_match
  00061	48 8b f0	 mov	 rsi, rax

; 3786 :     } else {

  00064	eb 07		 jmp	 SHORT $LN5@scanner_ma
$LN6@scanner_ma:

; 3787 :         status = sre_umatch(state, PatternObject_GetCode(self->pattern));

  00066	e8 00 00 00 00	 call	 sre_umatch
  0006b	8b f0		 mov	 esi, eax
$LN5@scanner_ma:

; 3788 :     }
; 3789 :     if (PyErr_Occurred())

  0006d	e8 00 00 00 00	 call	 PyErr_Occurred
  00072	48 85 c0	 test	 rax, rax
  00075	74 12		 je	 SHORT $LN4@scanner_ma

; 3790 :         return NULL;

  00077	33 c0		 xor	 eax, eax

; 3799 : 
; 3800 :     return match;
; 3801 : }

  00079	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00083	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00087	5f		 pop	 rdi
  00088	c3		 ret	 0
$LN4@scanner_ma:

; 3791 : 
; 3792 :     match = pattern_new_match((PatternObject*) self->pattern,
; 3793 :                                state, status);

  00089	48 8b 4f 60	 mov	 rcx, QWORD PTR [rdi+96]
  0008d	48 8d 57 68	 lea	 rdx, QWORD PTR [rdi+104]
  00091	44 8b c6	 mov	 r8d, esi
  00094	e8 00 00 00 00	 call	 pattern_new_match
  00099	4c 8b d8	 mov	 r11, rax

; 3794 : 
; 3795 :     if (status == 0 || state->ptr == state->start)

  0009c	85 f6		 test	 esi, esi
  0009e	74 1e		 je	 SHORT $LN2@scanner_ma
  000a0	48 8b 4f 68	 mov	 rcx, QWORD PTR [rdi+104]
  000a4	48 3b 4f 78	 cmp	 rcx, QWORD PTR [rdi+120]
  000a8	74 14		 je	 SHORT $LN2@scanner_ma

; 3797 :     else
; 3798 :         state->start = state->ptr;

  000aa	48 89 4f 78	 mov	 QWORD PTR [rdi+120], rcx

; 3799 : 
; 3800 :     return match;
; 3801 : }

  000ae	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b3	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000b8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bc	5f		 pop	 rdi
  000bd	c3		 ret	 0
$LN2@scanner_ma:

; 3796 :         state->start = (void*) ((char*) state->ptr + state->charsize);

  000be	48 63 87 a4 00
	00 00		 movsxd	 rax, DWORD PTR [rdi+164]

; 3799 : 
; 3800 :     return match;
; 3801 : }

  000c5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ca	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000cf	48 03 47 68	 add	 rax, QWORD PTR [rdi+104]
  000d3	48 89 47 78	 mov	 QWORD PTR [rdi+120], rax
  000d7	49 8b c3	 mov	 rax, r11
  000da	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000de	5f		 pop	 rdi
  000df	c3		 ret	 0
scanner_match ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$scanner_search DD imagerel scanner_search
	DD	imagerel scanner_search+224
	DD	imagerel $unwind$scanner_search
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$scanner_search DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT scanner_search
_TEXT	SEGMENT
self$ = 48
unused$ = 56
scanner_search PROC					; COMDAT

; 3806 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f9	 mov	 rdi, rcx

; 3807 :     SRE_STATE* state = &self->state;
; 3808 :     PyObject* match;
; 3809 :     int status;
; 3810 : 
; 3811 :     state_reset(state);

  00012	48 c7 81 b0 00
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rcx+176], -1
  0001d	48 c7 81 a8 00
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rcx+168], -1
  00028	48 c7 81 60 07
	00 00 00 00 00
	00		 mov	 QWORD PTR [rcx+1888], 0
  00033	48 83 c1 68	 add	 rcx, 104		; 00000068H
  00037	e8 00 00 00 00	 call	 data_stack_dealloc

; 3812 : 
; 3813 :     state->ptr = state->start;

  0003c	48 8b 47 78	 mov	 rax, QWORD PTR [rdi+120]

; 3814 : 
; 3815 :     if (state->logical_charsize == 1) {
; 3816 :         status = sre_search(state, PatternObject_GetCode(self->pattern));

  00040	48 8d 4f 68	 lea	 rcx, QWORD PTR [rdi+104]
  00044	48 89 47 68	 mov	 QWORD PTR [rdi+104], rax
  00048	48 8b 57 60	 mov	 rdx, QWORD PTR [rdi+96]
  0004c	48 81 c2 00 01
	00 00		 add	 rdx, 256		; 00000100H
  00053	83 bf a0 00 00
	00 01		 cmp	 DWORD PTR [rdi+160], 1
  0005a	75 0a		 jne	 SHORT $LN6@scanner_se
  0005c	e8 00 00 00 00	 call	 sre_search
  00061	48 8b f0	 mov	 rsi, rax

; 3817 :     } else {

  00064	eb 07		 jmp	 SHORT $LN5@scanner_se
$LN6@scanner_se:

; 3818 :         status = sre_usearch(state, PatternObject_GetCode(self->pattern));

  00066	e8 00 00 00 00	 call	 sre_usearch
  0006b	8b f0		 mov	 esi, eax
$LN5@scanner_se:

; 3819 :     }
; 3820 :     if (PyErr_Occurred())

  0006d	e8 00 00 00 00	 call	 PyErr_Occurred
  00072	48 85 c0	 test	 rax, rax
  00075	74 12		 je	 SHORT $LN4@scanner_se

; 3821 :         return NULL;

  00077	33 c0		 xor	 eax, eax

; 3830 : 
; 3831 :     return match;
; 3832 : }

  00079	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00083	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00087	5f		 pop	 rdi
  00088	c3		 ret	 0
$LN4@scanner_se:

; 3822 : 
; 3823 :     match = pattern_new_match((PatternObject*) self->pattern,
; 3824 :                                state, status);

  00089	48 8b 4f 60	 mov	 rcx, QWORD PTR [rdi+96]
  0008d	48 8d 57 68	 lea	 rdx, QWORD PTR [rdi+104]
  00091	44 8b c6	 mov	 r8d, esi
  00094	e8 00 00 00 00	 call	 pattern_new_match
  00099	4c 8b d8	 mov	 r11, rax

; 3825 : 
; 3826 :     if (status == 0 || state->ptr == state->start)

  0009c	85 f6		 test	 esi, esi
  0009e	74 1e		 je	 SHORT $LN2@scanner_se
  000a0	48 8b 4f 68	 mov	 rcx, QWORD PTR [rdi+104]
  000a4	48 3b 4f 78	 cmp	 rcx, QWORD PTR [rdi+120]
  000a8	74 14		 je	 SHORT $LN2@scanner_se

; 3828 :     else
; 3829 :         state->start = state->ptr;

  000aa	48 89 4f 78	 mov	 QWORD PTR [rdi+120], rcx

; 3830 : 
; 3831 :     return match;
; 3832 : }

  000ae	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b3	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000b8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bc	5f		 pop	 rdi
  000bd	c3		 ret	 0
$LN2@scanner_se:

; 3827 :         state->start = (void*) ((char*) state->ptr + state->charsize);

  000be	48 63 87 a4 00
	00 00		 movsxd	 rax, DWORD PTR [rdi+164]

; 3830 : 
; 3831 :     return match;
; 3832 : }

  000c5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ca	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000cf	48 03 47 68	 add	 rax, QWORD PTR [rdi+104]
  000d3	48 89 47 78	 mov	 QWORD PTR [rdi+120], rax
  000d7	49 8b c3	 mov	 rax, r11
  000da	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000de	5f		 pop	 rdi
  000df	c3		 ret	 0
scanner_search ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@MIGCLFHA@O?$HMnn?3scanner?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\objimpl.h
pdata	SEGMENT
$pdata$pattern_scanner DD imagerel pattern_scanner
	DD	imagerel pattern_scanner+100
	DD	imagerel $unwind$pattern_scanner
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$pattern_scanner DD imagerel pattern_scanner+100
	DD	imagerel pattern_scanner+234
	DD	imagerel $chain$0$pattern_scanner
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$pattern_scanner DD imagerel pattern_scanner+234
	DD	imagerel pattern_scanner+260
	DD	imagerel $chain$2$pattern_scanner
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$pattern_scanner DD 020021H
	DD	0c3400H
	DD	imagerel pattern_scanner
	DD	imagerel pattern_scanner+100
	DD	imagerel $unwind$pattern_scanner
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$pattern_scanner DD 020521H
	DD	0c3405H
	DD	imagerel pattern_scanner
	DD	imagerel pattern_scanner+100
	DD	imagerel $unwind$pattern_scanner
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_scanner DD 020801H
	DD	070049208H
xdata	ENDS
;	COMDAT ??_C@_0N@MIGCLFHA@O?$HMnn?3scanner?$AA@
CONST	SEGMENT
??_C@_0N@MIGCLFHA@O?$HMnn?3scanner?$AA@ DB 'O|nn:scanner', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_sre.c
CONST	ENDS
;	COMDAT pattern_scanner
_TEXT	SEGMENT
start$ = 64
string$ = 72
pattern$ = 96
args$ = 104
kw$ = 112
end$ = 120
pattern_scanner PROC					; COMDAT

; 3880 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	57		 push	 rdi
  00004	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00008	48 8b f9	 mov	 rdi, rcx
  0000b	49 8b c0	 mov	 rax, r8
  0000e	4c 8b d2	 mov	 r10, rdx

; 3881 :     /* create search state object */
; 3882 : 
; 3883 :     ScannerObject* self;
; 3884 : 
; 3885 :     PyObject* string;
; 3886 :     Py_ssize_t start = 0;
; 3887 :     Py_ssize_t end = PY_SSIZE_T_MAX;

  00011	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH

; 3888 :     static char* kwlist[] = { "source", "pos", "endpos", NULL };
; 3889 :     if (!PyArg_ParseTupleAndKeywords(args, kw, "O|nn:scanner", kwlist,
; 3890 :                                      &string, &start, &end))

  0001b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??pattern_scanner@@9@9
  00022	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@MIGCLFHA@O?$HMnn?3scanner?$AA@
  00029	49 89 4b 20	 mov	 QWORD PTR [r11+32], rcx
  0002d	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  00031	48 8b d0	 mov	 rdx, rax
  00034	49 89 4b d8	 mov	 QWORD PTR [r11-40], rcx
  00038	49 8d 4b e8	 lea	 rcx, QWORD PTR [r11-24]
  0003c	49 c7 43 e8 00
	00 00 00	 mov	 QWORD PTR [r11-24], 0
  00044	49 89 4b d0	 mov	 QWORD PTR [r11-48], rcx
  00048	49 8d 4b f0	 lea	 rcx, QWORD PTR [r11-16]
  0004c	49 89 4b c8	 mov	 QWORD PTR [r11-56], rcx
  00050	49 8b ca	 mov	 rcx, r10
  00053	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00058	85 c0		 test	 eax, eax
  0005a	75 08		 jne	 SHORT $LN3@pattern_sc

; 3891 :         return NULL;

  0005c	33 c0		 xor	 eax, eax

; 3909 : }

  0005e	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00062	5f		 pop	 rdi
  00063	c3		 ret	 0
$LN3@pattern_sc:
  00064	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx

; 3892 : 
; 3893 :     /* create scanner object */
; 3894 :     self = PyObject_NEW(ScannerObject, &Scanner_Type);

  00069	e8 00 00 00 00	 call	 _Py_PXCTX
  0006e	85 c0		 test	 eax, eax
  00070	74 0e		 je	 SHORT $LN6@pattern_sc
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Scanner_Type
  00079	e8 00 00 00 00	 call	 _PxObject_New
  0007e	eb 1b		 jmp	 SHORT $LN10@pattern_sc
$LN6@pattern_sc:
  00080	48 8b 0d 78 00
	00 00		 mov	 rcx, QWORD PTR Scanner_Type+120
  00087	e8 00 00 00 00	 call	 PyObject_Malloc
  0008c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Scanner_Type
  00093	48 8b c8	 mov	 rcx, rax
  00096	e8 00 00 00 00	 call	 PyObject_Init
$LN10@pattern_sc:
  0009b	48 8b d8	 mov	 rbx, rax

; 3895 :     if (!self)

  0009e	48 85 c0	 test	 rax, rax

; 3896 :         return NULL;

  000a1	74 3a		 je	 SHORT $LN11@pattern_sc

; 3897 :     self->pattern = NULL;

  000a3	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0

; 3898 : 
; 3899 :     string = state_init(&self->state, pattern, string, start, end);

  000ab	4c 8b 4c 24 40	 mov	 r9, QWORD PTR start$[rsp]
  000b0	4c 8b 44 24 48	 mov	 r8, QWORD PTR string$[rsp]
  000b5	48 8d 48 68	 lea	 rcx, QWORD PTR [rax+104]
  000b9	48 8b 44 24 78	 mov	 rax, QWORD PTR end$[rsp]
  000be	48 8b d7	 mov	 rdx, rdi
  000c1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c6	e8 00 00 00 00	 call	 state_init
  000cb	48 89 44 24 48	 mov	 QWORD PTR string$[rsp], rax

; 3900 :     if (!string) {

  000d0	48 85 c0	 test	 rax, rax
  000d3	75 15		 jne	 SHORT $LN1@pattern_sc

; 3901 :         Py_DECREF(self);

  000d5	48 8b cb	 mov	 rcx, rbx
  000d8	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@pattern_sc:

; 3902 :         return NULL;

  000dd	33 c0		 xor	 eax, eax
  000df	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 3909 : }

  000e4	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000e8	5f		 pop	 rdi
  000e9	c3		 ret	 0
$LN1@pattern_sc:

; 3903 :     }
; 3904 : 
; 3905 :     Py_INCREF(pattern);

  000ea	48 8b cf	 mov	 rcx, rdi
  000ed	e8 00 00 00 00	 call	 _Py_IncRef

; 3906 :     self->pattern = (PyObject*) pattern;

  000f2	48 89 7b 60	 mov	 QWORD PTR [rbx+96], rdi

; 3907 : 
; 3908 :     return (PyObject*) self;

  000f6	48 8b c3	 mov	 rax, rbx
  000f9	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 3909 : }

  000fe	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00102	5f		 pop	 rdi
  00103	c3		 ret	 0
pattern_scanner ENDP
_TEXT	ENDS
PUBLIC	??_C@_09JHBDCMB@copyright?$AA@			; `string'
PUBLIC	??_C@_09OIJCJPIM@MAXREPEAT?$AA@			; `string'
PUBLIC	??_C@_08JEAPHMON@CODESIZE?$AA@			; `string'
PUBLIC	??_C@_05DKLEPMBK@MAGIC?$AA@			; `string'
PUBLIC	PyInit__sre
EXTRN	PyLong_FromUnsignedLong:PROC
EXTRN	PyDict_SetItemString:PROC
EXTRN	PyLong_FromLong:PROC
EXTRN	PyModule_GetDict:PROC
EXTRN	PyModule_Create2:PROC
EXTRN	PyType_Ready:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit__sre DD imagerel $LN11
	DD	imagerel $LN11+76
	DD	imagerel $unwind$PyInit__sre
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyInit__sre DD imagerel $LN11+76
	DD	imagerel $LN11+104
	DD	imagerel $chain$0$PyInit__sre
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyInit__sre DD imagerel $LN11+104
	DD	imagerel $LN11+324
	DD	imagerel $chain$4$PyInit__sre
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$PyInit__sre DD imagerel $LN11+324
	DD	imagerel $LN11+331
	DD	imagerel $chain$5$PyInit__sre
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$PyInit__sre DD 021H
	DD	imagerel $LN11
	DD	imagerel $LN11+76
	DD	imagerel $unwind$PyInit__sre
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyInit__sre DD 060d21H
	DD	04740dH
	DD	076408H
	DD	063400H
	DD	imagerel $LN11
	DD	imagerel $LN11+76
	DD	imagerel $unwind$PyInit__sre
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyInit__sre DD 020521H
	DD	063405H
	DD	imagerel $LN11
	DD	imagerel $LN11+76
	DD	imagerel $unwind$PyInit__sre
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit__sre DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_09JHBDCMB@copyright?$AA@
CONST	SEGMENT
??_C@_09JHBDCMB@copyright?$AA@ DB 'copyright', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OIJCJPIM@MAXREPEAT?$AA@
CONST	SEGMENT
??_C@_09OIJCJPIM@MAXREPEAT?$AA@ DB 'MAXREPEAT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JEAPHMON@CODESIZE?$AA@
CONST	SEGMENT
??_C@_08JEAPHMON@CODESIZE?$AA@ DB 'CODESIZE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05DKLEPMBK@MAGIC?$AA@
CONST	SEGMENT
??_C@_05DKLEPMBK@MAGIC?$AA@ DB 'MAGIC', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyInit__sre
_TEXT	SEGMENT
PyInit__sre PROC					; COMDAT

; 3931 : {

$LN11:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3932 :     PyObject* m;
; 3933 :     PyObject* d;
; 3934 :     PyObject* x;
; 3935 : 
; 3936 :     /* Patch object types */
; 3937 :     if (PyType_Ready(&Pattern_Type) || PyType_Ready(&Match_Type) ||
; 3938 :         PyType_Ready(&Scanner_Type))

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Pattern_Type
  0000b	e8 00 00 00 00	 call	 PyType_Ready
  00010	85 c0		 test	 eax, eax
  00012	0f 85 2c 01 00
	00		 jne	 $LN6@PyInit__sr
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Match_Type
  0001f	e8 00 00 00 00	 call	 PyType_Ready
  00024	85 c0		 test	 eax, eax
  00026	0f 85 18 01 00
	00		 jne	 $LN6@PyInit__sr
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Scanner_Type
  00033	e8 00 00 00 00	 call	 PyType_Ready
  00038	85 c0		 test	 eax, eax
  0003a	0f 85 04 01 00
	00		 jne	 $LN6@PyInit__sr

; 3940 : 
; 3941 :     m = PyModule_Create(&sremodule);

  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sremodule
  00047	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  0004c	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00051	e8 00 00 00 00	 call	 PyModule_Create2
  00056	48 8b d8	 mov	 rbx, rax

; 3942 :     if (m == NULL)

  00059	48 85 c0	 test	 rax, rax
  0005c	75 0a		 jne	 SHORT $LN5@PyInit__sr
  0005e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 3970 : }

  00063	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00067	c3		 ret	 0
$LN5@PyInit__sr:

; 3943 :         return NULL;
; 3944 :     d = PyModule_GetDict(m);

  00068	48 8b c8	 mov	 rcx, rax
  0006b	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00070	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00075	e8 00 00 00 00	 call	 PyModule_GetDict

; 3945 : 
; 3946 :     x = PyLong_FromLong(SRE_MAGIC);

  0007a	b9 29 a6 31 01	 mov	 ecx, 20031017		; 0131a629H
  0007f	48 8b f0	 mov	 rsi, rax
  00082	e8 00 00 00 00	 call	 PyLong_FromLong
  00087	48 8b f8	 mov	 rdi, rax

; 3947 :     if (x) {

  0008a	48 85 c0	 test	 rax, rax
  0008d	74 1a		 je	 SHORT $LN4@PyInit__sr

; 3948 :         PyDict_SetItemString(d, "MAGIC", x);

  0008f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05DKLEPMBK@MAGIC?$AA@
  00096	4c 8b c0	 mov	 r8, rax
  00099	48 8b ce	 mov	 rcx, rsi
  0009c	e8 00 00 00 00	 call	 PyDict_SetItemString

; 3949 :         Py_DECREF(x);

  000a1	48 8b cf	 mov	 rcx, rdi
  000a4	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@PyInit__sr:

; 3950 :     }
; 3951 : 
; 3952 :     x = PyLong_FromLong(sizeof(SRE_CODE));

  000a9	b9 04 00 00 00	 mov	 ecx, 4
  000ae	e8 00 00 00 00	 call	 PyLong_FromLong
  000b3	48 8b f8	 mov	 rdi, rax

; 3953 :     if (x) {

  000b6	48 85 c0	 test	 rax, rax
  000b9	74 1a		 je	 SHORT $LN3@PyInit__sr

; 3954 :         PyDict_SetItemString(d, "CODESIZE", x);

  000bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08JEAPHMON@CODESIZE?$AA@
  000c2	4c 8b c0	 mov	 r8, rax
  000c5	48 8b ce	 mov	 rcx, rsi
  000c8	e8 00 00 00 00	 call	 PyDict_SetItemString

; 3955 :         Py_DECREF(x);

  000cd	48 8b cf	 mov	 rcx, rdi
  000d0	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyInit__sr:

; 3956 :     }
; 3957 : 
; 3958 :     x = PyLong_FromUnsignedLong(SRE_MAXREPEAT);

  000d5	83 c9 ff	 or	 ecx, -1			; ffffffffH
  000d8	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong
  000dd	48 8b f8	 mov	 rdi, rax

; 3959 :     if (x) {

  000e0	48 85 c0	 test	 rax, rax
  000e3	74 1a		 je	 SHORT $LN2@PyInit__sr

; 3960 :         PyDict_SetItemString(d, "MAXREPEAT", x);

  000e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09OIJCJPIM@MAXREPEAT?$AA@
  000ec	4c 8b c0	 mov	 r8, rax
  000ef	48 8b ce	 mov	 rcx, rsi
  000f2	e8 00 00 00 00	 call	 PyDict_SetItemString

; 3961 :         Py_DECREF(x);

  000f7	48 8b cf	 mov	 rcx, rdi
  000fa	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@PyInit__sr:

; 3962 :     }
; 3963 : 
; 3964 :     x = PyUnicode_FromString(copyright);

  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:copyright
  00106	e8 00 00 00 00	 call	 PyUnicode_FromString
  0010b	48 8b f8	 mov	 rdi, rax

; 3965 :     if (x) {

  0010e	48 85 c0	 test	 rax, rax
  00111	74 1a		 je	 SHORT $LN1@PyInit__sr

; 3966 :         PyDict_SetItemString(d, "copyright", x);

  00113	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09JHBDCMB@copyright?$AA@
  0011a	4c 8b c0	 mov	 r8, rax
  0011d	48 8b ce	 mov	 rcx, rsi
  00120	e8 00 00 00 00	 call	 PyDict_SetItemString

; 3967 :         Py_DECREF(x);

  00125	48 8b cf	 mov	 rcx, rdi
  00128	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyInit__sr:

; 3968 :     }
; 3969 :     return m;

  0012d	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  00132	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00137	48 8b c3	 mov	 rax, rbx
  0013a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 3970 : }

  0013f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00143	c3		 ret	 0
$LN6@PyInit__sr:

; 3939 :         return NULL;

  00144	33 c0		 xor	 eax, eax

; 3970 : }

  00146	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0014a	c3		 ret	 0
PyInit__sre ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@HDLODFOL@O?$HMnn?3match?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$pattern_match DD imagerel pattern_match
	DD	imagerel pattern_match+171
	DD	imagerel $unwind$pattern_match
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$pattern_match DD imagerel pattern_match+171
	DD	imagerel pattern_match+244
	DD	imagerel $chain$0$pattern_match
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$pattern_match DD imagerel pattern_match+244
	DD	imagerel pattern_match+287
	DD	imagerel $chain$2$pattern_match
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$pattern_match DD 020021H
	DD	0ee7400H
	DD	imagerel pattern_match
	DD	imagerel pattern_match+171
	DD	imagerel $unwind$pattern_match
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$pattern_match DD 020821H
	DD	0ee7408H
	DD	imagerel pattern_match
	DD	imagerel pattern_match+171
	DD	imagerel $unwind$pattern_match
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_match DD 030b01H
	DD	0ec010bH
	DD	03004H
xdata	ENDS
;	COMDAT ??_C@_0L@HDLODFOL@O?$HMnn?3match?$AA@
CONST	SEGMENT
??_C@_0L@HDLODFOL@O?$HMnn?3match?$AA@ DB 'O|nn:match', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT pattern_match
_TEXT	SEGMENT
string$ = 64
start$ = 72
state$ = 80
self$ = 1904
args$ = 1912
kw$ = 1920
end$ = 1928
pattern_match PROC					; COMDAT

; 1881 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	48 81 ec 60 07
	00 00		 sub	 rsp, 1888		; 00000760H
  0000b	48 8b d9	 mov	 rbx, rcx
  0000e	49 8b c0	 mov	 rax, r8
  00011	4c 8b d2	 mov	 r10, rdx

; 1882 :     SRE_STATE state;
; 1883 :     int status;
; 1884 : 
; 1885 :     PyObject* string;
; 1886 :     Py_ssize_t start = 0;
; 1887 :     Py_ssize_t end = PY_SSIZE_T_MAX;

  00014	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH

; 1888 :     static char* kwlist[] = { "pattern", "pos", "endpos", NULL };
; 1889 :     if (!PyArg_ParseTupleAndKeywords(args, kw, "O|nn:match", kwlist,
; 1890 :                                      &string, &start, &end))

  0001e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??pattern_match@@9@9
  00025	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@HDLODFOL@O?$HMnn?3match?$AA@
  0002c	49 89 4b 20	 mov	 QWORD PTR [r11+32], rcx
  00030	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  00034	48 8b d0	 mov	 rdx, rax
  00037	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0003c	48 8d 4c 24 48	 lea	 rcx, QWORD PTR start$[rsp]
  00041	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR start$[rsp], 0
  0004a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0004f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR string$[rsp]
  00054	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00059	49 8b ca	 mov	 rcx, r10
  0005c	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00061	85 c0		 test	 eax, eax
  00063	75 0b		 jne	 SHORT $LN5@pattern_ma
$LN9@pattern_ma:

; 1891 :         return NULL;

  00065	33 c0		 xor	 eax, eax

; 1914 : }

  00067	48 81 c4 60 07
	00 00		 add	 rsp, 1888		; 00000760H
  0006e	5b		 pop	 rbx
  0006f	c3		 ret	 0
$LN5@pattern_ma:

; 1892 : 
; 1893 :     string = state_init(&state, self, string, start, end);

  00070	48 8b 84 24 88
	07 00 00	 mov	 rax, QWORD PTR end$[rsp]
  00078	4c 8b 4c 24 48	 mov	 r9, QWORD PTR start$[rsp]
  0007d	4c 8b 44 24 40	 mov	 r8, QWORD PTR string$[rsp]
  00082	48 8d 4c 24 50	 lea	 rcx, QWORD PTR state$[rsp]
  00087	48 8b d3	 mov	 rdx, rbx
  0008a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008f	e8 00 00 00 00	 call	 state_init
  00094	48 89 44 24 40	 mov	 QWORD PTR string$[rsp], rax

; 1894 :     if (!string)

  00099	48 85 c0	 test	 rax, rax

; 1895 :         return NULL;

  0009c	74 c7		 je	 SHORT $LN9@pattern_ma

; 1896 : 
; 1897 :     state.ptr = state.start;
; 1898 : 
; 1899 :     TRACE(("|%p|%p|MATCH\n", PatternObject_GetCode(self), state.ptr));
; 1900 : 
; 1901 :     if (state.logical_charsize == 1) {

  0009e	83 bc 24 88 00
	00 00 01	 cmp	 DWORD PTR state$[rsp+56], 1
  000a6	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp+16]
  000ab	48 89 bc 24 70
	07 00 00	 mov	 QWORD PTR [rsp+1904], rdi
  000b3	48 89 44 24 50	 mov	 QWORD PTR state$[rsp], rax

; 1902 :         status = sre_match(&state, PatternObject_GetCode(self));

  000b8	48 8d 93 00 01
	00 00		 lea	 rdx, QWORD PTR [rbx+256]
  000bf	48 8d 4c 24 50	 lea	 rcx, QWORD PTR state$[rsp]
  000c4	75 0a		 jne	 SHORT $LN3@pattern_ma
  000c6	e8 00 00 00 00	 call	 sre_match
  000cb	48 8b f8	 mov	 rdi, rax

; 1903 :     } else {

  000ce	eb 07		 jmp	 SHORT $LN2@pattern_ma
$LN3@pattern_ma:

; 1904 :         status = sre_umatch(&state, PatternObject_GetCode(self));

  000d0	e8 00 00 00 00	 call	 sre_umatch
  000d5	8b f8		 mov	 edi, eax
$LN2@pattern_ma:

; 1905 :     }
; 1906 : 
; 1907 :     TRACE(("|%p|%p|END\n", PatternObject_GetCode(self), state.ptr));
; 1908 :     if (PyErr_Occurred())

  000d7	e8 00 00 00 00	 call	 PyErr_Occurred
  000dc	48 85 c0	 test	 rax, rax
  000df	74 13		 je	 SHORT $LN1@pattern_ma

; 1909 :         return NULL;

  000e1	33 c0		 xor	 eax, eax
  000e3	48 8b bc 24 70
	07 00 00	 mov	 rdi, QWORD PTR [rsp+1904]

; 1914 : }

  000eb	48 81 c4 60 07
	00 00		 add	 rsp, 1888		; 00000760H
  000f2	5b		 pop	 rbx
  000f3	c3		 ret	 0
$LN1@pattern_ma:

; 1910 : 
; 1911 :     state_fini(&state);

  000f4	48 8d 4c 24 50	 lea	 rcx, QWORD PTR state$[rsp]
  000f9	e8 00 00 00 00	 call	 state_fini

; 1912 : 
; 1913 :     return pattern_new_match(self, &state, status);

  000fe	48 8d 54 24 50	 lea	 rdx, QWORD PTR state$[rsp]
  00103	44 8b c7	 mov	 r8d, edi
  00106	48 8b cb	 mov	 rcx, rbx
  00109	e8 00 00 00 00	 call	 pattern_new_match
  0010e	48 8b bc 24 70
	07 00 00	 mov	 rdi, QWORD PTR [rsp+1904]

; 1914 : }

  00116	48 81 c4 60 07
	00 00		 add	 rsp, 1888		; 00000760H
  0011d	5b		 pop	 rbx
  0011e	c3		 ret	 0
pattern_match ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@HKAPAGAG@O?$HMnn?3search?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$pattern_search DD imagerel pattern_search
	DD	imagerel pattern_search+166
	DD	imagerel $unwind$pattern_search
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$pattern_search DD imagerel pattern_search+166
	DD	imagerel pattern_search+244
	DD	imagerel $chain$0$pattern_search
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$pattern_search DD imagerel pattern_search+244
	DD	imagerel pattern_search+277
	DD	imagerel $chain$2$pattern_search
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$pattern_search DD 020021H
	DD	0ee7400H
	DD	imagerel pattern_search
	DD	imagerel pattern_search+166
	DD	imagerel $unwind$pattern_search
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$pattern_search DD 020821H
	DD	0ee7408H
	DD	imagerel pattern_search
	DD	imagerel pattern_search+166
	DD	imagerel $unwind$pattern_search
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_search DD 030b01H
	DD	0ec010bH
	DD	03004H
xdata	ENDS
;	COMDAT ??_C@_0M@HKAPAGAG@O?$HMnn?3search?$AA@
CONST	SEGMENT
??_C@_0M@HKAPAGAG@O?$HMnn?3search?$AA@ DB 'O|nn:search', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT pattern_search
_TEXT	SEGMENT
string$ = 64
start$ = 72
state$ = 80
self$ = 1904
args$ = 1912
kw$ = 1920
end$ = 1928
pattern_search PROC					; COMDAT

; 1918 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	48 81 ec 60 07
	00 00		 sub	 rsp, 1888		; 00000760H
  0000b	48 8b d9	 mov	 rbx, rcx
  0000e	49 8b c0	 mov	 rax, r8
  00011	4c 8b d2	 mov	 r10, rdx

; 1919 :     SRE_STATE state;
; 1920 :     int status;
; 1921 : 
; 1922 :     PyObject* string;
; 1923 :     Py_ssize_t start = 0;
; 1924 :     Py_ssize_t end = PY_SSIZE_T_MAX;

  00014	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH

; 1925 :     static char* kwlist[] = { "pattern", "pos", "endpos", NULL };
; 1926 :     if (!PyArg_ParseTupleAndKeywords(args, kw, "O|nn:search", kwlist,
; 1927 :                                      &string, &start, &end))

  0001e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??pattern_search@@9@9
  00025	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0M@HKAPAGAG@O?$HMnn?3search?$AA@
  0002c	49 89 4b 20	 mov	 QWORD PTR [r11+32], rcx
  00030	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  00034	48 8b d0	 mov	 rdx, rax
  00037	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0003c	48 8d 4c 24 48	 lea	 rcx, QWORD PTR start$[rsp]
  00041	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR start$[rsp], 0
  0004a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0004f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR string$[rsp]
  00054	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00059	49 8b ca	 mov	 rcx, r10
  0005c	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00061	85 c0		 test	 eax, eax
  00063	75 0b		 jne	 SHORT $LN5@pattern_se
$LN9@pattern_se:

; 1928 :         return NULL;

  00065	33 c0		 xor	 eax, eax

; 1950 : }

  00067	48 81 c4 60 07
	00 00		 add	 rsp, 1888		; 00000760H
  0006e	5b		 pop	 rbx
  0006f	c3		 ret	 0
$LN5@pattern_se:

; 1929 : 
; 1930 :     string = state_init(&state, self, string, start, end);

  00070	48 8b 84 24 88
	07 00 00	 mov	 rax, QWORD PTR end$[rsp]
  00078	4c 8b 4c 24 48	 mov	 r9, QWORD PTR start$[rsp]
  0007d	4c 8b 44 24 40	 mov	 r8, QWORD PTR string$[rsp]
  00082	48 8d 4c 24 50	 lea	 rcx, QWORD PTR state$[rsp]
  00087	48 8b d3	 mov	 rdx, rbx
  0008a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008f	e8 00 00 00 00	 call	 state_init
  00094	48 89 44 24 40	 mov	 QWORD PTR string$[rsp], rax

; 1931 :     if (!string)

  00099	48 85 c0	 test	 rax, rax

; 1932 :         return NULL;

  0009c	74 c7		 je	 SHORT $LN9@pattern_se

; 1933 : 
; 1934 :     TRACE(("|%p|%p|SEARCH\n", PatternObject_GetCode(self), state.ptr));
; 1935 : 
; 1936 :     if (state.logical_charsize == 1) {

  0009e	83 bc 24 88 00
	00 00 01	 cmp	 DWORD PTR state$[rsp+56], 1
  000a6	48 89 bc 24 70
	07 00 00	 mov	 QWORD PTR [rsp+1904], rdi

; 1937 :         status = sre_search(&state, PatternObject_GetCode(self));

  000ae	48 8d 93 00 01
	00 00		 lea	 rdx, QWORD PTR [rbx+256]
  000b5	48 8d 4c 24 50	 lea	 rcx, QWORD PTR state$[rsp]
  000ba	75 0a		 jne	 SHORT $LN3@pattern_se
  000bc	e8 00 00 00 00	 call	 sre_search
  000c1	48 8b f8	 mov	 rdi, rax

; 1938 :     } else {

  000c4	eb 07		 jmp	 SHORT $LN2@pattern_se
$LN3@pattern_se:

; 1939 :         status = sre_usearch(&state, PatternObject_GetCode(self));

  000c6	e8 00 00 00 00	 call	 sre_usearch
  000cb	8b f8		 mov	 edi, eax
$LN2@pattern_se:

; 1940 :     }
; 1941 : 
; 1942 :     TRACE(("|%p|%p|END\n", PatternObject_GetCode(self), state.ptr));
; 1943 : 
; 1944 :     state_fini(&state);

  000cd	48 8d 4c 24 50	 lea	 rcx, QWORD PTR state$[rsp]
  000d2	e8 00 00 00 00	 call	 state_fini

; 1945 : 
; 1946 :     if (PyErr_Occurred())

  000d7	e8 00 00 00 00	 call	 PyErr_Occurred
  000dc	48 85 c0	 test	 rax, rax
  000df	74 13		 je	 SHORT $LN1@pattern_se

; 1947 :         return NULL;

  000e1	33 c0		 xor	 eax, eax
  000e3	48 8b bc 24 70
	07 00 00	 mov	 rdi, QWORD PTR [rsp+1904]

; 1950 : }

  000eb	48 81 c4 60 07
	00 00		 add	 rsp, 1888		; 00000760H
  000f2	5b		 pop	 rbx
  000f3	c3		 ret	 0
$LN1@pattern_se:

; 1948 : 
; 1949 :     return pattern_new_match(self, &state, status);

  000f4	48 8d 54 24 50	 lea	 rdx, QWORD PTR state$[rsp]
  000f9	44 8b c7	 mov	 r8d, edi
  000fc	48 8b cb	 mov	 rcx, rbx
  000ff	e8 00 00 00 00	 call	 pattern_new_match
  00104	48 8b bc 24 70
	07 00 00	 mov	 rdi, QWORD PTR [rsp+1904]

; 1950 : }

  0010c	48 81 c4 60 07
	00 00		 add	 rsp, 1888		; 00000760H
  00113	5b		 pop	 rbx
  00114	c3		 ret	 0
pattern_search ENDP
_TEXT	ENDS
EXTRN	PyCallIter_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$pattern_finditer DD imagerel pattern_finditer
	DD	imagerel pattern_finditer+35
	DD	imagerel $unwind$pattern_finditer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$pattern_finditer DD imagerel pattern_finditer+35
	DD	imagerel pattern_finditer+74
	DD	imagerel $chain$0$pattern_finditer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$pattern_finditer DD imagerel pattern_finditer+74
	DD	imagerel pattern_finditer+114
	DD	imagerel $chain$2$pattern_finditer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$pattern_finditer DD 020021H
	DD	067400H
	DD	imagerel pattern_finditer
	DD	imagerel pattern_finditer+35
	DD	imagerel $unwind$pattern_finditer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$pattern_finditer DD 020521H
	DD	067405H
	DD	imagerel pattern_finditer
	DD	imagerel pattern_finditer+35
	DD	imagerel $unwind$pattern_finditer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_finditer DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT pattern_finditer
_TEXT	SEGMENT
pattern$ = 48
args$ = 56
kw$ = 64
pattern_finditer PROC					; COMDAT

; 2151 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2152 :     PyObject* scanner;
; 2153 :     PyObject* search;
; 2154 :     PyObject* iterator;
; 2155 : 
; 2156 :     scanner = pattern_scanner(pattern, args, kw);

  00006	e8 00 00 00 00	 call	 pattern_scanner
  0000b	48 8b d8	 mov	 rbx, rax

; 2157 :     if (!scanner)

  0000e	48 85 c0	 test	 rax, rax
  00011	75 06		 jne	 SHORT $LN2@pattern_fi@2

; 2169 : }

  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5b		 pop	 rbx
  00018	c3		 ret	 0
$LN2@pattern_fi@2:

; 2158 :         return NULL;
; 2159 : 
; 2160 :     search = PyObject_GetAttrString(scanner, "search");

  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06GFPLNGOC@search?$AA@
  00020	48 8b c8	 mov	 rcx, rax
  00023	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00028	e8 00 00 00 00	 call	 PyObject_GetAttrString

; 2161 :     Py_DECREF(scanner);

  0002d	48 8b cb	 mov	 rcx, rbx
  00030	48 8b f8	 mov	 rdi, rax
  00033	e8 00 00 00 00	 call	 _Py_DecRef

; 2162 :     if (!search)

  00038	48 85 ff	 test	 rdi, rdi
  0003b	75 0d		 jne	 SHORT $LN1@pattern_fi@2

; 2163 :         return NULL;

  0003d	33 c0		 xor	 eax, eax
  0003f	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 2169 : }

  00044	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
$LN1@pattern_fi@2:

; 2164 : 
; 2165 :     iterator = PyCallIter_New(search, Py_None);

  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct
  00051	48 8b cf	 mov	 rcx, rdi
  00054	e8 00 00 00 00	 call	 PyCallIter_New

; 2166 :     Py_DECREF(search);

  00059	48 8b cf	 mov	 rcx, rdi
  0005c	48 8b d8	 mov	 rbx, rax
  0005f	e8 00 00 00 00	 call	 _Py_DecRef
  00064	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 2167 : 
; 2168 :     return iterator;

  00069	48 8b c3	 mov	 rax, rbx

; 2169 : }

  0006c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00070	5b		 pop	 rbx
  00071	c3		 ret	 0
pattern_finditer ENDP
_TEXT	ENDS
PUBLIC	??_C@_02IBMEMAAO@Nn?$AA@			; `string'
PUBLIC	??_C@_05PNMDMCHP@_subx?$AA@			; `string'
EXTRN	PyCallable_Check:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$pattern_subx DD imagerel pattern_subx
	DD	imagerel pattern_subx+419
	DD	imagerel $unwind$pattern_subx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$pattern_subx DD imagerel pattern_subx+419
	DD	imagerel pattern_subx+467
	DD	imagerel $chain$0$pattern_subx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$pattern_subx DD imagerel pattern_subx+467
	DD	imagerel pattern_subx+1168
	DD	imagerel $chain$1$pattern_subx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$pattern_subx DD imagerel pattern_subx+1168
	DD	imagerel pattern_subx+1192
	DD	imagerel $chain$2$pattern_subx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$pattern_subx DD 021H
	DD	imagerel pattern_subx+419
	DD	imagerel pattern_subx+467
	DD	imagerel $chain$0$pattern_subx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$pattern_subx DD 020821H
	DD	0ffd408H
	DD	imagerel pattern_subx+419
	DD	imagerel pattern_subx+467
	DD	imagerel $chain$0$pattern_subx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$pattern_subx DD 020821H
	DD	0f6f408H
	DD	imagerel pattern_subx
	DD	imagerel pattern_subx+419
	DD	imagerel $unwind$pattern_subx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_subx DD 082101H
	DD	0f70121H
	DD	0c010e012H
	DD	0600d700eH
	DD	0500b300cH
xdata	ENDS
;	COMDAT ??_C@_02IBMEMAAO@Nn?$AA@
CONST	SEGMENT
??_C@_02IBMEMAAO@Nn?$AA@ DB 'Nn', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PNMDMCHP@_subx?$AA@
CONST	SEGMENT
??_C@_05PNMDMCHP@_subx?$AA@ DB '_subx', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_sre.c
CONST	ENDS
;	COMDAT pattern_subx
_TEXT	SEGMENT
string$1$ = 48
logical_charsize$ = 48
$T29082 = 56
n$ = 56
charsize$ = 64
view$ = 80
state$ = 160
self$ = 2032
ptemplate$ = 2040
string$ = 2048
count$ = 2056
subn$ = 2064
pattern_subx PROC					; COMDAT

; 2286 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	53		 push	 rbx
  0000c	56		 push	 rsi
  0000d	57		 push	 rdi
  0000e	41 54		 push	 r12
  00010	41 56		 push	 r14
  00012	48 8d ac 24 48
	f9 ff ff	 lea	 rbp, QWORD PTR [rsp-1720]
  0001a	48 81 ec b8 07
	00 00		 sub	 rsp, 1976		; 000007b8H
  00021	4c 8b e1	 mov	 r12, rcx

; 2287 :     SRE_STATE state;
; 2288 :     PyObject* list;
; 2289 :     PyObject* item;
; 2290 :     PyObject* filter;
; 2291 :     PyObject* args;
; 2292 :     PyObject* match;
; 2293 :     void* ptr;
; 2294 :     int status;
; 2295 :     Py_ssize_t n;
; 2296 :     Py_ssize_t i, b, e;
; 2297 :     int logical_charsize, charsize;
; 2298 :     int filter_is_callable;
; 2299 :     Py_buffer view;
; 2300 : 
; 2301 :     if (PyCallable_Check(ptemplate)) {

  00024	48 8b ca	 mov	 rcx, rdx
  00027	4d 8b f1	 mov	 r14, r9
  0002a	49 8b f0	 mov	 rsi, r8
  0002d	48 8b da	 mov	 rbx, rdx
  00030	e8 00 00 00 00	 call	 PyCallable_Check
  00035	85 c0		 test	 eax, eax
  00037	74 48		 je	 SHORT $LN37@pattern_su

; 2302 :         /* sub/subn takes either a function or a template */
; 2303 :         filter = ptemplate;

  00039	48 8b fb	 mov	 rdi, rbx

; 2304 :         Py_INCREF(filter);

  0003c	e8 00 00 00 00	 call	 _Py_PXCTX
  00041	85 c0		 test	 eax, eax
  00043	75 32		 jne	 SHORT $LN41@pattern_su
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00053	4c 8b cb	 mov	 r9, rbx
  00056	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0005c	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00064	e8 00 00 00 00	 call	 _PyParallel_Guard
  00069	85 c0		 test	 eax, eax
  0006b	75 06		 jne	 SHORT $LN40@pattern_su
  0006d	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00071	74 04		 je	 SHORT $LN41@pattern_su
$LN40@pattern_su:
  00073	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN41@pattern_su:

; 2305 :         filter_is_callable = 1;

  00077	bb 01 00 00 00	 mov	 ebx, 1

; 2306 :     } else {

  0007c	e9 db 00 00 00	 jmp	 $LN31@pattern_su
$LN37@pattern_su:

; 2307 :         /* if not callable, check if it's a literal string */
; 2308 :         int literal;
; 2309 :         view.buf = NULL;
; 2310 :         ptr = getstring(ptemplate, &n, &logical_charsize, &charsize, &view);

  00081	48 8d 44 24 50	 lea	 rax, QWORD PTR view$[rsp]
  00086	4c 8d 4c 24 40	 lea	 r9, QWORD PTR charsize$[rsp]
  0008b	4c 8d 44 24 30	 lea	 r8, QWORD PTR logical_charsize$[rsp]
  00090	48 8d 54 24 38	 lea	 rdx, QWORD PTR n$[rsp]
  00095	48 8b cb	 mov	 rcx, rbx
  00098	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR view$[rsp], 0
  000a1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a6	e8 00 00 00 00	 call	 getstring

; 2311 :         b = charsize;
; 2312 :         if (ptr) {

  000ab	48 85 c0	 test	 rax, rax
  000ae	74 15		 je	 SHORT $LN35@pattern_su

; 2313 :             literal = sre_literal_template(b, ptr, n);

  000b0	4c 8b 44 24 38	 mov	 r8, QWORD PTR n$[rsp]
  000b5	8b 4c 24 40	 mov	 ecx, DWORD PTR charsize$[rsp]
  000b9	48 8b d0	 mov	 rdx, rax
  000bc	e8 00 00 00 00	 call	 sre_literal_template
  000c1	8b f8		 mov	 edi, eax

; 2314 :         } else {

  000c3	eb 07		 jmp	 SHORT $LN34@pattern_su
$LN35@pattern_su:

; 2315 :             PyErr_Clear();

  000c5	e8 00 00 00 00	 call	 PyErr_Clear

; 2316 :             literal = 0;

  000ca	33 ff		 xor	 edi, edi
$LN34@pattern_su:

; 2317 :         }
; 2318 :         if (view.buf)

  000cc	48 83 7c 24 50
	00		 cmp	 QWORD PTR view$[rsp], 0
  000d2	74 0a		 je	 SHORT $LN33@pattern_su

; 2319 :             PyBuffer_Release(&view);

  000d4	48 8d 4c 24 50	 lea	 rcx, QWORD PTR view$[rsp]
  000d9	e8 00 00 00 00	 call	 PyBuffer_Release
$LN33@pattern_su:

; 2320 :         if (literal) {

  000de	85 ff		 test	 edi, edi
  000e0	74 42		 je	 SHORT $LN32@pattern_su

; 2321 :             filter = ptemplate;

  000e2	48 8b fb	 mov	 rdi, rbx

; 2322 :             Py_INCREF(filter);

  000e5	e8 00 00 00 00	 call	 _Py_PXCTX
  000ea	85 c0		 test	 eax, eax
  000ec	75 32		 jne	 SHORT $LN45@pattern_su
  000ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000fc	4c 8b cb	 mov	 r9, rbx
  000ff	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00105	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0010d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00112	85 c0		 test	 eax, eax
  00114	75 06		 jne	 SHORT $LN44@pattern_su
  00116	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0011a	74 04		 je	 SHORT $LN45@pattern_su
$LN44@pattern_su:
  0011c	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN45@pattern_su:

; 2323 :             filter_is_callable = 0;

  00120	33 db		 xor	 ebx, ebx

; 2324 :         } else {

  00122	eb 38		 jmp	 SHORT $LN31@pattern_su
$LN32@pattern_su:

; 2325 :             /* not a literal; hand it over to the template compiler */
; 2326 :             filter = call(
; 2327 :                 SRE_PY_MODULE, "_subx",
; 2328 :                 PyTuple_Pack(2, self, ptemplate)
; 2329 :                 );

  00124	4c 8b c3	 mov	 r8, rbx
  00127	49 8b d4	 mov	 rdx, r12
  0012a	b9 02 00 00 00	 mov	 ecx, 2
  0012f	e8 00 00 00 00	 call	 PyTuple_Pack
  00134	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05PNMDMCHP@_subx?$AA@
  0013b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02EPEBAFDB@re?$AA@
  00142	4c 8b c0	 mov	 r8, rax
  00145	e8 00 00 00 00	 call	 call
  0014a	48 8b f8	 mov	 rdi, rax

; 2330 :             if (!filter)

  0014d	48 85 c0	 test	 rax, rax

; 2331 :                 return NULL;

  00150	74 3d		 je	 SHORT $LN69@pattern_su

; 2332 :             filter_is_callable = PyCallable_Check(filter);

  00152	48 8b c8	 mov	 rcx, rax
  00155	e8 00 00 00 00	 call	 PyCallable_Check
  0015a	8b d8		 mov	 ebx, eax
$LN31@pattern_su:

; 2333 :         }
; 2334 :     }
; 2335 : 
; 2336 :     string = state_init(&state, self, string, 0, PY_SSIZE_T_MAX);

  0015c	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00166	48 8d 4d a0	 lea	 rcx, QWORD PTR state$[rbp-256]
  0016a	45 33 c9	 xor	 r9d, r9d
  0016d	4c 8b c6	 mov	 r8, rsi
  00170	49 8b d4	 mov	 rdx, r12
  00173	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00178	e8 00 00 00 00	 call	 state_init
  0017d	48 89 44 24 30	 mov	 QWORD PTR string$1$[rsp], rax

; 2337 :     if (!string) {

  00182	48 85 c0	 test	 rax, rax
  00185	75 1a		 jne	 SHORT $LN29@pattern_su

; 2338 :         Py_DECREF(filter);

  00187	48 8b cf	 mov	 rcx, rdi
  0018a	e8 00 00 00 00	 call	 _Py_DecRef
$LN69@pattern_su:

; 2339 :         return NULL;

  0018f	33 c0		 xor	 eax, eax

; 2462 : 
; 2463 : }

  00191	48 81 c4 b8 07
	00 00		 add	 rsp, 1976		; 000007b8H
  00198	41 5e		 pop	 r14
  0019a	41 5c		 pop	 r12
  0019c	5f		 pop	 rdi
  0019d	5e		 pop	 rsi
  0019e	5b		 pop	 rbx
  0019f	5d		 pop	 rbp
  001a0	c3		 ret	 0
$LN29@pattern_su:

; 2340 :     }
; 2341 : 
; 2342 :     list = PyList_New(0);

  001a1	33 c9		 xor	 ecx, ecx
  001a3	4c 89 bc 24 b0
	07 00 00	 mov	 QWORD PTR [rsp+1968], r15
  001ab	e8 00 00 00 00	 call	 PyList_New
  001b0	4c 8b f8	 mov	 r15, rax

; 2343 :     if (!list) {

  001b3	48 85 c0	 test	 rax, rax
  001b6	75 18		 jne	 SHORT $LN28@pattern_su

; 2344 :         Py_DECREF(filter);

  001b8	48 8b cf	 mov	 rcx, rdi
  001bb	e8 00 00 00 00	 call	 _Py_DecRef

; 2345 :         state_fini(&state);

  001c0	48 8d 4d a0	 lea	 rcx, QWORD PTR state$[rbp-256]
  001c4	e8 00 00 00 00	 call	 state_fini

; 2346 :         return NULL;

  001c9	33 c0		 xor	 eax, eax
  001cb	e9 c0 02 00 00	 jmp	 $LN64@pattern_su
$LN28@pattern_su:

; 2387 :             /* ignore empty match on latest position */
; 2388 :             goto next;
; 2389 : 
; 2390 :         if (filter_is_callable) {

  001d0	48 63 c3	 movsxd	 rax, ebx
  001d3	4c 89 ac 24 f8
	07 00 00	 mov	 QWORD PTR [rsp+2040], r13
  001db	33 f6		 xor	 esi, esi
  001dd	48 89 44 24 38	 mov	 QWORD PTR $T29082[rsp], rax
  001e2	45 33 ed	 xor	 r13d, r13d
$LL27@pattern_su:

; 2347 :     }
; 2348 : 
; 2349 :     n = i = 0;
; 2350 : 
; 2351 :     while (!count || n < count) {

  001e5	4d 85 f6	 test	 r14, r14
  001e8	74 09		 je	 SHORT $LN25@pattern_su
  001ea	4d 3b ee	 cmp	 r13, r14
  001ed	0f 8d fb 01 00
	00		 jge	 $LN26@pattern_su
$LN25@pattern_su:

; 2352 : 
; 2353 :         state_reset(&state);

  001f3	48 8d 4d a0	 lea	 rcx, QWORD PTR state$[rbp-256]
  001f7	48 c7 45 e8 ff
	ff ff ff	 mov	 QWORD PTR state$[rbp-184], -1
  001ff	48 c7 45 e0 ff
	ff ff ff	 mov	 QWORD PTR state$[rbp-192], -1
  00207	48 c7 85 98 06
	00 00 00 00 00
	00		 mov	 QWORD PTR state$[rbp+1528], 0
  00212	e8 00 00 00 00	 call	 data_stack_dealloc

; 2354 : 
; 2355 :         state.ptr = state.start;
; 2356 : 
; 2357 :         if (state.logical_charsize == 1) {

  00217	83 7d d8 01	 cmp	 DWORD PTR state$[rbp-200], 1
  0021b	4c 8b 5d b0	 mov	 r11, QWORD PTR state$[rbp-240]

; 2358 :             status = sre_search(&state, PatternObject_GetCode(self));

  0021f	49 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR [r12+256]
  00227	48 8d 4d a0	 lea	 rcx, QWORD PTR state$[rbp-256]
  0022b	4c 89 5d a0	 mov	 QWORD PTR state$[rbp-256], r11
  0022f	75 0a		 jne	 SHORT $LN24@pattern_su
  00231	e8 00 00 00 00	 call	 sre_search
  00236	48 8b d8	 mov	 rbx, rax

; 2359 :         } else {

  00239	eb 07		 jmp	 SHORT $LN23@pattern_su
$LN24@pattern_su:

; 2360 :             status = sre_usearch(&state, PatternObject_GetCode(self));

  0023b	e8 00 00 00 00	 call	 sre_usearch
  00240	8b d8		 mov	 ebx, eax
$LN23@pattern_su:

; 2361 :         }
; 2362 : 
; 2363 :         if (PyErr_Occurred())

  00242	e8 00 00 00 00	 call	 PyErr_Occurred
  00247	48 85 c0	 test	 rax, rax
  0024a	0f 85 1d 02 00
	00		 jne	 $error$23779

; 2364 :             goto error;
; 2365 : 
; 2366 :         if (status <= 0) {

  00250	85 db		 test	 ebx, ebx
  00252	0f 8e 94 01 00
	00		 jle	 $LN66@pattern_su

; 2370 :             goto error;
; 2371 :         }
; 2372 : 
; 2373 :         b = STATE_OFFSET(&state, state.start);

  00258	48 8b 4d a8	 mov	 rcx, QWORD PTR state$[rbp-248]
  0025c	48 63 5d dc	 movsxd	 rbx, DWORD PTR state$[rbp-196]
  00260	4c 8b 5d b0	 mov	 r11, QWORD PTR state$[rbp-240]

; 2374 :         e = STATE_OFFSET(&state, state.ptr);

  00264	4c 8b 4d a0	 mov	 r9, QWORD PTR state$[rbp-256]
  00268	49 8b c3	 mov	 rax, r11
  0026b	48 2b c1	 sub	 rax, rcx
  0026e	48 99		 cdq
  00270	48 f7 fb	 idiv	 rbx
  00273	4c 8b d0	 mov	 r10, rax
  00276	49 8b c1	 mov	 rax, r9
  00279	48 2b c1	 sub	 rax, rcx
  0027c	48 99		 cdq
  0027e	48 f7 fb	 idiv	 rbx
  00281	4c 8b f0	 mov	 r14, rax

; 2375 : 
; 2376 :         if (i < b) {

  00284	49 3b f2	 cmp	 rsi, r10
  00287	7d 3b		 jge	 SHORT $LN67@pattern_su

; 2377 :             /* get segment before this match */
; 2378 :             item = PySequence_GetSlice(string, i, b);

  00289	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$1$[rsp]
  0028e	4d 8b c2	 mov	 r8, r10
  00291	48 8b d6	 mov	 rdx, rsi
  00294	e8 00 00 00 00	 call	 PySequence_GetSlice
  00299	48 8b f0	 mov	 rsi, rax

; 2379 :             if (!item)

  0029c	48 85 c0	 test	 rax, rax
  0029f	0f 84 c8 01 00
	00		 je	 $error$23779

; 2380 :                 goto error;
; 2381 :             status = PyList_Append(list, item);

  002a5	48 8b d0	 mov	 rdx, rax
  002a8	49 8b cf	 mov	 rcx, r15
  002ab	e8 00 00 00 00	 call	 PyList_Append

; 2382 :             Py_DECREF(item);

  002b0	48 8b ce	 mov	 rcx, rsi
  002b3	8b d8		 mov	 ebx, eax
  002b5	e8 00 00 00 00	 call	 _Py_DecRef

; 2383 :             if (status < 0)

  002ba	85 db		 test	 ebx, ebx
  002bc	0f 88 ab 01 00
	00		 js	 $error$23779

; 2384 :                 goto error;
; 2385 : 
; 2386 :         } else if (i == b && i == e && n > 0)

  002c2	eb 10		 jmp	 SHORT $LN15@pattern_su
$LN67@pattern_su:
  002c4	75 0e		 jne	 SHORT $LN15@pattern_su
  002c6	48 3b f0	 cmp	 rsi, rax
  002c9	75 09		 jne	 SHORT $LN15@pattern_su
  002cb	4d 85 ed	 test	 r13, r13
  002ce	0f 8f e7 00 00
	00		 jg	 $next$23792
$LN15@pattern_su:

; 2387 :             /* ignore empty match on latest position */
; 2388 :             goto next;
; 2389 : 
; 2390 :         if (filter_is_callable) {

  002d4	48 83 7c 24 38
	00		 cmp	 QWORD PTR $T29082[rsp], 0
  002da	74 67		 je	 SHORT $LN14@pattern_su

; 2391 :             /* pass match object through filter */
; 2392 :             match = pattern_new_match(self, &state, 1);

  002dc	48 8d 55 a0	 lea	 rdx, QWORD PTR state$[rbp-256]
  002e0	41 b8 01 00 00
	00		 mov	 r8d, 1
  002e6	49 8b cc	 mov	 rcx, r12
  002e9	e8 00 00 00 00	 call	 pattern_new_match
  002ee	48 8b d8	 mov	 rbx, rax

; 2393 :             if (!match)

  002f1	48 85 c0	 test	 rax, rax
  002f4	0f 84 73 01 00
	00		 je	 $error$23779

; 2394 :                 goto error;
; 2395 :             args = PyTuple_Pack(1, match);

  002fa	48 8b d0	 mov	 rdx, rax
  002fd	b9 01 00 00 00	 mov	 ecx, 1
  00302	e8 00 00 00 00	 call	 PyTuple_Pack
  00307	4c 8b e0	 mov	 r12, rax

; 2396 :             if (!args) {

  0030a	48 85 c0	 test	 rax, rax
  0030d	0f 84 cc 00 00
	00		 je	 $LN61@pattern_su

; 2398 :                 goto error;
; 2399 :             }
; 2400 :             item = PyObject_CallObject(filter, args);

  00313	48 8b d0	 mov	 rdx, rax
  00316	48 8b cf	 mov	 rcx, rdi
  00319	e8 00 00 00 00	 call	 PyObject_CallObject

; 2401 :             Py_DECREF(args);

  0031e	49 8b cc	 mov	 rcx, r12
  00321	48 8b f0	 mov	 rsi, rax
  00324	e8 00 00 00 00	 call	 _Py_DecRef

; 2402 :             Py_DECREF(match);

  00329	48 8b cb	 mov	 rcx, rbx
  0032c	e8 00 00 00 00	 call	 _Py_DecRef

; 2403 :             if (!item)

  00331	48 85 f6	 test	 rsi, rsi
  00334	0f 84 33 01 00
	00		 je	 $error$23779

; 2404 :                 goto error;
; 2405 :         } else {

  0033a	4c 8b a5 f0 06
	00 00		 mov	 r12, QWORD PTR self$[rbp-256]
  00341	eb 3e		 jmp	 SHORT $LN51@pattern_su
$LN14@pattern_su:

; 2406 :             /* filter is literal string */
; 2407 :             item = filter;

  00343	48 8b f7	 mov	 rsi, rdi

; 2408 :             Py_INCREF(item);

  00346	e8 00 00 00 00	 call	 _Py_PXCTX
  0034b	85 c0		 test	 eax, eax
  0034d	75 32		 jne	 SHORT $LN51@pattern_su
  0034f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00356	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0035d	4c 8b cf	 mov	 r9, rdi
  00360	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00366	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0036e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00373	85 c0		 test	 eax, eax
  00375	75 06		 jne	 SHORT $LN50@pattern_su
  00377	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  0037b	74 04		 je	 SHORT $LN51@pattern_su
$LN50@pattern_su:
  0037d	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN51@pattern_su:

; 2409 :         }
; 2410 : 
; 2411 :         /* add to list */
; 2412 :         if (item != Py_None) {

  00381	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00388	48 3b f0	 cmp	 rsi, rax
  0038b	74 1d		 je	 SHORT $LN8@pattern_su

; 2413 :             status = PyList_Append(list, item);

  0038d	48 8b d6	 mov	 rdx, rsi
  00390	49 8b cf	 mov	 rcx, r15
  00393	e8 00 00 00 00	 call	 PyList_Append

; 2414 :             Py_DECREF(item);

  00398	48 8b ce	 mov	 rcx, rsi
  0039b	8b d8		 mov	 ebx, eax
  0039d	e8 00 00 00 00	 call	 _Py_DecRef

; 2415 :             if (status < 0)

  003a2	85 db		 test	 ebx, ebx
  003a4	0f 88 c3 00 00
	00		 js	 $error$23779
$LN8@pattern_su:

; 2416 :                 goto error;
; 2417 :         }
; 2418 : 
; 2419 :         i = e;
; 2420 :         n = n + 1;

  003aa	8b 5d dc	 mov	 ebx, DWORD PTR state$[rbp-196]
  003ad	4c 8b 5d b0	 mov	 r11, QWORD PTR state$[rbp-240]
  003b1	4c 8b 4d a0	 mov	 r9, QWORD PTR state$[rbp-256]
  003b5	49 8b f6	 mov	 rsi, r14
  003b8	49 ff c5	 inc	 r13
$next$23792:

; 2426 :         else

  003bb	4c 8b b5 08 07
	00 00		 mov	 r14, QWORD PTR count$[rbp-256]
  003c2	4d 3b cb	 cmp	 r9, r11
  003c5	75 0f		 jne	 SHORT $LN7@pattern_su

; 2421 : 
; 2422 : next:
; 2423 :         /* move on */
; 2424 :         if (state.ptr == state.start)
; 2425 :             state.start = (void*) ((char*) state.ptr + state.charsize);

  003c7	48 63 c3	 movsxd	 rax, ebx
  003ca	49 03 c1	 add	 rax, r9
  003cd	48 89 45 b0	 mov	 QWORD PTR state$[rbp-240], rax

; 2426 :         else

  003d1	e9 0f fe ff ff	 jmp	 $LL27@pattern_su
$LN7@pattern_su:

; 2427 :             state.start = state.ptr;

  003d6	4c 89 4d b0	 mov	 QWORD PTR state$[rbp-240], r9

; 2428 : 
; 2429 :     }

  003da	e9 06 fe ff ff	 jmp	 $LL27@pattern_su
$LN61@pattern_su:

; 2397 :                 Py_DECREF(match);

  003df	48 8b cb	 mov	 rcx, rbx
  003e2	e8 00 00 00 00	 call	 _Py_DecRef
  003e7	e9 81 00 00 00	 jmp	 $error$23779
$LN66@pattern_su:

; 2367 :             if (status == 0)

  003ec	75 78		 jne	 SHORT $LN20@pattern_su
$LN26@pattern_su:

; 2430 : 
; 2431 :     /* get segment following last match */
; 2432 :     if (i < state.endpos) {

  003ee	4c 8b 45 d0	 mov	 r8, QWORD PTR state$[rbp-208]
  003f2	49 3b f0	 cmp	 rsi, r8
  003f5	7d 2e		 jge	 SHORT $LN3@pattern_su

; 2433 :         item = PySequence_GetSlice(string, i, state.endpos);

  003f7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$1$[rsp]
  003fc	48 8b d6	 mov	 rdx, rsi
  003ff	e8 00 00 00 00	 call	 PySequence_GetSlice
  00404	48 8b f0	 mov	 rsi, rax

; 2434 :         if (!item)

  00407	48 85 c0	 test	 rax, rax
  0040a	74 61		 je	 SHORT $error$23779

; 2435 :             goto error;
; 2436 :         status = PyList_Append(list, item);

  0040c	48 8b d0	 mov	 rdx, rax
  0040f	49 8b cf	 mov	 rcx, r15
  00412	e8 00 00 00 00	 call	 PyList_Append

; 2437 :         Py_DECREF(item);

  00417	48 8b ce	 mov	 rcx, rsi
  0041a	8b d8		 mov	 ebx, eax
  0041c	e8 00 00 00 00	 call	 _Py_DecRef

; 2438 :         if (status < 0)

  00421	85 db		 test	 ebx, ebx
  00423	78 48		 js	 SHORT $error$23779
$LN3@pattern_su:

; 2439 :             goto error;
; 2440 :     }
; 2441 : 
; 2442 :     state_fini(&state);

  00425	48 8d 4d a0	 lea	 rcx, QWORD PTR state$[rbp-256]
  00429	e8 00 00 00 00	 call	 state_fini

; 2443 : 
; 2444 :     Py_DECREF(filter);

  0042e	48 8b cf	 mov	 rcx, rdi
  00431	e8 00 00 00 00	 call	 _Py_DecRef

; 2445 : 
; 2446 :     /* convert list to single string (also removes list) */
; 2447 :     item = join_list(list, string);

  00436	48 8b 54 24 30	 mov	 rdx, QWORD PTR string$1$[rsp]
  0043b	49 8b cf	 mov	 rcx, r15
  0043e	e8 00 00 00 00	 call	 join_list

; 2448 : 
; 2449 :     if (!item)

  00443	48 85 c0	 test	 rax, rax

; 2450 :         return NULL;

  00446	74 3e		 je	 SHORT $LN68@pattern_su

; 2451 : 
; 2452 :     if (subn)

  00448	48 83 bd 10 07
	00 00 00	 cmp	 QWORD PTR subn$[rbp-256], 0
  00450	74 36		 je	 SHORT $LN65@pattern_su

; 2453 :         return Py_BuildValue("Nn", item, n);

  00452	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02IBMEMAAO@Nn?$AA@
  00459	4d 8b c5	 mov	 r8, r13
  0045c	48 8b d0	 mov	 rdx, rax
  0045f	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
  00464	eb 22		 jmp	 SHORT $LN65@pattern_su
$LN20@pattern_su:

; 2368 :                 break;
; 2369 :             pattern_error(status);

  00466	8b cb		 mov	 ecx, ebx
  00468	e8 00 00 00 00	 call	 pattern_error
$error$23779:

; 2454 : 
; 2455 :     return item;
; 2456 : 
; 2457 : error:
; 2458 :     Py_DECREF(list);

  0046d	49 8b cf	 mov	 rcx, r15
  00470	e8 00 00 00 00	 call	 _Py_DecRef

; 2459 :     state_fini(&state);

  00475	48 8d 4d a0	 lea	 rcx, QWORD PTR state$[rbp-256]
  00479	e8 00 00 00 00	 call	 state_fini

; 2460 :     Py_DECREF(filter);

  0047e	48 8b cf	 mov	 rcx, rdi
  00481	e8 00 00 00 00	 call	 _Py_DecRef
$LN68@pattern_su:

; 2461 :     return NULL;

  00486	33 c0		 xor	 eax, eax
$LN65@pattern_su:
  00488	4c 8b ac 24 f8
	07 00 00	 mov	 r13, QWORD PTR [rsp+2040]
$LN64@pattern_su:
  00490	4c 8b bc 24 b0
	07 00 00	 mov	 r15, QWORD PTR [rsp+1968]

; 2462 : 
; 2463 : }

  00498	48 81 c4 b8 07
	00 00		 add	 rsp, 1976		; 000007b8H
  0049f	41 5e		 pop	 r14
  004a1	41 5c		 pop	 r12
  004a3	5f		 pop	 rdi
  004a4	5e		 pop	 rsi
  004a5	5b		 pop	 rbx
  004a6	5d		 pop	 rbp
  004a7	c3		 ret	 0
pattern_subx ENDP
_TEXT	ENDS
PUBLIC	??_C@_08GGLMCPHI@OO?$HMn?3sub?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$pattern_sub DD imagerel pattern_sub
	DD	imagerel pattern_sub+124
	DD	imagerel $unwind$pattern_sub
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_sub DD 020801H
	DD	030049208H
xdata	ENDS
;	COMDAT ??_C@_08GGLMCPHI@OO?$HMn?3sub?$AA@
CONST	SEGMENT
??_C@_08GGLMCPHI@OO?$HMn?3sub?$AA@ DB 'OO|n:sub', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT pattern_sub
_TEXT	SEGMENT
string$ = 64
ptemplate$ = 72
self$ = 96
args$ = 104
kw$ = 112
count$ = 120
pattern_sub PROC					; COMDAT

; 2467 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00008	48 8b d9	 mov	 rbx, rcx

; 2468 :     PyObject* ptemplate;
; 2469 :     PyObject* string;
; 2470 :     Py_ssize_t count = 0;
; 2471 :     static char* kwlist[] = { "repl", "string", "count", NULL };
; 2472 :     if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|n:sub", kwlist,
; 2473 :                                      &ptemplate, &string, &count))

  0000b	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  0000f	49 8b c0	 mov	 rax, r8
  00012	49 89 4b d8	 mov	 QWORD PTR [r11-40], rcx
  00016	49 8d 4b e8	 lea	 rcx, QWORD PTR [r11-24]
  0001a	4c 8b d2	 mov	 r10, rdx
  0001d	49 89 4b d0	 mov	 QWORD PTR [r11-48], rcx
  00021	49 8d 4b f0	 lea	 rcx, QWORD PTR [r11-16]
  00025	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??pattern_sub@@9@9
  0002c	49 89 4b c8	 mov	 QWORD PTR [r11-56], rcx
  00030	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_08GGLMCPHI@OO?$HMn?3sub?$AA@
  00037	48 8b d0	 mov	 rdx, rax
  0003a	49 8b ca	 mov	 rcx, r10
  0003d	49 c7 43 20 00
	00 00 00	 mov	 QWORD PTR [r11+32], 0
  00045	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0004a	85 c0		 test	 eax, eax
  0004c	75 08		 jne	 SHORT $LN1@pattern_su@2

; 2474 :         return NULL;

  0004e	33 c0		 xor	 eax, eax

; 2477 : }

  00050	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00054	5b		 pop	 rbx
  00055	c3		 ret	 0
$LN1@pattern_su@2:

; 2475 : 
; 2476 :     return pattern_subx(self, ptemplate, string, count, 0);

  00056	4c 8b 4c 24 78	 mov	 r9, QWORD PTR count$[rsp]
  0005b	4c 8b 44 24 40	 mov	 r8, QWORD PTR string$[rsp]
  00060	48 8b 54 24 48	 mov	 rdx, QWORD PTR ptemplate$[rsp]
  00065	48 8b cb	 mov	 rcx, rbx
  00068	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00071	e8 00 00 00 00	 call	 pattern_subx

; 2477 : }

  00076	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0007a	5b		 pop	 rbx
  0007b	c3		 ret	 0
pattern_sub ENDP
_TEXT	ENDS
PUBLIC	??_C@_09KFMGADAI@OO?$HMn?3subn?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$pattern_subn DD imagerel pattern_subn
	DD	imagerel pattern_subn+124
	DD	imagerel $unwind$pattern_subn
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_subn DD 020801H
	DD	030049208H
xdata	ENDS
;	COMDAT ??_C@_09KFMGADAI@OO?$HMn?3subn?$AA@
CONST	SEGMENT
??_C@_09KFMGADAI@OO?$HMn?3subn?$AA@ DB 'OO|n:subn', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT pattern_subn
_TEXT	SEGMENT
string$ = 64
ptemplate$ = 72
self$ = 96
args$ = 104
kw$ = 112
count$ = 120
pattern_subn PROC					; COMDAT

; 2481 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00008	48 8b d9	 mov	 rbx, rcx

; 2482 :     PyObject* ptemplate;
; 2483 :     PyObject* string;
; 2484 :     Py_ssize_t count = 0;
; 2485 :     static char* kwlist[] = { "repl", "string", "count", NULL };
; 2486 :     if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|n:subn", kwlist,
; 2487 :                                      &ptemplate, &string, &count))

  0000b	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  0000f	49 8b c0	 mov	 rax, r8
  00012	49 89 4b d8	 mov	 QWORD PTR [r11-40], rcx
  00016	49 8d 4b e8	 lea	 rcx, QWORD PTR [r11-24]
  0001a	4c 8b d2	 mov	 r10, rdx
  0001d	49 89 4b d0	 mov	 QWORD PTR [r11-48], rcx
  00021	49 8d 4b f0	 lea	 rcx, QWORD PTR [r11-16]
  00025	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??pattern_subn@@9@9
  0002c	49 89 4b c8	 mov	 QWORD PTR [r11-56], rcx
  00030	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_09KFMGADAI@OO?$HMn?3subn?$AA@
  00037	48 8b d0	 mov	 rdx, rax
  0003a	49 8b ca	 mov	 rcx, r10
  0003d	49 c7 43 20 00
	00 00 00	 mov	 QWORD PTR [r11+32], 0
  00045	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0004a	85 c0		 test	 eax, eax
  0004c	75 08		 jne	 SHORT $LN1@pattern_su@3

; 2488 :         return NULL;

  0004e	33 c0		 xor	 eax, eax

; 2491 : }

  00050	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00054	5b		 pop	 rbx
  00055	c3		 ret	 0
$LN1@pattern_su@3:

; 2489 : 
; 2490 :     return pattern_subx(self, ptemplate, string, count, 1);

  00056	4c 8b 4c 24 78	 mov	 r9, QWORD PTR count$[rsp]
  0005b	4c 8b 44 24 40	 mov	 r8, QWORD PTR string$[rsp]
  00060	48 8b 54 24 48	 mov	 rdx, QWORD PTR ptemplate$[rsp]
  00065	48 8b cb	 mov	 rcx, rbx
  00068	48 c7 44 24 20
	01 00 00 00	 mov	 QWORD PTR [rsp+32], 1
  00071	e8 00 00 00 00	 call	 pattern_subx

; 2491 : }

  00076	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0007a	5b		 pop	 rbx
  0007b	c3		 ret	 0
pattern_subn ENDP
_TEXT	ENDS
PUBLIC	??_C@_08ECDGFLNN@OiO?$CB?$HMnOO?$AA@		; `string'
EXTRN	PyLong_AsUnsignedLong:PROC
EXTRN	PyList_Type:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_compile DD imagerel _compile
	DD	imagerel _compile+238
	DD	imagerel $unwind$_compile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$_compile DD imagerel _compile+238
	DD	imagerel _compile+305
	DD	imagerel $chain$3$_compile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$_compile DD imagerel _compile+305
	DD	imagerel _compile+362
	DD	imagerel $chain$4$_compile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$_compile DD imagerel _compile+362
	DD	imagerel _compile+384
	DD	imagerel $chain$5$_compile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$_compile DD imagerel _compile+384
	DD	imagerel _compile+738
	DD	imagerel $chain$6$_compile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$_compile DD imagerel _compile+738
	DD	imagerel _compile+765
	DD	imagerel $chain$7$_compile
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$_compile DD 021H
	DD	imagerel _compile
	DD	imagerel _compile+238
	DD	imagerel $unwind$_compile
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$_compile DD 020021H
	DD	010d400H
	DD	imagerel _compile
	DD	imagerel _compile+238
	DD	imagerel $unwind$_compile
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$_compile DD 021H
	DD	imagerel _compile+238
	DD	imagerel _compile+305
	DD	imagerel $chain$3$_compile
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$_compile DD 020821H
	DD	011c408H
	DD	imagerel _compile+238
	DD	imagerel _compile+305
	DD	imagerel $chain$3$_compile
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$_compile DD 041021H
	DD	010d410H
	DD	0176408H
	DD	imagerel _compile
	DD	imagerel _compile+238
	DD	imagerel $unwind$_compile
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_compile DD 089201H
	DD	0127492H
	DD	016348aH
	DD	0130110H
	DD	05002e004H
xdata	ENDS
;	COMDAT ??_C@_08ECDGFLNN@OiO?$CB?$HMnOO?$AA@
CONST	SEGMENT
??_C@_08ECDGFLNN@OiO?$CB?$HMnOO?$AA@ DB 'OiO!|nOO', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_sre.c
CONST	ENDS
;	COMDAT _compile
_TEXT	SEGMENT
indexgroup$ = 80
pattern$ = 88
code$ = 96
groups$ = 104
p_length$23990 = 112
self_$ = 176
args$ = 184
flags$ = 192
groupindex$ = 200
_compile PROC						; COMDAT

; 2647 : {

  00000	40 55		 push	 rbp
  00002	41 56		 push	 r14
  00004	48 8d 6c 24 b1	 lea	 rbp, QWORD PTR [rsp-79]
  00009	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 2648 :     /* "compile" pattern descriptor to pattern object */
; 2649 : 
; 2650 :     PatternObject* self;
; 2651 :     Py_ssize_t i, n;
; 2652 : 
; 2653 :     PyObject* pattern;
; 2654 :     int flags = 0;

  00010	45 33 f6	 xor	 r14d, r14d
  00013	48 8b c2	 mov	 rax, rdx

; 2655 :     PyObject* code;
; 2656 :     Py_ssize_t groups = 0;
; 2657 :     PyObject* groupindex = NULL;
; 2658 :     PyObject* indexgroup = NULL;
; 2659 : 
; 2660 :     if (!PyArg_ParseTuple(args, "OiO!|nOO", &pattern, &flags,
; 2661 :                           &PyList_Type, &code, &groups,
; 2662 :                           &groupindex, &indexgroup))

  00016	48 8d 4d 07	 lea	 rcx, QWORD PTR indexgroup$[rbp-73]
  0001a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0001f	48 8d 4d 7f	 lea	 rcx, QWORD PTR groupindex$[rbp-73]
  00023	4c 8d 4d 77	 lea	 r9, QWORD PTR flags$[rbp-73]
  00027	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0002c	48 8d 4d 1f	 lea	 rcx, QWORD PTR groups$[rbp-73]
  00030	4c 8d 45 0f	 lea	 r8, QWORD PTR pattern$[rbp-73]
  00034	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00039	48 8d 4d 17	 lea	 rcx, QWORD PTR code$[rbp-73]
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08ECDGFLNN@OiO?$CB?$HMnOO?$AA@
  00044	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyList_Type
  00050	44 89 75 77	 mov	 DWORD PTR flags$[rbp-73], r14d
  00054	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00059	48 8b c8	 mov	 rcx, rax
  0005c	4c 89 75 1f	 mov	 QWORD PTR groups$[rbp-73], r14
  00060	4c 89 75 7f	 mov	 QWORD PTR groupindex$[rbp-73], r14
  00064	4c 89 75 07	 mov	 QWORD PTR indexgroup$[rbp-73], r14
  00068	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0006d	85 c0		 test	 eax, eax
  0006f	75 0d		 jne	 SHORT $LN19@compile

; 2663 :         return NULL;

  00071	33 c0		 xor	 eax, eax

; 2728 : }

  00073	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0007a	41 5e		 pop	 r14
  0007c	5d		 pop	 rbp
  0007d	c3		 ret	 0
$LN19@compile:

; 2664 : 
; 2665 :     n = PyList_GET_SIZE(code);

  0007e	48 8b 45 17	 mov	 rax, QWORD PTR code$[rbp-73]
  00082	48 89 9c 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], rbx
  0008a	48 89 bc 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rdi
  00092	48 8b 78 60	 mov	 rdi, QWORD PTR [rax+96]

; 2666 :     /* coverity[ampersand_in_size] */
; 2667 :     self = PyObject_NEW_VAR(PatternObject, &Pattern_Type, n);

  00096	e8 00 00 00 00	 call	 _Py_PXCTX
  0009b	85 c0		 test	 eax, eax
  0009d	74 11		 je	 SHORT $LN22@compile
  0009f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Pattern_Type
  000a6	48 8b d7	 mov	 rdx, rdi
  000a9	e8 00 00 00 00	 call	 _PxObject_NewVar
  000ae	eb 32		 jmp	 SHORT $LN45@compile
$LN22@compile:
  000b0	48 8b 0d 80 00
	00 00		 mov	 rcx, QWORD PTR Pattern_Type+128
  000b7	48 8b 05 78 00
	00 00		 mov	 rax, QWORD PTR Pattern_Type+120
  000be	48 0f af cf	 imul	 rcx, rdi
  000c2	48 8d 4c 01 07	 lea	 rcx, QWORD PTR [rcx+rax+7]
  000c7	48 83 e1 f8	 and	 rcx, -8
  000cb	e8 00 00 00 00	 call	 PyObject_Malloc
  000d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Pattern_Type
  000d7	4c 8b c7	 mov	 r8, rdi
  000da	48 8b c8	 mov	 rcx, rax
  000dd	e8 00 00 00 00	 call	 PyObject_InitVar
$LN45@compile:
  000e2	48 8b d8	 mov	 rbx, rax

; 2668 :     if (!self)

  000e5	48 85 c0	 test	 rax, rax
  000e8	0f 84 f4 01 00
	00		 je	 $LN43@compile
$LN18@compile:
  000ee	48 89 b4 24 b8
	00 00 00	 mov	 QWORD PTR [rsp+184], rsi
  000f6	4c 89 ac 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], r13

; 2671 :     self->pattern = NULL;
; 2672 :     self->groupindex = NULL;
; 2673 :     self->indexgroup = NULL;
; 2674 :     self->view.buf = NULL;

  000fe	4c 8d ab a8 00
	00 00		 lea	 r13, QWORD PTR [rbx+168]
  00105	4c 89 b3 98 00
	00 00		 mov	 QWORD PTR [rbx+152], r14
  0010c	4c 89 b3 88 00
	00 00		 mov	 QWORD PTR [rbx+136], r14
  00113	4c 89 73 78	 mov	 QWORD PTR [rbx+120], r14
  00117	4d 89 75 00	 mov	 QWORD PTR [r13], r14
  0011b	4c 89 b3 80 00
	00 00		 mov	 QWORD PTR [rbx+128], r14

; 2675 : 
; 2676 :     self->codesize = n;

  00122	48 89 bb f8 00
	00 00		 mov	 QWORD PTR [rbx+248], rdi

; 2677 : 
; 2678 :     for (i = 0; i < n; i++) {

  00129	49 8b f6	 mov	 rsi, r14
  0012c	48 85 ff	 test	 rdi, rdi
  0012f	7e 39		 jle	 SHORT $LN15@compile

; 2669 :         return NULL;
; 2670 :     self->weakreflist = NULL;

  00131	4c 89 a4 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], r12
  00139	4c 8d a3 00 01
	00 00		 lea	 r12, QWORD PTR [rbx+256]
$LL17@compile:

; 2679 :         PyObject *o = PyList_GET_ITEM(code, i);

  00140	48 8b 45 17	 mov	 rax, QWORD PTR code$[rbp-73]
  00144	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]

; 2680 :         unsigned long value = PyLong_AsUnsignedLong(o);

  00148	48 8b 0c f1	 mov	 rcx, QWORD PTR [rcx+rsi*8]
  0014c	e8 00 00 00 00	 call	 PyLong_AsUnsignedLong
  00151	48 ff c6	 inc	 rsi
  00154	49 83 c4 04	 add	 r12, 4
  00158	41 89 44 24 fc	 mov	 DWORD PTR [r12-4], eax
  0015d	48 3b f7	 cmp	 rsi, rdi
  00160	7c de		 jl	 SHORT $LL17@compile
  00162	4c 8b a4 24 88
	00 00 00	 mov	 r12, QWORD PTR [rsp+136]
$LN15@compile:

; 2681 :         self->code[i] = (SRE_CODE) value;
; 2682 :         if ((unsigned long) self->code[i] != value) {
; 2683 :             PyErr_SetString(PyExc_OverflowError,
; 2684 :                             "regular expression code size limit exceeded");
; 2685 :             break;
; 2686 :         }
; 2687 :     }
; 2688 : 
; 2689 :     if (PyErr_Occurred()) {

  0016a	e8 00 00 00 00	 call	 PyErr_Occurred
  0016f	48 8b b4 24 b8
	00 00 00	 mov	 rsi, QWORD PTR [rsp+184]
  00177	48 85 c0	 test	 rax, rax

; 2690 :         Py_DECREF(self);
; 2691 :         return NULL;

  0017a	0f 85 4b 01 00
	00		 jne	 $LN46@compile

; 2692 :     }
; 2693 : 
; 2694 :     if (pattern == Py_None) {

  00180	48 8b 4d 0f	 mov	 rcx, QWORD PTR pattern$[rbp-73]
  00184	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0018b	48 3b c8	 cmp	 rcx, rax
  0018e	75 0d		 jne	 SHORT $LN12@compile

; 2695 :         self->logical_charsize = -1;

  00190	48 c7 83 a0 00
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rbx+160], -1

; 2696 :         self->charsize = -1;
; 2697 :     }
; 2698 :     else {

  0019b	eb 25		 jmp	 SHORT $LN10@compile
$LN12@compile:

; 2699 :         Py_ssize_t p_length;
; 2700 :         if (!getstring(pattern, &p_length, &self->logical_charsize,
; 2701 :                        &self->charsize, &self->view)) {

  0019d	4c 8d 8b a4 00
	00 00		 lea	 r9, QWORD PTR [rbx+164]
  001a4	4c 8d 83 a0 00
	00 00		 lea	 r8, QWORD PTR [rbx+160]
  001ab	48 8d 55 27	 lea	 rdx, QWORD PTR p_length$23990[rbp-73]
  001af	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  001b4	e8 00 00 00 00	 call	 getstring
  001b9	48 85 c0	 test	 rax, rax

; 2702 :             Py_DECREF(self);
; 2703 :             return NULL;

  001bc	0f 84 09 01 00
	00		 je	 $LN46@compile
$LN10@compile:

; 2704 :         }
; 2705 :     }
; 2706 : 
; 2707 :     Py_INCREF(pattern);

  001c2	48 8b 7d 0f	 mov	 rdi, QWORD PTR pattern$[rbp-73]
  001c6	e8 00 00 00 00	 call	 _Py_PXCTX
  001cb	85 c0		 test	 eax, eax
  001cd	75 32		 jne	 SHORT $LN26@compile
  001cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  001dd	4c 8b cf	 mov	 r9, rdi
  001e0	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  001e6	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001ee	e8 00 00 00 00	 call	 _PyParallel_Guard
  001f3	85 c0		 test	 eax, eax
  001f5	75 06		 jne	 SHORT $LN25@compile
  001f7	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  001fb	74 04		 je	 SHORT $LN26@compile
$LN25@compile:
  001fd	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN26@compile:

; 2708 :     self->pattern = pattern;

  00201	48 8b 45 0f	 mov	 rax, QWORD PTR pattern$[rbp-73]
  00205	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax

; 2709 : 
; 2710 :     self->flags = flags;

  0020c	8b 45 77	 mov	 eax, DWORD PTR flags$[rbp-73]
  0020f	89 83 90 00 00
	00		 mov	 DWORD PTR [rbx+144], eax

; 2711 : 
; 2712 :     self->groups = groups;

  00215	48 8b 45 1f	 mov	 rax, QWORD PTR groups$[rbp-73]
  00219	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax

; 2713 : 
; 2714 :     Py_XINCREF(groupindex);

  0021d	48 8b 7d 7f	 mov	 rdi, QWORD PTR groupindex$[rbp-73]
  00221	48 85 ff	 test	 rdi, rdi
  00224	74 3f		 je	 SHORT $LN8@compile
  00226	e8 00 00 00 00	 call	 _Py_PXCTX
  0022b	85 c0		 test	 eax, eax
  0022d	75 32		 jne	 SHORT $LN40@compile
  0022f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00236	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0023d	4c 8b cf	 mov	 r9, rdi
  00240	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00246	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0024e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00253	85 c0		 test	 eax, eax
  00255	75 06		 jne	 SHORT $LN29@compile
  00257	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  0025b	74 04		 je	 SHORT $LN40@compile
$LN29@compile:
  0025d	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN40@compile:
  00261	48 8b 7d 7f	 mov	 rdi, QWORD PTR groupindex$[rbp-73]
$LN8@compile:

; 2715 :     self->groupindex = groupindex;

  00265	48 89 7b 78	 mov	 QWORD PTR [rbx+120], rdi

; 2716 : 
; 2717 :     Py_XINCREF(indexgroup);

  00269	48 8b 7d 07	 mov	 rdi, QWORD PTR indexgroup$[rbp-73]
  0026d	48 85 ff	 test	 rdi, rdi
  00270	74 3f		 je	 SHORT $LN4@compile
  00272	e8 00 00 00 00	 call	 _Py_PXCTX
  00277	85 c0		 test	 eax, eax
  00279	75 32		 jne	 SHORT $LN41@compile
  0027b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00282	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00289	4c 8b cf	 mov	 r9, rdi
  0028c	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00292	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0029a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0029f	85 c0		 test	 eax, eax
  002a1	75 06		 jne	 SHORT $LN33@compile
  002a3	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  002a7	74 04		 je	 SHORT $LN41@compile
$LN33@compile:
  002a9	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN41@compile:
  002ad	48 8b 7d 07	 mov	 rdi, QWORD PTR indexgroup$[rbp-73]
$LN4@compile:

; 2718 :     self->indexgroup = indexgroup;
; 2719 : 
; 2720 :     self->weakreflist = NULL;
; 2721 : 
; 2722 :     if (!_validate(self)) {

  002b1	48 8b cb	 mov	 rcx, rbx
  002b4	48 89 bb 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rdi
  002bb	4c 89 b3 98 00
	00 00		 mov	 QWORD PTR [rbx+152], r14
  002c2	e8 00 00 00 00	 call	 _validate
  002c7	85 c0		 test	 eax, eax
  002c9	75 0c		 jne	 SHORT $LN1@compile
$LN46@compile:

; 2723 :         Py_DECREF(self);

  002cb	48 8b cb	 mov	 rcx, rbx
  002ce	e8 00 00 00 00	 call	 _Py_DecRef

; 2724 :         return NULL;

  002d3	33 c0		 xor	 eax, eax
  002d5	eb 03		 jmp	 SHORT $LN44@compile
$LN1@compile:

; 2725 :     }
; 2726 : 
; 2727 :     return (PyObject*) self;

  002d7	48 8b c3	 mov	 rax, rbx
$LN44@compile:
  002da	4c 8b ac 24 80
	00 00 00	 mov	 r13, QWORD PTR [rsp+128]
$LN43@compile:
  002e2	48 8b 9c 24 b0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+176]
  002ea	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR [rsp+144]

; 2728 : }

  002f2	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  002f9	41 5e		 pop	 r14
  002fb	5d		 pop	 rbp
  002fc	c3		 ret	 0
_compile ENDP
_TEXT	ENDS
END
