; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_05HMENAHCI@_sha1?$AA@			; `string'
PUBLIC	??_C@_04PGHFOLLE@sha1?$AA@			; `string'
PUBLIC	??_C@_06ICGJLFIM@string?$AA@			; `string'
PUBLIC	??_C@_0L@GFKAPDAF@_sha1?4sha1?$AA@		; `string'
PUBLIC	??_C@_0M@NPLIJFCD@digest_size?$AA@		; `string'
PUBLIC	??_C@_04MEMAJGDJ@name?$AA@			; `string'
PUBLIC	??_C@_0L@EHHMJOPG@block_size?$AA@		; `string'
PUBLIC	??_C@_06HDLLMMEJ@update?$AA@			; `string'
PUBLIC	??_C@_09NNAIGNDA@hexdigest?$AA@			; `string'
PUBLIC	??_C@_06IJPNAHC@digest?$AA@			; `string'
PUBLIC	??_C@_04COAGEIMF@copy?$AA@			; `string'
;	COMDAT ??_C@_05HMENAHCI@_sha1?$AA@
CONST	SEGMENT
??_C@_05HMENAHCI@_sha1?$AA@ DB '_sha1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PGHFOLLE@sha1?$AA@
CONST	SEGMENT
??_C@_04PGHFOLLE@sha1?$AA@ DB 'sha1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06ICGJLFIM@string?$AA@
CONST	SEGMENT
??_C@_06ICGJLFIM@string?$AA@ DB 'string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GFKAPDAF@_sha1?4sha1?$AA@
CONST	SEGMENT
??_C@_0L@GFKAPDAF@_sha1?4sha1?$AA@ DB '_sha1.sha1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NPLIJFCD@digest_size?$AA@
CONST	SEGMENT
??_C@_0M@NPLIJFCD@digest_size?$AA@ DB 'digest_size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name?$AA@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name?$AA@ DB 'name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EHHMJOPG@block_size?$AA@
CONST	SEGMENT
??_C@_0L@EHHMJOPG@block_size?$AA@ DB 'block_size', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06HDLLMMEJ@update?$AA@
CONST	SEGMENT
??_C@_06HDLLMMEJ@update?$AA@ DB 'update', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NNAIGNDA@hexdigest?$AA@
CONST	SEGMENT
??_C@_09NNAIGNDA@hexdigest?$AA@ DB 'hexdigest', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06IJPNAHC@digest?$AA@
CONST	SEGMENT
??_C@_06IJPNAHC@digest?$AA@ DB 'digest', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04COAGEIMF@copy?$AA@
CONST	SEGMENT
??_C@_04COAGEIMF@copy?$AA@ DB 'copy', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
SHA1_copy__doc__ DB 'Return a copy of the hash object.', 00H
	ORG $+6
SHA1_digest__doc__ DB 'Return the digest value as a string of binary data'
	DB	'.', 00H
	ORG $+4
SHA1_hexdigest__doc__ DB 'Return the digest value as a string of hexadeci'
	DB	'mal digits.', 00H
	ORG $+5
SHA1_update__doc__ DB 'Update this hash object''s state with the provided'
	DB	' string.', 00H
	ORG $+6
SHA1_methods DQ	FLAT:??_C@_04COAGEIMF@copy?$AA@
	DQ	FLAT:SHA1_copy
	DD	04H
	ORG $+4
	DQ	FLAT:SHA1_copy__doc__
	DQ	FLAT:??_C@_06IJPNAHC@digest?$AA@
	DQ	FLAT:SHA1_digest
	DD	04H
	ORG $+4
	DQ	FLAT:SHA1_digest__doc__
	DQ	FLAT:??_C@_09NNAIGNDA@hexdigest?$AA@
	DQ	FLAT:SHA1_hexdigest
	DD	04H
	ORG $+4
	DQ	FLAT:SHA1_hexdigest__doc__
	DQ	FLAT:??_C@_06HDLLMMEJ@update?$AA@
	DQ	FLAT:SHA1_update
	DD	01H
	ORG $+4
	DQ	FLAT:SHA1_update__doc__
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
SHA1_getseters DQ FLAT:??_C@_0L@EHHMJOPG@block_size?$AA@
	DQ	FLAT:SHA1_get_block_size
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:??_C@_04MEMAJGDJ@name?$AA@
	DQ	FLAT:SHA1_get_name
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0M@NPLIJFCD@digest_size?$AA@
	DQ	FLAT:sha1_get_digest_size
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+32
SHA1type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0L@GFKAPDAF@_sha1?4sha1?$AA@
	DQ	00000000000000c0H
	DQ	0000000000000000H
	DQ	FLAT:SHA1_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040000H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:SHA1_methods
	DQ	0000000000000000H
	DQ	FLAT:SHA1_getseters
	ORG $+136
SHA1_new__doc__ DB 'Return a new SHA1 hash object; optionally initialized'
	DB	' with a string.', 00H
	ORG $+3
?kwlist@?1??SHA1_new@@9@9 DQ FLAT:??_C@_06ICGJLFIM@string?$AA@ ; `SHA1_new'::`2'::kwlist
	DQ	0000000000000000H
	ORG $+8
SHA1_functions DQ FLAT:??_C@_04PGHFOLLE@sha1?$AA@
	DQ	FLAT:SHA1_new
	DD	03H
	ORG $+4
	DQ	FLAT:SHA1_new__doc__
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
_sha1module DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_05HMENAHCI@_sha1?$AA@
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	FLAT:SHA1_functions
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\modules\sha1module.c
pdata	SEGMENT
$pdata$sha1_compress DD imagerel sha1_compress
	DD	imagerel sha1_compress+1190
	DD	imagerel $unwind$sha1_compress
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sha1_compress DD 0d1f01H
	DD	030641fH
	DD	02f541fH
	DD	02e341fH
	DD	028011fH
	DD	0e016f018H
	DD	0c012d014H
	DD	07010H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT sha1_compress
_TEXT	SEGMENT
W$ = 0
sha1$ = 368
buf$ = 376
sha1_compress PROC					; COMDAT

; 108  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 81 ec 40 01
	00 00		 sub	 rsp, 320		; 00000140H

; 109  :     SHA1_INT32 a,b,c,d,e,W[80],i;
; 110  : 
; 111  :     /* copy the state into 512-bits into W[0..15] */
; 112  :     for (i = 0; i < 16; i++) {

  0001f	4c 8d 0c 24	 lea	 r9, QWORD PTR W$[rsp]
  00023	4c 8d 54 24 02	 lea	 r10, QWORD PTR W$[rsp+2]
  00028	4c 8d 5c 24 06	 lea	 r11, QWORD PTR W$[rsp+6]
  0002d	4c 2b ca	 sub	 r9, rdx
  00030	4c 2b d2	 sub	 r10, rdx
  00033	4c 2b da	 sub	 r11, rdx
  00036	48 8d 5c 24 0a	 lea	 rbx, QWORD PTR W$[rsp+10]
  0003b	41 bd 04 00 00
	00		 mov	 r13d, 4
  00041	4c 8d 42 02	 lea	 r8, QWORD PTR [rdx+2]
  00045	48 2b da	 sub	 rbx, rdx
  00048	41 8b d5	 mov	 edx, r13d
  0004b	48 8b e9	 mov	 rbp, rcx
  0004e	66 90		 npad	 2
$LL14@sha1_compr:

; 113  :         LOAD32H(W[i], buf + (4*i));

  00050	41 0f b6 40 ff	 movzx	 eax, BYTE PTR [r8-1]
  00055	41 0f b6 48 fe	 movzx	 ecx, BYTE PTR [r8-2]
  0005a	49 83 c0 10	 add	 r8, 16
  0005e	c1 e1 08	 shl	 ecx, 8
  00061	0b c8		 or	 ecx, eax
  00063	41 0f b6 40 f0	 movzx	 eax, BYTE PTR [r8-16]
  00068	c1 e1 08	 shl	 ecx, 8
  0006b	0b c8		 or	 ecx, eax
  0006d	41 0f b6 40 f1	 movzx	 eax, BYTE PTR [r8-15]
  00072	c1 e1 08	 shl	 ecx, 8
  00075	0b c8		 or	 ecx, eax
  00077	41 0f b6 40 f3	 movzx	 eax, BYTE PTR [r8-13]
  0007c	43 89 4c 01 ee	 mov	 DWORD PTR [r9+r8-18], ecx
  00081	41 0f b6 48 f2	 movzx	 ecx, BYTE PTR [r8-14]
  00086	c1 e1 08	 shl	 ecx, 8
  00089	0b c8		 or	 ecx, eax
  0008b	41 0f b6 40 f4	 movzx	 eax, BYTE PTR [r8-12]
  00090	c1 e1 08	 shl	 ecx, 8
  00093	0b c8		 or	 ecx, eax
  00095	41 0f b6 40 f5	 movzx	 eax, BYTE PTR [r8-11]
  0009a	c1 e1 08	 shl	 ecx, 8
  0009d	0b c8		 or	 ecx, eax
  0009f	41 0f b6 40 f7	 movzx	 eax, BYTE PTR [r8-9]
  000a4	43 89 4c 02 f0	 mov	 DWORD PTR [r10+r8-16], ecx
  000a9	41 0f b6 48 f6	 movzx	 ecx, BYTE PTR [r8-10]
  000ae	c1 e1 08	 shl	 ecx, 8
  000b1	0b c8		 or	 ecx, eax
  000b3	41 0f b6 40 f8	 movzx	 eax, BYTE PTR [r8-8]
  000b8	c1 e1 08	 shl	 ecx, 8
  000bb	0b c8		 or	 ecx, eax
  000bd	41 0f b6 40 f9	 movzx	 eax, BYTE PTR [r8-7]
  000c2	c1 e1 08	 shl	 ecx, 8
  000c5	0b c8		 or	 ecx, eax
  000c7	41 0f b6 40 fb	 movzx	 eax, BYTE PTR [r8-5]
  000cc	43 89 4c 03 f0	 mov	 DWORD PTR [r11+r8-16], ecx
  000d1	41 0f b6 48 fa	 movzx	 ecx, BYTE PTR [r8-6]
  000d6	c1 e1 08	 shl	 ecx, 8
  000d9	0b c8		 or	 ecx, eax
  000db	41 0f b6 40 fc	 movzx	 eax, BYTE PTR [r8-4]
  000e0	c1 e1 08	 shl	 ecx, 8
  000e3	0b c8		 or	 ecx, eax
  000e5	41 0f b6 40 fd	 movzx	 eax, BYTE PTR [r8-3]
  000ea	c1 e1 08	 shl	 ecx, 8
  000ed	0b c8		 or	 ecx, eax
  000ef	48 ff ca	 dec	 rdx
  000f2	42 89 4c 03 f0	 mov	 DWORD PTR [rbx+r8-16], ecx
  000f7	0f 85 53 ff ff
	ff		 jne	 $LL14@sha1_compr

; 114  :     }
; 115  : 
; 116  :     /* copy state */
; 117  :     a = sha1->state[0];

  000fd	44 8b 75 08	 mov	 r14d, DWORD PTR [rbp+8]

; 118  :     b = sha1->state[1];

  00101	44 8b 7d 0c	 mov	 r15d, DWORD PTR [rbp+12]

; 119  :     c = sha1->state[2];

  00105	44 8b 55 10	 mov	 r10d, DWORD PTR [rbp+16]

; 120  :     d = sha1->state[3];

  00109	44 8b 5d 14	 mov	 r11d, DWORD PTR [rbp+20]

; 121  :     e = sha1->state[4];

  0010d	8b 5d 18	 mov	 ebx, DWORD PTR [rbp+24]
  00110	41 8b f6	 mov	 esi, r14d
  00113	41 8b ff	 mov	 edi, r15d
  00116	4c 8d 4c 24 20	 lea	 r9, QWORD PTR W$[rsp+32]
  0011b	44 8d 62 10	 lea	 r12d, QWORD PTR [rdx+16]
  0011f	90		 npad	 1
$LL11@sha1_compr:

; 122  : 
; 123  :     /* expand it */
; 124  :     for (i = 16; i < 80; i++) {
; 125  :         W[i] = ROL(W[i-3] ^ W[i-8] ^ W[i-14] ^ W[i-16], 1);

  00120	41 8b 51 e8	 mov	 edx, DWORD PTR [r9-24]
  00124	41 8b 49 ec	 mov	 ecx, DWORD PTR [r9-20]
  00128	45 8b 41 e0	 mov	 r8d, DWORD PTR [r9-32]
  0012c	45 33 41 14	 xor	 r8d, DWORD PTR [r9+20]
  00130	41 8b 41 e4	 mov	 eax, DWORD PTR [r9-28]
  00134	49 83 c1 10	 add	 r9, 16
  00138	41 33 41 08	 xor	 eax, DWORD PTR [r9+8]
  0013c	44 33 c2	 xor	 r8d, edx
  0013f	41 33 41 f4	 xor	 eax, DWORD PTR [r9-12]
  00143	45 33 41 f0	 xor	 r8d, DWORD PTR [r9-16]
  00147	33 c1		 xor	 eax, ecx
  00149	41 d1 c0	 rol	 r8d, 1
  0014c	d1 c0		 rol	 eax, 1
  0014e	45 89 41 10	 mov	 DWORD PTR [r9+16], r8d
  00152	41 89 41 14	 mov	 DWORD PTR [r9+20], eax
  00156	41 8b 41 0c	 mov	 eax, DWORD PTR [r9+12]
  0015a	41 33 41 e0	 xor	 eax, DWORD PTR [r9-32]
  0015e	41 33 41 f8	 xor	 eax, DWORD PTR [r9-8]
  00162	33 c2		 xor	 eax, edx
  00164	d1 c0		 rol	 eax, 1
  00166	41 89 41 18	 mov	 DWORD PTR [r9+24], eax
  0016a	41 8b 41 e4	 mov	 eax, DWORD PTR [r9-28]
  0016e	41 33 41 fc	 xor	 eax, DWORD PTR [r9-4]
  00172	41 33 c0	 xor	 eax, r8d
  00175	33 c1		 xor	 eax, ecx
  00177	d1 c0		 rol	 eax, 1
  00179	49 ff cc	 dec	 r12
  0017c	41 89 41 1c	 mov	 DWORD PTR [r9+28], eax
  00180	75 9e		 jne	 SHORT $LL11@sha1_compr

; 126  :     }
; 127  : 
; 128  :     /* compress */
; 129  :     /* round one */
; 130  :     #define FF_0(a,b,c,d,e,i) e = (ROLc(a, 5) + F0(b,c,d) + e + W[i] + 0x5a827999UL); b = ROLc(b, 30);
; 131  :     #define FF_1(a,b,c,d,e,i) e = (ROLc(a, 5) + F1(b,c,d) + e + W[i] + 0x6ed9eba1UL); b = ROLc(b, 30);
; 132  :     #define FF_2(a,b,c,d,e,i) e = (ROLc(a, 5) + F2(b,c,d) + e + W[i] + 0x8f1bbcdcUL); b = ROLc(b, 30);
; 133  :     #define FF_3(a,b,c,d,e,i) e = (ROLc(a, 5) + F3(b,c,d) + e + W[i] + 0xca62c1d6UL); b = ROLc(b, 30);
; 134  : 
; 135  :     for (i = 0; i < 20; ) {

  00182	48 8d 14 24	 lea	 rdx, QWORD PTR W$[rsp]
  00186	4d 8b c5	 mov	 r8, r13
  00189	0f 1f 80 00 00
	00 00		 npad	 7
$LL8@sha1_compr:

; 136  :        FF_0(a,b,c,d,e,i++);

  00190	41 8b c3	 mov	 eax, r11d
  00193	8b ce		 mov	 ecx, esi

; 137  :        FF_0(e,a,b,c,d,i++);
; 138  :        FF_0(d,e,a,b,c,i++);
; 139  :        FF_0(c,d,e,a,b,i++);
; 140  :        FF_0(b,c,d,e,a,i++);

  00195	48 83 c2 14	 add	 rdx, 20
  00199	41 33 c2	 xor	 eax, r10d
  0019c	c1 c1 05	 rol	 ecx, 5
  0019f	23 c7		 and	 eax, edi
  001a1	41 33 c3	 xor	 eax, r11d
  001a4	03 c8		 add	 ecx, eax
  001a6	41 8b c2	 mov	 eax, r10d
  001a9	03 4a ec	 add	 ecx, DWORD PTR [rdx-20]
  001ac	c1 cf 02	 ror	 edi, 2
  001af	33 c7		 xor	 eax, edi
  001b1	8d 9c 0b 99 79
	82 5a		 lea	 ebx, DWORD PTR [rbx+rcx+1518500249]
  001b8	23 c6		 and	 eax, esi
  001ba	8b cb		 mov	 ecx, ebx
  001bc	41 33 c2	 xor	 eax, r10d
  001bf	c1 c1 05	 rol	 ecx, 5
  001c2	03 c8		 add	 ecx, eax
  001c4	8b c7		 mov	 eax, edi
  001c6	03 4a f0	 add	 ecx, DWORD PTR [rdx-16]
  001c9	c1 ce 02	 ror	 esi, 2
  001cc	33 c6		 xor	 eax, esi
  001ce	45 8d 9c 0b 99
	79 82 5a	 lea	 r11d, DWORD PTR [r11+rcx+1518500249]
  001d6	23 c3		 and	 eax, ebx
  001d8	41 8b cb	 mov	 ecx, r11d
  001db	33 c7		 xor	 eax, edi
  001dd	c1 c1 05	 rol	 ecx, 5
  001e0	03 c8		 add	 ecx, eax
  001e2	03 4a f4	 add	 ecx, DWORD PTR [rdx-12]
  001e5	c1 cb 02	 ror	 ebx, 2
  001e8	45 8d 94 0a 99
	79 82 5a	 lea	 r10d, DWORD PTR [r10+rcx+1518500249]
  001f0	8b c3		 mov	 eax, ebx
  001f2	33 c6		 xor	 eax, esi
  001f4	41 8b ca	 mov	 ecx, r10d
  001f7	41 23 c3	 and	 eax, r11d
  001fa	c1 c1 05	 rol	 ecx, 5
  001fd	33 c6		 xor	 eax, esi
  001ff	03 c8		 add	 ecx, eax
  00201	8b c3		 mov	 eax, ebx
  00203	03 4a f8	 add	 ecx, DWORD PTR [rdx-8]
  00206	41 c1 cb 02	 ror	 r11d, 2
  0020a	8d bc 0f 99 79
	82 5a		 lea	 edi, DWORD PTR [rdi+rcx+1518500249]
  00211	41 33 c3	 xor	 eax, r11d
  00214	41 23 c2	 and	 eax, r10d
  00217	8b cf		 mov	 ecx, edi
  00219	c1 c1 05	 rol	 ecx, 5
  0021c	33 c3		 xor	 eax, ebx
  0021e	03 c8		 add	 ecx, eax
  00220	03 4a fc	 add	 ecx, DWORD PTR [rdx-4]
  00223	41 c1 ca 02	 ror	 r10d, 2
  00227	49 ff c8	 dec	 r8
  0022a	8d b4 0e 99 79
	82 5a		 lea	 esi, DWORD PTR [rsi+rcx+1518500249]
  00231	0f 85 59 ff ff
	ff		 jne	 $LL8@sha1_compr

; 126  :     }
; 127  : 
; 128  :     /* compress */
; 129  :     /* round one */
; 130  :     #define FF_0(a,b,c,d,e,i) e = (ROLc(a, 5) + F0(b,c,d) + e + W[i] + 0x5a827999UL); b = ROLc(b, 30);
; 131  :     #define FF_1(a,b,c,d,e,i) e = (ROLc(a, 5) + F1(b,c,d) + e + W[i] + 0x6ed9eba1UL); b = ROLc(b, 30);
; 132  :     #define FF_2(a,b,c,d,e,i) e = (ROLc(a, 5) + F2(b,c,d) + e + W[i] + 0x8f1bbcdcUL); b = ROLc(b, 30);
; 133  :     #define FF_3(a,b,c,d,e,i) e = (ROLc(a, 5) + F3(b,c,d) + e + W[i] + 0xca62c1d6UL); b = ROLc(b, 30);
; 134  : 
; 135  :     for (i = 0; i < 20; ) {

  00237	48 8d 54 24 50	 lea	 rdx, QWORD PTR W$[rsp+80]
  0023c	4d 8b c5	 mov	 r8, r13
  0023f	90		 npad	 1
$LL6@sha1_compr:

; 145  :        FF_1(a,b,c,d,e,i++);

  00240	41 8b c3	 mov	 eax, r11d
  00243	8b ce		 mov	 ecx, esi

; 146  :        FF_1(e,a,b,c,d,i++);
; 147  :        FF_1(d,e,a,b,c,i++);
; 148  :        FF_1(c,d,e,a,b,i++);
; 149  :        FF_1(b,c,d,e,a,i++);

  00245	48 83 c2 14	 add	 rdx, 20
  00249	41 33 c2	 xor	 eax, r10d
  0024c	c1 c1 05	 rol	 ecx, 5
  0024f	33 c7		 xor	 eax, edi
  00251	03 c8		 add	 ecx, eax
  00253	41 8b c2	 mov	 eax, r10d
  00256	03 4a ec	 add	 ecx, DWORD PTR [rdx-20]
  00259	c1 cf 02	 ror	 edi, 2
  0025c	33 c7		 xor	 eax, edi
  0025e	8d 9c 0b a1 eb
	d9 6e		 lea	 ebx, DWORD PTR [rbx+rcx+1859775393]
  00265	33 c6		 xor	 eax, esi
  00267	8b cb		 mov	 ecx, ebx
  00269	c1 c1 05	 rol	 ecx, 5
  0026c	03 c8		 add	 ecx, eax
  0026e	8b c3		 mov	 eax, ebx
  00270	03 4a f0	 add	 ecx, DWORD PTR [rdx-16]
  00273	33 c7		 xor	 eax, edi
  00275	c1 ce 02	 ror	 esi, 2
  00278	45 8d 9c 0b a1
	eb d9 6e	 lea	 r11d, DWORD PTR [r11+rcx+1859775393]
  00280	33 c6		 xor	 eax, esi
  00282	41 8b cb	 mov	 ecx, r11d
  00285	c1 c1 05	 rol	 ecx, 5
  00288	03 c8		 add	 ecx, eax
  0028a	03 4a f4	 add	 ecx, DWORD PTR [rdx-12]
  0028d	c1 cb 02	 ror	 ebx, 2
  00290	45 8d 94 0a a1
	eb d9 6e	 lea	 r10d, DWORD PTR [r10+rcx+1859775393]
  00298	8b c3		 mov	 eax, ebx
  0029a	41 33 c3	 xor	 eax, r11d
  0029d	41 8b ca	 mov	 ecx, r10d
  002a0	c1 c1 05	 rol	 ecx, 5
  002a3	33 c6		 xor	 eax, esi
  002a5	03 c8		 add	 ecx, eax
  002a7	8b c3		 mov	 eax, ebx
  002a9	03 4a f8	 add	 ecx, DWORD PTR [rdx-8]
  002ac	41 c1 cb 02	 ror	 r11d, 2
  002b0	8d bc 0f a1 eb
	d9 6e		 lea	 edi, DWORD PTR [rdi+rcx+1859775393]
  002b7	41 33 c3	 xor	 eax, r11d
  002ba	41 33 c2	 xor	 eax, r10d
  002bd	8b cf		 mov	 ecx, edi
  002bf	c1 c1 05	 rol	 ecx, 5
  002c2	03 c8		 add	 ecx, eax
  002c4	03 4a fc	 add	 ecx, DWORD PTR [rdx-4]
  002c7	41 c1 ca 02	 ror	 r10d, 2
  002cb	49 ff c8	 dec	 r8
  002ce	8d b4 0e a1 eb
	d9 6e		 lea	 esi, DWORD PTR [rsi+rcx+1859775393]
  002d5	0f 85 65 ff ff
	ff		 jne	 $LL6@sha1_compr

; 141  :     }
; 142  : 
; 143  :     /* round two */
; 144  :     for (; i < 40; )  {

  002db	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR W$[rsp+160]
  002e3	4d 8b cd	 mov	 r9, r13
  002e6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@sha1_compr:

; 154  :        FF_2(a,b,c,d,e,i++);

  002f0	41 8b ca	 mov	 ecx, r10d
  002f3	41 8b c2	 mov	 eax, r10d
  002f6	8b d6		 mov	 edx, esi
  002f8	0b cf		 or	 ecx, edi
  002fa	23 c7		 and	 eax, edi
  002fc	c1 c2 05	 rol	 edx, 5
  002ff	41 23 cb	 and	 ecx, r11d

; 155  :        FF_2(e,a,b,c,d,i++);
; 156  :        FF_2(d,e,a,b,c,i++);
; 157  :        FF_2(c,d,e,a,b,i++);
; 158  :        FF_2(b,c,d,e,a,i++);

  00302	49 83 c0 14	 add	 r8, 20
  00306	0b c8		 or	 ecx, eax
  00308	41 03 48 ec	 add	 ecx, DWORD PTR [r8-20]
  0030c	03 cb		 add	 ecx, ebx
  0030e	c1 cf 02	 ror	 edi, 2
  00311	8d 9c 11 dc bc
	1b 8f		 lea	 ebx, DWORD PTR [rcx+rdx-1894007588]
  00318	8b cf		 mov	 ecx, edi
  0031a	8b c7		 mov	 eax, edi
  0031c	0b ce		 or	 ecx, esi
  0031e	23 c6		 and	 eax, esi
  00320	8b d3		 mov	 edx, ebx
  00322	41 23 ca	 and	 ecx, r10d
  00325	c1 c2 05	 rol	 edx, 5
  00328	0b c8		 or	 ecx, eax
  0032a	8b c3		 mov	 eax, ebx
  0032c	41 03 48 f0	 add	 ecx, DWORD PTR [r8-16]
  00330	41 03 cb	 add	 ecx, r11d
  00333	c1 ce 02	 ror	 esi, 2
  00336	44 8d 9c 11 dc
	bc 1b 8f	 lea	 r11d, DWORD PTR [rcx+rdx-1894007588]
  0033e	23 c6		 and	 eax, esi
  00340	8b cb		 mov	 ecx, ebx
  00342	0b ce		 or	 ecx, esi
  00344	41 8b d3	 mov	 edx, r11d
  00347	23 cf		 and	 ecx, edi
  00349	c1 c2 05	 rol	 edx, 5
  0034c	0b c8		 or	 ecx, eax
  0034e	41 03 48 f4	 add	 ecx, DWORD PTR [r8-12]
  00352	41 03 ca	 add	 ecx, r10d
  00355	c1 cb 02	 ror	 ebx, 2
  00358	44 8d 94 11 dc
	bc 1b 8f	 lea	 r10d, DWORD PTR [rcx+rdx-1894007588]
  00360	8b cb		 mov	 ecx, ebx
  00362	8b c3		 mov	 eax, ebx
  00364	41 0b cb	 or	 ecx, r11d
  00367	41 23 c3	 and	 eax, r11d
  0036a	41 8b d2	 mov	 edx, r10d
  0036d	23 ce		 and	 ecx, esi
  0036f	c1 c2 05	 rol	 edx, 5
  00372	0b c8		 or	 ecx, eax
  00374	41 03 48 f8	 add	 ecx, DWORD PTR [r8-8]
  00378	03 cf		 add	 ecx, edi
  0037a	41 c1 cb 02	 ror	 r11d, 2
  0037e	8d bc 11 dc bc
	1b 8f		 lea	 edi, DWORD PTR [rcx+rdx-1894007588]
  00385	41 8b cb	 mov	 ecx, r11d
  00388	41 8b c3	 mov	 eax, r11d
  0038b	41 0b ca	 or	 ecx, r10d
  0038e	41 23 c2	 and	 eax, r10d
  00391	8b d7		 mov	 edx, edi
  00393	23 cb		 and	 ecx, ebx
  00395	c1 c2 05	 rol	 edx, 5
  00398	0b c8		 or	 ecx, eax
  0039a	41 03 48 fc	 add	 ecx, DWORD PTR [r8-4]
  0039e	03 ce		 add	 ecx, esi
  003a0	41 c1 ca 02	 ror	 r10d, 2
  003a4	49 ff c9	 dec	 r9
  003a7	8d b4 11 dc bc
	1b 8f		 lea	 esi, DWORD PTR [rcx+rdx-1894007588]
  003ae	0f 85 3c ff ff
	ff		 jne	 $LL4@sha1_compr

; 150  :     }
; 151  : 
; 152  :     /* round three */
; 153  :     for (; i < 60; )  {

  003b4	48 8d 94 24 f0
	00 00 00	 lea	 rdx, QWORD PTR W$[rsp+240]
  003bc	0f 1f 40 00	 npad	 4
$LL2@sha1_compr:

; 159  :     }
; 160  : 
; 161  :     /* round four */
; 162  :     for (; i < 80; )  {
; 163  :        FF_3(a,b,c,d,e,i++);

  003c0	41 8b c3	 mov	 eax, r11d
  003c3	8b ce		 mov	 ecx, esi

; 164  :        FF_3(e,a,b,c,d,i++);
; 165  :        FF_3(d,e,a,b,c,i++);
; 166  :        FF_3(c,d,e,a,b,i++);
; 167  :        FF_3(b,c,d,e,a,i++);

  003c5	48 83 c2 14	 add	 rdx, 20
  003c9	41 33 c2	 xor	 eax, r10d
  003cc	c1 c1 05	 rol	 ecx, 5
  003cf	33 c7		 xor	 eax, edi
  003d1	03 42 ec	 add	 eax, DWORD PTR [rdx-20]
  003d4	03 c3		 add	 eax, ebx
  003d6	c1 cf 02	 ror	 edi, 2
  003d9	8d 9c 08 d6 c1
	62 ca		 lea	 ebx, DWORD PTR [rax+rcx-899497514]
  003e0	41 8b c2	 mov	 eax, r10d
  003e3	33 c7		 xor	 eax, edi
  003e5	8b cb		 mov	 ecx, ebx
  003e7	33 c6		 xor	 eax, esi
  003e9	c1 c1 05	 rol	 ecx, 5
  003ec	03 42 f0	 add	 eax, DWORD PTR [rdx-16]
  003ef	41 03 c3	 add	 eax, r11d
  003f2	c1 ce 02	 ror	 esi, 2
  003f5	44 8d 9c 08 d6
	c1 62 ca	 lea	 r11d, DWORD PTR [rax+rcx-899497514]
  003fd	8b c3		 mov	 eax, ebx
  003ff	33 c7		 xor	 eax, edi
  00401	41 8b cb	 mov	 ecx, r11d
  00404	33 c6		 xor	 eax, esi
  00406	c1 c1 05	 rol	 ecx, 5
  00409	03 42 f4	 add	 eax, DWORD PTR [rdx-12]
  0040c	41 03 c2	 add	 eax, r10d
  0040f	c1 cb 02	 ror	 ebx, 2
  00412	44 8d 94 08 d6
	c1 62 ca	 lea	 r10d, DWORD PTR [rax+rcx-899497514]
  0041a	8b c3		 mov	 eax, ebx
  0041c	41 33 c3	 xor	 eax, r11d
  0041f	41 8b ca	 mov	 ecx, r10d
  00422	33 c6		 xor	 eax, esi
  00424	c1 c1 05	 rol	 ecx, 5
  00427	03 42 f8	 add	 eax, DWORD PTR [rdx-8]
  0042a	03 c7		 add	 eax, edi
  0042c	41 c1 cb 02	 ror	 r11d, 2
  00430	8d bc 08 d6 c1
	62 ca		 lea	 edi, DWORD PTR [rax+rcx-899497514]
  00437	8b c3		 mov	 eax, ebx
  00439	41 33 c3	 xor	 eax, r11d
  0043c	8b cf		 mov	 ecx, edi
  0043e	41 33 c2	 xor	 eax, r10d
  00441	c1 c1 05	 rol	 ecx, 5
  00444	03 42 fc	 add	 eax, DWORD PTR [rdx-4]
  00447	03 c6		 add	 eax, esi
  00449	41 c1 ca 02	 ror	 r10d, 2
  0044d	49 ff cd	 dec	 r13
  00450	8d b4 08 d6 c1
	62 ca		 lea	 esi, DWORD PTR [rax+rcx-899497514]
  00457	0f 85 63 ff ff
	ff		 jne	 $LL2@sha1_compr

; 168  :     }
; 169  : 
; 170  :     #undef FF_0
; 171  :     #undef FF_1
; 172  :     #undef FF_2
; 173  :     #undef FF_3
; 174  : 
; 175  :     /* store */
; 176  :     sha1->state[0] = sha1->state[0] + a;

  0045d	41 8d 04 36	 lea	 eax, DWORD PTR [r14+rsi]
  00461	89 45 08	 mov	 DWORD PTR [rbp+8], eax

; 177  :     sha1->state[1] = sha1->state[1] + b;

  00464	41 8d 04 3f	 lea	 eax, DWORD PTR [r15+rdi]
  00468	89 45 0c	 mov	 DWORD PTR [rbp+12], eax

; 178  :     sha1->state[2] = sha1->state[2] + c;

  0046b	8b 45 10	 mov	 eax, DWORD PTR [rbp+16]
  0046e	41 03 c2	 add	 eax, r10d
  00471	89 45 10	 mov	 DWORD PTR [rbp+16], eax

; 179  :     sha1->state[3] = sha1->state[3] + d;

  00474	8b 45 14	 mov	 eax, DWORD PTR [rbp+20]
  00477	41 03 c3	 add	 eax, r11d

; 180  :     sha1->state[4] = sha1->state[4] + e;
; 181  : }

  0047a	4c 8d 9c 24 40
	01 00 00	 lea	 r11, QWORD PTR [rsp+320]
  00482	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  00486	89 45 14	 mov	 DWORD PTR [rbp+20], eax
  00489	8b 45 18	 mov	 eax, DWORD PTR [rbp+24]
  0048c	03 c3		 add	 eax, ebx
  0048e	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  00492	89 45 18	 mov	 DWORD PTR [rbp+24], eax
  00495	49 8b 6b 38	 mov	 rbp, QWORD PTR [r11+56]
  00499	49 8b e3	 mov	 rsp, r11
  0049c	41 5f		 pop	 r15
  0049e	41 5e		 pop	 r14
  004a0	41 5d		 pop	 r13
  004a2	41 5c		 pop	 r12
  004a4	5f		 pop	 rdi
  004a5	c3		 ret	 0
sha1_compress ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT sha1_init
_TEXT	SEGMENT
sha1$ = 8
sha1_init PROC						; COMDAT

; 190  :    assert(sha1 != NULL);
; 191  :    sha1->state[0] = 0x67452301UL;
; 192  :    sha1->state[1] = 0xefcdab89UL;
; 193  :    sha1->state[2] = 0x98badcfeUL;
; 194  :    sha1->state[3] = 0x10325476UL;
; 195  :    sha1->state[4] = 0xc3d2e1f0UL;
; 196  :    sha1->curlen = 0;

  00000	33 c0		 xor	 eax, eax
  00002	c7 41 08 01 23
	45 67		 mov	 DWORD PTR [rcx+8], 1732584193 ; 67452301H
  00009	c7 41 0c 89 ab
	cd ef		 mov	 DWORD PTR [rcx+12], -271733879 ; efcdab89H
  00010	c7 41 10 fe dc
	ba 98		 mov	 DWORD PTR [rcx+16], -1732584194 ; 98badcfeH
  00017	c7 41 14 76 54
	32 10		 mov	 DWORD PTR [rcx+20], 271733878 ; 10325476H
  0001e	c7 41 18 f0 e1
	d2 c3		 mov	 DWORD PTR [rcx+24], -1009589776 ; c3d2e1f0H
  00025	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 197  :    sha1->length = 0;

  00028	48 89 01	 mov	 QWORD PTR [rcx], rax

; 198  : }

  0002b	c3		 ret	 0
sha1_init ENDP
_TEXT	ENDS
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$sha1_process DD imagerel sha1_process
	DD	imagerel sha1_process+24
	DD	imagerel $unwind$sha1_process
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$sha1_process DD imagerel sha1_process+24
	DD	imagerel sha1_process+190
	DD	imagerel $chain$1$sha1_process
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$sha1_process DD imagerel sha1_process+190
	DD	imagerel sha1_process+192
	DD	imagerel $chain$2$sha1_process
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$sha1_process DD 021H
	DD	imagerel sha1_process
	DD	imagerel sha1_process+24
	DD	imagerel $unwind$sha1_process
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$sha1_process DD 041321H
	DD	063413H
	DD	07c405H
	DD	imagerel sha1_process
	DD	imagerel sha1_process+24
	DD	imagerel $unwind$sha1_process
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sha1_process DD 061801H
	DD	096418H
	DD	085418H
	DD	070143218H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT sha1_process
_TEXT	SEGMENT
sha1$ = 48
in$ = 56
inlen$ = 64
sha1_process PROC					; COMDAT

; 210  :     Py_ssize_t n;
; 211  : 
; 212  :     assert(sha1 != NULL);
; 213  :     assert(in != NULL);
; 214  :     assert(sha1->curlen <= sizeof(sha1->buf));
; 215  : 
; 216  :     while (inlen > 0) {

  00000	4d 85 c0	 test	 r8, r8
  00003	0f 8e b5 00 00
	00		 jle	 $LN11@sha1_proce
  00009	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000e	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00013	57		 push	 rdi
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00018	4c 89 64 24 38	 mov	 QWORD PTR [rsp+56], r12

; 209  : {

  0001d	49 8b f0	 mov	 rsi, r8
  00020	48 8b ea	 mov	 rbp, rdx

; 210  :     Py_ssize_t n;
; 211  : 
; 212  :     assert(sha1 != NULL);
; 213  :     assert(in != NULL);
; 214  :     assert(sha1->curlen <= sizeof(sha1->buf));
; 215  : 
; 216  :     while (inlen > 0) {

  00023	45 33 e4	 xor	 r12d, r12d
  00026	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0002b	48 8b f9	 mov	 rdi, rcx
  0002e	66 90		 npad	 2
$LL5@sha1_proce:

; 217  :         if (sha1->curlen == 0 && inlen >= SHA1_BLOCKSIZE) {

  00030	8b 4f 1c	 mov	 ecx, DWORD PTR [rdi+28]
  00033	85 c9		 test	 ecx, ecx
  00035	75 22		 jne	 SHORT $LN3@sha1_proce
  00037	48 83 fe 40	 cmp	 rsi, 64			; 00000040H
  0003b	7c 1c		 jl	 SHORT $LN3@sha1_proce

; 218  :            sha1_compress(sha1, (unsigned char *)in);

  0003d	48 8b d5	 mov	 rdx, rbp
  00040	48 8b cf	 mov	 rcx, rdi
  00043	e8 00 00 00 00	 call	 sha1_compress

; 219  :            sha1->length   += SHA1_BLOCKSIZE * 8;

  00048	48 81 07 00 02
	00 00		 add	 QWORD PTR [rdi], 512	; 00000200H

; 220  :            in             += SHA1_BLOCKSIZE;

  0004f	48 83 c5 40	 add	 rbp, 64			; 00000040H

; 221  :            inlen          -= SHA1_BLOCKSIZE;

  00053	48 83 ee 40	 sub	 rsi, 64			; 00000040H

; 222  :         } else {

  00057	eb 47		 jmp	 SHORT $LN1@sha1_proce
$LN3@sha1_proce:

; 223  :            n = MIN(inlen, (Py_ssize_t)(SHA1_BLOCKSIZE - sha1->curlen));
; 224  :            memcpy(sha1->buf + sha1->curlen, in, (size_t)n);

  00059	8b 47 1c	 mov	 eax, DWORD PTR [rdi+28]
  0005c	bb 40 00 00 00	 mov	 ebx, 64			; 00000040H
  00061	48 8b d5	 mov	 rdx, rbp
  00064	2b d9		 sub	 ebx, ecx
  00066	48 8d 4c 38 20	 lea	 rcx, QWORD PTR [rax+rdi+32]
  0006b	48 3b f3	 cmp	 rsi, rbx
  0006e	48 0f 4c de	 cmovl	 rbx, rsi
  00072	4c 8b c3	 mov	 r8, rbx
  00075	e8 00 00 00 00	 call	 memcpy

; 225  :            sha1->curlen   += n;

  0007a	01 5f 1c	 add	 DWORD PTR [rdi+28], ebx

; 226  :            in             += n;

  0007d	48 03 eb	 add	 rbp, rbx

; 227  :            inlen          -= n;

  00080	48 2b f3	 sub	 rsi, rbx

; 228  :            if (sha1->curlen == SHA1_BLOCKSIZE) {

  00083	83 7f 1c 40	 cmp	 DWORD PTR [rdi+28], 64	; 00000040H
  00087	75 17		 jne	 SHORT $LN1@sha1_proce

; 229  :               sha1_compress(sha1, sha1->buf);

  00089	48 8d 57 20	 lea	 rdx, QWORD PTR [rdi+32]
  0008d	48 8b cf	 mov	 rcx, rdi
  00090	e8 00 00 00 00	 call	 sha1_compress

; 230  :               sha1->length += 8*SHA1_BLOCKSIZE;

  00095	48 81 07 00 02
	00 00		 add	 QWORD PTR [rdi], 512	; 00000200H

; 231  :               sha1->curlen = 0;

  0009c	44 89 67 1c	 mov	 DWORD PTR [rdi+28], r12d
$LN1@sha1_proce:

; 210  :     Py_ssize_t n;
; 211  : 
; 212  :     assert(sha1 != NULL);
; 213  :     assert(in != NULL);
; 214  :     assert(sha1->curlen <= sizeof(sha1->buf));
; 215  : 
; 216  :     while (inlen > 0) {

  000a0	48 85 f6	 test	 rsi, rsi
  000a3	7f 8b		 jg	 SHORT $LL5@sha1_proce

; 232  :            }
; 233  :        }
; 234  :     }
; 235  : }

  000a5	4c 8b 64 24 38	 mov	 r12, QWORD PTR [rsp+56]
  000aa	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000af	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000b4	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000b9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bd	5f		 pop	 rdi
$LN11@sha1_proce:
  000be	f3 c3		 fatret	 0
sha1_process ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sha1_done DD imagerel sha1_done
	DD	imagerel sha1_done+369
	DD	imagerel $unwind$sha1_done
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sha1_done DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT sha1_done
_TEXT	SEGMENT
sha1$ = 48
out$ = 56
sha1_done PROC						; COMDAT

; 244  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 245  :     int i;
; 246  : 
; 247  :     assert(sha1 != NULL);
; 248  :     assert(out != NULL);
; 249  :     assert(sha1->curlen < sizeof(sha1->buf));
; 250  : 
; 251  :     /* increase the length of the message */
; 252  :     sha1->length += sha1->curlen * 8;

  0000a	44 8b 49 1c	 mov	 r9d, DWORD PTR [rcx+28]
  0000e	48 8b fa	 mov	 rdi, rdx
  00011	48 8b d9	 mov	 rbx, rcx
  00014	46 8d 04 cd 00
	00 00 00	 lea	 r8d, DWORD PTR [r9*8]
  0001c	4c 01 01	 add	 QWORD PTR [rcx], r8

; 253  : 
; 254  :     /* append the '1' bit */
; 255  :     sha1->buf[sha1->curlen++] = (unsigned char)0x80;

  0001f	41 c6 44 09 20
	80		 mov	 BYTE PTR [r9+rcx+32], 128 ; 00000080H
  00025	ff 41 1c	 inc	 DWORD PTR [rcx+28]
  00028	8b 41 1c	 mov	 eax, DWORD PTR [rcx+28]

; 256  : 
; 257  :     /* if the length is currently above 56 bytes we append zeros
; 258  :      * then compress.  Then we can fall back to padding zeros and length
; 259  :      * encoding like normal.
; 260  :      */
; 261  :     if (sha1->curlen > 56) {

  0002b	83 f8 38	 cmp	 eax, 56			; 00000038H
  0002e	76 30		 jbe	 SHORT $LN12@sha1_done

; 262  :         while (sha1->curlen < 64) {

  00030	83 f8 40	 cmp	 eax, 64			; 00000040H
  00033	73 1b		 jae	 SHORT $LN6@sha1_done
  00035	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL7@sha1_done:

; 263  :             sha1->buf[sha1->curlen++] = (unsigned char)0;

  00040	c6 44 08 20 00	 mov	 BYTE PTR [rax+rcx+32], 0
  00045	ff 41 1c	 inc	 DWORD PTR [rcx+28]
  00048	8b 41 1c	 mov	 eax, DWORD PTR [rcx+28]
  0004b	83 f8 40	 cmp	 eax, 64			; 00000040H
  0004e	72 f0		 jb	 SHORT $LL7@sha1_done
$LN6@sha1_done:

; 264  :         }
; 265  :         sha1_compress(sha1, sha1->buf);

  00050	48 8d 51 20	 lea	 rdx, QWORD PTR [rcx+32]
  00054	e8 00 00 00 00	 call	 sha1_compress

; 266  :         sha1->curlen = 0;

  00059	c7 43 1c 00 00
	00 00		 mov	 DWORD PTR [rbx+28], 0
$LN12@sha1_done:

; 267  :     }
; 268  : 
; 269  :     /* pad upto 56 bytes of zeroes */
; 270  :     while (sha1->curlen < 56) {

  00060	83 7b 1c 38	 cmp	 DWORD PTR [rbx+28], 56	; 00000038H
  00064	73 1b		 jae	 SHORT $LN4@sha1_done
  00066	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL5@sha1_done:

; 271  :         sha1->buf[sha1->curlen++] = (unsigned char)0;

  00070	8b 43 1c	 mov	 eax, DWORD PTR [rbx+28]
  00073	c6 44 18 20 00	 mov	 BYTE PTR [rax+rbx+32], 0
  00078	ff 43 1c	 inc	 DWORD PTR [rbx+28]
  0007b	83 7b 1c 38	 cmp	 DWORD PTR [rbx+28], 56	; 00000038H
  0007f	72 ef		 jb	 SHORT $LL5@sha1_done
$LN4@sha1_done:

; 272  :     }
; 273  : 
; 274  :     /* store length */
; 275  :     STORE64H(sha1->length, sha1->buf+56);

  00081	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]

; 276  :     sha1_compress(sha1, sha1->buf);

  00084	48 8d 53 20	 lea	 rdx, QWORD PTR [rbx+32]
  00088	48 8b c1	 mov	 rax, rcx
  0008b	48 c1 f8 38	 sar	 rax, 56			; 00000038H
  0008f	88 43 58	 mov	 BYTE PTR [rbx+88], al
  00092	48 8b c1	 mov	 rax, rcx
  00095	48 c1 f8 30	 sar	 rax, 48			; 00000030H
  00099	88 43 59	 mov	 BYTE PTR [rbx+89], al
  0009c	48 8b c1	 mov	 rax, rcx
  0009f	48 c1 f8 28	 sar	 rax, 40			; 00000028H
  000a3	88 43 5a	 mov	 BYTE PTR [rbx+90], al
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 c1 f8 20	 sar	 rax, 32			; 00000020H
  000ad	88 43 5b	 mov	 BYTE PTR [rbx+91], al
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	48 c1 f8 18	 sar	 rax, 24
  000b7	88 43 5c	 mov	 BYTE PTR [rbx+92], al
  000ba	48 8b c1	 mov	 rax, rcx
  000bd	48 c1 f9 08	 sar	 rcx, 8
  000c1	48 c1 f8 10	 sar	 rax, 16
  000c5	88 4b 5e	 mov	 BYTE PTR [rbx+94], cl
  000c8	48 8b cb	 mov	 rcx, rbx
  000cb	88 43 5d	 mov	 BYTE PTR [rbx+93], al
  000ce	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  000d1	88 43 5f	 mov	 BYTE PTR [rbx+95], al
  000d4	e8 00 00 00 00	 call	 sha1_compress

; 277  : 
; 278  :     /* copy output */
; 279  :     for (i = 0; i < 5; i++) {
; 280  :         STORE32H(sha1->state[i], out+(4*i));

  000d9	44 0f b6 5b 0b	 movzx	 r11d, BYTE PTR [rbx+11]
  000de	44 88 1f	 mov	 BYTE PTR [rdi], r11b
  000e1	0f b6 43 0a	 movzx	 eax, BYTE PTR [rbx+10]
  000e5	88 47 01	 mov	 BYTE PTR [rdi+1], al
  000e8	0f b6 43 09	 movzx	 eax, BYTE PTR [rbx+9]
  000ec	88 47 02	 mov	 BYTE PTR [rdi+2], al
  000ef	0f b6 43 08	 movzx	 eax, BYTE PTR [rbx+8]
  000f3	88 47 03	 mov	 BYTE PTR [rdi+3], al
  000f6	0f b6 43 0f	 movzx	 eax, BYTE PTR [rbx+15]
  000fa	88 47 04	 mov	 BYTE PTR [rdi+4], al
  000fd	0f b6 43 0e	 movzx	 eax, BYTE PTR [rbx+14]
  00101	88 47 05	 mov	 BYTE PTR [rdi+5], al
  00104	0f b6 43 0d	 movzx	 eax, BYTE PTR [rbx+13]
  00108	88 47 06	 mov	 BYTE PTR [rdi+6], al
  0010b	0f b6 43 0c	 movzx	 eax, BYTE PTR [rbx+12]
  0010f	88 47 07	 mov	 BYTE PTR [rdi+7], al
  00112	0f b6 43 13	 movzx	 eax, BYTE PTR [rbx+19]
  00116	88 47 08	 mov	 BYTE PTR [rdi+8], al
  00119	0f b6 43 12	 movzx	 eax, BYTE PTR [rbx+18]
  0011d	88 47 09	 mov	 BYTE PTR [rdi+9], al
  00120	0f b6 43 11	 movzx	 eax, BYTE PTR [rbx+17]
  00124	88 47 0a	 mov	 BYTE PTR [rdi+10], al
  00127	0f b6 43 10	 movzx	 eax, BYTE PTR [rbx+16]
  0012b	88 47 0b	 mov	 BYTE PTR [rdi+11], al
  0012e	0f b6 43 17	 movzx	 eax, BYTE PTR [rbx+23]
  00132	88 47 0c	 mov	 BYTE PTR [rdi+12], al
  00135	0f b6 43 16	 movzx	 eax, BYTE PTR [rbx+22]
  00139	88 47 0d	 mov	 BYTE PTR [rdi+13], al
  0013c	0f b6 43 15	 movzx	 eax, BYTE PTR [rbx+21]
  00140	88 47 0e	 mov	 BYTE PTR [rdi+14], al
  00143	0f b6 43 14	 movzx	 eax, BYTE PTR [rbx+20]
  00147	88 47 0f	 mov	 BYTE PTR [rdi+15], al
  0014a	0f b6 43 1b	 movzx	 eax, BYTE PTR [rbx+27]
  0014e	88 47 10	 mov	 BYTE PTR [rdi+16], al
  00151	0f b6 43 1a	 movzx	 eax, BYTE PTR [rbx+26]
  00155	88 47 11	 mov	 BYTE PTR [rdi+17], al
  00158	0f b6 43 19	 movzx	 eax, BYTE PTR [rbx+25]
  0015c	88 47 12	 mov	 BYTE PTR [rdi+18], al
  0015f	0f b6 43 18	 movzx	 eax, BYTE PTR [rbx+24]

; 281  :     }
; 282  : }

  00163	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00168	88 47 13	 mov	 BYTE PTR [rdi+19], al
  0016b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0016f	5f		 pop	 rdi
  00170	c3		 ret	 0
sha1_done ENDP
_TEXT	ENDS
EXTRN	_PyObject_New:PROC
EXTRN	_PxObject_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$newSHA1object DD imagerel newSHA1object
	DD	imagerel newSHA1object+38
	DD	imagerel $unwind$newSHA1object
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newSHA1object DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT newSHA1object
_TEXT	SEGMENT
newSHA1object PROC					; COMDAT

; 300  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 301  :     return (SHA1object *)PyObject_New(SHA1object, &SHA1type);

  00004	e8 00 00 00 00	 call	 _Py_PXCTX
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:SHA1type
  00010	85 c0		 test	 eax, eax
  00012	74 09		 je	 SHORT $LN3@newSHA1obj

; 302  : }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	e9 00 00 00 00	 jmp	 _PxObject_New
$LN3@newSHA1obj:
  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	e9 00 00 00 00	 jmp	 _PyObject_New
newSHA1object ENDP
_TEXT	ENDS
EXTRN	PyObject_Free:PROC
; Function compile flags: /Ogtpy
;	COMDAT SHA1_dealloc
_TEXT	SEGMENT
ptr$ = 8
SHA1_dealloc PROC					; COMDAT

; 310  :     PyObject_Del(ptr);
; 311  : }

  00000	e9 00 00 00 00	 jmp	 PyObject_Free
SHA1_dealloc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SHA1_copy DD imagerel SHA1_copy
	DD	imagerel SHA1_copy+70
	DD	imagerel $unwind$SHA1_copy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SHA1_copy DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT SHA1_copy
_TEXT	SEGMENT
self$ = 48
unused$ = 56
SHA1_copy PROC						; COMDAT

; 320  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 321  :     SHA1object *newobj;
; 322  : 
; 323  :     if ((newobj = newSHA1object()) == NULL)

  0000d	e8 00 00 00 00	 call	 newSHA1object
  00012	48 8b d8	 mov	 rbx, rax
  00015	48 85 c0	 test	 rax, rax
  00018	75 0b		 jne	 SHORT $LN1@SHA1_copy

; 328  : }

  0001a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0001f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
$LN1@SHA1_copy:

; 324  :         return NULL;
; 325  : 
; 326  :     newobj->hash_state = self->hash_state;

  00025	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  00029	48 8d 57 60	 lea	 rdx, QWORD PTR [rdi+96]
  0002d	41 b8 60 00 00
	00		 mov	 r8d, 96			; 00000060H
  00033	e8 00 00 00 00	 call	 memcpy

; 327  :     return (PyObject *)newobj;

  00038	48 8b c3	 mov	 rax, rbx

; 328  : }

  0003b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5f		 pop	 rdi
  00045	c3		 ret	 0
SHA1_copy ENDP
_TEXT	ENDS
EXTRN	PyBytes_FromStringAndSize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$SHA1_digest DD imagerel SHA1_digest
	DD	imagerel SHA1_digest+107
	DD	imagerel $unwind$SHA1_digest
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SHA1_digest DD 020a01H
	DD	015010aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT SHA1_digest
_TEXT	SEGMENT
digest$ = 32
self$ = 176
unused$ = 184
SHA1_digest PROC					; COMDAT

; 335  : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 336  :     unsigned char digest[SHA1_DIGESTSIZE];
; 337  :     struct sha1_state temp;
; 338  : 
; 339  :     temp = self->hash_state;

  0000a	0f 10 41 60	 movups	 xmm0, XMMWORD PTR [rcx+96]
  0000e	0f 10 49 70	 movups	 xmm1, XMMWORD PTR [rcx+112]

; 340  :     sha1_done(&temp, digest);

  00012	48 8d 54 24 20	 lea	 rdx, QWORD PTR digest$[rsp]
  00017	0f 29 40 98	 movaps	 XMMWORD PTR [rax-104], xmm0
  0001b	0f 29 48 a8	 movaps	 XMMWORD PTR [rax-88], xmm1
  0001f	0f 10 81 80 00
	00 00		 movups	 xmm0, XMMWORD PTR [rcx+128]
  00026	0f 10 89 90 00
	00 00		 movups	 xmm1, XMMWORD PTR [rcx+144]
  0002d	0f 29 40 b8	 movaps	 XMMWORD PTR [rax-72], xmm0
  00031	0f 29 48 c8	 movaps	 XMMWORD PTR [rax-56], xmm1
  00035	0f 10 81 a0 00
	00 00		 movups	 xmm0, XMMWORD PTR [rcx+160]
  0003c	0f 10 89 b0 00
	00 00		 movups	 xmm1, XMMWORD PTR [rcx+176]
  00043	48 8d 48 98	 lea	 rcx, QWORD PTR [rax-104]
  00047	0f 29 40 d8	 movaps	 XMMWORD PTR [rax-40], xmm0
  0004b	0f 29 48 e8	 movaps	 XMMWORD PTR [rax-24], xmm1
  0004f	e8 00 00 00 00	 call	 sha1_done

; 341  :     return PyBytes_FromStringAndSize((const char *)digest, SHA1_DIGESTSIZE);

  00054	48 8d 4c 24 20	 lea	 rcx, QWORD PTR digest$[rsp]
  00059	ba 14 00 00 00	 mov	 edx, 20
  0005e	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize

; 342  : }

  00063	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0006a	c3		 ret	 0
SHA1_digest ENDP
_TEXT	ENDS
EXTRN	Py_hexdigits:QWORD
EXTRN	PyUnicode_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$SHA1_hexdigest DD imagerel SHA1_hexdigest
	DD	imagerel SHA1_hexdigest+229
	DD	imagerel $unwind$SHA1_hexdigest
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SHA1_hexdigest DD 020a01H
	DD	015010aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT SHA1_hexdigest
_TEXT	SEGMENT
digest$ = 32
self$ = 176
unused$ = 184
SHA1_hexdigest PROC					; COMDAT

; 349  : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 350  :     unsigned char digest[SHA1_DIGESTSIZE];
; 351  :     struct sha1_state temp;
; 352  :     PyObject *retval;
; 353  :     Py_UCS1 *hex_digest;
; 354  :     int i, j;
; 355  : 
; 356  :     /* Get the raw (binary) digest value */
; 357  :     temp = self->hash_state;

  0000a	0f 10 41 60	 movups	 xmm0, XMMWORD PTR [rcx+96]
  0000e	0f 10 49 70	 movups	 xmm1, XMMWORD PTR [rcx+112]

; 358  :     sha1_done(&temp, digest);

  00012	48 8d 54 24 20	 lea	 rdx, QWORD PTR digest$[rsp]
  00017	0f 29 40 98	 movaps	 XMMWORD PTR [rax-104], xmm0
  0001b	0f 29 48 a8	 movaps	 XMMWORD PTR [rax-88], xmm1
  0001f	0f 10 81 80 00
	00 00		 movups	 xmm0, XMMWORD PTR [rcx+128]
  00026	0f 10 89 90 00
	00 00		 movups	 xmm1, XMMWORD PTR [rcx+144]
  0002d	0f 29 40 b8	 movaps	 XMMWORD PTR [rax-72], xmm0
  00031	0f 29 48 c8	 movaps	 XMMWORD PTR [rax-56], xmm1
  00035	0f 10 81 a0 00
	00 00		 movups	 xmm0, XMMWORD PTR [rcx+160]
  0003c	0f 10 89 b0 00
	00 00		 movups	 xmm1, XMMWORD PTR [rcx+176]
  00043	48 8d 48 98	 lea	 rcx, QWORD PTR [rax-104]
  00047	0f 29 40 d8	 movaps	 XMMWORD PTR [rax-40], xmm0
  0004b	0f 29 48 e8	 movaps	 XMMWORD PTR [rax-24], xmm1
  0004f	e8 00 00 00 00	 call	 sha1_done

; 359  : 
; 360  :     /* Create a new string */
; 361  :     retval = PyUnicode_New(SHA1_DIGESTSIZE * 2, 127);

  00054	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00059	8d 4a a9	 lea	 ecx, QWORD PTR [rdx-87]
  0005c	e8 00 00 00 00	 call	 PyUnicode_New
  00061	4c 8b d8	 mov	 r11, rax

; 362  :     if (!retval)

  00064	48 85 c0	 test	 rax, rax
  00067	75 08		 jne	 SHORT $LN4@SHA1_hexdi

; 378  : }

  00069	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00070	c3		 ret	 0
$LN4@SHA1_hexdi:

; 363  :             return NULL;
; 364  :     hex_digest = PyUnicode_1BYTE_DATA(retval);

  00071	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00074	a8 20		 test	 al, 32			; 00000020H
  00076	74 16		 je	 SHORT $LN9@SHA1_hexdi
  00078	a8 40		 test	 al, 64			; 00000040H
  0007a	74 09		 je	 SHORT $LN7@SHA1_hexdi
  0007c	4d 8d 83 80 00
	00 00		 lea	 r8, QWORD PTR [r11+128]
  00083	eb 10		 jmp	 SHORT $LN10@SHA1_hexdi
$LN7@SHA1_hexdi:
  00085	4d 8d 83 a0 00
	00 00		 lea	 r8, QWORD PTR [r11+160]
  0008c	eb 07		 jmp	 SHORT $LN10@SHA1_hexdi
$LN9@SHA1_hexdi:
  0008e	4d 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [r11+160]
$LN10@SHA1_hexdi:

; 365  : 
; 366  :     /* Make hex version of the digest */
; 367  :     for(i=j=0; i<SHA1_DIGESTSIZE; i++) {

  00095	45 33 c9	 xor	 r9d, r9d
  00098	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL3@SHA1_hexdi:

; 368  :         unsigned char c;
; 369  :         c = (digest[i] >> 4) & 0xf;
; 370  :         hex_digest[j++] = Py_hexdigits[c];

  000a0	42 0f b6 54 0c
	20		 movzx	 edx, BYTE PTR digest$[rsp+r9]
  000a6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  000ad	49 ff c1	 inc	 r9
  000b0	8b ca		 mov	 ecx, edx

; 371  :         c = (digest[i] & 0xf);

  000b2	83 e2 0f	 and	 edx, 15

; 372  :         hex_digest[j++] = Py_hexdigits[c];

  000b5	49 83 c0 02	 add	 r8, 2
  000b9	48 c1 e9 04	 shr	 rcx, 4
  000bd	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  000c1	41 88 48 fe	 mov	 BYTE PTR [r8-2], cl
  000c5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  000cc	0f b6 0c 02	 movzx	 ecx, BYTE PTR [rdx+rax]
  000d0	41 88 48 ff	 mov	 BYTE PTR [r8-1], cl
  000d4	49 83 f9 14	 cmp	 r9, 20
  000d8	7c c6		 jl	 SHORT $LL3@SHA1_hexdi

; 373  :     }
; 374  : #ifdef Py_DEBUG
; 375  :     assert(_PyUnicode_CheckConsistency(retval, 1));
; 376  : #endif
; 377  :     return retval;

  000da	49 8b c3	 mov	 rax, r11

; 378  : }

  000dd	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  000e4	c3		 ret	 0
SHA1_hexdigest ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@NHOOCGGK@object?5supporting?5the?5buffer?5API@ ; `string'
PUBLIC	??_C@_0CA@DGKHNIN@Buffer?5must?5be?5single?5dimension?$AA@ ; `string'
PUBLIC	??_C@_0CP@IBHDLOCD@Unicode?9objects?5must?5be?5encoded?5@ ; `string'
PUBLIC	??_C@_08BNPIIEPK@O?3update?$AA@			; `string'
EXTRN	PyExc_TypeError:QWORD
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyBuffer_Release:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_BufferError:QWORD
EXTRN	PyObject_GetBuffer:PROC
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$SHA1_update DD imagerel SHA1_update
	DD	imagerel SHA1_update+321
	DD	imagerel $unwind$SHA1_update
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SHA1_update DD 020901H
	DD	03002f209H
xdata	ENDS
;	COMDAT ??_C@_0CK@NHOOCGGK@object?5supporting?5the?5buffer?5API@
CONST	SEGMENT
??_C@_0CK@NHOOCGGK@object?5supporting?5the?5buffer?5API@ DB 'object suppo'
	DB	'rting the buffer API required', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DGKHNIN@Buffer?5must?5be?5single?5dimension?$AA@
CONST	SEGMENT
??_C@_0CA@DGKHNIN@Buffer?5must?5be?5single?5dimension?$AA@ DB 'Buffer mus'
	DB	't be single dimension', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@IBHDLOCD@Unicode?9objects?5must?5be?5encoded?5@
CONST	SEGMENT
??_C@_0CP@IBHDLOCD@Unicode?9objects?5must?5be?5encoded?5@ DB 'Unicode-obj'
	DB	'ects must be encoded before hashing', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BNPIIEPK@O?3update?$AA@
CONST	SEGMENT
??_C@_08BNPIIEPK@O?3update?$AA@ DB 'O:update', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\sha1module.c
CONST	ENDS
;	COMDAT SHA1_update
_TEXT	SEGMENT
buf$ = 48
self$ = 144
args$ = 152
obj$ = 160
SHA1_update PROC					; COMDAT

; 385  : {

  00000	40 53		 push	 rbx
  00002	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00009	48 8b c2	 mov	 rax, rdx
  0000c	48 8b d9	 mov	 rbx, rcx

; 386  :     PyObject *obj;
; 387  :     Py_buffer buf;
; 388  : 
; 389  :     if (!PyArg_ParseTuple(args, "O:update", &obj))

  0000f	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR obj$[rsp]
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08BNPIIEPK@O?3update?$AA@
  0001e	48 8b c8	 mov	 rcx, rax
  00021	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00026	85 c0		 test	 eax, eax

; 390  :         return NULL;

  00028	0f 84 08 01 00
	00		 je	 $LN16@SHA1_updat

; 391  : 
; 392  :     GET_BUFFER_VIEW_OR_ERROUT(obj, &buf);

  0002e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  00036	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0003a	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00044	74 0c		 je	 SHORT $LN5@SHA1_updat
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@IBHDLOCD@Unicode?9objects?5must?5be?5encoded?5@
  0004d	e9 d8 00 00 00	 jmp	 $LN17@SHA1_updat
$LN5@SHA1_updat:
  00052	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  00059	48 85 c0	 test	 rax, rax
  0005c	0f 84 c1 00 00
	00		 je	 $LN3@SHA1_updat
  00062	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00066	0f 84 b7 00 00
	00		 je	 $LN3@SHA1_updat
  0006c	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf$[rsp]
  00071	45 33 c0	 xor	 r8d, r8d
  00074	e8 00 00 00 00	 call	 PyObject_GetBuffer
  00079	83 f8 ff	 cmp	 eax, -1
  0007c	0f 84 b4 00 00
	00		 je	 $LN16@SHA1_updat
  00082	83 7c 24 54 01	 cmp	 DWORD PTR buf$[rsp+36], 1
  00087	7e 28		 jle	 SHORT $LN7@SHA1_updat
  00089	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  00090	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@DGKHNIN@Buffer?5must?5be?5single?5dimension?$AA@
  00097	e8 00 00 00 00	 call	 PyErr_SetString
  0009c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  000a1	e8 00 00 00 00	 call	 PyBuffer_Release
  000a6	33 c0		 xor	 eax, eax

; 399  : }

  000a8	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  000af	5b		 pop	 rbx
  000b0	c3		 ret	 0
$LN7@SHA1_updat:

; 393  : 
; 394  :     sha1_process(&self->hash_state, buf.buf, buf.len);

  000b1	4c 8b 44 24 40	 mov	 r8, QWORD PTR buf$[rsp+16]
  000b6	48 8b 54 24 30	 mov	 rdx, QWORD PTR buf$[rsp]
  000bb	48 8d 4b 60	 lea	 rcx, QWORD PTR [rbx+96]
  000bf	e8 00 00 00 00	 call	 sha1_process

; 395  : 
; 396  :     PyBuffer_Release(&buf);

  000c4	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  000c9	e8 00 00 00 00	 call	 PyBuffer_Release

; 397  :     Py_INCREF(Py_None);

  000ce	e8 00 00 00 00	 call	 _Py_PXCTX
  000d3	85 c0		 test	 eax, eax
  000d5	75 3c		 jne	 SHORT $LN13@SHA1_updat
  000d7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  000de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000ec	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000f2	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000fa	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ff	85 c0		 test	 eax, eax
  00101	75 09		 jne	 SHORT $LN12@SHA1_updat
  00103	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0010a	74 07		 je	 SHORT $LN13@SHA1_updat
$LN12@SHA1_updat:
  0010c	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN13@SHA1_updat:

; 398  :     return Py_None;

  00113	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 399  : }

  0011a	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00121	5b		 pop	 rbx
  00122	c3		 ret	 0
$LN3@SHA1_updat:

; 391  : 
; 392  :     GET_BUFFER_VIEW_OR_ERROUT(obj, &buf);

  00123	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@NHOOCGGK@object?5supporting?5the?5buffer?5API@
$LN17@SHA1_updat:
  0012a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00131	e8 00 00 00 00	 call	 PyErr_SetString
$LN16@SHA1_updat:
  00136	33 c0		 xor	 eax, eax

; 399  : }

  00138	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  0013f	5b		 pop	 rbx
  00140	c3		 ret	 0
SHA1_update ENDP
_TEXT	ENDS
EXTRN	PyLong_FromLong:PROC
; Function compile flags: /Ogtpy
;	COMDAT SHA1_get_block_size
_TEXT	SEGMENT
self$ = 8
closure$ = 16
SHA1_get_block_size PROC				; COMDAT

; 412  :     return PyLong_FromLong(SHA1_BLOCKSIZE);

  00000	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H

; 413  : }

  00005	e9 00 00 00 00	 jmp	 PyLong_FromLong
SHA1_get_block_size ENDP
_TEXT	ENDS
PUBLIC	??_C@_04KPMLCNGO@SHA1?$AA@			; `string'
EXTRN	PyUnicode_FromStringAndSize:PROC
;	COMDAT ??_C@_04KPMLCNGO@SHA1?$AA@
CONST	SEGMENT
??_C@_04KPMLCNGO@SHA1?$AA@ DB 'SHA1', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT SHA1_get_name
_TEXT	SEGMENT
self$ = 8
closure$ = 16
SHA1_get_name PROC					; COMDAT

; 418  :     return PyUnicode_FromStringAndSize("SHA1", 4);

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04KPMLCNGO@SHA1?$AA@
  00007	ba 04 00 00 00	 mov	 edx, 4

; 419  : }

  0000c	e9 00 00 00 00	 jmp	 PyUnicode_FromStringAndSize
SHA1_get_name ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT sha1_get_digest_size
_TEXT	SEGMENT
self$ = 8
closure$ = 16
sha1_get_digest_size PROC				; COMDAT

; 424  :     return PyLong_FromLong(SHA1_DIGESTSIZE);

  00000	b9 14 00 00 00	 mov	 ecx, 20

; 425  : }

  00005	e9 00 00 00 00	 jmp	 PyLong_FromLong
sha1_get_digest_size ENDP
_TEXT	ENDS
PUBLIC	??_C@_06KJFPOEIK@?$HMO?3new?$AA@		; `string'
EXTRN	PyErr_Occurred:PROC
EXTRN	PyArg_ParseTupleAndKeywords:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$SHA1_new DD imagerel SHA1_new
	DD	imagerel SHA1_new+234
	DD	imagerel $unwind$SHA1_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$SHA1_new DD imagerel SHA1_new+234
	DD	imagerel SHA1_new+293
	DD	imagerel $chain$0$SHA1_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$SHA1_new DD imagerel SHA1_new+293
	DD	imagerel SHA1_new+420
	DD	imagerel $chain$3$SHA1_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$SHA1_new DD 040c21H
	DD	010740cH
	DD	0123400H
	DD	imagerel SHA1_new
	DD	imagerel SHA1_new+234
	DD	imagerel $unwind$SHA1_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$SHA1_new DD 020821H
	DD	0123408H
	DD	imagerel SHA1_new
	DD	imagerel SHA1_new+234
	DD	imagerel $unwind$SHA1_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SHA1_new DD 020a01H
	DD	011010aH
xdata	ENDS
;	COMDAT ??_C@_06KJFPOEIK@?$HMO?3new?$AA@
CONST	SEGMENT
??_C@_06KJFPOEIK@?$HMO?3new?$AA@ DB '|O:new', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT SHA1_new
_TEXT	SEGMENT
buf$ = 48
self$ = 144
args$ = 152
kwdict$ = 160
data_obj$ = 168
SHA1_new PROC						; COMDAT

; 486  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 487  :     static char *kwlist[] = {"string", NULL};
; 488  :     SHA1object *new;
; 489  :     PyObject *data_obj = NULL;
; 490  :     Py_buffer buf;
; 491  : 
; 492  :     if (!PyArg_ParseTupleAndKeywords(args, kwdict, "|O:new", kwlist,
; 493  :                                      &data_obj)) {

  0000a	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  0000e	49 8b c0	 mov	 rax, r8
  00011	4c 8b d2	 mov	 r10, rdx
  00014	49 89 4b 98	 mov	 QWORD PTR [r11-104], rcx
  00018	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??SHA1_new@@9@9
  0001f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06KJFPOEIK@?$HMO?3new?$AA@
  00026	49 8b ca	 mov	 rcx, r10
  00029	48 8b d0	 mov	 rdx, rax
  0002c	49 c7 43 20 00
	00 00 00	 mov	 QWORD PTR [r11+32], 0
  00034	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00039	85 c0		 test	 eax, eax

; 494  :         return NULL;

  0003b	74 34		 je	 SHORT $LN20@SHA1_new

; 495  :     }
; 496  : 
; 497  :     if (data_obj)

  0003d	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR data_obj$[rsp]
  00045	48 85 c9	 test	 rcx, rcx
  00048	0f 84 9c 00 00
	00		 je	 $LN11@SHA1_new

; 498  :         GET_BUFFER_VIEW_OR_ERROUT(data_obj, &buf);

  0004e	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00052	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  0005c	74 1d		 je	 SHORT $LN10@SHA1_new
  0005e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@IBHDLOCD@Unicode?9objects?5must?5be?5encoded?5@
  0006c	e8 00 00 00 00	 call	 PyErr_SetString
$LN20@SHA1_new:
  00071	33 c0		 xor	 eax, eax

; 520  : }

  00073	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0007a	c3		 ret	 0
$LN10@SHA1_new:

; 498  :         GET_BUFFER_VIEW_OR_ERROUT(data_obj, &buf);

  0007b	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  00082	48 85 c0	 test	 rax, rax
  00085	74 46		 je	 SHORT $LN8@SHA1_new
  00087	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0008b	74 40		 je	 SHORT $LN8@SHA1_new
  0008d	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf$[rsp]
  00092	45 33 c0	 xor	 r8d, r8d
  00095	e8 00 00 00 00	 call	 PyObject_GetBuffer
  0009a	83 f8 ff	 cmp	 eax, -1
  0009d	74 d2		 je	 SHORT $LN20@SHA1_new
  0009f	83 7c 24 54 01	 cmp	 DWORD PTR buf$[rsp+36], 1
  000a4	7e 44		 jle	 SHORT $LN11@SHA1_new
  000a6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  000ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@DGKHNIN@Buffer?5must?5be?5single?5dimension?$AA@
  000b4	e8 00 00 00 00	 call	 PyErr_SetString
  000b9	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  000be	e8 00 00 00 00	 call	 PyBuffer_Release
  000c3	33 c0		 xor	 eax, eax

; 520  : }

  000c5	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  000cc	c3		 ret	 0
$LN8@SHA1_new:

; 498  :         GET_BUFFER_VIEW_OR_ERROUT(data_obj, &buf);

  000cd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@NHOOCGGK@object?5supporting?5the?5buffer?5API@
  000db	e8 00 00 00 00	 call	 PyErr_SetString
  000e0	33 c0		 xor	 eax, eax

; 520  : }

  000e2	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  000e9	c3		 ret	 0
$LN11@SHA1_new:
  000ea	48 89 9c 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rbx

; 499  : 
; 500  :     if ((new = newSHA1object()) == NULL) {

  000f2	e8 00 00 00 00	 call	 newSHA1object
  000f7	48 8b d8	 mov	 rbx, rax
  000fa	48 85 c0	 test	 rax, rax
  000fd	75 26		 jne	 SHORT $LN5@SHA1_new

; 501  :         if (data_obj)

  000ff	48 39 84 24 a8
	00 00 00	 cmp	 QWORD PTR data_obj$[rsp], rax
  00107	74 0a		 je	 SHORT $LN4@SHA1_new

; 502  :             PyBuffer_Release(&buf);

  00109	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  0010e	e8 00 00 00 00	 call	 PyBuffer_Release
$LN4@SHA1_new:

; 503  :         return NULL;

  00113	33 c0		 xor	 eax, eax
  00115	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]

; 520  : }

  0011d	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00124	c3		 ret	 0
$LN5@SHA1_new:

; 504  :     }
; 505  : 
; 506  :     sha1_init(&new->hash_state);

  00125	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  00129	48 89 bc 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rdi
  00131	e8 00 00 00 00	 call	 sha1_init

; 507  : 
; 508  :     if (PyErr_Occurred()) {

  00136	e8 00 00 00 00	 call	 PyErr_Occurred
  0013b	48 85 c0	 test	 rax, rax
  0013e	74 21		 je	 SHORT $LN3@SHA1_new

; 509  :         Py_DECREF(new);

  00140	48 8b cb	 mov	 rcx, rbx
  00143	e8 00 00 00 00	 call	 _Py_DecRef

; 510  :         if (data_obj)

  00148	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR data_obj$[rsp], 0
  00151	74 0a		 je	 SHORT $LN2@SHA1_new

; 511  :             PyBuffer_Release(&buf);

  00153	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  00158	e8 00 00 00 00	 call	 PyBuffer_Release
$LN2@SHA1_new:

; 512  :         return NULL;

  0015d	33 c0		 xor	 eax, eax
  0015f	eb 2b		 jmp	 SHORT $LN19@SHA1_new
$LN3@SHA1_new:

; 513  :     }
; 514  :     if (data_obj) {

  00161	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR data_obj$[rsp], 0
  0016a	74 1d		 je	 SHORT $LN1@SHA1_new

; 515  :         sha1_process(&new->hash_state, buf.buf, buf.len);

  0016c	4c 8b 44 24 40	 mov	 r8, QWORD PTR buf$[rsp+16]
  00171	48 8b 54 24 30	 mov	 rdx, QWORD PTR buf$[rsp]
  00176	48 8d 4b 60	 lea	 rcx, QWORD PTR [rbx+96]
  0017a	e8 00 00 00 00	 call	 sha1_process

; 516  :         PyBuffer_Release(&buf);

  0017f	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  00184	e8 00 00 00 00	 call	 PyBuffer_Release
$LN1@SHA1_new:

; 517  :     }
; 518  : 
; 519  :     return (PyObject *)new;

  00189	48 8b c3	 mov	 rax, rbx
$LN19@SHA1_new:
  0018c	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR [rsp+128]
  00194	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]

; 520  : }

  0019c	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001a3	c3		 ret	 0
SHA1_new ENDP
_TEXT	ENDS
PUBLIC	PyInit__sha1
EXTRN	PyModule_Create2:PROC
EXTRN	PyType_Ready:PROC
EXTRN	PyType_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit__sha1 DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$PyInit__sha1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit__sha1 DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyInit__sha1
_TEXT	SEGMENT
PyInit__sha1 PROC					; COMDAT

; 550  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 551  :     Py_TYPE(&SHA1type) = &PyType_Type;

  00004	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyType_Type

; 552  :     if (PyType_Ready(&SHA1type) < 0)

  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:SHA1type
  00012	48 89 05 58 00
	00 00		 mov	 QWORD PTR SHA1type+88, rax
  00019	e8 00 00 00 00	 call	 PyType_Ready
  0001e	85 c0		 test	 eax, eax
  00020	79 07		 jns	 SHORT $LN1@PyInit__sh

; 553  :         return NULL;

  00022	33 c0		 xor	 eax, eax

; 555  : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
$LN1@PyInit__sh:

; 554  :     return PyModule_Create(&_sha1module);

  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_sha1module
  00030	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H

; 555  : }

  00035	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00039	e9 00 00 00 00	 jmp	 PyModule_Create2
PyInit__sha1 ENDP
_TEXT	ENDS
END
