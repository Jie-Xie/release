; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_01DDCIFGEA@E?$AA@				; `string'
PUBLIC	??_C@_03LKNCIKJB@NAN?$AA@			; `string'
PUBLIC	??_C@_03OEIAHPBN@INF?$AA@			; `string'
PUBLIC	??_C@_01KGKMHCOC@e?$AA@				; `string'
PUBLIC	??_C@_03LHCJEHON@nan?$AA@			; `string'
PUBLIC	??_C@_03OJHLLCGB@inf?$AA@			; `string'
;	COMDAT ??_C@_01DDCIFGEA@E?$AA@
CONST	SEGMENT
??_C@_01DDCIFGEA@E?$AA@ DB 'E', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LKNCIKJB@NAN?$AA@
CONST	SEGMENT
??_C@_03LKNCIKJB@NAN?$AA@ DB 'NAN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OEIAHPBN@INF?$AA@
CONST	SEGMENT
??_C@_03OEIAHPBN@INF?$AA@ DB 'INF', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
lc_float_strings DQ FLAT:??_C@_03OJHLLCGB@inf?$AA@
	DQ	FLAT:??_C@_03LHCJEHON@nan?$AA@
	DQ	FLAT:??_C@_01KGKMHCOC@e?$AA@
uc_float_strings DQ FLAT:??_C@_03OEIAHPBN@INF?$AA@
	DQ	FLAT:??_C@_03LKNCIKJB@NAN?$AA@
	DQ	FLAT:??_C@_01DDCIFGEA@E?$AA@
_DATA	ENDS
;	COMDAT ??_C@_01KGKMHCOC@e?$AA@
CONST	SEGMENT
??_C@_01KGKMHCOC@e?$AA@ DB 'e', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LHCJEHON@nan?$AA@
CONST	SEGMENT
??_C@_03LHCJEHON@nan?$AA@ DB 'nan', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OJHLLCGB@inf?$AA@
CONST	SEGMENT
??_C@_03OJHLLCGB@inf?$AA@ DB 'inf', 00H			; `string'
CONST	ENDS
EXTRN	_Py_ctype_tolower:BYTE
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\pystrtod.c
;	COMDAT case_insensitive_match
_TEXT	SEGMENT
s$ = 8
t$ = 16
case_insensitive_match PROC				; COMDAT

; 12   :     while(*t && Py_TOLOWER(*s) == *t) {

  00000	44 0f b6 02	 movzx	 r8d, BYTE PTR [rdx]
  00004	4c 8b c9	 mov	 r9, rcx
  00007	45 84 c0	 test	 r8b, r8b
  0000a	74 33		 je	 SHORT $LN1@case_insen
  0000c	4c 2b ca	 sub	 r9, rdx
  0000f	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:_Py_ctype_tolower
  00016	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL2@case_insen:
  00020	41 0f b6 04 11	 movzx	 eax, BYTE PTR [r9+rdx]
  00025	42 0f b6 0c 10	 movzx	 ecx, BYTE PTR [rax+r10]
  0002a	41 0f be c0	 movsx	 eax, r8b
  0002e	3b c8		 cmp	 ecx, eax
  00030	75 0d		 jne	 SHORT $LN1@case_insen
  00032	44 0f b6 42 01	 movzx	 r8d, BYTE PTR [rdx+1]

; 13   :         s++;
; 14   :         t++;

  00037	48 ff c2	 inc	 rdx
  0003a	45 84 c0	 test	 r8b, r8b
  0003d	75 e1		 jne	 SHORT $LL2@case_insen
$LN1@case_insen:

; 15   :     }
; 16   :     return *t ? 0 : 1;

  0003f	33 c0		 xor	 eax, eax
  00041	38 02		 cmp	 BYTE PTR [rdx], al
  00043	0f 94 c0	 sete	 al

; 17   : }

  00046	c3		 ret	 0
case_insensitive_match ENDP
_TEXT	ENDS
PUBLIC	__real@bff0000000000000
PUBLIC	??_C@_05KMOPHDFI@inity?$AA@			; `string'
PUBLIC	_Py_parse_inf_or_nan
EXTRN	_Py_dg_stdnan:PROC
EXTRN	_Py_dg_infinity:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_parse_inf_or_nan DD imagerel $LN12
	DD	imagerel $LN12+196
	DD	imagerel $unwind$_Py_parse_inf_or_nan
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_parse_inf_or_nan DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT ??_C@_05KMOPHDFI@inity?$AA@
CONST	SEGMENT
??_C@_05KMOPHDFI@inity?$AA@ DB 'inity', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_parse_inf_or_nan
_TEXT	SEGMENT
p$ = 48
endptr$ = 56
_Py_parse_inf_or_nan PROC				; COMDAT

; 29   : {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 30   :     double retval;
; 31   :     const char *s;
; 32   :     int negate = 0;
; 33   : 
; 34   :     s = p;
; 35   :     if (*s == '-') {

  0000f	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00012	33 ff		 xor	 edi, edi
  00014	48 8b f2	 mov	 rsi, rdx
  00017	4c 8b d9	 mov	 r11, rcx
  0001a	48 8b d9	 mov	 rbx, rcx
  0001d	3c 2d		 cmp	 al, 45			; 0000002dH
  0001f	75 07		 jne	 SHORT $LN8@Py_parse_i

; 36   :         negate = 1;

  00021	bf 01 00 00 00	 mov	 edi, 1

; 37   :         s++;

  00026	eb 04		 jmp	 SHORT $LN11@Py_parse_i
$LN8@Py_parse_i:

; 38   :     }
; 39   :     else if (*s == '+') {

  00028	3c 2b		 cmp	 al, 43			; 0000002bH
  0002a	75 04		 jne	 SHORT $LN6@Py_parse_i
$LN11@Py_parse_i:

; 40   :         s++;

  0002c	48 8d 59 01	 lea	 rbx, QWORD PTR [rcx+1]
$LN6@Py_parse_i:

; 41   :     }
; 42   :     if (case_insensitive_match(s, "inf")) {

  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03OJHLLCGB@inf?$AA@
  00037	48 8b cb	 mov	 rcx, rbx
  0003a	e8 00 00 00 00	 call	 case_insensitive_match
  0003f	85 c0		 test	 eax, eax
  00041	74 35		 je	 SHORT $LN5@Py_parse_i

; 43   :         s += 3;

  00043	48 83 c3 03	 add	 rbx, 3

; 44   :         if (case_insensitive_match(s, "inity"))

  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05KMOPHDFI@inity?$AA@
  0004e	48 8b cb	 mov	 rcx, rbx
  00051	e8 00 00 00 00	 call	 case_insensitive_match
  00056	85 c0		 test	 eax, eax
  00058	74 04		 je	 SHORT $LN4@Py_parse_i

; 45   :             s += 5;

  0005a	48 83 c3 05	 add	 rbx, 5
$LN4@Py_parse_i:

; 46   :         retval = _Py_dg_infinity(negate);

  0005e	8b cf		 mov	 ecx, edi
  00060	e8 00 00 00 00	 call	 _Py_dg_infinity

; 51   :     }
; 52   :     else {
; 53   :         s = p;
; 54   :         retval = -1.0;
; 55   :     }
; 56   :     *endptr = (char *)s;

  00065	48 89 1e	 mov	 QWORD PTR [rsi], rbx

; 58   : }

  00068	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00072	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
$LN5@Py_parse_i:

; 47   :     }
; 48   :     else if (case_insensitive_match(s, "nan")) {

  00078	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03LHCJEHON@nan?$AA@
  0007f	48 8b cb	 mov	 rcx, rbx
  00082	e8 00 00 00 00	 call	 case_insensitive_match
  00087	85 c0		 test	 eax, eax
  00089	74 1e		 je	 SHORT $LN2@Py_parse_i

; 49   :         s += 3;
; 50   :         retval = _Py_dg_stdnan(negate);

  0008b	8b cf		 mov	 ecx, edi
  0008d	48 83 c3 03	 add	 rbx, 3
  00091	e8 00 00 00 00	 call	 _Py_dg_stdnan

; 51   :     }
; 52   :     else {
; 53   :         s = p;
; 54   :         retval = -1.0;
; 55   :     }
; 56   :     *endptr = (char *)s;

  00096	48 89 1e	 mov	 QWORD PTR [rsi], rbx

; 58   : }

  00099	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000a3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a7	5f		 pop	 rdi
  000a8	c3		 ret	 0
$LN2@Py_parse_i:

; 57   :     return retval;

  000a9	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000

; 58   : }

  000b1	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b6	4c 89 1e	 mov	 QWORD PTR [rsi], r11
  000b9	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000be	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c2	5f		 pop	 rdi
  000c3	c3		 ret	 0
_Py_parse_inf_or_nan ENDP
_TEXT	ENDS
EXTRN	_Py_dg_strtod:PROC
EXTRN	__imp__errno:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyOS_ascii_strtod DD imagerel _PyOS_ascii_strtod
	DD	imagerel _PyOS_ascii_strtod+66
	DD	imagerel $unwind$_PyOS_ascii_strtod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyOS_ascii_strtod DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyOS_ascii_strtod
_TEXT	SEGMENT
nptr$ = 48
endptr$ = 56
_PyOS_ascii_strtod PROC					; COMDAT

; 132  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	48 8b f9	 mov	 rdi, rcx

; 133  :     double result;
; 134  :     _Py_SET_53BIT_PRECISION_HEADER;
; 135  : 
; 136  :     assert(nptr != NULL);
; 137  :     /* Set errno to zero, so that we can distinguish zero results
; 138  :        and underflows */
; 139  :     errno = 0;

  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 140  : 
; 141  :     _Py_SET_53BIT_PRECISION_START;
; 142  :     result = _Py_dg_strtod(nptr, endptr);

  00016	48 8b d3	 mov	 rdx, rbx
  00019	48 8b cf	 mov	 rcx, rdi
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  00022	e8 00 00 00 00	 call	 _Py_dg_strtod

; 143  :     _Py_SET_53BIT_PRECISION_END;
; 144  : 
; 145  :     if (*endptr == nptr)

  00027	48 39 3b	 cmp	 QWORD PTR [rbx], rdi
  0002a	75 0b		 jne	 SHORT $LN4@PyOS_ascii

; 146  :         /* string might represent an inf or nan */
; 147  :         result = _Py_parse_inf_or_nan(nptr, endptr);

  0002c	48 8b d3	 mov	 rdx, rbx
  0002f	48 8b cf	 mov	 rcx, rdi
  00032	e8 00 00 00 00	 call	 _Py_parse_inf_or_nan
$LN4@PyOS_ascii:

; 148  : 
; 149  :     return result;
; 150  : 
; 151  : }

  00037	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
_PyOS_ascii_strtod ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@POKIHDFE@value?5too?5large?5to?5convert?5to?5fl@ ; `string'
PUBLIC	__real@3ff0000000000000
PUBLIC	__mask@@AbsDouble@
PUBLIC	??_C@_0CK@IAECOGLD@could?5not?5convert?5string?5to?5floa@ ; `string'
PUBLIC	PyOS_string_to_double
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyErr_NoMemory:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyOS_string_to_double DD imagerel $LN14
	DD	imagerel $LN14+275
	DD	imagerel $unwind$PyOS_string_to_double
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyOS_string_to_double DD 0a2401H
	DD	027824H
	DD	036814H
	DD	0c640fH
	DD	0a340fH
	DD	0700b720fH
xdata	ENDS
;	COMDAT ??_C@_0CM@POKIHDFE@value?5too?5large?5to?5convert?5to?5fl@
CONST	SEGMENT
??_C@_0CM@POKIHDFE@value?5too?5large?5to?5convert?5to?5fl@ DB 'value too '
	DB	'large to convert to float: %.200s', 00H	; `string'
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __mask@@AbsDouble@
CONST	SEGMENT
__mask@@AbsDouble@ DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH, 0ffH
	DB	0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT ??_C@_0CK@IAECOGLD@could?5not?5convert?5string?5to?5floa@
CONST	SEGMENT
??_C@_0CK@IAECOGLD@could?5not?5convert?5string?5to?5floa@ DB 'could not c'
	DB	'onvert string to float: %.200s', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyOS_string_to_double
_TEXT	SEGMENT
s$ = 80
fail_pos$ = 88
endptr$ = 88
overflow_exception$ = 96
PyOS_string_to_double PROC				; COMDAT

; 340  : {

$LN14:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	0f 29 74 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm6

; 341  :     double x, result=-1.0;

  00014	f2 0f 10 35 00
	00 00 00	 movsdx	 xmm6, QWORD PTR __real@bff0000000000000
  0001c	49 8b f0	 mov	 rsi, r8
  0001f	0f 29 7c 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm7
  00024	48 8b fa	 mov	 rdi, rdx
  00027	48 8b d9	 mov	 rbx, rcx

; 342  :     char *fail_pos;
; 343  : 
; 344  :     errno = 0;

  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 345  :     PyFPE_START_PROTECT("PyOS_string_to_double", return -1.0)
; 346  :     x = _PyOS_ascii_strtod(s, &fail_pos);

  00030	48 8d 54 24 58	 lea	 rdx, QWORD PTR fail_pos$[rsp]
  00035	48 8b cb	 mov	 rcx, rbx
  00038	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  0003e	e8 00 00 00 00	 call	 _PyOS_ascii_strtod
  00043	66 0f 28 f8	 movapd	 xmm7, xmm0

; 347  :     PyFPE_END_PROTECT(x)
; 348  : 
; 349  :     if (errno == ENOMEM) {

  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0004d	83 38 0c	 cmp	 DWORD PTR [rax], 12
  00050	75 0f		 jne	 SHORT $LN10@PyOS_strin

; 350  :         PyErr_NoMemory();

  00052	e8 00 00 00 00	 call	 PyErr_NoMemory

; 351  :         fail_pos = (char *)s;

  00057	48 89 5c 24 58	 mov	 QWORD PTR fail_pos$[rsp], rbx
  0005c	e9 87 00 00 00	 jmp	 $LN2@PyOS_strin
$LN10@PyOS_strin:

; 352  :     }
; 353  :     else if (!endptr && (fail_pos == s || *fail_pos != '\0'))

  00061	48 8b 44 24 58	 mov	 rax, QWORD PTR fail_pos$[rsp]
  00066	48 85 ff	 test	 rdi, rdi
  00069	75 22		 jne	 SHORT $LN8@PyOS_strin
  0006b	48 3b c3	 cmp	 rax, rbx
  0006e	74 05		 je	 SHORT $LN7@PyOS_strin
  00070	40 38 38	 cmp	 BYTE PTR [rax], dil
  00073	74 18		 je	 SHORT $LN8@PyOS_strin
$LN7@PyOS_strin:

; 354  :         PyErr_Format(PyExc_ValueError,
; 355  :                       "could not convert string to float: "
; 356  :                       "%.200s", s);

  00075	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0007c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@IAECOGLD@could?5not?5convert?5string?5to?5floa@
  00083	4c 8b c3	 mov	 r8, rbx
  00086	e8 00 00 00 00	 call	 PyErr_Format
  0008b	eb 68		 jmp	 SHORT $LN13@PyOS_strin
$LN8@PyOS_strin:

; 357  :     else if (fail_pos == s)

  0008d	48 3b c3	 cmp	 rax, rbx
  00090	75 18		 jne	 SHORT $LN5@PyOS_strin

; 358  :         PyErr_Format(PyExc_ValueError,
; 359  :                       "could not convert string to float: "
; 360  :                       "%.200s", s);

  00092	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00099	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@IAECOGLD@could?5not?5convert?5string?5to?5floa@
  000a0	4c 8b c3	 mov	 r8, rbx
  000a3	e8 00 00 00 00	 call	 PyErr_Format
  000a8	eb 3e		 jmp	 SHORT $LN2@PyOS_strin
$LN5@PyOS_strin:

; 361  :     else if (errno == ERANGE && fabs(x) >= 1.0 && overflow_exception)

  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000b0	83 38 22	 cmp	 DWORD PTR [rax], 34	; 00000022H
  000b3	75 2f		 jne	 SHORT $LN3@PyOS_strin
  000b5	66 0f 28 c7	 movapd	 xmm0, xmm7
  000b9	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __mask@@AbsDouble@
  000c1	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@3ff0000000000000
  000c9	72 19		 jb	 SHORT $LN3@PyOS_strin
  000cb	48 85 f6	 test	 rsi, rsi
  000ce	74 14		 je	 SHORT $LN3@PyOS_strin

; 362  :         PyErr_Format(overflow_exception,
; 363  :                       "value too large to convert to float: "
; 364  :                       "%.200s", s);

  000d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@POKIHDFE@value?5too?5large?5to?5convert?5to?5fl@
  000d7	4c 8b c3	 mov	 r8, rbx
  000da	48 8b ce	 mov	 rcx, rsi
  000dd	e8 00 00 00 00	 call	 PyErr_Format

; 365  :     else

  000e2	eb 04		 jmp	 SHORT $LN2@PyOS_strin
$LN3@PyOS_strin:

; 366  :         result = x;

  000e4	66 0f 28 f7	 movapd	 xmm6, xmm7
$LN2@PyOS_strin:

; 367  : 
; 368  :     if (endptr != NULL)

  000e8	48 85 ff	 test	 rdi, rdi
  000eb	74 08		 je	 SHORT $LN13@PyOS_strin

; 369  :         *endptr = fail_pos;

  000ed	48 8b 44 24 58	 mov	 rax, QWORD PTR fail_pos$[rsp]
  000f2	48 89 07	 mov	 QWORD PTR [rdi], rax
$LN13@PyOS_strin:

; 370  :     return result;
; 371  : }

  000f5	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000fa	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  000ff	0f 28 7c 24 20	 movaps	 xmm7, XMMWORD PTR [rsp+32]
  00104	66 0f 28 c6	 movapd	 xmm0, xmm6
  00108	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  0010d	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00111	5f		 pop	 rdi
  00112	c3		 ret	 0
PyOS_string_to_double ENDP
_TEXT	ENDS
PUBLIC	??_C@_06DKNJDFNG@?$CF?$CL?402d?$AA@		; `string'
PUBLIC	??_C@_0BF@GKLBOEON@?4?4?2Python?2pystrtod?4c?$AA@ ; `string'
PUBLIC	??_C@_03JFMEENOE@ERR?$AA@			; `string'
EXTRN	__imp_sprintf:PROC
EXTRN	_PyErr_BadInternalCall:PROC
EXTRN	_Py_dg_freedtoa:PROC
EXTRN	__imp_strncpy:PROC
EXTRN	PyMem_Malloc:PROC
EXTRN	_Py_ctype_table:BYTE
EXTRN	_Py_dg_dtoa:PROC
EXTRN	memset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$format_float_short DD imagerel format_float_short
	DD	imagerel format_float_short+97
	DD	imagerel $unwind$format_float_short
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$format_float_short DD imagerel format_float_short+97
	DD	imagerel format_float_short+293
	DD	imagerel $chain$1$format_float_short
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$format_float_short DD imagerel format_float_short+293
	DD	imagerel format_float_short+316
	DD	imagerel $chain$2$format_float_short
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$format_float_short DD imagerel format_float_short+316
	DD	imagerel format_float_short+1021
	DD	imagerel $chain$3$format_float_short
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$format_float_short DD 040021H
	DD	011d400H
	DD	010c400H
	DD	imagerel format_float_short
	DD	imagerel format_float_short+97
	DD	imagerel $unwind$format_float_short
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$format_float_short DD 021H
	DD	imagerel format_float_short
	DD	imagerel format_float_short+97
	DD	imagerel $unwind$format_float_short
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$format_float_short DD 041021H
	DD	011d410H
	DD	010c408H
	DD	imagerel format_float_short
	DD	imagerel format_float_short+97
	DD	imagerel $unwind$format_float_short
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$format_float_short DD 081001H
	DD	0123410H
	DD	0f00c9210H
	DD	07008e00aH
	DD	050066007H
xdata	ENDS
;	COMDAT ??_C@_06DKNJDFNG@?$CF?$CL?402d?$AA@
CONST	SEGMENT
??_C@_06DKNJDFNG@?$CF?$CL?402d?$AA@ DB '%+.02d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GKLBOEON@?4?4?2Python?2pystrtod?4c?$AA@
CONST	SEGMENT
??_C@_0BF@GKLBOEON@?4?4?2Python?2pystrtod?4c?$AA@ DB '..\Python\pystrtod.'
	DB	'c', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_03JFMEENOE@ERR?$AA@
CONST	SEGMENT
??_C@_03JFMEENOE@ERR?$AA@ DB 'ERR', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT format_float_short
_TEXT	SEGMENT
sign$ = 48
exp$1$ = 52
decpt_as_int$ = 56
digits$1$ = 64
digits_end$ = 72
d$ = 128
format_code$ = 136
mode$ = 144
precision$ = 152
always_add_sign$ = 160
add_dot_0_if_integer$ = 168
use_alt_formatting$ = 176
float_strings$ = 184
type$ = 192
format_float_short PROC					; COMDAT

; 929  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 56		 push	 r14
  0000a	41 57		 push	 r15
  0000c	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00010	49 8b d9	 mov	 rbx, r9
  00013	41 8b c8	 mov	 ecx, r8d

; 930  :     char *buf = NULL;
; 931  :     char *p = NULL;
; 932  :     Py_ssize_t bufsize = 0;
; 933  :     char *digits, *digits_end;
; 934  :     int decpt_as_int, sign, exp_len, exp = 0, use_exp = 0;
; 935  :     Py_ssize_t decpt, digits_len, vdigits_start, vdigits_end;
; 936  :     _Py_SET_53BIT_PRECISION_HEADER;
; 937  : 
; 938  :     /* _Py_dg_dtoa returns a digit string (no decimal point or exponent).
; 939  :        Must be matched by a call to _Py_dg_freedtoa. */
; 940  :     _Py_SET_53BIT_PRECISION_START;
; 941  :     digits = _Py_dg_dtoa(d, mode, precision, &decpt_as_int, &sign,
; 942  :                          &digits_end);

  00016	48 8d 44 24 48	 lea	 rax, QWORD PTR digits_end$[rsp]
  0001b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00020	48 8d 44 24 30	 lea	 rax, QWORD PTR sign$[rsp]
  00025	0f b6 fa	 movzx	 edi, dl
  00028	33 f6		 xor	 esi, esi
  0002a	4c 8d 4c 24 38	 lea	 r9, QWORD PTR decpt_as_int$[rsp]
  0002f	44 8b c3	 mov	 r8d, ebx
  00032	8b d1		 mov	 edx, ecx
  00034	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00039	89 74 24 34	 mov	 DWORD PTR exp$1$[rsp], esi
  0003d	44 8b fe	 mov	 r15d, esi
  00040	e8 00 00 00 00	 call	 _Py_dg_dtoa

; 943  :     _Py_SET_53BIT_PRECISION_END;
; 944  : 
; 945  :     decpt = (Py_ssize_t)decpt_as_int;

  00045	48 63 6c 24 38	 movsxd	 rbp, DWORD PTR decpt_as_int$[rsp]
  0004a	4c 8b f0	 mov	 r14, rax
  0004d	48 89 44 24 40	 mov	 QWORD PTR digits$1$[rsp], rax

; 946  :     if (digits == NULL) {

  00052	48 85 c0	 test	 rax, rax
  00055	75 0a		 jne	 SHORT $LN46@format_flo

; 947  :         /* The only failure mode is no memory. */
; 948  :         PyErr_NoMemory();

  00057	e8 00 00 00 00	 call	 PyErr_NoMemory

; 949  :         goto exit;

  0005c	e9 c4 00 00 00	 jmp	 $LN58@format_flo
$LN46@format_flo:
  00061	4c 89 a4 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], r12
  00069	4c 89 ac 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], r13

; 950  :     }
; 951  :     assert(digits_end != NULL && digits_end >= digits);
; 952  :     digits_len = digits_end - digits;

  00071	4c 8b 6c 24 48	 mov	 r13, QWORD PTR digits_end$[rsp]
  00076	4c 2b e8	 sub	 r13, rax

; 953  : 
; 954  :     if (digits_len && !Py_ISDIGIT(digits[0])) {

  00079	0f 84 2b 01 00
	00		 je	 $LN45@format_flo
  0007f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00082	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  00089	f6 04 81 04	 test	 BYTE PTR [rcx+rax*4], 4
  0008d	0f 85 17 01 00
	00		 jne	 $LN45@format_flo

; 955  :         /* Infinities and nans here; adapt Gay's output,
; 956  :            so convert Infinity to inf and NaN to nan, and
; 957  :            ignore sign of nan. Then return. */
; 958  : 
; 959  :         /* ignore the actual sign of a nan */
; 960  :         if (digits[0] == 'n' || digits[0] == 'N')

  00093	3c 6e		 cmp	 al, 110			; 0000006eH
  00095	74 04		 je	 SHORT $LN43@format_flo
  00097	3c 4e		 cmp	 al, 78			; 0000004eH
  00099	75 04		 jne	 SHORT $LN44@format_flo
$LN43@format_flo:

; 961  :             sign = 0;

  0009b	89 74 24 30	 mov	 DWORD PTR sign$[rsp], esi
$LN44@format_flo:

; 962  : 
; 963  :         /* We only need 5 bytes to hold the result "+inf\0" . */
; 964  :         bufsize = 5; /* Used later in an assert. */
; 965  :         buf = (char *)PyMem_Malloc(bufsize);

  0009f	b9 05 00 00 00	 mov	 ecx, 5
  000a4	e8 00 00 00 00	 call	 PyMem_Malloc
  000a9	48 8b f0	 mov	 rsi, rax

; 966  :         if (buf == NULL) {

  000ac	48 85 c0	 test	 rax, rax
  000af	75 07		 jne	 SHORT $LN42@format_flo

; 967  :             PyErr_NoMemory();

  000b1	e8 00 00 00 00	 call	 PyErr_NoMemory

; 968  :             goto exit;

  000b6	eb 55		 jmp	 SHORT $LN2@format_flo
$LN42@format_flo:

; 969  :         }
; 970  :         p = buf;
; 971  : 
; 972  :         if (sign == 1) {

  000b8	83 7c 24 30 01	 cmp	 DWORD PTR sign$[rsp], 1
  000bd	48 8b f8	 mov	 rdi, rax
  000c0	75 05		 jne	 SHORT $LN41@format_flo

; 973  :             *p++ = '-';

  000c2	c6 00 2d	 mov	 BYTE PTR [rax], 45	; 0000002dH
  000c5	eb 0d		 jmp	 SHORT $LN59@format_flo
$LN41@format_flo:

; 974  :         }
; 975  :         else if (always_add_sign) {

  000c7	44 39 bc 24 a0
	00 00 00	 cmp	 DWORD PTR always_add_sign$[rsp], r15d
  000cf	74 07		 je	 SHORT $LN39@format_flo

; 976  :             *p++ = '+';

  000d1	c6 00 2b	 mov	 BYTE PTR [rax], 43	; 0000002bH
$LN59@format_flo:
  000d4	48 8d 78 01	 lea	 rdi, QWORD PTR [rax+1]
$LN39@format_flo:

; 977  :         }
; 978  :         if (digits[0] == 'i' || digits[0] == 'I') {

  000d8	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  000dc	3c 69		 cmp	 al, 105			; 00000069H
  000de	0f 84 8c 00 00
	00		 je	 $LN37@format_flo
  000e4	3c 49		 cmp	 al, 73			; 00000049H
  000e6	0f 84 84 00 00
	00		 je	 $LN37@format_flo

; 984  :         }
; 985  :         else if (digits[0] == 'n' || digits[0] == 'N') {

  000ec	3c 6e		 cmp	 al, 110			; 0000006eH
  000ee	74 4c		 je	 SHORT $LN33@format_flo
  000f0	3c 4e		 cmp	 al, 78			; 0000004eH
  000f2	74 48		 je	 SHORT $LN33@format_flo

; 993  :             /* shouldn't get here: Gay's code should always return
; 994  :                something starting with a digit, an 'I',  or 'N' */
; 995  :             strncpy(p, "ERR", 3);

  000f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03JFMEENOE@ERR?$AA@
  000fb	41 b8 03 00 00
	00		 mov	 r8d, 3
  00101	48 8b cf	 mov	 rcx, rdi
  00104	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy
$LN57@format_flo:
$exit$20363:

; 1158 :     }
; 1159 :   exit:
; 1160 :     if (buf) {
; 1161 :         *p = '\0';

  0010a	c6 07 00	 mov	 BYTE PTR [rdi], 0
$LN2@format_flo:

; 1162 :         /* It's too late if this fails, as we've already stepped on
; 1163 :            memory that isn't ours. But it's an okay debugging test. */
; 1164 :         assert(p-buf < bufsize);
; 1165 :     }
; 1166 :     if (digits)
; 1167 :         _Py_dg_freedtoa(digits);

  0010d	49 8b ce	 mov	 rcx, r14
  00110	e8 00 00 00 00	 call	 _Py_dg_freedtoa
  00115	4c 8b ac 24 88
	00 00 00	 mov	 r13, QWORD PTR [rsp+136]
  0011d	4c 8b a4 24 80
	00 00 00	 mov	 r12, QWORD PTR [rsp+128]
$LN58@format_flo:

; 1168 : 
; 1169 :     return buf;

  00125	48 8b c6	 mov	 rax, rsi

; 1170 : }

  00128	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  00130	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00134	41 5f		 pop	 r15
  00136	41 5e		 pop	 r14
  00138	5f		 pop	 rdi
  00139	5e		 pop	 rsi
  0013a	5d		 pop	 rbp
  0013b	c3		 ret	 0
$LN33@format_flo:

; 986  :             strncpy(p, float_strings[OFS_NAN], 3);

  0013c	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR float_strings$[rsp]
  00144	41 b8 03 00 00
	00		 mov	 r8d, 3
  0014a	48 8b cf	 mov	 rcx, rdi
  0014d	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00151	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 987  :             p += 3;
; 988  : 
; 989  :             if (type)

  00157	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR type$[rsp]
  0015f	48 83 c7 03	 add	 rdi, 3

; 991  :         }
; 992  :         else {

  00163	48 85 c0	 test	 rax, rax
  00166	74 a2		 je	 SHORT $exit$20363

; 990  :                 *type = Py_DTST_NAN;

  00168	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2

; 991  :         }
; 992  :         else {

  0016e	eb 9a		 jmp	 SHORT $exit$20363
$LN37@format_flo:

; 979  :             strncpy(p, float_strings[OFS_INF], 3);

  00170	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR float_strings$[rsp]
  00178	41 b8 03 00 00
	00		 mov	 r8d, 3
  0017e	48 8b cf	 mov	 rcx, rdi
  00181	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00184	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 980  :             p += 3;
; 981  : 
; 982  :             if (type)

  0018a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR type$[rsp]
  00192	48 83 c7 03	 add	 rdi, 3
  00196	48 85 c0	 test	 rax, rax
  00199	0f 84 6b ff ff
	ff		 je	 $LN57@format_flo

; 983  :                 *type = Py_DTST_INFINITE;

  0019f	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 996  :             /* p += 3; */
; 997  :             assert(0);
; 998  :         }
; 999  :         goto exit;

  001a5	e9 60 ff ff ff	 jmp	 $LN57@format_flo
$LN45@format_flo:

; 1000 :     }
; 1001 : 
; 1002 :     /* The result must be finite (not inf or nan). */
; 1003 :     if (type)

  001aa	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR type$[rsp]
  001b2	48 85 c0	 test	 rax, rax
  001b5	74 02		 je	 SHORT $LN30@format_flo

; 1004 :         *type = Py_DTST_FINITE;

  001b7	89 30		 mov	 DWORD PTR [rax], esi
$LN30@format_flo:

; 1005 : 
; 1006 : 
; 1007 :     /* We got digits back, format them.  We may need to pad 'digits'
; 1008 :        either on the left or right (or both) with extra zeros, so in
; 1009 :        general the resulting string has the form
; 1010 : 
; 1011 :          [<sign>]<zeros><digits><zeros>[<exponent>]
; 1012 : 
; 1013 :        where either of the <zeros> pieces could be empty, and there's a
; 1014 :        decimal point that could appear either in <digits> or in the
; 1015 :        leading or trailing <zeros>.
; 1016 : 
; 1017 :        Imagine an infinite 'virtual' string vdigits, consisting of the
; 1018 :        string 'digits' (starting at index 0) padded on both the left and
; 1019 :        right with infinite strings of zeros.  We want to output a slice
; 1020 : 
; 1021 :          vdigits[vdigits_start : vdigits_end]
; 1022 : 
; 1023 :        of this virtual string.  Thus if vdigits_start < 0 then we'll end
; 1024 :        up producing some leading zeros; if vdigits_end > digits_len there
; 1025 :        will be trailing zeros in the output.  The next section of code
; 1026 :        determines whether to use an exponent or not, figures out the
; 1027 :        position 'decpt' of the decimal point, and computes 'vdigits_start'
; 1028 :        and 'vdigits_end'. */
; 1029 :     vdigits_end = digits_len;
; 1030 :     switch (format_code) {

  001b9	40 0f be cf	 movsx	 ecx, dil
  001bd	4d 8b e5	 mov	 r12, r13
  001c0	83 e9 65	 sub	 ecx, 101		; 00000065H
  001c3	74 74		 je	 SHORT $LN27@format_flo
  001c5	ff c9		 dec	 ecx
  001c7	74 61		 je	 SHORT $LN26@format_flo
  001c9	ff c9		 dec	 ecx
  001cb	74 29		 je	 SHORT $LN25@format_flo
  001cd	83 f9 0b	 cmp	 ecx, 11
  001d0	74 16		 je	 SHORT $LN21@format_flo

; 1054 :     default:
; 1055 :         PyErr_BadInternalCall();

  001d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@GKLBOEON@?4?4?2Python?2pystrtod?4c?$AA@
  001d9	ba 1f 04 00 00	 mov	 edx, 1055		; 0000041fH
  001de	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1056 :         goto exit;

  001e3	e9 25 ff ff ff	 jmp	 $LN2@format_flo
$LN21@format_flo:

; 1044 :         break;
; 1045 :     case 'r':
; 1046 :         /* convert to exponential format at 1e16.  We used to convert
; 1047 :            at 1e17, but that gives odd-looking results for some values
; 1048 :            when a 16-digit 'shortest' repr is padded with bogus zeros.
; 1049 :            For example, repr(2e16+8) would give 20000000000000010.0;
; 1050 :            the true value is 20000000000000008.0. */
; 1051 :         if (decpt <= -4 || decpt > 16)

  001e8	48 83 fd fc	 cmp	 rbp, -4
  001ec	7e 4e		 jle	 SHORT $LN19@format_flo
  001ee	48 83 fd 10	 cmp	 rbp, 16
  001f2	7e 3a		 jle	 SHORT $LN17@format_flo

; 1052 :             use_exp = 1;
; 1053 :         break;

  001f4	eb 46		 jmp	 SHORT $LN19@format_flo
$LN25@format_flo:

; 1037 :         break;
; 1038 :     case 'g':
; 1039 :         if (decpt <= -4 || decpt >
; 1040 :             (add_dot_0_if_integer ? precision-1 : precision))

  001f6	48 83 fd fc	 cmp	 rbp, -4
  001fa	7e 15		 jle	 SHORT $LN23@format_flo
  001fc	48 8d 43 ff	 lea	 rax, QWORD PTR [rbx-1]
  00200	39 b4 24 a8 00
	00 00		 cmp	 DWORD PTR add_dot_0_if_integer$[rsp], esi
  00207	75 03		 jne	 SHORT $LN50@format_flo
  00209	48 8b c3	 mov	 rax, rbx
$LN50@format_flo:
  0020c	48 3b e8	 cmp	 rbp, rax
  0020f	7e 06		 jle	 SHORT $LN24@format_flo
$LN23@format_flo:

; 1041 :             use_exp = 1;

  00211	41 bf 01 00 00
	00		 mov	 r15d, 1
$LN24@format_flo:

; 1042 :         if (use_alt_formatting)

  00217	39 b4 24 b0 00
	00 00		 cmp	 DWORD PTR use_alt_formatting$[rsp], esi
  0021e	74 03		 je	 SHORT $LN28@format_flo

; 1043 :             vdigits_end = precision;

  00220	4c 8b e3	 mov	 r12, rbx
$LN28@format_flo:

; 1057 :     }
; 1058 : 
; 1059 :     /* if using an exponent, reset decimal point position to 1 and adjust
; 1060 :        exponent accordingly.*/
; 1061 :     if (use_exp) {

  00223	45 85 ff	 test	 r15d, r15d
  00226	74 06		 je	 SHORT $LN17@format_flo
  00228	eb 18		 jmp	 SHORT $LN55@format_flo
$LN26@format_flo:

; 1034 :         break;
; 1035 :     case 'f':
; 1036 :         vdigits_end = decpt + precision;

  0022a	4c 8d 24 2b	 lea	 r12, QWORD PTR [rbx+rbp]
$LN17@format_flo:

; 1064 :     }
; 1065 :     /* ensure vdigits_start < decpt <= vdigits_end, or vdigits_start <
; 1066 :        decpt < vdigits_end if add_dot_0_if_integer and no exponent */
; 1067 :     vdigits_start = decpt <= 0 ? decpt-1 : 0;

  0022e	48 85 ed	 test	 rbp, rbp
  00231	7f 1b		 jg	 SHORT $LN51@format_flo
  00233	4c 8d 75 ff	 lea	 r14, QWORD PTR [rbp-1]
  00237	eb 18		 jmp	 SHORT $LN52@format_flo
$LN27@format_flo:

; 1033 :         vdigits_end = precision;

  00239	4c 8b e3	 mov	 r12, rbx
$LN19@format_flo:

; 1031 :     case 'e':
; 1032 :         use_exp = 1;

  0023c	41 bf 01 00 00
	00		 mov	 r15d, 1
$LN55@format_flo:

; 1062 :         exp = decpt - 1;

  00242	8d 45 ff	 lea	 eax, DWORD PTR [rbp-1]

; 1063 :         decpt = 1;

  00245	bd 01 00 00 00	 mov	 ebp, 1
  0024a	89 44 24 34	 mov	 DWORD PTR exp$1$[rsp], eax
$LN51@format_flo:

; 1064 :     }
; 1065 :     /* ensure vdigits_start < decpt <= vdigits_end, or vdigits_start <
; 1066 :        decpt < vdigits_end if add_dot_0_if_integer and no exponent */
; 1067 :     vdigits_start = decpt <= 0 ? decpt-1 : 0;

  0024e	4c 8b f6	 mov	 r14, rsi
$LN52@format_flo:

; 1068 :     if (!use_exp && add_dot_0_if_integer)

  00251	45 85 ff	 test	 r15d, r15d
  00254	75 14		 jne	 SHORT $LN16@format_flo
  00256	39 b4 24 a8 00
	00 00		 cmp	 DWORD PTR add_dot_0_if_integer$[rsp], esi
  0025d	74 0b		 je	 SHORT $LN16@format_flo

; 1069 :         vdigits_end = vdigits_end > decpt ? vdigits_end : decpt + 1;

  0025f	4c 3b e5	 cmp	 r12, rbp
  00262	7f 13		 jg	 SHORT $LN15@format_flo
  00264	4c 8d 65 01	 lea	 r12, QWORD PTR [rbp+1]

; 1070 :     else

  00268	eb 0d		 jmp	 SHORT $LN15@format_flo
$LN16@format_flo:

; 1071 :         vdigits_end = vdigits_end > decpt ? vdigits_end : decpt;

  0026a	4c 3b e5	 cmp	 r12, rbp
  0026d	48 8b c5	 mov	 rax, rbp
  00270	49 0f 4f c4	 cmovg	 rax, r12
  00274	4c 8b e0	 mov	 r12, rax
$LN15@format_flo:

; 1072 : 
; 1073 :     /* double check inequalities */
; 1074 :     assert(vdigits_start <= 0 &&
; 1075 :            0 <= digits_len &&
; 1076 :            digits_len <= vdigits_end);
; 1077 :     /* decimal point should be in (vdigits_start, vdigits_end] */
; 1078 :     assert(vdigits_start < decpt && decpt <= vdigits_end);
; 1079 : 
; 1080 :     /* Compute an upper bound how much memory we need. This might be a few
; 1081 :        chars too long, but no big deal. */
; 1082 :     bufsize =
; 1083 :         /* sign, decimal point and trailing 0 byte */
; 1084 :         3 +
; 1085 : 
; 1086 :         /* total digit count (including zero padding on both sides) */
; 1087 :         (vdigits_end - vdigits_start) +
; 1088 : 
; 1089 :         /* exponent "e+100", max 3 numerical digits */
; 1090 :         (use_exp ? 5 : 0);

  00277	41 8b c7	 mov	 eax, r15d
  0027a	f7 d8		 neg	 eax
  0027c	48 1b c9	 sbb	 rcx, rcx
  0027f	83 e1 05	 and	 ecx, 5

; 1091 : 
; 1092 :     /* Now allocate the memory and initialize p to point to the start of
; 1093 :        it. */
; 1094 :     buf = (char *)PyMem_Malloc(bufsize);

  00282	49 2b ce	 sub	 rcx, r14
  00285	4a 8d 4c 21 03	 lea	 rcx, QWORD PTR [rcx+r12+3]
  0028a	e8 00 00 00 00	 call	 PyMem_Malloc
  0028f	48 8b f0	 mov	 rsi, rax

; 1095 :     if (buf == NULL) {

  00292	48 85 c0	 test	 rax, rax
  00295	75 0f		 jne	 SHORT $LN14@format_flo

; 1096 :         PyErr_NoMemory();

  00297	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1097 :         goto exit;

  0029c	4c 8b 74 24 40	 mov	 r14, QWORD PTR digits$1$[rsp]
  002a1	e9 67 fe ff ff	 jmp	 $LN2@format_flo
$LN14@format_flo:

; 1098 :     }
; 1099 :     p = buf;
; 1100 : 
; 1101 :     /* Add a negative sign if negative, and a plus sign if non-negative
; 1102 :        and always_add_sign is true. */
; 1103 :     if (sign == 1)

  002a6	83 7c 24 30 01	 cmp	 DWORD PTR sign$[rsp], 1
  002ab	48 8b f8	 mov	 rdi, rax
  002ae	75 05		 jne	 SHORT $LN13@format_flo

; 1104 :         *p++ = '-';

  002b0	c6 00 2d	 mov	 BYTE PTR [rax], 45	; 0000002dH
  002b3	eb 0d		 jmp	 SHORT $LN60@format_flo
$LN13@format_flo:

; 1105 :     else if (always_add_sign)

  002b5	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR always_add_sign$[rsp], 0
  002bd	74 07		 je	 SHORT $LN11@format_flo

; 1106 :         *p++ = '+';

  002bf	c6 00 2b	 mov	 BYTE PTR [rax], 43	; 0000002bH
$LN60@format_flo:
  002c2	48 8d 78 01	 lea	 rdi, QWORD PTR [rax+1]
$LN11@format_flo:

; 1107 : 
; 1108 :     /* note that exactly one of the three 'if' conditions is true,
; 1109 :        so we include exactly one decimal point */
; 1110 :     /* Zero padding on left of digit string */
; 1111 :     if (decpt <= 0) {
; 1112 :         memset(p, '0', decpt-vdigits_start);

  002c6	ba 30 00 00 00	 mov	 edx, 48			; 00000030H
  002cb	48 8b cf	 mov	 rcx, rdi
  002ce	48 85 ed	 test	 rbp, rbp
  002d1	7f 2f		 jg	 SHORT $LN10@format_flo
  002d3	48 8b dd	 mov	 rbx, rbp
  002d6	49 2b de	 sub	 rbx, r14
  002d9	4c 8b c3	 mov	 r8, rbx
  002dc	e8 00 00 00 00	 call	 memset

; 1113 :         p += decpt - vdigits_start;

  002e1	48 03 fb	 add	 rdi, rbx

; 1114 :         *p++ = '.';
; 1115 :         memset(p, '0', 0-decpt);

  002e4	4c 8b c5	 mov	 r8, rbp
  002e7	c6 07 2e	 mov	 BYTE PTR [rdi], 46	; 0000002eH
  002ea	48 ff c7	 inc	 rdi
  002ed	49 f7 d8	 neg	 r8
  002f0	48 8b cf	 mov	 rcx, rdi
  002f3	ba 30 00 00 00	 mov	 edx, 48			; 00000030H
  002f8	e8 00 00 00 00	 call	 memset

; 1116 :         p += 0-decpt;

  002fd	48 2b fd	 sub	 rdi, rbp

; 1117 :     }
; 1118 :     else {

  00300	eb 0e		 jmp	 SHORT $LN9@format_flo
$LN10@format_flo:

; 1119 :         memset(p, '0', 0-vdigits_start);

  00302	4d 8b c6	 mov	 r8, r14
  00305	49 f7 d8	 neg	 r8
  00308	e8 00 00 00 00	 call	 memset

; 1120 :         p += 0 - vdigits_start;

  0030d	49 2b fe	 sub	 rdi, r14
$LN9@format_flo:

; 1121 :     }
; 1122 : 
; 1123 :     /* Digits, with included decimal point */
; 1124 :     if (0 < decpt && decpt <= digits_len) {

  00310	48 85 ed	 test	 rbp, rbp
  00313	7e 3d		 jle	 SHORT $LN8@format_flo
  00315	49 3b ed	 cmp	 rbp, r13
  00318	7f 38		 jg	 SHORT $LN8@format_flo

; 1125 :         strncpy(p, digits, decpt-0);

  0031a	4c 8b 74 24 40	 mov	 r14, QWORD PTR digits$1$[rsp]
  0031f	4c 8b c5	 mov	 r8, rbp
  00322	48 8b cf	 mov	 rcx, rdi
  00325	49 8b d6	 mov	 rdx, r14
  00328	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 1126 :         p += decpt-0;

  0032e	48 03 fd	 add	 rdi, rbp

; 1127 :         *p++ = '.';
; 1128 :         strncpy(p, digits+decpt, digits_len-decpt);

  00331	49 8b dd	 mov	 rbx, r13
  00334	c6 07 2e	 mov	 BYTE PTR [rdi], 46	; 0000002eH
  00337	48 ff c7	 inc	 rdi
  0033a	48 2b dd	 sub	 rbx, rbp
  0033d	49 8d 14 2e	 lea	 rdx, QWORD PTR [r14+rbp]
  00341	48 8b cf	 mov	 rcx, rdi
  00344	4c 8b c3	 mov	 r8, rbx
  00347	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 1129 :         p += digits_len-decpt;

  0034d	48 03 fb	 add	 rdi, rbx

; 1130 :     }
; 1131 :     else {

  00350	eb 17		 jmp	 SHORT $LN7@format_flo
$LN8@format_flo:

; 1132 :         strncpy(p, digits, digits_len);

  00352	4c 8b 74 24 40	 mov	 r14, QWORD PTR digits$1$[rsp]
  00357	4d 8b c5	 mov	 r8, r13
  0035a	48 8b cf	 mov	 rcx, rdi
  0035d	49 8b d6	 mov	 rdx, r14
  00360	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 1133 :         p += digits_len;

  00366	49 03 fd	 add	 rdi, r13
$LN7@format_flo:

; 1134 :     }
; 1135 : 
; 1136 :     /* And zeros on the right */
; 1137 :     if (digits_len < decpt) {
; 1138 :         memset(p, '0', decpt-digits_len);

  00369	ba 30 00 00 00	 mov	 edx, 48			; 00000030H
  0036e	48 8b cf	 mov	 rcx, rdi
  00371	4c 3b ed	 cmp	 r13, rbp
  00374	7d 25		 jge	 SHORT $LN6@format_flo
  00376	48 8b dd	 mov	 rbx, rbp
  00379	49 2b dd	 sub	 rbx, r13
  0037c	4c 8b c3	 mov	 r8, rbx
  0037f	e8 00 00 00 00	 call	 memset

; 1139 :         p += decpt-digits_len;

  00384	48 03 fb	 add	 rdi, rbx

; 1140 :         *p++ = '.';
; 1141 :         memset(p, '0', vdigits_end-decpt);

  00387	ba 30 00 00 00	 mov	 edx, 48			; 00000030H
  0038c	48 ff c7	 inc	 rdi
  0038f	c6 47 ff 2e	 mov	 BYTE PTR [rdi-1], 46	; 0000002eH
  00393	4c 2b e5	 sub	 r12, rbp
  00396	48 8b cf	 mov	 rcx, rdi

; 1142 :         p += vdigits_end-decpt;
; 1143 :     }
; 1144 :     else {

  00399	eb 03		 jmp	 SHORT $LN61@format_flo
$LN6@format_flo:

; 1145 :         memset(p, '0', vdigits_end-digits_len);

  0039b	4d 2b e5	 sub	 r12, r13
$LN61@format_flo:
  0039e	4d 8b c4	 mov	 r8, r12
  003a1	e8 00 00 00 00	 call	 memset

; 1146 :         p += vdigits_end-digits_len;

  003a6	49 03 fc	 add	 rdi, r12

; 1147 :     }
; 1148 : 
; 1149 :     /* Delete a trailing decimal pt unless using alternative formatting. */
; 1150 :     if (p[-1] == '.' && !use_alt_formatting)

  003a9	80 7f ff 2e	 cmp	 BYTE PTR [rdi-1], 46	; 0000002eH
  003ad	48 8d 47 ff	 lea	 rax, QWORD PTR [rdi-1]
  003b1	75 0c		 jne	 SHORT $LN4@format_flo
  003b3	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR use_alt_formatting$[rsp], 0
  003bb	48 0f 44 f8	 cmove	 rdi, rax
$LN4@format_flo:

; 1151 :         p--;
; 1152 : 
; 1153 :     /* Now that we've done zero padding, add an exponent if needed. */
; 1154 :     if (use_exp) {

  003bf	45 85 ff	 test	 r15d, r15d
  003c2	0f 84 42 fd ff
	ff		 je	 $exit$20363

; 1155 :         *p++ = float_strings[OFS_E][0];

  003c8	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR float_strings$[rsp]

; 1156 :         exp_len = sprintf(p, "%+.02d", exp);

  003d0	44 8b 44 24 34	 mov	 r8d, DWORD PTR exp$1$[rsp]
  003d5	48 ff c7	 inc	 rdi
  003d8	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  003dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06DKNJDFNG@?$CF?$CL?402d?$AA@
  003e3	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  003e6	48 8b cf	 mov	 rcx, rdi
  003e9	88 47 ff	 mov	 BYTE PTR [rdi-1], al
  003ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf

; 1157 :         p += exp_len;

  003f2	48 63 c8	 movsxd	 rcx, eax
  003f5	48 03 f9	 add	 rdi, rcx
  003f8	e9 0d fd ff ff	 jmp	 $exit$20363
format_float_short ENDP
_TEXT	ENDS
PUBLIC	PyOS_double_to_string
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyOS_double_to_string DD imagerel $LN18
	DD	imagerel $LN18+318
	DD	imagerel $unwind$PyOS_double_to_string
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyOS_double_to_string DD 040a01H
	DD	0c340aH
	DD	07006920aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyOS_double_to_string
_TEXT	SEGMENT
val$ = 96
format_code$ = 104
precision$ = 112
flags$ = 120
type$ = 128
PyOS_double_to_string PROC				; COMDAT

; 1178 : {

$LN18:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000a	0f be da	 movsx	 ebx, dl
  0000d	41 8b f9	 mov	 edi, r9d
  00010	45 8b d8	 mov	 r11d, r8d

; 1179 :     char **float_strings = lc_float_strings;
; 1180 :     int mode;
; 1181 : 
; 1182 :     /* Validate format_code, and map upper and lower case. Compute the
; 1183 :        mode and make any adjustments as needed. */
; 1184 :     switch (format_code) {

  00013	8d 43 bb	 lea	 eax, DWORD PTR [rbx-69]
  00016	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:lc_float_strings
  0001d	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00020	0f 87 ac 00 00
	00		 ja	 $LN1@PyOS_doubl
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  0002d	48 98		 cdqe
  0002f	0f b6 84 02 00
	00 00 00	 movzx	 eax, BYTE PTR $LN15@PyOS_doubl[rdx+rax]
  00037	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN16@PyOS_doubl[rdx+rax*4]
  0003e	48 03 ca	 add	 rcx, rdx
  00041	ff e1		 jmp	 rcx
$LN10@PyOS_doubl:

; 1185 :     /* exponent */
; 1186 :     case 'E':
; 1187 :         float_strings = uc_float_strings;

  00043	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:uc_float_strings

; 1188 :         format_code = 'e';

  0004a	b3 65		 mov	 bl, 101			; 00000065H
$LN9@PyOS_doubl:

; 1189 :         /* Fall through. */
; 1190 :     case 'e':
; 1191 :         mode = 2;

  0004c	41 b8 02 00 00
	00		 mov	 r8d, 2

; 1192 :         precision++;

  00052	41 ff c3	 inc	 r11d
$LN2@PyOS_doubl:

; 1228 :         return NULL;
; 1229 :     }
; 1230 : 
; 1231 :     return format_float_short(val, format_code, mode, precision,
; 1232 :                               flags & Py_DTSF_SIGN,
; 1233 :                               flags & Py_DTSF_ADD_DOT_0,
; 1234 :                               flags & Py_DTSF_ALT,
; 1235 :                               float_strings, type);

  00055	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR type$[rsp]
  0005d	41 8b d1	 mov	 edx, r9d
  00060	41 8b c9	 mov	 ecx, r9d
  00063	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00068	4c 89 54 24 38	 mov	 QWORD PTR [rsp+56], r10
  0006d	83 e2 04	 and	 edx, 4
  00070	89 54 24 30	 mov	 DWORD PTR [rsp+48], edx
  00074	83 e1 02	 and	 ecx, 2
  00077	83 e7 01	 and	 edi, 1
  0007a	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  0007e	0f b6 d3	 movzx	 edx, bl
  00081	4d 63 cb	 movsxd	 r9, r11d
  00084	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  00088	e8 00 00 00 00	 call	 format_float_short

; 1236 : }

  0008d	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00092	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00096	5f		 pop	 rdi
  00097	c3		 ret	 0
$LN8@PyOS_doubl:

; 1193 :         break;
; 1194 : 
; 1195 :     /* fixed */
; 1196 :     case 'F':
; 1197 :         float_strings = uc_float_strings;

  00098	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:uc_float_strings

; 1198 :         format_code = 'f';

  0009f	b3 66		 mov	 bl, 102			; 00000066H
$LN7@PyOS_doubl:

; 1199 :         /* Fall through. */
; 1200 :     case 'f':
; 1201 :         mode = 3;

  000a1	41 b8 03 00 00
	00		 mov	 r8d, 3

; 1202 :         break;

  000a7	eb ac		 jmp	 SHORT $LN2@PyOS_doubl
$LN6@PyOS_doubl:

; 1203 : 
; 1204 :     /* general */
; 1205 :     case 'G':
; 1206 :         float_strings = uc_float_strings;

  000a9	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:uc_float_strings

; 1207 :         format_code = 'g';

  000b0	b3 67		 mov	 bl, 103			; 00000067H
$LN5@PyOS_doubl:

; 1208 :         /* Fall through. */
; 1209 :     case 'g':
; 1210 :         mode = 2;

  000b2	41 b8 02 00 00
	00		 mov	 r8d, 2

; 1211 :         /* precision 0 makes no sense for 'g' format; interpret as 1 */
; 1212 :         if (precision == 0)

  000b8	45 85 db	 test	 r11d, r11d
  000bb	75 98		 jne	 SHORT $LN2@PyOS_doubl

; 1213 :             precision = 1;

  000bd	45 8d 58 ff	 lea	 r11d, QWORD PTR [r8-1]

; 1214 :         break;

  000c1	eb 92		 jmp	 SHORT $LN2@PyOS_doubl
$LN3@PyOS_doubl:

; 1215 : 
; 1216 :     /* repr format */
; 1217 :     case 'r':
; 1218 :         mode = 0;

  000c3	45 33 c0	 xor	 r8d, r8d

; 1219 :         /* Supplied precision is unused, must be 0. */
; 1220 :         if (precision != 0) {

  000c6	45 85 db	 test	 r11d, r11d
  000c9	74 8a		 je	 SHORT $LN2@PyOS_doubl

; 1221 :             PyErr_BadInternalCall();

  000cb	ba c5 04 00 00	 mov	 edx, 1221		; 000004c5H

; 1222 :             return NULL;

  000d0	eb 05		 jmp	 SHORT $LN17@PyOS_doubl
$LN1@PyOS_doubl:

; 1223 :         }
; 1224 :         break;
; 1225 : 
; 1226 :     default:
; 1227 :         PyErr_BadInternalCall();

  000d2	ba cb 04 00 00	 mov	 edx, 1227		; 000004cbH
$LN17@PyOS_doubl:
  000d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@GKLBOEON@?4?4?2Python?2pystrtod?4c?$AA@
  000de	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1236 : }

  000e3	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000e8	33 c0		 xor	 eax, eax
  000ea	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000ee	5f		 pop	 rdi
  000ef	c3		 ret	 0
$LN16@PyOS_doubl:
  000f0	00 00 00 00	 DD	 $LN10@PyOS_doubl
  000f4	00 00 00 00	 DD	 $LN8@PyOS_doubl
  000f8	00 00 00 00	 DD	 $LN6@PyOS_doubl
  000fc	00 00 00 00	 DD	 $LN9@PyOS_doubl
  00100	00 00 00 00	 DD	 $LN7@PyOS_doubl
  00104	00 00 00 00	 DD	 $LN5@PyOS_doubl
  00108	00 00 00 00	 DD	 $LN3@PyOS_doubl
  0010c	00 00 00 00	 DD	 $LN1@PyOS_doubl
$LN15@PyOS_doubl:
  00110	00		 DB	 0
  00111	01		 DB	 1
  00112	02		 DB	 2
  00113	07		 DB	 7
  00114	07		 DB	 7
  00115	07		 DB	 7
  00116	07		 DB	 7
  00117	07		 DB	 7
  00118	07		 DB	 7
  00119	07		 DB	 7
  0011a	07		 DB	 7
  0011b	07		 DB	 7
  0011c	07		 DB	 7
  0011d	07		 DB	 7
  0011e	07		 DB	 7
  0011f	07		 DB	 7
  00120	07		 DB	 7
  00121	07		 DB	 7
  00122	07		 DB	 7
  00123	07		 DB	 7
  00124	07		 DB	 7
  00125	07		 DB	 7
  00126	07		 DB	 7
  00127	07		 DB	 7
  00128	07		 DB	 7
  00129	07		 DB	 7
  0012a	07		 DB	 7
  0012b	07		 DB	 7
  0012c	07		 DB	 7
  0012d	07		 DB	 7
  0012e	07		 DB	 7
  0012f	07		 DB	 7
  00130	03		 DB	 3
  00131	04		 DB	 4
  00132	05		 DB	 5
  00133	07		 DB	 7
  00134	07		 DB	 7
  00135	07		 DB	 7
  00136	07		 DB	 7
  00137	07		 DB	 7
  00138	07		 DB	 7
  00139	07		 DB	 7
  0013a	07		 DB	 7
  0013b	07		 DB	 7
  0013c	07		 DB	 7
  0013d	06		 DB	 6
PyOS_double_to_string ENDP
_TEXT	ENDS
END
