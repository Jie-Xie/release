; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
arenas	DQ	01H DUP (?)
maxarenas DD	01H DUP (?)
	ALIGN	8

unused_arena_objects DQ 01H DUP (?)
usable_arenas DQ 01H DUP (?)
narenas_currently_allocated DQ 01H DUP (?)
ntimes_arena_allocated DQ 01H DUP (?)
narenas_highwater DQ 01H DUP (?)
_Py_AllocatedBlocks DQ 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
usedpools DQ	FLAT:usedpools-16
	DQ	FLAT:usedpools-16
	DQ	FLAT:usedpools
	DQ	FLAT:usedpools
	DQ	FLAT:usedpools+16
	DQ	FLAT:usedpools+16
	DQ	FLAT:usedpools+32
	DQ	FLAT:usedpools+32
	DQ	FLAT:usedpools+48
	DQ	FLAT:usedpools+48
	DQ	FLAT:usedpools+64
	DQ	FLAT:usedpools+64
	DQ	FLAT:usedpools+80
	DQ	FLAT:usedpools+80
	DQ	FLAT:usedpools+96
	DQ	FLAT:usedpools+96
	DQ	FLAT:usedpools+112
	DQ	FLAT:usedpools+112
	DQ	FLAT:usedpools+128
	DQ	FLAT:usedpools+128
	DQ	FLAT:usedpools+144
	DQ	FLAT:usedpools+144
	DQ	FLAT:usedpools+160
	DQ	FLAT:usedpools+160
	DQ	FLAT:usedpools+176
	DQ	FLAT:usedpools+176
	DQ	FLAT:usedpools+192
	DQ	FLAT:usedpools+192
	DQ	FLAT:usedpools+208
	DQ	FLAT:usedpools+208
	DQ	FLAT:usedpools+224
	DQ	FLAT:usedpools+224
	DQ	FLAT:usedpools+240
	DQ	FLAT:usedpools+240
	DQ	FLAT:usedpools+256
	DQ	FLAT:usedpools+256
	DQ	FLAT:usedpools+272
	DQ	FLAT:usedpools+272
	DQ	FLAT:usedpools+288
	DQ	FLAT:usedpools+288
	DQ	FLAT:usedpools+304
	DQ	FLAT:usedpools+304
	DQ	FLAT:usedpools+320
	DQ	FLAT:usedpools+320
	DQ	FLAT:usedpools+336
	DQ	FLAT:usedpools+336
	DQ	FLAT:usedpools+352
	DQ	FLAT:usedpools+352
	DQ	FLAT:usedpools+368
	DQ	FLAT:usedpools+368
	DQ	FLAT:usedpools+384
	DQ	FLAT:usedpools+384
	DQ	FLAT:usedpools+400
	DQ	FLAT:usedpools+400
	DQ	FLAT:usedpools+416
	DQ	FLAT:usedpools+416
	DQ	FLAT:usedpools+432
	DQ	FLAT:usedpools+432
	DQ	FLAT:usedpools+448
	DQ	FLAT:usedpools+448
	DQ	FLAT:usedpools+464
	DQ	FLAT:usedpools+464
	DQ	FLAT:usedpools+480
	DQ	FLAT:usedpools+480
	DQ	FLAT:usedpools+496
	DQ	FLAT:usedpools+496
	DQ	FLAT:usedpools+512
	DQ	FLAT:usedpools+512
	DQ	FLAT:usedpools+528
	DQ	FLAT:usedpools+528
	DQ	FLAT:usedpools+544
	DQ	FLAT:usedpools+544
	DQ	FLAT:usedpools+560
	DQ	FLAT:usedpools+560
	DQ	FLAT:usedpools+576
	DQ	FLAT:usedpools+576
	DQ	FLAT:usedpools+592
	DQ	FLAT:usedpools+592
	DQ	FLAT:usedpools+608
	DQ	FLAT:usedpools+608
	DQ	FLAT:usedpools+624
	DQ	FLAT:usedpools+624
	DQ	FLAT:usedpools+640
	DQ	FLAT:usedpools+640
	DQ	FLAT:usedpools+656
	DQ	FLAT:usedpools+656
	DQ	FLAT:usedpools+672
	DQ	FLAT:usedpools+672
	DQ	FLAT:usedpools+688
	DQ	FLAT:usedpools+688
	DQ	FLAT:usedpools+704
	DQ	FLAT:usedpools+704
	DQ	FLAT:usedpools+720
	DQ	FLAT:usedpools+720
	DQ	FLAT:usedpools+736
	DQ	FLAT:usedpools+736
	DQ	FLAT:usedpools+752
	DQ	FLAT:usedpools+752
	DQ	FLAT:usedpools+768
	DQ	FLAT:usedpools+768
	DQ	FLAT:usedpools+784
	DQ	FLAT:usedpools+784
	DQ	FLAT:usedpools+800
	DQ	FLAT:usedpools+800
	DQ	FLAT:usedpools+816
	DQ	FLAT:usedpools+816
	DQ	FLAT:usedpools+832
	DQ	FLAT:usedpools+832
	DQ	FLAT:usedpools+848
	DQ	FLAT:usedpools+848
	DQ	FLAT:usedpools+864
	DQ	FLAT:usedpools+864
	DQ	FLAT:usedpools+880
	DQ	FLAT:usedpools+880
	DQ	FLAT:usedpools+896
	DQ	FLAT:usedpools+896
	DQ	FLAT:usedpools+912
	DQ	FLAT:usedpools+912
	DQ	FLAT:usedpools+928
	DQ	FLAT:usedpools+928
	DQ	FLAT:usedpools+944
	DQ	FLAT:usedpools+944
	DQ	FLAT:usedpools+960
	DQ	FLAT:usedpools+960
	DQ	FLAT:usedpools+976
	DQ	FLAT:usedpools+976
	DQ	FLAT:usedpools+992
	DQ	FLAT:usedpools+992
_DATA	ENDS
PUBLIC	_Py_GetAllocatedBlocks
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\obmalloc.c
;	COMDAT _Py_GetAllocatedBlocks
_TEXT	SEGMENT
_Py_GetAllocatedBlocks PROC				; COMDAT

; 558  :     READ_LOCK();
; 559  :     return _Py_AllocatedBlocks;

  00000	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_AllocatedBlocks

; 560  :     READ_UNLOCK();
; 561  : }

  00007	c3		 ret	 0
_Py_GetAllocatedBlocks ENDP
_TEXT	ENDS
PUBLIC	??_C@_09MEEKLCNL@new_arena?$AA@			; `string'
PUBLIC	??_C@_0BG@PMODNIDG@?4?4?2Objects?2obmalloc?4c?$AA@ ; `string'
EXTRN	__imp_malloc:PROC
EXTRN	__imp_realloc:PROC
EXTRN	_PyParallel_ContextGuardFailure:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$new_arena DD imagerel new_arena
	DD	imagerel new_arena+417
	DD	imagerel $unwind$new_arena
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$new_arena DD 063d01H
	DD	06743dH
	DD	07340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT ??_C@_09MEEKLCNL@new_arena?$AA@
CONST	SEGMENT
??_C@_09MEEKLCNL@new_arena?$AA@ DB 'new_arena', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PMODNIDG@?4?4?2Objects?2obmalloc?4c?$AA@
CONST	SEGMENT
??_C@_0BG@PMODNIDG@?4?4?2Objects?2obmalloc?4c?$AA@ DB '..\Objects\obmallo'
	DB	'c.c', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT new_arena
_TEXT	SEGMENT
new_arena PROC						; COMDAT

; 571  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 572  :     struct arena_object* arenaobj = NULL;

  0000a	33 f6		 xor	 esi, esi

; 573  :     uint excess;        /* number of bytes above pool alignment */
; 574  :     void *address;
; 575  :     int err;
; 576  :     Py_GUARD

  0000c	e8 00 00 00 00	 call	 _Py_PXCTX
  00011	85 c0		 test	 eax, eax
  00013	74 1c		 je	 SHORT $LN10@new_arena
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@PMODNIDG@?4?4?2Objects?2obmalloc?4c?$AA@
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09MEEKLCNL@new_arena?$AA@
  00023	45 33 c9	 xor	 r9d, r9d
  00026	41 b8 40 02 00
	00		 mov	 r8d, 576		; 00000240H
  0002c	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN10@new_arena:

; 577  : 
; 578  : #ifdef PYMALLOC_DEBUG
; 579  :     if (Py_GETENV("PYTHONMALLOCSTATS"))
; 580  :         _PyObject_DebugMallocStats(stderr);
; 581  : #endif
; 582  :     if (unused_arena_objects == NULL) {

  00031	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR unused_arena_objects
  00038	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0003d	48 85 db	 test	 rbx, rbx
  00040	0f 85 a5 00 00
	00		 jne	 $LN9@new_arena

; 583  :         uint i;
; 584  :         uint numarenas;
; 585  :         size_t nbytes;
; 586  : 
; 587  :         /* Double the number of arena objects on each allocation.
; 588  :          * Note that it's possible for `numarenas` to overflow.
; 589  :          */
; 590  :         numarenas = maxarenas ? maxarenas << 1 : INITIAL_ARENA_OBJECTS;

  00046	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR maxarenas
  0004c	85 db		 test	 ebx, ebx
  0004e	74 1a		 je	 SHORT $LN13@new_arena
  00050	8d 3c 1b	 lea	 edi, DWORD PTR [rbx+rbx]

; 591  :         if (numarenas <= maxarenas)

  00053	3b fb		 cmp	 edi, ebx
  00055	77 18		 ja	 SHORT $LN19@new_arena

; 663  : 
; 664  : end:
; 665  :     return arenaobj;

  00057	48 8b c6	 mov	 rax, rsi
  0005a	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 666  : }

  0005f	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00064	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00068	5e		 pop	 rsi
  00069	c3		 ret	 0
$LN13@new_arena:

; 583  :         uint i;
; 584  :         uint numarenas;
; 585  :         size_t nbytes;
; 586  : 
; 587  :         /* Double the number of arena objects on each allocation.
; 588  :          * Note that it's possible for `numarenas` to overflow.
; 589  :          */
; 590  :         numarenas = maxarenas ? maxarenas << 1 : INITIAL_ARENA_OBJECTS;

  0006a	bf 10 00 00 00	 mov	 edi, 16
$LN19@new_arena:

; 592  :             goto end;                   /* overflow */
; 593  : #if SIZEOF_SIZE_T <= SIZEOF_INT
; 594  :         if (numarenas > PY_SIZE_MAX / sizeof(*arenas))
; 595  :             goto end;                   /* overflow */
; 596  : #endif
; 597  :         nbytes = numarenas * sizeof(*arenas);
; 598  :         arenaobj = (struct arena_object *)realloc(arenas, nbytes);

  0006f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR arenas
  00076	8b c7		 mov	 eax, edi
  00078	48 8d 14 40	 lea	 rdx, QWORD PTR [rax+rax*2]
  0007c	48 c1 e2 04	 shl	 rdx, 4
  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  00086	4c 8b d8	 mov	 r11, rax

; 599  :         if (arenaobj == NULL)

  00089	48 85 c0	 test	 rax, rax
  0008c	0f 84 ff 00 00
	00		 je	 $end$20655

; 600  :             goto end;
; 601  :         arenas = arenaobj;

  00092	48 89 05 00 00
	00 00		 mov	 QWORD PTR arenas, rax

; 602  : 
; 603  :         /* We might need to fix pointers that were copied.  However,
; 604  :          * new_arena only gets called when all the pages in the
; 605  :          * previous arenas are full.  Thus, there are *no* pointers
; 606  :          * into the old array. Thus, we don't have to worry about
; 607  :          * invalid pointers.  Just to be sure, some asserts:
; 608  :          */
; 609  :         assert(usable_arenas == NULL);
; 610  :         assert(unused_arena_objects == NULL);
; 611  : 
; 612  :         /* Put the new arenas on the unused_arena_objects list. */
; 613  :         for (i = maxarenas; i < numarenas; ++i) {

  00099	8b d3		 mov	 edx, ebx
  0009b	48 63 c3	 movsxd	 rax, ebx
  0009e	3b df		 cmp	 ebx, edi
  000a0	73 38		 jae	 SHORT $LN4@new_arena

; 600  :             goto end;
; 601  :         arenas = arenaobj;

  000a2	4c 8d 04 40	 lea	 r8, QWORD PTR [rax+rax*2]
  000a6	44 8d 4f ff	 lea	 r9d, DWORD PTR [rdi-1]
  000aa	49 c1 e0 04	 shl	 r8, 4
  000ae	4d 03 c3	 add	 r8, r11
$LL6@new_arena:

; 614  :             arenas[i].address = 0;              /* mark as unassociated */

  000b1	49 89 30	 mov	 QWORD PTR [r8], rsi

; 615  :             arenas[i].nextarena = i < numarenas - 1 ?
; 616  :                                    &arenas[i+1] : NULL;

  000b4	41 3b d1	 cmp	 edx, r9d
  000b7	73 10		 jae	 SHORT $LN15@new_arena
  000b9	8d 42 01	 lea	 eax, DWORD PTR [rdx+1]
  000bc	48 8d 04 40	 lea	 rax, QWORD PTR [rax+rax*2]
  000c0	48 c1 e0 04	 shl	 rax, 4
  000c4	49 03 c3	 add	 rax, r11
  000c7	eb 03		 jmp	 SHORT $LN16@new_arena
$LN15@new_arena:
  000c9	48 8b c6	 mov	 rax, rsi
$LN16@new_arena:

; 602  : 
; 603  :         /* We might need to fix pointers that were copied.  However,
; 604  :          * new_arena only gets called when all the pages in the
; 605  :          * previous arenas are full.  Thus, there are *no* pointers
; 606  :          * into the old array. Thus, we don't have to worry about
; 607  :          * invalid pointers.  Just to be sure, some asserts:
; 608  :          */
; 609  :         assert(usable_arenas == NULL);
; 610  :         assert(unused_arena_objects == NULL);
; 611  : 
; 612  :         /* Put the new arenas on the unused_arena_objects list. */
; 613  :         for (i = maxarenas; i < numarenas; ++i) {

  000cc	ff c2		 inc	 edx

; 615  :             arenas[i].nextarena = i < numarenas - 1 ?
; 616  :                                    &arenas[i+1] : NULL;

  000ce	49 89 40 20	 mov	 QWORD PTR [r8+32], rax
  000d2	49 83 c0 30	 add	 r8, 48			; 00000030H
  000d6	3b d7		 cmp	 edx, edi
  000d8	72 d7		 jb	 SHORT $LL6@new_arena
$LN4@new_arena:

; 617  :         }
; 618  : 
; 619  :         /* Update globals. */
; 620  :         unused_arena_objects = &arenas[maxarenas];

  000da	48 8d 1c 5b	 lea	 rbx, QWORD PTR [rbx+rbx*2]

; 621  :         maxarenas = numarenas;

  000de	89 3d 00 00 00
	00		 mov	 DWORD PTR maxarenas, edi
  000e4	48 c1 e3 04	 shl	 rbx, 4
  000e8	49 03 db	 add	 rbx, r11
$LN9@new_arena:

; 622  :     }
; 623  : 
; 624  :     /* Take the next available arena object off the head of the list. */
; 625  :     assert(unused_arena_objects != NULL);
; 626  :     arenaobj = unused_arena_objects;
; 627  :     unused_arena_objects = arenaobj->nextarena;

  000eb	48 8b 7b 20	 mov	 rdi, QWORD PTR [rbx+32]

; 628  :     assert(arenaobj->address == 0);
; 629  : #ifdef ARENAS_USE_MMAP
; 630  :     address = mmap(NULL, ARENA_SIZE, PROT_READ|PROT_WRITE,
; 631  :                                    MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
; 632  :     err = (address == MAP_FAILED);
; 633  : #else
; 634  :     address = malloc(ARENA_SIZE);

  000ef	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  000f4	48 89 3d 00 00
	00 00		 mov	 QWORD PTR unused_arena_objects, rdi
  000fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00101	4c 8b d8	 mov	 r11, rax

; 635  :     err = (address == 0);

  00104	48 85 c0	 test	 rax, rax

; 636  : #endif
; 637  :     if (err) {

  00107	75 1e		 jne	 SHORT $LN3@new_arena

; 638  :         /* The allocation failed: return NULL after putting the
; 639  :          * arenaobj back.
; 640  :          */
; 641  :         arenaobj->nextarena = unused_arena_objects;

  00109	48 89 7b 20	 mov	 QWORD PTR [rbx+32], rdi

; 642  :         unused_arena_objects = arenaobj;

  0010d	48 89 1d 00 00
	00 00		 mov	 QWORD PTR unused_arena_objects, rbx

; 663  : 
; 664  : end:
; 665  :     return arenaobj;

  00114	48 8b c3	 mov	 rax, rbx
  00117	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 666  : }

  0011c	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00121	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00125	5e		 pop	 rsi
  00126	c3		 ret	 0
$LN3@new_arena:

; 643  :         goto end;
; 644  :     }
; 645  :     arenaobj->address = (uptr)address;
; 646  : 
; 647  :     ++narenas_currently_allocated;

  00127	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR narenas_currently_allocated

; 648  :     ++ntimes_arena_allocated;

  0012e	48 ff 05 00 00
	00 00		 inc	 QWORD PTR ntimes_arena_allocated
  00135	48 89 03	 mov	 QWORD PTR [rbx], rax

; 649  :     if (narenas_currently_allocated > narenas_highwater)

  00138	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR narenas_highwater
  0013f	48 ff c1	 inc	 rcx

; 650  :         narenas_highwater = narenas_currently_allocated;
; 651  :     arenaobj->freepools = NULL;

  00142	48 89 73 18	 mov	 QWORD PTR [rbx+24], rsi
  00146	48 3b c8	 cmp	 rcx, rax
  00149	48 89 0d 00 00
	00 00		 mov	 QWORD PTR narenas_currently_allocated, rcx

; 652  :     /* pool_address <- first pool-aligned address in the arena
; 653  :        nfreepools <- number of whole pools that fit after alignment */
; 654  :     arenaobj->pool_address = (block*)arenaobj->address;

  00150	4c 89 5b 08	 mov	 QWORD PTR [rbx+8], r11
  00154	48 0f 47 c1	 cmova	 rax, rcx

; 655  :     arenaobj->nfreepools = ARENA_SIZE / POOL_SIZE;
; 656  :     assert(POOL_SIZE * arenaobj->nfreepools == ARENA_SIZE);
; 657  :     excess = (uint)(arenaobj->address & POOL_SIZE_MASK);

  00158	41 8b cb	 mov	 ecx, r11d
  0015b	c7 43 10 40 00
	00 00		 mov	 DWORD PTR [rbx+16], 64	; 00000040H
  00162	81 e1 ff 0f 00
	00		 and	 ecx, 4095		; 00000fffH
  00168	48 89 05 00 00
	00 00		 mov	 QWORD PTR narenas_highwater, rax

; 658  :     if (excess != 0) {

  0016f	74 17		 je	 SHORT $LN1@new_arena

; 659  :         --arenaobj->nfreepools;
; 660  :         arenaobj->pool_address += POOL_SIZE - excess;

  00171	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  00176	c7 43 10 3f 00
	00 00		 mov	 DWORD PTR [rbx+16], 63	; 0000003fH
  0017d	2b c1		 sub	 eax, ecx
  0017f	8b c8		 mov	 ecx, eax
  00181	49 03 cb	 add	 rcx, r11
  00184	48 89 4b 08	 mov	 QWORD PTR [rbx+8], rcx
$LN1@new_arena:

; 661  :     }
; 662  :     arenaobj->ntotalpools = arenaobj->nfreepools;

  00188	8b 43 10	 mov	 eax, DWORD PTR [rbx+16]
  0018b	89 43 14	 mov	 DWORD PTR [rbx+20], eax

; 663  : 
; 664  : end:
; 665  :     return arenaobj;

  0018e	48 8b c3	 mov	 rax, rbx
$end$20655:
  00191	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 666  : }

  00196	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0019b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0019f	5e		 pop	 rsi
  001a0	c3		 ret	 0
new_arena ENDP
_TEXT	ENDS
PUBLIC	PyObject_Malloc
EXTRN	_PxMem_Malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_Malloc DD imagerel $LN29
	DD	imagerel $LN29+54
	DD	imagerel $unwind$PyObject_Malloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyObject_Malloc DD imagerel $LN29+54
	DD	imagerel $LN29+342
	DD	imagerel $chain$3$PyObject_Malloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$PyObject_Malloc DD imagerel $LN29+342
	DD	imagerel $LN29+520
	DD	imagerel $chain$5$PyObject_Malloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$PyObject_Malloc DD 080021H
	DD	09c400H
	DD	086400H
	DD	075400H
	DD	063400H
	DD	imagerel $LN29
	DD	imagerel $LN29+54
	DD	imagerel $unwind$PyObject_Malloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyObject_Malloc DD 082921H
	DD	09c429H
	DD	08641dH
	DD	075411H
	DD	063405H
	DD	imagerel $LN29
	DD	imagerel $LN29+54
	DD	imagerel $unwind$PyObject_Malloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_Malloc DD 020601H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyObject_Malloc
_TEXT	SEGMENT
nbytes$ = 48
PyObject_Malloc PROC					; COMDAT

; 803  : {

$LN29:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b f9	 mov	 rdi, rcx

; 804  :     block *bp;
; 805  :     poolp pool;
; 806  :     poolp next;
; 807  :     uint size;
; 808  :     Px_RETURN(_PxMem_Malloc(nbytes))

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 0d		 je	 SHORT $LN17@PyObject_M
  00012	48 8b cf	 mov	 rcx, rdi

; 1007 :             UNLOCK();
; 1008 :         }
; 1009 :         return result;
; 1010 :     }
; 1011 : }

  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5f		 pop	 rdi
  0001a	e9 00 00 00 00	 jmp	 _PxMem_Malloc
$LN17@PyObject_M:

; 809  : 
; 810  : #ifdef WITH_VALGRIND
; 811  :     if (UNLIKELY(running_on_valgrind == -1))
; 812  :         running_on_valgrind = RUNNING_ON_VALGRIND;
; 813  :     if (UNLIKELY(running_on_valgrind))
; 814  :         goto redirect;
; 815  : #endif
; 816  : 
; 817  :     /*
; 818  :      * Limit ourselves to PY_SSIZE_T_MAX bytes to prevent security holes.
; 819  :      * Most python internals blindly use a signed Py_ssize_t to track
; 820  :      * things without checking for overflows or negatives.
; 821  :      * As size_t is unsigned, checking for nbytes < 0 is not required.
; 822  :      */
; 823  :     if (nbytes > PY_SSIZE_T_MAX)

  0001f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00029	48 3b f8	 cmp	 rdi, rax
  0002c	76 08		 jbe	 SHORT $LN16@PyObject_M

; 824  :         return NULL;

  0002e	33 c0		 xor	 eax, eax

; 1007 :             UNLOCK();
; 1008 :         }
; 1009 :         return result;
; 1010 :     }
; 1011 : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5f		 pop	 rdi
  00035	c3		 ret	 0
$LN16@PyObject_M:
  00036	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 825  : 
; 826  :     _Py_AllocatedBlocks++;

  0003b	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR _Py_AllocatedBlocks
  00042	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  00047	48 ff c3	 inc	 rbx

; 827  : 
; 828  :     /*
; 829  :      * This implicitly redirects malloc(0).
; 830  :      */
; 831  :     if ((nbytes - 1) < SMALL_REQUEST_THRESHOLD) {

  0004a	48 8d 47 ff	 lea	 rax, QWORD PTR [rdi-1]
  0004e	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00053	48 89 1d 00 00
	00 00		 mov	 QWORD PTR _Py_AllocatedBlocks, rbx
  0005a	4c 89 64 24 48	 mov	 QWORD PTR [rsp+72], r12
  0005f	48 3d 00 02 00
	00		 cmp	 rax, 512		; 00000200H
  00065	0f 83 ad 00 00
	00		 jae	 $redirect$20707

; 832  :         LOCK();
; 833  :         /*
; 834  :          * Most frequent paths first
; 835  :          */
; 836  :         size = (uint)(nbytes - 1) >> ALIGNMENT_SHIFT;

  0006b	8d 77 ff	 lea	 esi, DWORD PTR [rdi-1]

; 837  :         pool = usedpools[size + size];

  0006e	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:usedpools
  00075	c1 ee 03	 shr	 esi, 3
  00078	8d 04 36	 lea	 eax, DWORD PTR [rsi+rsi]
  0007b	8b e8		 mov	 ebp, eax
  0007d	49 8b 14 c4	 mov	 rdx, QWORD PTR [r12+rax*8]

; 838  :         if (pool != pool->nextpool) {

  00081	4c 8b 4a 10	 mov	 r9, QWORD PTR [rdx+16]
  00085	49 3b d1	 cmp	 rdx, r9
  00088	74 44		 je	 SHORT $LN14@PyObject_M

; 839  :             /*
; 840  :              * There is a used pool for this size class.
; 841  :              * Pick up the head block of its free list.
; 842  :              */
; 843  :             ++pool->ref.count;
; 844  :             bp = pool->freeblock;

  0008a	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]
  0008e	ff 02		 inc	 DWORD PTR [rdx]

; 845  :             assert(bp != NULL);
; 846  :             if ((pool->freeblock = *(block **)bp) != NULL) {

  00090	49 8b 08	 mov	 rcx, QWORD PTR [r8]
  00093	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx
  00097	48 85 c9	 test	 rcx, rcx

; 847  :                 UNLOCK();
; 848  :                 return (void *)bp;

  0009a	75 2d		 jne	 SHORT $LN28@PyObject_M

; 849  :             }
; 850  :             /*
; 851  :              * Reached the end of the free list, try to extend it.
; 852  :              */
; 853  :             if (pool->nextoffset <= pool->maxnextoffset) {

  0009c	8b 42 28	 mov	 eax, DWORD PTR [rdx+40]
  0009f	3b 42 2c	 cmp	 eax, DWORD PTR [rdx+44]
  000a2	77 19		 ja	 SHORT $LN12@PyObject_M

; 854  :                 /* There is room for another block. */
; 855  :                 pool->freeblock = (block*)pool +
; 856  :                                   pool->nextoffset;

  000a4	48 8d 0c 02	 lea	 rcx, QWORD PTR [rdx+rax]

; 857  :                 pool->nextoffset += INDEX2SIZE(size);

  000a8	8d 44 f0 08	 lea	 eax, DWORD PTR [rax+rsi*8+8]

; 858  :                 *(block **)(pool->freeblock) = NULL;

  000ac	33 db		 xor	 ebx, ebx
  000ae	89 42 28	 mov	 DWORD PTR [rdx+40], eax
  000b1	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx
  000b5	48 89 19	 mov	 QWORD PTR [rcx], rbx

; 859  :                 UNLOCK();
; 860  :                 return (void *)bp;

  000b8	49 8b c0	 mov	 rax, r8
  000bb	eb 7f		 jmp	 SHORT $LN1@PyObject_M
$LN12@PyObject_M:

; 861  :             }
; 862  :             /* Pool is full, unlink from used pools. */
; 863  :             next = pool->nextpool;
; 864  :             pool = pool->prevpool;

  000bd	48 8b 42 18	 mov	 rax, QWORD PTR [rdx+24]

; 865  :             next->prevpool = pool;

  000c1	49 89 41 18	 mov	 QWORD PTR [r9+24], rax

; 866  :             pool->nextpool = next;

  000c5	4c 89 48 10	 mov	 QWORD PTR [rax+16], r9
$LN28@PyObject_M:

; 867  :             UNLOCK();
; 868  :             return (void *)bp;

  000c9	49 8b c0	 mov	 rax, r8
  000cc	eb 6e		 jmp	 SHORT $LN1@PyObject_M
$LN14@PyObject_M:

; 869  :         }
; 870  : 
; 871  :         /* There isn't a pool of the right size class immediately
; 872  :          * available:  use a free pool.
; 873  :          */
; 874  :         if (usable_arenas == NULL) {

  000ce	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR usable_arenas
  000d5	33 db		 xor	 ebx, ebx
  000d7	4d 85 c0	 test	 r8, r8
  000da	75 1c		 jne	 SHORT $LN11@PyObject_M

; 875  :             /* No arena has a free pool:  allocate a new arena. */
; 876  : #ifdef WITH_MEMORY_LIMITS
; 877  :             if (narenas_currently_allocated >= MAX_ARENAS) {
; 878  :                 UNLOCK();
; 879  :                 goto redirect;
; 880  :             }
; 881  : #endif
; 882  :             usable_arenas = new_arena();

  000dc	e8 00 00 00 00	 call	 new_arena
  000e1	4c 8b c0	 mov	 r8, rax
  000e4	48 89 05 00 00
	00 00		 mov	 QWORD PTR usable_arenas, rax

; 883  :             if (usable_arenas == NULL) {

  000eb	48 85 c0	 test	 rax, rax
  000ee	74 21		 je	 SHORT $LN20@PyObject_M

; 884  :                 UNLOCK();
; 885  :                 goto redirect;
; 886  :             }
; 887  :             usable_arenas->nextarena =
; 888  :                 usable_arenas->prevarena = NULL;

  000f0	48 89 58 28	 mov	 QWORD PTR [rax+40], rbx
  000f4	48 89 58 20	 mov	 QWORD PTR [rax+32], rbx
$LN11@PyObject_M:

; 889  :         }
; 890  :         assert(usable_arenas->address != 0);
; 891  : 
; 892  :         /* Try to get a cached free pool. */
; 893  :         pool = usable_arenas->freepools;

  000f8	4d 8b 48 18	 mov	 r9, QWORD PTR [r8+24]

; 894  :         if (pool != NULL) {

  000fc	41 ba 00 10 00
	00		 mov	 r10d, 4096		; 00001000H
  00102	4d 85 c9	 test	 r9, r9
  00105	74 4f		 je	 SHORT $LN9@PyObject_M

; 895  :             /* Unlink from cached pools. */
; 896  :             usable_arenas->freepools = pool->nextpool;

  00107	49 8b 41 10	 mov	 rax, QWORD PTR [r9+16]
  0010b	49 89 40 18	 mov	 QWORD PTR [r8+24], rax

; 897  : 
; 898  :             /* This arena already had the smallest nfreepools
; 899  :              * value, so decreasing nfreepools doesn't change
; 900  :              * that, and we don't need to rearrange the
; 901  :              * usable_arenas list.  However, if the arena has
; 902  :              * become wholly allocated, we need to remove its
; 903  :              * arena_object from usable_arenas.
; 904  :              */
; 905  :             --usable_arenas->nfreepools;
; 906  :             if (usable_arenas->nfreepools == 0) {
; 907  :                 /* Wholly allocated:  remove. */
; 908  :                 assert(usable_arenas->freepools == NULL);
; 909  :                 assert(usable_arenas->nextarena == NULL ||
; 910  :                        usable_arenas->nextarena->prevarena ==
; 911  :                        usable_arenas);
; 912  : 
; 913  :                 usable_arenas = usable_arenas->nextarena;
; 914  :                 if (usable_arenas != NULL) {
; 915  :                     usable_arenas->prevarena = NULL;
; 916  :                     assert(usable_arenas->address != 0);
; 917  :                 }
; 918  :             }
; 919  :             else {

  0010f	eb 7e		 jmp	 SHORT $LN27@PyObject_M
$LN20@PyObject_M:

; 961  :             UNLOCK();
; 962  :             return (void *)bp;

  00111	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR _Py_AllocatedBlocks
$redirect$20707:

; 985  :                 assert(usable_arenas->address != 0);
; 986  :             }
; 987  :         }
; 988  : 
; 989  :         goto init_pool;
; 990  :     }
; 991  : 
; 992  :     /* The small block allocator ends here. */
; 993  : 
; 994  : redirect:
; 995  :     /* Redirect the original request to the underlying (libc) allocator.
; 996  :      * We jump here on bigger requests, on error in the code above (as a
; 997  :      * last chance to serve the request) or when the max memory limit
; 998  :      * has been reached.
; 999  :      */
; 1000 :     if (nbytes == 0)

  00118	b8 01 00 00 00	 mov	 eax, 1
  0011d	48 85 ff	 test	 rdi, rdi
  00120	48 0f 44 f8	 cmove	 rdi, rax

; 1001 :         nbytes = 1;
; 1002 :     {
; 1003 :         void *result = malloc(nbytes);

  00124	48 8b cf	 mov	 rcx, rdi
  00127	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc

; 1004 :         if (!result) {

  0012d	48 85 c0	 test	 rax, rax
  00130	75 0a		 jne	 SHORT $LN1@PyObject_M

; 1005 :             LOCK();
; 1006 :             _Py_AllocatedBlocks--;

  00132	48 ff cb	 dec	 rbx
  00135	48 89 1d 00 00
	00 00		 mov	 QWORD PTR _Py_AllocatedBlocks, rbx
$LN1@PyObject_M:
  0013c	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00141	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00146	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0014b	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]

; 1007 :             UNLOCK();
; 1008 :         }
; 1009 :         return result;
; 1010 :     }
; 1011 : }

  00150	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00154	5f		 pop	 rdi
  00155	c3		 ret	 0
$LN9@PyObject_M:

; 963  :         }
; 964  : 
; 965  :         /* Carve off a new pool. */
; 966  :         assert(usable_arenas->nfreepools > 0);
; 967  :         assert(usable_arenas->freepools == NULL);
; 968  :         pool = (poolp)usable_arenas->pool_address;

  00156	4d 8b 48 08	 mov	 r9, QWORD PTR [r8+8]

; 969  :         assert((block*)pool <= (block*)usable_arenas->address +
; 970  :                                ARENA_SIZE - POOL_SIZE);
; 971  :         pool->arenaindex = usable_arenas - arenas;

  0015a	49 8b c8	 mov	 rcx, r8
  0015d	48 b8 ab aa aa
	aa aa aa aa 2a	 mov	 rax, 3074457345618258603 ; 2aaaaaaaaaaaaaabH
  00167	48 2b 0d 00 00
	00 00		 sub	 rcx, QWORD PTR arenas

; 972  :         assert(&arenas[pool->arenaindex] == usable_arenas);
; 973  :         pool->szidx = DUMMY_SIZE_IDX;

  0016e	41 c7 41 24 ff
	ff 00 00	 mov	 DWORD PTR [r9+36], 65535 ; 0000ffffH
  00176	48 f7 e9	 imul	 rcx
  00179	48 c1 fa 03	 sar	 rdx, 3
  0017d	48 8b c2	 mov	 rax, rdx
  00180	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  00184	48 03 d0	 add	 rdx, rax
  00187	41 89 51 20	 mov	 DWORD PTR [r9+32], edx

; 974  :         usable_arenas->pool_address += POOL_SIZE;

  0018b	4d 01 50 08	 add	 QWORD PTR [r8+8], r10
$LN27@PyObject_M:

; 975  :         --usable_arenas->nfreepools;

  0018f	41 ff 48 10	 dec	 DWORD PTR [r8+16]

; 976  : 
; 977  :         if (usable_arenas->nfreepools == 0) {

  00193	75 14		 jne	 SHORT $init_pool$20721

; 978  :             assert(usable_arenas->nextarena == NULL ||
; 979  :                    usable_arenas->nextarena->prevarena ==
; 980  :                    usable_arenas);
; 981  :             /* Unlink the arena:  it is completely allocated. */
; 982  :             usable_arenas = usable_arenas->nextarena;

  00195	49 8b 40 20	 mov	 rax, QWORD PTR [r8+32]
  00199	48 89 05 00 00
	00 00		 mov	 QWORD PTR usable_arenas, rax

; 983  :             if (usable_arenas != NULL) {

  001a0	48 85 c0	 test	 rax, rax
  001a3	74 04		 je	 SHORT $init_pool$20721

; 984  :                 usable_arenas->prevarena = NULL;

  001a5	48 89 58 28	 mov	 QWORD PTR [rax+40], rbx
$init_pool$20721:

; 920  :                 /* nfreepools > 0:  it must be that freepools
; 921  :                  * isn't NULL, or that we haven't yet carved
; 922  :                  * off all the arena's pools for the first
; 923  :                  * time.
; 924  :                  */
; 925  :                 assert(usable_arenas->freepools != NULL ||
; 926  :                        usable_arenas->pool_address <=
; 927  :                        (block*)usable_arenas->address +
; 928  :                            ARENA_SIZE - POOL_SIZE);
; 929  :             }
; 930  :         init_pool:
; 931  :             /* Frontlink to used pools. */
; 932  :             next = usedpools[size + size]; /* == prev */

  001a9	49 8b 04 ec	 mov	 rax, QWORD PTR [r12+rbp*8]

; 933  :             pool->nextpool = next;

  001ad	49 89 41 10	 mov	 QWORD PTR [r9+16], rax

; 934  :             pool->prevpool = next;

  001b1	49 89 41 18	 mov	 QWORD PTR [r9+24], rax

; 935  :             next->nextpool = pool;

  001b5	4c 89 48 10	 mov	 QWORD PTR [rax+16], r9

; 936  :             next->prevpool = pool;

  001b9	4c 89 48 18	 mov	 QWORD PTR [rax+24], r9

; 937  :             pool->ref.count = 1;

  001bd	b8 01 00 00 00	 mov	 eax, 1
  001c2	41 89 01	 mov	 DWORD PTR [r9], eax

; 938  :             if (pool->szidx == size) {

  001c5	41 39 71 24	 cmp	 DWORD PTR [r9+36], esi
  001c9	75 10		 jne	 SHORT $LN5@PyObject_M

; 939  :                 /* Luckily, this pool last contained blocks
; 940  :                  * of the same size class, so its header
; 941  :                  * and free list are already initialized.
; 942  :                  */
; 943  :                 bp = pool->freeblock;

  001cb	49 8b 41 08	 mov	 rax, QWORD PTR [r9+8]

; 944  :                 assert(bp != NULL);
; 945  :                 pool->freeblock = *(block **)bp;

  001cf	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001d2	49 89 49 08	 mov	 QWORD PTR [r9+8], rcx

; 946  :                 UNLOCK();
; 947  :                 return (void *)bp;

  001d6	e9 61 ff ff ff	 jmp	 $LN1@PyObject_M
$LN5@PyObject_M:

; 948  :             }
; 949  :             /*
; 950  :              * Initialize the pool header, set up the free list to
; 951  :              * contain just the second block, and return the first
; 952  :              * block.
; 953  :              */
; 954  :             pool->szidx = size;
; 955  :             size = INDEX2SIZE(size);

  001db	8d 14 f5 08 00
	00 00		 lea	 edx, DWORD PTR [rsi*8+8]

; 956  :             bp = (block *)pool + POOL_OVERHEAD;

  001e2	49 8d 41 30	 lea	 rax, QWORD PTR [r9+48]
  001e6	41 89 71 24	 mov	 DWORD PTR [r9+36], esi

; 957  :             pool->nextoffset = POOL_OVERHEAD + (size << 1);

  001ea	8d 4c 12 30	 lea	 ecx, DWORD PTR [rdx+rdx+48]

; 958  :             pool->maxnextoffset = POOL_SIZE - size;

  001ee	44 2b d2	 sub	 r10d, edx

; 959  :             pool->freeblock = bp + size;

  001f1	48 03 d0	 add	 rdx, rax
  001f4	41 89 49 28	 mov	 DWORD PTR [r9+40], ecx
  001f8	45 89 51 2c	 mov	 DWORD PTR [r9+44], r10d
  001fc	49 89 51 08	 mov	 QWORD PTR [r9+8], rdx

; 960  :             *(block **)(pool->freeblock) = NULL;

  00200	48 89 1a	 mov	 QWORD PTR [rdx], rbx

; 961  :             UNLOCK();
; 962  :             return (void *)bp;

  00203	e9 34 ff ff ff	 jmp	 $LN1@PyObject_M
PyObject_Malloc ENDP
_TEXT	ENDS
PUBLIC	PyObject_Free
EXTRN	__imp_free:PROC
EXTRN	_PxMem_Free:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_Free DD imagerel $LN24
	DD	imagerel $LN24+515
	DD	imagerel $unwind$PyObject_Free
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_Free DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyObject_Free
_TEXT	SEGMENT
p$ = 48
PyObject_Free PROC					; COMDAT

; 1018 : {

$LN24:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1019 :     poolp pool;
; 1020 :     block *lastfree;
; 1021 :     poolp next, prev;
; 1022 :     uint size;
; 1023 : #ifndef Py_USING_MEMORY_DEBUGGER
; 1024 :     uint arenaindex_temp;
; 1025 : #endif
; 1026 :     Px_RETURN_VOID(_PxMem_Free(p))

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 0d		 je	 SHORT $LN18@PyObject_F
  00012	48 8b cb	 mov	 rcx, rbx

; 1241 : }

  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5b		 pop	 rbx
  0001a	e9 00 00 00 00	 jmp	 _PxMem_Free
$LN18@PyObject_F:

; 1027 : 
; 1028 :     if (p == NULL)      /* free(NULL) has no effect */

  0001f	48 85 db	 test	 rbx, rbx
  00022	0f 84 d5 01 00
	00		 je	 $LN19@PyObject_F

; 1029 :         return;
; 1030 : 
; 1031 :     _Py_AllocatedBlocks--;

  00028	48 ff 0d 00 00
	00 00		 dec	 QWORD PTR _Py_AllocatedBlocks

; 1032 : 
; 1033 : #ifdef WITH_VALGRIND
; 1034 :     if (UNLIKELY(running_on_valgrind > 0))
; 1035 :         goto redirect;
; 1036 : #endif
; 1037 : 
; 1038 :     pool = POOL_ADDR(p);

  0002f	4c 8b c3	 mov	 r8, rbx
  00032	49 81 e0 00 f0
	ff ff		 and	 r8, -4096		; fffffffffffff000H

; 1039 :     if (Py_ADDRESS_IN_RANGE(p, pool)) {

  00039	41 8b 40 20	 mov	 eax, DWORD PTR [r8+32]
  0003d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR maxarenas
  00043	0f 83 ab 01 00
	00		 jae	 $LN16@PyObject_F
  00049	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR arenas
  00050	48 8d 0c 40	 lea	 rcx, QWORD PTR [rax+rax*2]
  00054	48 8b c3	 mov	 rax, rbx
  00057	48 03 c9	 add	 rcx, rcx
  0005a	49 8b 14 c9	 mov	 rdx, QWORD PTR [r9+rcx*8]
  0005e	48 2b c2	 sub	 rax, rdx
  00061	48 3d 00 00 04
	00		 cmp	 rax, 262144		; 00040000H
  00067	0f 83 87 01 00
	00		 jae	 $LN16@PyObject_F
  0006d	48 85 d2	 test	 rdx, rdx
  00070	0f 84 7e 01 00
	00		 je	 $LN16@PyObject_F

; 1040 :         /* We allocated this address. */
; 1041 :         LOCK();
; 1042 :         /* Link p to the start of the pool's freeblock list.  Since
; 1043 :          * the pool had at least the p block outstanding, the pool
; 1044 :          * wasn't empty (so it's already in a usedpools[] list, or
; 1045 :          * was full and is in no list -- it's not in the freeblocks
; 1046 :          * list in any case).
; 1047 :          */
; 1048 :         assert(pool->ref.count > 0);            /* else it was empty */
; 1049 :         *(block **)p = lastfree = pool->freeblock;

  00076	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  0007a	48 89 03	 mov	 QWORD PTR [rbx], rax

; 1050 :         pool->freeblock = (block *)p;

  0007d	49 89 58 08	 mov	 QWORD PTR [r8+8], rbx

; 1051 :         if (lastfree) {

  00081	48 85 c0	 test	 rax, rax
  00084	0f 84 3c 01 00
	00		 je	 $LN15@PyObject_F

; 1052 :             struct arena_object* ao;
; 1053 :             uint nf;  /* ao->nfreepools */
; 1054 : 
; 1055 :             /* freeblock wasn't NULL, so the pool wasn't full,
; 1056 :              * and the pool is in a usedpools[] list.
; 1057 :              */
; 1058 :             if (--pool->ref.count != 0) {

  0008a	41 ff 08	 dec	 DWORD PTR [r8]
  0008d	0f 85 6a 01 00
	00		 jne	 $LN19@PyObject_F

; 1059 :                 /* pool isn't empty:  leave it in usedpools */
; 1060 :                 UNLOCK();
; 1061 :                 return;
; 1062 :             }
; 1063 :             /* Pool is now empty:  unlink from usedpools, and
; 1064 :              * link to the front of freepools.  This ensures that
; 1065 :              * previously freed pools will be allocated later
; 1066 :              * (being not referenced, they are perhaps paged out).
; 1067 :              */
; 1068 :             next = pool->nextpool;

  00093	49 8b 48 10	 mov	 rcx, QWORD PTR [r8+16]

; 1069 :             prev = pool->prevpool;

  00097	49 8b 40 18	 mov	 rax, QWORD PTR [r8+24]

; 1070 :             next->prevpool = prev;

  0009b	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 1071 :             prev->nextpool = next;

  0009f	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1072 : 
; 1073 :             /* Link the pool to freepools.  This is a singly-linked
; 1074 :              * list, and pool->prevpool isn't used there.
; 1075 :              */
; 1076 :             ao = &arenas[pool->arenaindex];

  000a3	41 8b 40 20	 mov	 eax, DWORD PTR [r8+32]
  000a7	48 8d 1c 40	 lea	 rbx, QWORD PTR [rax+rax*2]
  000ab	48 c1 e3 04	 shl	 rbx, 4
  000af	49 03 d9	 add	 rbx, r9

; 1077 :             pool->nextpool = ao->freepools;

  000b2	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  000b6	49 89 40 10	 mov	 QWORD PTR [r8+16], rax

; 1078 :             ao->freepools = pool;
; 1079 :             nf = ++ao->nfreepools;

  000ba	ff 43 10	 inc	 DWORD PTR [rbx+16]
  000bd	8b 53 10	 mov	 edx, DWORD PTR [rbx+16]
  000c0	4c 89 43 18	 mov	 QWORD PTR [rbx+24], r8

; 1080 : 
; 1081 :             /* All the rest is arena management.  We just freed
; 1082 :              * a pool, and there are 4 cases for arena mgmt:
; 1083 :              * 1. If all the pools are free, return the arena to
; 1084 :              *    the system free().
; 1085 :              * 2. If this is the only free pool in the arena,
; 1086 :              *    add the arena back to the `usable_arenas` list.
; 1087 :              * 3. If the "next" arena has a smaller count of free
; 1088 :              *    pools, we have to "slide this arena right" to
; 1089 :              *    restore that usable_arenas is sorted in order of
; 1090 :              *    nfreepools.
; 1091 :              * 4. Else there's nothing more to do.
; 1092 :              */
; 1093 :             if (nf == ao->ntotalpools) {

  000c4	3b 53 14	 cmp	 edx, DWORD PTR [rbx+20]
  000c7	75 5a		 jne	 SHORT $LN13@PyObject_F

; 1094 :                 /* Case 1.  First unlink ao from usable_arenas.
; 1095 :                  */
; 1096 :                 assert(ao->prevarena == NULL ||
; 1097 :                        ao->prevarena->address != 0);
; 1098 :                 assert(ao ->nextarena == NULL ||
; 1099 :                        ao->nextarena->address != 0);
; 1100 : 
; 1101 :                 /* Fix the pointer in the prevarena, or the
; 1102 :                  * usable_arenas pointer.
; 1103 :                  */
; 1104 :                 if (ao->prevarena == NULL) {

  000c9	48 8b 4b 28	 mov	 rcx, QWORD PTR [rbx+40]

; 1105 :                     usable_arenas = ao->nextarena;

  000cd	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000d1	48 85 c9	 test	 rcx, rcx
  000d4	75 09		 jne	 SHORT $LN12@PyObject_F
  000d6	48 89 05 00 00
	00 00		 mov	 QWORD PTR usable_arenas, rax

; 1106 :                     assert(usable_arenas == NULL ||
; 1107 :                            usable_arenas->address != 0);
; 1108 :                 }
; 1109 :                 else {

  000dd	eb 04		 jmp	 SHORT $LN11@PyObject_F
$LN12@PyObject_F:

; 1110 :                     assert(ao->prevarena->nextarena == ao);
; 1111 :                     ao->prevarena->nextarena =
; 1112 :                         ao->nextarena;

  000df	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
$LN11@PyObject_F:

; 1113 :                 }
; 1114 :                 /* Fix the pointer in the nextarena. */
; 1115 :                 if (ao->nextarena != NULL) {

  000e3	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  000e7	48 85 c9	 test	 rcx, rcx
  000ea	74 08		 je	 SHORT $LN10@PyObject_F

; 1116 :                     assert(ao->nextarena->prevarena == ao);
; 1117 :                     ao->nextarena->prevarena =
; 1118 :                         ao->prevarena;

  000ec	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  000f0	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
$LN10@PyObject_F:

; 1119 :                 }
; 1120 :                 /* Record that this arena_object slot is
; 1121 :                  * available to be reused.
; 1122 :                  */
; 1123 :                 ao->nextarena = unused_arena_objects;

  000f4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR unused_arena_objects

; 1124 :                 unused_arena_objects = ao;
; 1125 : 
; 1126 :                 /* Free the entire arena. */
; 1127 : #ifdef ARENAS_USE_MMAP
; 1128 :                 munmap((void *)ao->address, ARENA_SIZE);
; 1129 : #else
; 1130 :                 free((void *)ao->address);

  000fb	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000fe	48 89 1d 00 00
	00 00		 mov	 QWORD PTR unused_arena_objects, rbx
  00105	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  00109	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1131 : #endif
; 1132 :                 ao->address = 0;                        /* mark unassociated */
; 1133 :                 --narenas_currently_allocated;

  0010f	48 ff 0d 00 00
	00 00		 dec	 QWORD PTR narenas_currently_allocated
  00116	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0

; 1241 : }

  0011d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00121	5b		 pop	 rbx
  00122	c3		 ret	 0
$LN13@PyObject_F:

; 1134 : 
; 1135 :                 UNLOCK();
; 1136 :                 return;
; 1137 :             }
; 1138 :             if (nf == 1) {

  00123	83 fa 01	 cmp	 edx, 1
  00126	75 29		 jne	 SHORT $LN9@PyObject_F

; 1139 :                 /* Case 2.  Put ao at the head of
; 1140 :                  * usable_arenas.  Note that because
; 1141 :                  * ao->nfreepools was 0 before, ao isn't
; 1142 :                  * currently on the usable_arenas list.
; 1143 :                  */
; 1144 :                 ao->nextarena = usable_arenas;

  00128	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas

; 1145 :                 ao->prevarena = NULL;

  0012f	48 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [rbx+40], 0
  00137	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 1146 :                 if (usable_arenas)

  0013b	48 85 c0	 test	 rax, rax
  0013e	74 04		 je	 SHORT $LN8@PyObject_F

; 1147 :                     usable_arenas->prevarena = ao;

  00140	48 89 58 28	 mov	 QWORD PTR [rax+40], rbx
$LN8@PyObject_F:

; 1148 :                 usable_arenas = ao;

  00144	48 89 1d 00 00
	00 00		 mov	 QWORD PTR usable_arenas, rbx

; 1241 : }

  0014b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0014f	5b		 pop	 rbx
  00150	c3		 ret	 0
$LN9@PyObject_F:

; 1149 :                 assert(usable_arenas->address != 0);
; 1150 : 
; 1151 :                 UNLOCK();
; 1152 :                 return;
; 1153 :             }
; 1154 :             /* If this arena is now out of order, we need to keep
; 1155 :              * the list sorted.  The list is kept sorted so that
; 1156 :              * the "most full" arenas are used first, which allows
; 1157 :              * the nearly empty arenas to be completely freed.  In
; 1158 :              * a few un-scientific tests, it seems like this
; 1159 :              * approach allowed a lot more memory to be freed.
; 1160 :              */
; 1161 :             if (ao->nextarena == NULL ||
; 1162 :                          nf <= ao->nextarena->nfreepools) {

  00151	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00155	48 85 c0	 test	 rax, rax
  00158	0f 84 9f 00 00
	00		 je	 $LN19@PyObject_F
  0015e	3b 50 10	 cmp	 edx, DWORD PTR [rax+16]
  00161	0f 86 96 00 00
	00		 jbe	 $LN19@PyObject_F

; 1163 :                 /* Case 4.  Nothing to do. */
; 1164 :                 UNLOCK();
; 1165 :                 return;
; 1166 :             }
; 1167 :             /* Case 3:  We have to move the arena towards the end
; 1168 :              * of the list, because it has more free pools than
; 1169 :              * the arena to its right.
; 1170 :              * First unlink ao from usable_arenas.
; 1171 :              */
; 1172 :             if (ao->prevarena != NULL) {

  00167	48 8b 4b 28	 mov	 rcx, QWORD PTR [rbx+40]
  0016b	48 85 c9	 test	 rcx, rcx
  0016e	74 06		 je	 SHORT $LN5@PyObject_F

; 1173 :                 /* ao isn't at the head of the list */
; 1174 :                 assert(ao->prevarena->nextarena == ao);
; 1175 :                 ao->prevarena->nextarena = ao->nextarena;

  00170	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1176 :             }
; 1177 :             else {

  00174	eb 07		 jmp	 SHORT $LN4@PyObject_F
$LN5@PyObject_F:

; 1178 :                 /* ao is at the head of the list */
; 1179 :                 assert(usable_arenas == ao);
; 1180 :                 usable_arenas = ao->nextarena;

  00176	48 89 05 00 00
	00 00		 mov	 QWORD PTR usable_arenas, rax
$LN4@PyObject_F:

; 1181 :             }
; 1182 :             ao->nextarena->prevarena = ao->prevarena;

  0017d	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00181	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  00185	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1183 : 
; 1184 :             /* Locate the new insertion point by iterating over
; 1185 :              * the list, using our nextarena pointer.
; 1186 :              */
; 1187 :             while (ao->nextarena != NULL &&
; 1188 :                             nf > ao->nextarena->nfreepools) {

  00189	48 83 7b 20 00	 cmp	 QWORD PTR [rbx+32], 0
  0018e	74 1b		 je	 SHORT $LN23@PyObject_F
$LL3@PyObject_F:
  00190	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00194	3b 50 10	 cmp	 edx, DWORD PTR [rax+16]
  00197	76 12		 jbe	 SHORT $LN23@PyObject_F

; 1189 :                 ao->prevarena = ao->nextarena;

  00199	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax

; 1190 :                 ao->nextarena = ao->nextarena->nextarena;

  0019d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  001a1	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  001a5	48 83 f8 00	 cmp	 rax, 0
  001a9	75 e5		 jne	 SHORT $LL3@PyObject_F
$LN23@PyObject_F:

; 1191 :             }
; 1192 : 
; 1193 :             /* Insert ao at this point. */
; 1194 :             assert(ao->nextarena == NULL ||
; 1195 :                 ao->prevarena == ao->nextarena->prevarena);
; 1196 :             assert(ao->prevarena->nextarena == ao->nextarena);
; 1197 : 
; 1198 :             ao->prevarena->nextarena = ao;

  001ab	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  001af	48 89 58 20	 mov	 QWORD PTR [rax+32], rbx

; 1199 :             if (ao->nextarena != NULL)

  001b3	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  001b7	48 85 c0	 test	 rax, rax
  001ba	74 41		 je	 SHORT $LN19@PyObject_F

; 1200 :                 ao->nextarena->prevarena = ao;

  001bc	48 89 58 28	 mov	 QWORD PTR [rax+40], rbx

; 1241 : }

  001c0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001c4	5b		 pop	 rbx
  001c5	c3		 ret	 0
$LN15@PyObject_F:

; 1201 : 
; 1202 :             /* Verify that the swaps worked. */
; 1203 :             assert(ao->nextarena == NULL ||
; 1204 :                       nf <= ao->nextarena->nfreepools);
; 1205 :             assert(ao->prevarena == NULL ||
; 1206 :                       nf > ao->prevarena->nfreepools);
; 1207 :             assert(ao->nextarena == NULL ||
; 1208 :                 ao->nextarena->prevarena == ao);
; 1209 :             assert((usable_arenas == ao &&
; 1210 :                 ao->prevarena == NULL) ||
; 1211 :                 ao->prevarena->nextarena == ao);
; 1212 : 
; 1213 :             UNLOCK();
; 1214 :             return;
; 1215 :         }
; 1216 :         /* Pool was full, so doesn't currently live in any list:
; 1217 :          * link it to the front of the appropriate usedpools[] list.
; 1218 :          * This mimics LRU pool usage for new allocations and
; 1219 :          * targets optimal filling when several pools contain
; 1220 :          * blocks of the same size class.
; 1221 :          */
; 1222 :         --pool->ref.count;
; 1223 :         assert(pool->ref.count > 0);            /* else the pool is empty */
; 1224 :         size = pool->szidx;
; 1225 :         next = usedpools[size + size];

  001c6	41 8b 40 24	 mov	 eax, DWORD PTR [r8+36]
  001ca	41 ff 08	 dec	 DWORD PTR [r8]
  001cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:usedpools
  001d4	03 c0		 add	 eax, eax
  001d6	48 8b 14 c2	 mov	 rdx, QWORD PTR [rdx+rax*8]

; 1226 :         prev = next->prevpool;

  001da	48 8b 42 18	 mov	 rax, QWORD PTR [rdx+24]

; 1227 :         /* insert pool before next:   prev <-> pool <-> next */
; 1228 :         pool->nextpool = next;

  001de	49 89 50 10	 mov	 QWORD PTR [r8+16], rdx

; 1229 :         pool->prevpool = prev;

  001e2	49 89 40 18	 mov	 QWORD PTR [r8+24], rax

; 1230 :         next->prevpool = pool;

  001e6	4c 89 42 18	 mov	 QWORD PTR [rdx+24], r8

; 1231 :         prev->nextpool = pool;

  001ea	4c 89 40 10	 mov	 QWORD PTR [rax+16], r8

; 1241 : }

  001ee	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001f2	5b		 pop	 rbx
  001f3	c3		 ret	 0
$LN16@PyObject_F:

; 1232 :         UNLOCK();
; 1233 :         return;
; 1234 :     }
; 1235 : 
; 1236 : #ifdef WITH_VALGRIND
; 1237 : redirect:
; 1238 : #endif
; 1239 :     /* We didn't allocate this address. */
; 1240 :     free(p);

  001f4	48 8b cb	 mov	 rcx, rbx
  001f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN19@PyObject_F:

; 1241 : }

  001fd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00201	5b		 pop	 rbx
  00202	c3		 ret	 0
PyObject_Free ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@LPLEGNPM@PyObject_Realloc?$AA@	; `string'
PUBLIC	PyObject_Realloc
EXTRN	_PxMem_Realloc:PROC
EXTRN	_PyParallel_Guard:PROC
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_Realloc DD imagerel $LN18
	DD	imagerel $LN18+217
	DD	imagerel $unwind$PyObject_Realloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyObject_Realloc DD imagerel $LN18+217
	DD	imagerel $LN18+272
	DD	imagerel $chain$0$PyObject_Realloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyObject_Realloc DD imagerel $LN18+272
	DD	imagerel $LN18+332
	DD	imagerel $chain$2$PyObject_Realloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyObject_Realloc DD imagerel $LN18+332
	DD	imagerel $LN18+392
	DD	imagerel $chain$3$PyObject_Realloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyObject_Realloc DD 021H
	DD	imagerel $LN18
	DD	imagerel $LN18+217
	DD	imagerel $unwind$PyObject_Realloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyObject_Realloc DD 020021H
	DD	086400H
	DD	imagerel $LN18
	DD	imagerel $LN18+217
	DD	imagerel $unwind$PyObject_Realloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyObject_Realloc DD 020521H
	DD	086405H
	DD	imagerel $LN18
	DD	imagerel $LN18+217
	DD	imagerel $unwind$PyObject_Realloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_Realloc DD 040a01H
	DD	09340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0BB@LPLEGNPM@PyObject_Realloc?$AA@
CONST	SEGMENT
??_C@_0BB@LPLEGNPM@PyObject_Realloc?$AA@ DB 'PyObject_Realloc', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyObject_Realloc
_TEXT	SEGMENT
p$ = 64
nbytes$ = 72
PyObject_Realloc PROC					; COMDAT

; 1251 : {

$LN18:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 1252 :     void *bp;
; 1253 :     poolp pool;
; 1254 :     size_t size;
; 1255 : #ifndef Py_USING_MEMORY_DEBUGGER
; 1256 :     uint arenaindex_temp;
; 1257 : #endif
; 1258 :     if (p == NULL)

  00010	48 85 c9	 test	 rcx, rcx
  00013	75 12		 jne	 SHORT $LN12@PyObject_R

; 1259 :         return PyObject_Malloc(nbytes);

  00015	48 8b ca	 mov	 rcx, rdx

; 1329 : }

  00018	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0001d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00021	5f		 pop	 rdi
  00022	e9 00 00 00 00	 jmp	 PyObject_Malloc
$LN12@PyObject_R:

; 1260 : 
; 1261 :     PyPx_GUARD_MEM(p);

  00027	e8 00 00 00 00	 call	 _Py_PXCTX
  0002c	4c 8b cb	 mov	 r9, rbx
  0002f	41 b8 ed 04 00
	00		 mov	 r8d, 1261		; 000004edH
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@PMODNIDG@?4?4?2Objects?2obmalloc?4c?$AA@
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@LPLEGNPM@PyObject_Realloc?$AA@
  00043	85 c0		 test	 eax, eax
  00045	74 0a		 je	 SHORT $LN9@PyObject_R
  00047	c7 44 24 20 00
	04 00 00	 mov	 DWORD PTR [rsp+32], 1024 ; 00000400H
  0004f	eb 08		 jmp	 SHORT $LN17@PyObject_R
$LN9@PyObject_R:
  00051	c7 44 24 20 00
	02 00 00	 mov	 DWORD PTR [rsp+32], 512	; 00000200H
$LN17@PyObject_R:
  00059	e8 00 00 00 00	 call	 _PyParallel_Guard

; 1262 :     Px_RETURN(_PxMem_Realloc(p, nbytes))

  0005e	e8 00 00 00 00	 call	 _Py_PXCTX
  00063	85 c0		 test	 eax, eax
  00065	74 15		 je	 SHORT $LN7@PyObject_R
  00067	48 8b d7	 mov	 rdx, rdi
  0006a	48 8b cb	 mov	 rcx, rbx

; 1329 : }

  0006d	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00072	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00076	5f		 pop	 rdi
  00077	e9 00 00 00 00	 jmp	 _PxMem_Realloc
$LN7@PyObject_R:

; 1263 : 
; 1264 :     /*
; 1265 :      * Limit ourselves to PY_SSIZE_T_MAX bytes to prevent security holes.
; 1266 :      * Most python internals blindly use a signed Py_ssize_t to track
; 1267 :      * things without checking for overflows or negatives.
; 1268 :      * As size_t is unsigned, checking for nbytes < 0 is not required.
; 1269 :      */
; 1270 :     if (nbytes > PY_SSIZE_T_MAX)

  0007c	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00086	48 3b f8	 cmp	 rdi, rax
  00089	76 0d		 jbe	 SHORT $LN6@PyObject_R

; 1271 :         return NULL;

  0008b	33 c0		 xor	 eax, eax

; 1329 : }

  0008d	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00092	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00096	5f		 pop	 rdi
  00097	c3		 ret	 0
$LN6@PyObject_R:

; 1272 : 
; 1273 : #ifdef WITH_VALGRIND
; 1274 :     /* Treat running_on_valgrind == -1 the same as 0 */
; 1275 :     if (UNLIKELY(running_on_valgrind > 0))
; 1276 :         goto redirect;
; 1277 : #endif
; 1278 : 
; 1279 :     pool = POOL_ADDR(p);

  00098	48 8b d3	 mov	 rdx, rbx
  0009b	48 81 e2 00 f0
	ff ff		 and	 rdx, -4096		; fffffffffffff000H

; 1280 :     if (Py_ADDRESS_IN_RANGE(p, pool)) {

  000a2	8b 42 20	 mov	 eax, DWORD PTR [rdx+32]
  000a5	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR maxarenas
  000ab	0f 83 9b 00 00
	00		 jae	 $LN5@PyObject_R
  000b1	48 8d 0c 40	 lea	 rcx, QWORD PTR [rax+rax*2]
  000b5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR arenas
  000bc	48 03 c9	 add	 rcx, rcx
  000bf	4c 8b 04 c8	 mov	 r8, QWORD PTR [rax+rcx*8]
  000c3	48 8b c3	 mov	 rax, rbx
  000c6	49 2b c0	 sub	 rax, r8
  000c9	48 3d 00 00 04
	00		 cmp	 rax, 262144		; 00040000H
  000cf	73 7b		 jae	 SHORT $LN5@PyObject_R
  000d1	4d 85 c0	 test	 r8, r8
  000d4	74 76		 je	 SHORT $LN5@PyObject_R

; 1281 :         /* We're in charge of this block */
; 1282 :         size = INDEX2SIZE(pool->szidx);

  000d6	8b 42 24	 mov	 eax, DWORD PTR [rdx+36]
  000d9	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  000de	8d 04 c5 08 00
	00 00		 lea	 eax, DWORD PTR [rax*8+8]
  000e5	8b f0		 mov	 esi, eax

; 1283 :         if (nbytes <= size) {

  000e7	48 3b fe	 cmp	 rdi, rsi
  000ea	77 27		 ja	 SHORT $LN4@PyObject_R

; 1284 :             /* The block is staying the same or shrinking.  If
; 1285 :              * it's shrinking, there's a tradeoff:  it costs
; 1286 :              * cycles to copy the block to a smaller size class,
; 1287 :              * but it wastes memory not to copy it.  The
; 1288 :              * compromise here is to copy on shrink only if at
; 1289 :              * least 25% of size can be shaved off.
; 1290 :              */
; 1291 :             if (4 * nbytes > 3 * size) {

  000ec	48 8d 0c 40	 lea	 rcx, QWORD PTR [rax+rax*2]
  000f0	48 8d 04 bd 00
	00 00 00	 lea	 rax, QWORD PTR [rdi*4]
  000f8	48 3b c1	 cmp	 rax, rcx
  000fb	76 13		 jbe	 SHORT $LN3@PyObject_R

; 1292 :                 /* It's the same,
; 1293 :                  * or shrinking and new/old > 3/4.
; 1294 :                  */
; 1295 :                 return p;

  000fd	48 8b c3	 mov	 rax, rbx
  00100	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 1329 : }

  00105	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0010a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0010e	5f		 pop	 rdi
  0010f	c3		 ret	 0
$LN3@PyObject_R:

; 1296 :             }
; 1297 :             size = nbytes;

  00110	48 8b f7	 mov	 rsi, rdi
$LN4@PyObject_R:

; 1298 :         }
; 1299 :         bp = PyObject_Malloc(nbytes);

  00113	48 8b cf	 mov	 rcx, rdi
  00116	e8 00 00 00 00	 call	 PyObject_Malloc
  0011b	48 8b f8	 mov	 rdi, rax

; 1300 :         if (bp != NULL) {

  0011e	48 85 c0	 test	 rax, rax
  00121	74 16		 je	 SHORT $LN2@PyObject_R

; 1301 :             memcpy(bp, p, size);

  00123	4c 8b c6	 mov	 r8, rsi
  00126	48 8b d3	 mov	 rdx, rbx
  00129	48 8b c8	 mov	 rcx, rax
  0012c	e8 00 00 00 00	 call	 memcpy

; 1302 :             PyObject_Free(p);

  00131	48 8b cb	 mov	 rcx, rbx
  00134	e8 00 00 00 00	 call	 PyObject_Free
$LN2@PyObject_R:

; 1303 :         }
; 1304 :         return bp;

  00139	48 8b c7	 mov	 rax, rdi
  0013c	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 1329 : }

  00141	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00146	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0014a	5f		 pop	 rdi
  0014b	c3		 ret	 0
$LN5@PyObject_R:

; 1305 :     }
; 1306 : #ifdef WITH_VALGRIND
; 1307 :  redirect:
; 1308 : #endif
; 1309 :     /* We're not managing this block.  If nbytes <=
; 1310 :      * SMALL_REQUEST_THRESHOLD, it's tempting to try to take over this
; 1311 :      * block.  However, if we do, we need to copy the valid data from
; 1312 :      * the C-managed block to one of our blocks, and there's no portable
; 1313 :      * way to know how much of the memory space starting at p is valid.
; 1314 :      * As bug 1185883 pointed out the hard way, it's possible that the
; 1315 :      * C-managed block is "at the end" of allocated VM space, so that
; 1316 :      * a memory fault can occur if we try to copy nbytes bytes starting
; 1317 :      * at p.  Instead we punt:  let C continue to manage this block.
; 1318 :      */
; 1319 :     if (nbytes)
; 1320 :         return realloc(p, nbytes);

  0014c	48 8b cb	 mov	 rcx, rbx
  0014f	48 85 ff	 test	 rdi, rdi
  00152	74 14		 je	 SHORT $LN1@PyObject_R
  00154	48 8b d7	 mov	 rdx, rdi

; 1329 : }

  00157	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0015c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00160	5f		 pop	 rdi
  00161	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_realloc
$LN1@PyObject_R:

; 1321 :     /* C doesn't define the result of realloc(p, 0) (it may or may not
; 1322 :      * return NULL then), but Python's docs promise that nbytes==0 never
; 1323 :      * returns NULL.  We don't pass 0 to realloc(), to avoid that endcase
; 1324 :      * to begin with.  Even then, we can't be sure that realloc() won't
; 1325 :      * return NULL.
; 1326 :      */
; 1327 :     bp = realloc(p, 1);

  00168	ba 01 00 00 00	 mov	 edx, 1
  0016d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc

; 1328 :     return bp ? bp : p;

  00173	48 85 c0	 test	 rax, rax
  00176	48 0f 45 d8	 cmovne	 rbx, rax
  0017a	48 8b c3	 mov	 rax, rbx

; 1329 : }

  0017d	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00182	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00186	5f		 pop	 rdi
  00187	c3		 ret	 0
PyObject_Realloc ENDP
_TEXT	ENDS
EXTRN	__imp_fputc:PROC
EXTRN	__imp_fputs:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$printone DD imagerel printone
	DD	imagerel printone+276
	DD	imagerel $unwind$printone
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printone DD 091701H
	DD	0166417H
	DD	0155417H
	DD	0143417H
	DD	0120117H
	DD	07010H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT printone
_TEXT	SEGMENT
buf$ = 32
out$ = 160
msg$ = 168
value$ = 176
printone PROC						; COMDAT

; 1808 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00017	48 8b fa	 mov	 rdi, rdx
  0001a	48 8b d9	 mov	 rbx, rcx

; 1812 : 
; 1813 :     fputs(msg, out);

  0001d	48 8b d1	 mov	 rdx, rcx
  00020	48 8b cf	 mov	 rcx, rdi
  00023	49 8b f0	 mov	 rsi, r8
  00026	49 8b e8	 mov	 rbp, r8
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputs

; 1814 :     for (i = (int)strlen(msg); i < 35; ++i)

  0002f	48 83 c9 ff	 or	 rcx, -1
  00033	33 c0		 xor	 eax, eax
  00035	f2 ae		 repne scasb
  00037	48 f7 d1	 not	 rcx
  0003a	48 ff c9	 dec	 rcx
  0003d	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00040	7d 21		 jge	 SHORT $LN8@printone

; 1809 :     int i, k;
; 1810 :     char buf[100];
; 1811 :     size_t origvalue = value;

  00042	bf 23 00 00 00	 mov	 edi, 35			; 00000023H
  00047	2b f9		 sub	 edi, ecx
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL10@printone:

; 1815 :         fputc(' ', out);

  00050	48 8b d3	 mov	 rdx, rbx
  00053	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc
  0005e	48 ff cf	 dec	 rdi
  00061	75 ed		 jne	 SHORT $LL10@printone
$LN8@printone:

; 1816 :     fputc('=', out);

  00063	48 8b d3	 mov	 rdx, rbx
  00066	b9 3d 00 00 00	 mov	 ecx, 61			; 0000003dH
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc

; 1817 : 
; 1818 :     /* Write the value with commas. */
; 1819 :     i = 22;
; 1820 :     buf[i--] = '\0';
; 1821 :     buf[i--] = '\n';
; 1822 :     k = 3;

  00071	bf 03 00 00 00	 mov	 edi, 3
  00076	66 c7 44 24 35
	0a 00		 mov	 WORD PTR buf$[rsp+21], 10
  0007d	8d 4f 11	 lea	 ecx, QWORD PTR [rdi+17]
  00080	49 b8 cd cc cc
	cc cc cc cc cc	 mov	 r8, -3689348814741910323 ; cccccccccccccccdH
  0008a	66 0f 1f 44 00
	00		 npad	 6
$LL7@printone:

; 1823 :     do {
; 1824 :         size_t nextvalue = value / 10;

  00090	49 8b c0	 mov	 rax, r8

; 1825 :         PY_UINT32_T digit = (PY_UINT32_T)(value - nextvalue * 10);
; 1826 :         value = nextvalue;
; 1827 :         buf[i--] = (char)(digit + '0');

  00093	48 ff c9	 dec	 rcx
  00096	48 f7 e6	 mul	 rsi
  00099	48 c1 ea 03	 shr	 rdx, 3
  0009d	8d 04 92	 lea	 eax, DWORD PTR [rdx+rdx*4]
  000a0	03 c0		 add	 eax, eax
  000a2	2b f0		 sub	 esi, eax
  000a4	8b c6		 mov	 eax, esi
  000a6	48 8b f2	 mov	 rsi, rdx
  000a9	04 30		 add	 al, 48			; 00000030H

; 1828 :         --k;

  000ab	ff cf		 dec	 edi
  000ad	88 44 0c 21	 mov	 BYTE PTR buf$[rsp+rcx+1], al

; 1829 :         if (k == 0 && value && i >= 0) {

  000b1	75 17		 jne	 SHORT $LN6@printone
  000b3	48 85 d2	 test	 rdx, rdx
  000b6	74 1e		 je	 SHORT $LN3@printone
  000b8	48 85 c9	 test	 rcx, rcx
  000bb	78 0d		 js	 SHORT $LN6@printone

; 1830 :             k = 3;
; 1831 :             buf[i--] = ',';

  000bd	c6 44 0c 20 2c	 mov	 BYTE PTR buf$[rsp+rcx], 44 ; 0000002cH
  000c2	48 ff c9	 dec	 rcx
  000c5	bf 03 00 00 00	 mov	 edi, 3
$LN6@printone:

; 1832 :         }
; 1833 :     } while (value && i >= 0);

  000ca	48 85 d2	 test	 rdx, rdx
  000cd	74 07		 je	 SHORT $LN3@printone
  000cf	48 85 c9	 test	 rcx, rcx
  000d2	79 bc		 jns	 SHORT $LL7@printone

; 1834 : 
; 1835 :     while (i >= 0)

  000d4	eb 14		 jmp	 SHORT $LN1@printone
$LN3@printone:
  000d6	48 85 c9	 test	 rcx, rcx
  000d9	78 0f		 js	 SHORT $LN1@printone
  000db	0f 1f 44 00 00	 npad	 5
$LL2@printone:

; 1836 :         buf[i--] = ' ';

  000e0	c6 44 0c 20 20	 mov	 BYTE PTR buf$[rsp+rcx], 32 ; 00000020H
  000e5	48 ff c9	 dec	 rcx
  000e8	79 f6		 jns	 SHORT $LL2@printone
$LN1@printone:

; 1837 :     fputs(buf, out);

  000ea	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  000ef	48 8b d3	 mov	 rdx, rbx
  000f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputs

; 1838 : 
; 1839 :     return origvalue;
; 1840 : }

  000f8	4c 8d 9c 24 90
	00 00 00	 lea	 r11, QWORD PTR [rsp+144]
  00100	48 8b c5	 mov	 rax, rbp
  00103	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00107	49 8b 6b 18	 mov	 rbp, QWORD PTR [r11+24]
  0010b	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  0010f	49 8b e3	 mov	 rsp, r11
  00112	5f		 pop	 rdi
  00113	c3		 ret	 0
printone ENDP
_TEXT	ENDS
PUBLIC	??_C@_05LLFBPGHK@?$CF48s?5?$AA@			; `string'
PUBLIC	??_C@_0BI@LPNJKHAA@?$CFd?5?$CFss?5?$CK?5?$CFzd?5bytes?5each?$AA@ ; `string'
PUBLIC	??_C@_0BH@PHOKLIIM@_PyDebugAllocatorStats?$AA@	; `string'
PUBLIC	_PyDebugAllocatorStats
EXTRN	PyOS_snprintf:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyDebugAllocatorStats DD imagerel $LN4
	DD	imagerel $LN4+185
	DD	imagerel $unwind$_PyDebugAllocatorStats
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyDebugAllocatorStats DD 091701H
	DD	02a6417H
	DD	0295417H
	DD	0283417H
	DD	0260117H
	DD	07010H
xdata	ENDS
;	COMDAT ??_C@_05LLFBPGHK@?$CF48s?5?$AA@
CONST	SEGMENT
??_C@_05LLFBPGHK@?$CF48s?5?$AA@ DB '%48s ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LPNJKHAA@?$CFd?5?$CFss?5?$CK?5?$CFzd?5bytes?5each?$AA@
CONST	SEGMENT
??_C@_0BI@LPNJKHAA@?$CFd?5?$CFss?5?$CK?5?$CFzd?5bytes?5each?$AA@ DB '%d %'
	DB	'ss * %zd bytes each', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PHOKLIIM@_PyDebugAllocatorStats?$AA@
CONST	SEGMENT
??_C@_0BH@PHOKLIIM@_PyDebugAllocatorStats?$AA@ DB '_PyDebugAllocatorStats'
	DB	00H						; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyDebugAllocatorStats
_TEXT	SEGMENT
buf1$ = 48
buf2$ = 176
out$ = 320
block_name$ = 328
num_blocks$ = 336
sizeof_block$ = 344
_PyDebugAllocatorStats PROC				; COMDAT

; 1845 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 81 ec 30 01
	00 00		 sub	 rsp, 304		; 00000130H
  00017	49 8b d9	 mov	 rbx, r9
  0001a	49 63 f8	 movsxd	 rdi, r8d
  0001d	48 8b f2	 mov	 rsi, rdx
  00020	48 8b e9	 mov	 rbp, rcx

; 1846 :     char buf1[128];
; 1847 :     char buf2[128];
; 1848 :     Py_GUARD

  00023	e8 00 00 00 00	 call	 _Py_PXCTX
  00028	85 c0		 test	 eax, eax
  0002a	74 1c		 je	 SHORT $LN1@PyDebugAll
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@PMODNIDG@?4?4?2Objects?2obmalloc?4c?$AA@
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@PHOKLIIM@_PyDebugAllocatorStats?$AA@
  0003a	45 33 c9	 xor	 r9d, r9d
  0003d	41 b8 38 07 00
	00		 mov	 r8d, 1848		; 00000738H
  00043	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN1@PyDebugAll:

; 1849 :     PyOS_snprintf(buf1, sizeof(buf1),
; 1850 :                   "%d %ss * %zd bytes each",
; 1851 :                   num_blocks, block_name, sizeof_block);

  00048	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BI@LPNJKHAA@?$CFd?5?$CFss?5?$CK?5?$CFzd?5bytes?5each?$AA@
  0004f	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf1$[rsp]
  00054	44 8b cf	 mov	 r9d, edi
  00057	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0005c	48 89 5c 24 28	 mov	 QWORD PTR [rsp+40], rbx
  00061	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00066	e8 00 00 00 00	 call	 PyOS_snprintf

; 1852 :     PyOS_snprintf(buf2, sizeof(buf2),
; 1853 :                   "%48s ", buf1);

  0006b	4c 8d 4c 24 30	 lea	 r9, QWORD PTR buf1$[rsp]
  00070	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05LLFBPGHK@?$CF48s?5?$AA@
  00077	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf2$[rsp]
  0007f	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00084	e8 00 00 00 00	 call	 PyOS_snprintf

; 1854 :     (void)printone(out, buf2, num_blocks * sizeof_block);

  00089	4c 8b c7	 mov	 r8, rdi
  0008c	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR buf2$[rsp]
  00094	4c 0f af c3	 imul	 r8, rbx
  00098	48 8b cd	 mov	 rcx, rbp
  0009b	e8 00 00 00 00	 call	 printone

; 1855 : }

  000a0	4c 8d 9c 24 30
	01 00 00	 lea	 r11, QWORD PTR [rsp+304]
  000a8	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  000ac	49 8b 6b 18	 mov	 rbp, QWORD PTR [r11+24]
  000b0	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  000b4	49 8b e3	 mov	 rsp, r11
  000b7	5f		 pop	 rdi
  000b8	c3		 ret	 0
_PyDebugAllocatorStats ENDP
_TEXT	ENDS
PUBLIC	??_C@_05KGEAEGFG@Total?$AA@			; `string'
PUBLIC	??_C@_0CA@GBCGKCEO@?$CD?5bytes?5lost?5to?5arena?5alignment?$AA@ ; `string'
PUBLIC	??_C@_0BN@DPIKIPML@?$CD?5bytes?5lost?5to?5quantization?$AA@ ; `string'
PUBLIC	??_C@_0BN@OBJGCACO@?$CD?5bytes?5lost?5to?5pool?5headers?$AA@ ; `string'
PUBLIC	??_C@_0BL@FMCCONMC@?$CFu?5unused?5pools?5?$CK?5?$CFd?5bytes?$AA@ ; `string'
PUBLIC	??_C@_0BM@KKPDFEBK@?$CD?5bytes?5in?5available?5blocks?$AA@ ; `string'
PUBLIC	??_C@_0BM@DGPGANCG@?$CD?5bytes?5in?5allocated?5blocks?$AA@ ; `string'
PUBLIC	??_C@_0BM@EMIIMIHN@?$CFIu?5arenas?5?$CK?5?$CFd?5bytes?1arena?$AA@ ; `string'
PUBLIC	??_C@_0BL@CDPEAAIO@?$CD?5arenas?5allocated?5current?$AA@ ; `string'
PUBLIC	??_C@_0BI@NDJBDOMD@?$CD?5arenas?5highwater?5mark?$AA@ ; `string'
PUBLIC	??_C@_0BD@EGEFNLBB@?$CD?5arenas?5reclaimed?$AA@	; `string'
PUBLIC	??_C@_0BJ@BBJOHCGI@?$CD?5arenas?5allocated?5total?$AA@ ; `string'
PUBLIC	??_C@_0BL@KKKLDLHO@?$CF5u?5?$CF6u?5?$CF11Iu?5?$CF15Iu?5?$CF13Iu?6?$AA@ ; `string'
PUBLIC	??_C@_0GP@CMHKANCA@class?5?5?5size?5?5?5num?5pools?5?5?5block@ ; `string'
PUBLIC	??_C@_0DB@PNOPCKMC@Small?5block?5threshold?5?$DN?5?$CFd?0?5in?5?$CF@ ; `string'
PUBLIC	??_C@_0BL@OPOOMDLH@_PyObject_DebugMallocStats?$AA@ ; `string'
PUBLIC	_PyObject_DebugMallocStats
EXTRN	__imp_fprintf:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_DebugMallocStats DD imagerel $LN32
	DD	imagerel $LN32+1148
	DD	imagerel $unwind$_PyObject_DebugMallocStats
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_DebugMallocStats DD 0a1801H
	DD	0dd0118H
	DD	0e00ff011H
	DD	0c00bd00dH
	DD	060087009H
	DD	030065007H
xdata	ENDS
;	COMDAT ??_C@_05KGEAEGFG@Total?$AA@
CONST	SEGMENT
??_C@_05KGEAEGFG@Total?$AA@ DB 'Total', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@GBCGKCEO@?$CD?5bytes?5lost?5to?5arena?5alignment?$AA@
CONST	SEGMENT
??_C@_0CA@GBCGKCEO@?$CD?5bytes?5lost?5to?5arena?5alignment?$AA@ DB '# byt'
	DB	'es lost to arena alignment', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DPIKIPML@?$CD?5bytes?5lost?5to?5quantization?$AA@
CONST	SEGMENT
??_C@_0BN@DPIKIPML@?$CD?5bytes?5lost?5to?5quantization?$AA@ DB '# bytes l'
	DB	'ost to quantization', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OBJGCACO@?$CD?5bytes?5lost?5to?5pool?5headers?$AA@
CONST	SEGMENT
??_C@_0BN@OBJGCACO@?$CD?5bytes?5lost?5to?5pool?5headers?$AA@ DB '# bytes '
	DB	'lost to pool headers', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FMCCONMC@?$CFu?5unused?5pools?5?$CK?5?$CFd?5bytes?$AA@
CONST	SEGMENT
??_C@_0BL@FMCCONMC@?$CFu?5unused?5pools?5?$CK?5?$CFd?5bytes?$AA@ DB '%u u'
	DB	'nused pools * %d bytes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KKPDFEBK@?$CD?5bytes?5in?5available?5blocks?$AA@
CONST	SEGMENT
??_C@_0BM@KKPDFEBK@?$CD?5bytes?5in?5available?5blocks?$AA@ DB '# bytes in'
	DB	' available blocks', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DGPGANCG@?$CD?5bytes?5in?5allocated?5blocks?$AA@
CONST	SEGMENT
??_C@_0BM@DGPGANCG@?$CD?5bytes?5in?5allocated?5blocks?$AA@ DB '# bytes in'
	DB	' allocated blocks', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@EMIIMIHN@?$CFIu?5arenas?5?$CK?5?$CFd?5bytes?1arena?$AA@
CONST	SEGMENT
??_C@_0BM@EMIIMIHN@?$CFIu?5arenas?5?$CK?5?$CFd?5bytes?1arena?$AA@ DB '%Iu'
	DB	' arenas * %d bytes/arena', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CDPEAAIO@?$CD?5arenas?5allocated?5current?$AA@
CONST	SEGMENT
??_C@_0BL@CDPEAAIO@?$CD?5arenas?5allocated?5current?$AA@ DB '# arenas all'
	DB	'ocated current', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NDJBDOMD@?$CD?5arenas?5highwater?5mark?$AA@
CONST	SEGMENT
??_C@_0BI@NDJBDOMD@?$CD?5arenas?5highwater?5mark?$AA@ DB '# arenas highwa'
	DB	'ter mark', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EGEFNLBB@?$CD?5arenas?5reclaimed?$AA@
CONST	SEGMENT
??_C@_0BD@EGEFNLBB@?$CD?5arenas?5reclaimed?$AA@ DB '# arenas reclaimed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BBJOHCGI@?$CD?5arenas?5allocated?5total?$AA@
CONST	SEGMENT
??_C@_0BJ@BBJOHCGI@?$CD?5arenas?5allocated?5total?$AA@ DB '# arenas alloc'
	DB	'ated total', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KKKLDLHO@?$CF5u?5?$CF6u?5?$CF11Iu?5?$CF15Iu?5?$CF13Iu?6?$AA@
CONST	SEGMENT
??_C@_0BL@KKKLDLHO@?$CF5u?5?$CF6u?5?$CF11Iu?5?$CF15Iu?5?$CF13Iu?6?$AA@ DB '%'
	DB	'5u %6u %11Iu %15Iu %13Iu', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GP@CMHKANCA@class?5?5?5size?5?5?5num?5pools?5?5?5block@
CONST	SEGMENT
??_C@_0GP@CMHKANCA@class?5?5?5size?5?5?5num?5pools?5?5?5block@ DB 'class '
	DB	'  size   num pools   blocks in use  avail blocks', 0aH, '----'
	DB	'-   ----   ---------   -------------  ------------', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@PNOPCKMC@Small?5block?5threshold?5?$DN?5?$CFd?0?5in?5?$CF@
CONST	SEGMENT
??_C@_0DB@PNOPCKMC@Small?5block?5threshold?5?$DN?5?$CFd?0?5in?5?$CF@ DB 'S'
	DB	'mall block threshold = %d, in %u size classes.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OPOOMDLH@_PyObject_DebugMallocStats?$AA@
CONST	SEGMENT
??_C@_0BL@OPOOMDLH@_PyObject_DebugMallocStats?$AA@ DB '_PyObject_DebugMal'
	DB	'locStats', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyObject_DebugMallocStats
_TEXT	SEGMENT
quantization$1$ = 64
narenas$1$ = 72
arena_alignment$1$ = 80
buf$ = 96
numblocks$ = 224
numpools$ = 736
numfreeblocks$ = 1248
out$ = 1840
numfreepools$1$ = 1848
available_bytes$1$ = 1856
pool_header_bytes$1$ = 1864
_PyObject_DebugMallocStats PROC				; COMDAT

; 1865 : {

$LN32:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	41 57		 push	 r15
  00011	48 81 ec e8 06
	00 00		 sub	 rsp, 1768		; 000006e8H

; 1866 :     uint i;
; 1867 :     const uint numclasses = SMALL_REQUEST_THRESHOLD >> ALIGNMENT_SHIFT;
; 1868 :     /* # of pools, allocated blocks, and free blocks per class index */
; 1869 :     size_t numpools[SMALL_REQUEST_THRESHOLD >> ALIGNMENT_SHIFT];
; 1870 :     size_t numblocks[SMALL_REQUEST_THRESHOLD >> ALIGNMENT_SHIFT];
; 1871 :     size_t numfreeblocks[SMALL_REQUEST_THRESHOLD >> ALIGNMENT_SHIFT];
; 1872 :     /* total # of allocated bytes in used and full pools */
; 1873 :     size_t allocated_bytes = 0;

  00018	33 db		 xor	 ebx, ebx
  0001a	4c 8b f9	 mov	 r15, rcx

; 1874 :     /* total # of available bytes in used pools */
; 1875 :     size_t available_bytes = 0;

  0001d	48 89 9c 24 40
	07 00 00	 mov	 QWORD PTR available_bytes$1$[rsp], rbx

; 1876 :     /* # of free pools + pools not yet carved out of current arena */
; 1877 :     uint numfreepools = 0;

  00025	44 8b eb	 mov	 r13d, ebx
  00028	89 9c 24 38 07
	00 00		 mov	 DWORD PTR numfreepools$1$[rsp], ebx

; 1878 :     /* # of bytes for arena alignment padding */
; 1879 :     size_t arena_alignment = 0;

  0002f	44 8b f3	 mov	 r14d, ebx
  00032	48 89 5c 24 50	 mov	 QWORD PTR arena_alignment$1$[rsp], rbx

; 1880 :     /* # of bytes in used and full pools used for pool_headers */
; 1881 :     size_t pool_header_bytes = 0;

  00037	48 89 9c 24 48
	07 00 00	 mov	 QWORD PTR pool_header_bytes$1$[rsp], rbx

; 1882 :     /* # of bytes in used and full pools wasted due to quantization,
; 1883 :      * i.e. the necessarily leftover space at the ends of used and
; 1884 :      * full pools.
; 1885 :      */
; 1886 :     size_t quantization = 0;

  0003f	48 89 5c 24 40	 mov	 QWORD PTR quantization$1$[rsp], rbx

; 1887 :     /* # of arenas actually allocated. */
; 1888 :     size_t narenas = 0;

  00044	8b eb		 mov	 ebp, ebx
  00046	48 89 5c 24 48	 mov	 QWORD PTR narenas$1$[rsp], rbx

; 1889 :     /* running total -- should equal narenas * ARENA_SIZE */
; 1890 :     size_t total;
; 1891 :     char buf[128];
; 1892 : 
; 1893 :     Py_GUARD

  0004b	e8 00 00 00 00	 call	 _Py_PXCTX
  00050	85 c0		 test	 eax, eax
  00052	74 1c		 je	 SHORT $LN17@PyObject_D
  00054	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@PMODNIDG@?4?4?2Objects?2obmalloc?4c?$AA@
  0005b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@OPOOMDLH@_PyObject_DebugMallocStats?$AA@
  00062	45 33 c9	 xor	 r9d, r9d
  00065	41 b8 65 07 00
	00		 mov	 r8d, 1893		; 00000765H
  0006b	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN17@PyObject_D:

; 1894 : 
; 1895 :     fprintf(out, "Small block threshold = %d, in %u size classes.\n",
; 1896 :             SMALL_REQUEST_THRESHOLD, numclasses);

  00070	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@PNOPCKMC@Small?5block?5threshold?5?$DN?5?$CFd?0?5in?5?$CF@
  00077	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  0007d	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  00083	49 8b cf	 mov	 rcx, r15
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 1897 : 
; 1898 :     for (i = 0; i < numclasses; ++i)
; 1899 :         numpools[i] = numblocks[i] = numfreeblocks[i] = 0;

  0008c	41 bc 08 00 00
	00		 mov	 r12d, 8
  00092	48 8d 84 24 e0
	02 00 00	 lea	 rax, QWORD PTR numpools$[rsp]
  0009a	41 8b cc	 mov	 ecx, r12d
  0009d	0f 1f 00	 npad	 3
$LL30@PyObject_D:
  000a0	48 89 18	 mov	 QWORD PTR [rax], rbx
  000a3	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  000a7	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  000ab	48 83 c0 40	 add	 rax, 64			; 00000040H
  000af	48 ff c9	 dec	 rcx
  000b2	48 89 58 d8	 mov	 QWORD PTR [rax-40], rbx
  000b6	48 89 58 e0	 mov	 QWORD PTR [rax-32], rbx
  000ba	48 89 58 e8	 mov	 QWORD PTR [rax-24], rbx
  000be	48 89 58 f0	 mov	 QWORD PTR [rax-16], rbx
  000c2	48 89 58 f8	 mov	 QWORD PTR [rax-8], rbx
  000c6	75 d8		 jne	 SHORT $LL30@PyObject_D
  000c8	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR numblocks$[rsp]
  000d0	49 8b cc	 mov	 rcx, r12
  000d3	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL29@PyObject_D:
  000e0	48 89 18	 mov	 QWORD PTR [rax], rbx
  000e3	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  000e7	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  000eb	48 83 c0 40	 add	 rax, 64			; 00000040H
  000ef	48 ff c9	 dec	 rcx
  000f2	48 89 58 d8	 mov	 QWORD PTR [rax-40], rbx
  000f6	48 89 58 e0	 mov	 QWORD PTR [rax-32], rbx
  000fa	48 89 58 e8	 mov	 QWORD PTR [rax-24], rbx
  000fe	48 89 58 f0	 mov	 QWORD PTR [rax-16], rbx
  00102	48 89 58 f8	 mov	 QWORD PTR [rax-8], rbx
  00106	75 d8		 jne	 SHORT $LL29@PyObject_D
  00108	48 8d 84 24 e0
	04 00 00	 lea	 rax, QWORD PTR numfreeblocks$[rsp]
  00110	49 8b cc	 mov	 rcx, r12
  00113	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL28@PyObject_D:
  00120	48 89 18	 mov	 QWORD PTR [rax], rbx
  00123	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00127	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  0012b	48 83 c0 40	 add	 rax, 64			; 00000040H
  0012f	48 ff c9	 dec	 rcx
  00132	48 89 58 d8	 mov	 QWORD PTR [rax-40], rbx
  00136	48 89 58 e0	 mov	 QWORD PTR [rax-32], rbx
  0013a	48 89 58 e8	 mov	 QWORD PTR [rax-24], rbx
  0013e	48 89 58 f0	 mov	 QWORD PTR [rax-16], rbx
  00142	48 89 58 f8	 mov	 QWORD PTR [rax-8], rbx
  00146	75 d8		 jne	 SHORT $LL28@PyObject_D

; 1900 : 
; 1901 :     /* Because full pools aren't linked to from anything, it's easiest
; 1902 :      * to march over all the arenas.  If we're lucky, most of the memory
; 1903 :      * will be living in full pools -- would be a shame to miss them.
; 1904 :      */
; 1905 :     for (i = 0; i < maxarenas; ++i) {

  00148	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR maxarenas
  0014e	85 c0		 test	 eax, eax
  00150	0f 84 af 00 00
	00		 je	 $LN11@PyObject_D
  00156	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR arenas
  0015d	8b f0		 mov	 esi, eax
  0015f	90		 npad	 1
$LL13@PyObject_D:

; 1906 :         uint j;
; 1907 :         uptr base = arenas[i].address;

  00160	4c 8b 0f	 mov	 r9, QWORD PTR [rdi]

; 1908 : 
; 1909 :         /* Skip arenas which are not allocated. */
; 1910 :         if (arenas[i].address == (uptr)NULL)

  00163	4d 85 c9	 test	 r9, r9
  00166	74 7e		 je	 SHORT $LN12@PyObject_D

; 1911 :             continue;
; 1912 :         narenas += 1;
; 1913 : 
; 1914 :         numfreepools += arenas[i].nfreepools;

  00168	44 03 6f 10	 add	 r13d, DWORD PTR [rdi+16]
  0016c	48 ff c5	 inc	 rbp

; 1915 : 
; 1916 :         /* round up to pool alignment */
; 1917 :         if (base & (uptr)POOL_SIZE_MASK) {

  0016f	49 f7 c1 ff 0f
	00 00		 test	 r9, 4095		; 00000fffH
  00176	74 15		 je	 SHORT $LN9@PyObject_D

; 1918 :             arena_alignment += POOL_SIZE;
; 1919 :             base &= ~(uptr)POOL_SIZE_MASK;

  00178	49 81 e1 00 f0
	ff ff		 and	 r9, -4096		; fffffffffffff000H
  0017f	49 81 c6 00 10
	00 00		 add	 r14, 4096		; 00001000H

; 1920 :             base += POOL_SIZE;

  00186	49 81 c1 00 10
	00 00		 add	 r9, 4096		; 00001000H
$LN9@PyObject_D:

; 1921 :         }
; 1922 : 
; 1923 :         /* visit every pool in the arena */
; 1924 :         assert(base <= (uptr) arenas[i].pool_address);
; 1925 :         for (j = 0;
; 1926 :                     base < (uptr) arenas[i].pool_address;
; 1927 :                     ++j, base += POOL_SIZE) {

  0018d	4c 8b 5f 08	 mov	 r11, QWORD PTR [rdi+8]
  00191	4d 3b cb	 cmp	 r9, r11
  00194	73 50		 jae	 SHORT $LN12@PyObject_D
  00196	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL8@PyObject_D:

; 1928 :             poolp p = (poolp)base;
; 1929 :             const uint sz = p->szidx;
; 1930 :             uint freeblocks;
; 1931 : 
; 1932 :             if (p->ref.count == 0) {

  001a0	45 8b 11	 mov	 r10d, DWORD PTR [r9]
  001a3	41 8b 49 24	 mov	 ecx, DWORD PTR [r9+36]
  001a7	45 85 d2	 test	 r10d, r10d
  001aa	74 2e		 je	 SHORT $LN7@PyObject_D

; 1933 :                 /* currently unused */
; 1934 :                 assert(pool_is_in_list(p, arenas[i].freepools));
; 1935 :                 continue;
; 1936 :             }
; 1937 :             ++numpools[sz];

  001ac	48 ff 84 cc e0
	02 00 00	 inc	 QWORD PTR numpools$[rsp+rcx*8]

; 1938 :             numblocks[sz] += p->ref.count;

  001b4	4c 01 94 cc e0
	00 00 00	 add	 QWORD PTR numblocks$[rsp+rcx*8], r10
  001bc	44 8b c1	 mov	 r8d, ecx

; 1939 :             freeblocks = NUMBLOCKS(sz) - p->ref.count;

  001bf	33 d2		 xor	 edx, edx
  001c1	b8 d0 0f 00 00	 mov	 eax, 4048		; 00000fd0H
  001c6	8d 0c cd 08 00
	00 00		 lea	 ecx, DWORD PTR [rcx*8+8]
  001cd	f7 f1		 div	 ecx
  001cf	41 2b c2	 sub	 eax, r10d

; 1940 :             numfreeblocks[sz] += freeblocks;

  001d2	4a 01 84 c4 e0
	04 00 00	 add	 QWORD PTR numfreeblocks$[rsp+r8*8], rax
$LN7@PyObject_D:

; 1921 :         }
; 1922 : 
; 1923 :         /* visit every pool in the arena */
; 1924 :         assert(base <= (uptr) arenas[i].pool_address);
; 1925 :         for (j = 0;
; 1926 :                     base < (uptr) arenas[i].pool_address;
; 1927 :                     ++j, base += POOL_SIZE) {

  001da	49 81 c1 00 10
	00 00		 add	 r9, 4096		; 00001000H
  001e1	4d 3b cb	 cmp	 r9, r11
  001e4	72 ba		 jb	 SHORT $LL8@PyObject_D
$LN12@PyObject_D:

; 1900 : 
; 1901 :     /* Because full pools aren't linked to from anything, it's easiest
; 1902 :      * to march over all the arenas.  If we're lucky, most of the memory
; 1903 :      * will be living in full pools -- would be a shame to miss them.
; 1904 :      */
; 1905 :     for (i = 0; i < maxarenas; ++i) {

  001e6	48 83 c7 30	 add	 rdi, 48			; 00000030H
  001ea	48 ff ce	 dec	 rsi
  001ed	0f 85 6d ff ff
	ff		 jne	 $LL13@PyObject_D
  001f3	4c 89 74 24 50	 mov	 QWORD PTR arena_alignment$1$[rsp], r14
  001f8	44 89 ac 24 38
	07 00 00	 mov	 DWORD PTR numfreepools$1$[rsp], r13d
  00200	48 89 6c 24 48	 mov	 QWORD PTR narenas$1$[rsp], rbp
$LN11@PyObject_D:

; 1941 : #ifdef Py_DEBUG
; 1942 :             if (freeblocks > 0)
; 1943 :                 assert(pool_is_in_list(p, usedpools[sz + sz]));
; 1944 : #endif
; 1945 :         }
; 1946 :     }
; 1947 :     assert(narenas == narenas_currently_allocated);
; 1948 : 
; 1949 :     fputc('\n', out);

  00205	49 8b d7	 mov	 rdx, r15
  00208	b9 0a 00 00 00	 mov	 ecx, 10
  0020d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc

; 1950 :     fputs("class   size   num pools   blocks in use  avail blocks\n"
; 1951 :           "-----   ----   ---------   -------------  ------------\n",
; 1952 :           out);

  00213	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0GP@CMHKANCA@class?5?5?5size?5?5?5num?5pools?5?5?5block@
  0021a	49 8b d7	 mov	 rdx, r15
  0021d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputs

; 1953 : 
; 1954 :     for (i = 0; i < numclasses; ++i) {

  00223	44 8b eb	 mov	 r13d, ebx
  00226	49 8b ec	 mov	 rbp, r12
  00229	48 8b fb	 mov	 rdi, rbx
  0022c	0f 1f 40 00	 npad	 4
$LL4@PyObject_D:

; 1955 :         size_t p = numpools[i];

  00230	48 8b b4 3c e0
	02 00 00	 mov	 rsi, QWORD PTR numpools$[rsp+rdi]

; 1956 :         size_t b = numblocks[i];

  00238	4c 8b b4 3c e0
	00 00 00	 mov	 r14, QWORD PTR numblocks$[rsp+rdi]

; 1957 :         size_t f = numfreeblocks[i];

  00240	4c 8b bc 3c e0
	04 00 00	 mov	 r15, QWORD PTR numfreeblocks$[rsp+rdi]

; 1958 :         uint size = INDEX2SIZE(i);
; 1959 :         if (p == 0) {

  00248	48 85 f6	 test	 rsi, rsi
  0024b	74 7e		 je	 SHORT $LN31@PyObject_D

; 1960 :             assert(b == 0 && f == 0);
; 1961 :             continue;
; 1962 :         }
; 1963 :         fprintf(out, "%5u %6u "
; 1964 :                         "%11" PY_FORMAT_SIZE_T "u "
; 1965 :                         "%15" PY_FORMAT_SIZE_T "u "
; 1966 :                         "%13" PY_FORMAT_SIZE_T "u\n",
; 1967 :                 i, size, p, b, f);

  0024d	48 8b 8c 24 30
	07 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  00255	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15
  0025a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@KKKLDLHO@?$CF5u?5?$CF6u?5?$CF11Iu?5?$CF15Iu?5?$CF13Iu?6?$AA@
  00261	45 8b cc	 mov	 r9d, r12d
  00264	45 8b c5	 mov	 r8d, r13d
  00267	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  0026c	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00271	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 1970 :         pool_header_bytes += p * POOL_OVERHEAD;
; 1971 :         quantization += p * ((POOL_SIZE - POOL_OVERHEAD) % size);

  00277	33 d2		 xor	 edx, edx
  00279	4c 8b dd	 mov	 r11, rbp
  0027c	48 8b c5	 mov	 rax, rbp
  0027f	49 0f af c7	 imul	 rax, r15
  00283	4c 8b bc 24 48
	07 00 00	 mov	 r15, QWORD PTR pool_header_bytes$1$[rsp]
  0028b	4d 0f af de	 imul	 r11, r14
  0028f	4c 8b b4 24 40
	07 00 00	 mov	 r14, QWORD PTR available_bytes$1$[rsp]
  00297	49 03 db	 add	 rbx, r11
  0029a	4c 03 f0	 add	 r14, rax
  0029d	48 8d 04 76	 lea	 rax, QWORD PTR [rsi+rsi*2]
  002a1	48 c1 e0 04	 shl	 rax, 4
  002a5	4c 89 b4 24 40
	07 00 00	 mov	 QWORD PTR available_bytes$1$[rsp], r14
  002ad	4c 03 f8	 add	 r15, rax
  002b0	b8 d0 0f 00 00	 mov	 eax, 4048		; 00000fd0H
  002b5	48 f7 f5	 div	 rbp
  002b8	4c 89 bc 24 48
	07 00 00	 mov	 QWORD PTR pool_header_bytes$1$[rsp], r15
  002c0	48 0f af d6	 imul	 rdx, rsi
  002c4	48 01 54 24 40	 add	 QWORD PTR quantization$1$[rsp], rdx
  002c9	eb 10		 jmp	 SHORT $LN3@PyObject_D
$LN31@PyObject_D:

; 1968 :         allocated_bytes += b * size;
; 1969 :         available_bytes += f * size;

  002cb	4c 8b b4 24 40
	07 00 00	 mov	 r14, QWORD PTR available_bytes$1$[rsp]
  002d3	4c 8b bc 24 48
	07 00 00	 mov	 r15, QWORD PTR pool_header_bytes$1$[rsp]
$LN3@PyObject_D:

; 1953 : 
; 1954 :     for (i = 0; i < numclasses; ++i) {

  002db	41 83 c4 08	 add	 r12d, 8
  002df	41 ff c5	 inc	 r13d
  002e2	48 83 c5 08	 add	 rbp, 8
  002e6	48 83 c7 08	 add	 rdi, 8
  002ea	41 81 fc 08 02
	00 00		 cmp	 r12d, 520		; 00000208H
  002f1	0f 82 39 ff ff
	ff		 jb	 $LL4@PyObject_D

; 1972 :     }
; 1973 :     fputc('\n', out);

  002f7	48 8b b4 24 30
	07 00 00	 mov	 rsi, QWORD PTR out$[rsp]
  002ff	b9 0a 00 00 00	 mov	 ecx, 10
  00304	48 8b d6	 mov	 rdx, rsi
  00307	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc

; 1974 : #ifdef PYMALLOC_DEBUG
; 1975 :     (void)printone(out, "# times object malloc called", serialno);
; 1976 : #endif
; 1977 :     (void)printone(out, "# arenas allocated total", ntimes_arena_allocated);

  0030d	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR ntimes_arena_allocated
  00314	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@BBJOHCGI@?$CD?5arenas?5allocated?5total?$AA@
  0031b	48 8b ce	 mov	 rcx, rsi
  0031e	e8 00 00 00 00	 call	 printone

; 1978 :     (void)printone(out, "# arenas reclaimed", ntimes_arena_allocated - narenas);

  00323	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR ntimes_arena_allocated
  0032a	48 8b 7c 24 48	 mov	 rdi, QWORD PTR narenas$1$[rsp]
  0032f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@EGEFNLBB@?$CD?5arenas?5reclaimed?$AA@
  00336	4c 2b c7	 sub	 r8, rdi
  00339	48 8b ce	 mov	 rcx, rsi
  0033c	e8 00 00 00 00	 call	 printone

; 1979 :     (void)printone(out, "# arenas highwater mark", narenas_highwater);

  00341	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR narenas_highwater
  00348	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@NDJBDOMD@?$CD?5arenas?5highwater?5mark?$AA@
  0034f	48 8b ce	 mov	 rcx, rsi
  00352	e8 00 00 00 00	 call	 printone

; 1980 :     (void)printone(out, "# arenas allocated current", narenas);

  00357	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@CDPEAAIO@?$CD?5arenas?5allocated?5current?$AA@
  0035e	4c 8b c7	 mov	 r8, rdi
  00361	48 8b ce	 mov	 rcx, rsi
  00364	e8 00 00 00 00	 call	 printone

; 1981 : 
; 1982 :     PyOS_snprintf(buf, sizeof(buf),
; 1983 :         "%" PY_FORMAT_SIZE_T "u arenas * %d bytes/arena",
; 1984 :         narenas, ARENA_SIZE);

  00369	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BM@EMIIMIHN@?$CFIu?5arenas?5?$CK?5?$CFd?5bytes?1arena?$AA@
  00370	48 8d 4c 24 60	 lea	 rcx, QWORD PTR buf$[rsp]
  00375	4c 8b cf	 mov	 r9, rdi
  00378	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0037d	c7 44 24 20 00
	00 04 00	 mov	 DWORD PTR [rsp+32], 262144 ; 00040000H
  00385	e8 00 00 00 00	 call	 PyOS_snprintf

; 1985 :     (void)printone(out, buf, narenas * ARENA_SIZE);

  0038a	48 c1 e7 12	 shl	 rdi, 18
  0038e	48 8d 54 24 60	 lea	 rdx, QWORD PTR buf$[rsp]
  00393	4c 8b c7	 mov	 r8, rdi
  00396	48 8b ce	 mov	 rcx, rsi
  00399	e8 00 00 00 00	 call	 printone

; 1986 : 
; 1987 :     fputc('\n', out);

  0039e	48 8b d6	 mov	 rdx, rsi
  003a1	b9 0a 00 00 00	 mov	 ecx, 10
  003a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc

; 1988 : 
; 1989 :     total = printone(out, "# bytes in allocated blocks", allocated_bytes);

  003ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@DGPGANCG@?$CD?5bytes?5in?5allocated?5blocks?$AA@
  003b3	4c 8b c3	 mov	 r8, rbx
  003b6	48 8b ce	 mov	 rcx, rsi
  003b9	e8 00 00 00 00	 call	 printone

; 1990 :     total += printone(out, "# bytes in available blocks", available_bytes);

  003be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@KKPDFEBK@?$CD?5bytes?5in?5available?5blocks?$AA@
  003c5	4d 8b c6	 mov	 r8, r14
  003c8	48 8b ce	 mov	 rcx, rsi
  003cb	48 8b d8	 mov	 rbx, rax
  003ce	e8 00 00 00 00	 call	 printone

; 1991 : 
; 1992 :     PyOS_snprintf(buf, sizeof(buf),
; 1993 :         "%u unused pools * %d bytes", numfreepools, POOL_SIZE);

  003d3	8b bc 24 38 07
	00 00		 mov	 edi, DWORD PTR numfreepools$1$[rsp]
  003da	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BL@FMCCONMC@?$CFu?5unused?5pools?5?$CK?5?$CFd?5bytes?$AA@
  003e1	48 8d 4c 24 60	 lea	 rcx, QWORD PTR buf$[rsp]
  003e6	44 8b cf	 mov	 r9d, edi
  003e9	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  003ee	48 03 d8	 add	 rbx, rax
  003f1	c7 44 24 20 00
	10 00 00	 mov	 DWORD PTR [rsp+32], 4096 ; 00001000H
  003f9	e8 00 00 00 00	 call	 PyOS_snprintf

; 1994 :     total += printone(out, buf, (size_t)numfreepools * POOL_SIZE);

  003fe	44 8b c7	 mov	 r8d, edi
  00401	48 8d 54 24 60	 lea	 rdx, QWORD PTR buf$[rsp]
  00406	48 8b ce	 mov	 rcx, rsi
  00409	49 c1 e0 0c	 shl	 r8, 12
  0040d	e8 00 00 00 00	 call	 printone

; 1995 : 
; 1996 :     total += printone(out, "# bytes lost to pool headers", pool_header_bytes);

  00412	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@OBJGCACO@?$CD?5bytes?5lost?5to?5pool?5headers?$AA@
  00419	4d 8b c7	 mov	 r8, r15
  0041c	48 8b ce	 mov	 rcx, rsi
  0041f	48 03 d8	 add	 rbx, rax
  00422	e8 00 00 00 00	 call	 printone

; 1997 :     total += printone(out, "# bytes lost to quantization", quantization);

  00427	4c 8b 44 24 40	 mov	 r8, QWORD PTR quantization$1$[rsp]
  0042c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@DPIKIPML@?$CD?5bytes?5lost?5to?5quantization?$AA@
  00433	48 8b ce	 mov	 rcx, rsi
  00436	48 03 d8	 add	 rbx, rax
  00439	e8 00 00 00 00	 call	 printone

; 1998 :     total += printone(out, "# bytes lost to arena alignment", arena_alignment);

  0043e	4c 8b 44 24 50	 mov	 r8, QWORD PTR arena_alignment$1$[rsp]
  00443	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@GBCGKCEO@?$CD?5bytes?5lost?5to?5arena?5alignment?$AA@
  0044a	48 8b ce	 mov	 rcx, rsi
  0044d	48 03 d8	 add	 rbx, rax
  00450	e8 00 00 00 00	 call	 printone

; 1999 :     (void)printone(out, "Total", total);

  00455	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05KGEAEGFG@Total?$AA@
  0045c	48 8b ce	 mov	 rcx, rsi
  0045f	4c 8d 04 18	 lea	 r8, QWORD PTR [rax+rbx]
  00463	e8 00 00 00 00	 call	 printone

; 2000 : }

  00468	48 81 c4 e8 06
	00 00		 add	 rsp, 1768		; 000006e8H
  0046f	41 5f		 pop	 r15
  00471	41 5e		 pop	 r14
  00473	41 5d		 pop	 r13
  00475	41 5c		 pop	 r12
  00477	5f		 pop	 rdi
  00478	5e		 pop	 rsi
  00479	5d		 pop	 rbp
  0047a	5b		 pop	 rbx
  0047b	c3		 ret	 0
_PyObject_DebugMallocStats ENDP
_TEXT	ENDS
PUBLIC	_PyMem_InRange
EXTRN	__C_specific_handler:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyMem_InRange DD imagerel $LN15
	DD	imagerel $LN15+118
	DD	imagerel $unwind$_PyMem_InRange
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyMem_InRange$filt$0 DD imagerel _PyMem_InRange$filt$0
	DD	imagerel _PyMem_InRange$filt$0+26
	DD	imagerel $unwind$_PyMem_InRange$filt$0
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyMem_InRange$filt$0 DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyMem_InRange DD 010909H
	DD	02209H
	DD	imagerel __C_specific_handler
	DD	01H
	DD	imagerel $LN15+30
	DD	imagerel $LN15+38
	DD	imagerel _PyMem_InRange$filt$0
	DD	imagerel $LN15+38
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyMem_InRange
_TEXT	SEGMENT
arenaindex_temp$ = 0
m$ = 32
result$ = 40
_PyMem_InRange PROC					; COMDAT

; 2026 : {

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24
  00009	4c 8b c9	 mov	 r9, rcx

; 2027 :     struct arena_object *arena;
; 2028 :     uint arenaindex_temp;
; 2029 :     uptr address;
; 2030 :     uptr addr2;
; 2031 :     uptr up;
; 2032 :     uptr pdiff;
; 2033 :     poolp pool;
; 2034 :     int invalid = 0;

  0000c	33 d2		 xor	 edx, edx

; 2035 :     int result = 0;

  0000e	44 8b c2	 mov	 r8d, edx
  00011	89 54 24 28	 mov	 DWORD PTR result$[rsp], edx

; 2036 :     int result2 = 0;
; 2037 :     void *v;
; 2038 :     struct arena_object *ap = NULL;
; 2039 : 
; 2040 :     up = (uptr)m;
; 2041 :     pool = POOL_ADDR(m);

  00015	48 8b c1	 mov	 rax, rcx
  00018	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H

; 2042 :     READ_LOCK();
; 2043 :     __try {
; 2044 :         arenaindex_temp = pool->arenaindex;

  0001e	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00021	89 04 24	 mov	 DWORD PTR arenaindex_temp$[rsp], eax

; 2045 :     } __except(

  00024	eb 12		 jmp	 SHORT $LN14@PyMem_InRa
$LN12@PyMem_InRa:

; 2046 :         GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
; 2047 :             EXCEPTION_EXECUTE_HANDLER :
; 2048 :             EXCEPTION_CONTINUE_SEARCH
; 2049 :     ) {
; 2050 :         invalid = 1;

  00026	ba 01 00 00 00	 mov	 edx, 1
  0002b	4c 8b 4c 24 20	 mov	 r9, QWORD PTR m$[rsp]
  00030	44 8b 44 24 28	 mov	 r8d, DWORD PTR result$[rsp]
  00035	8b 04 24	 mov	 eax, DWORD PTR arenaindex_temp$[rsp]
$LN14@PyMem_InRa:

; 2051 :     }
; 2052 :     if (invalid)

  00038	85 d2		 test	 edx, edx
  0003a	75 32		 jne	 SHORT $end$121120

; 2053 :         goto end;
; 2054 : 
; 2055 :     if (arenaindex_temp < maxarenas) {

  0003c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR maxarenas
  00042	73 2a		 jae	 SHORT $end$121120

; 2056 :         v = (void *)arenas[arenaindex_temp].address;
; 2057 :         ap = (struct arena_object *)v;
; 2058 :         addr2 = arenas[arenaindex_temp].address;
; 2059 :         arena = &arenas[arenaindex_temp];

  00044	48 8d 14 40	 lea	 rdx, QWORD PTR [rax+rax*2]
  00048	48 03 d2	 add	 rdx, rdx

; 2060 :         address = arena->address;

  0004b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR arenas
  00052	48 8b 04 d1	 mov	 rax, QWORD PTR [rcx+rdx*8]

; 2061 :         pdiff = up - address;

  00056	4c 2b c8	 sub	 r9, rax

; 2062 :         if (pdiff < (uptr)ARENA_SIZE)

  00059	49 81 f9 00 00
	04 00		 cmp	 r9, 262144		; 00040000H
  00060	73 0c		 jae	 SHORT $end$121120

; 2063 :             if (address != 0)

  00062	b9 01 00 00 00	 mov	 ecx, 1
  00067	48 85 c0	 test	 rax, rax
  0006a	44 0f 45 c1	 cmovne	 r8d, ecx
$end$121120:

; 2064 :                 result = 1;
; 2065 :     }
; 2066 :     result2 = arenaindex_temp < maxarenas &&
; 2067 :            (uptr)m - arenas[arenaindex_temp].address < (uptr)ARENA_SIZE &&
; 2068 :            arenas[arenaindex_temp].address != 0;
; 2069 :     assert(result == result2);
; 2070 : end:
; 2071 :     READ_UNLOCK();
; 2072 :     return result;

  0006e	41 8b c0	 mov	 eax, r8d
$LN6@PyMem_InRa:

; 2073 : }

  00071	48 83 c4 18	 add	 rsp, 24
  00075	c3		 ret	 0
_PyMem_InRange ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
arenaindex_temp$ = 0
m$ = 32
result$ = 40
_PyMem_InRange$filt$0 PROC
  00000	40 55		 push	 rbp
  00002	48 8b ea	 mov	 rbp, rdx
$LN11@PyMem_InRa@2:
  00005	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 2049 :     ) {

  00008	33 c9		 xor	 ecx, ecx
  0000a	81 38 05 00 00
	c0		 cmp	 DWORD PTR [rax], -1073741819 ; c0000005H
  00010	0f 94 c1	 sete	 cl
  00013	8b c1		 mov	 eax, ecx
  00015	8b c1		 mov	 eax, ecx
$LN13@PyMem_InRa@2:
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
  00019	cc		 int	 3
_PyMem_InRange$filt$0 ENDP
text$x	ENDS
END
