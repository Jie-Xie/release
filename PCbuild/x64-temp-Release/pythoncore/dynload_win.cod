; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_04HGKCMEGH@?4pyd?$AA@			; `string'
PUBLIC	_PyImport_DynLoadFiletab
_DATA	SEGMENT
_PyImport_DynLoadFiletab DQ FLAT:??_C@_04HGKCMEGH@?4pyd?$AA@
	DQ	0000000000000000H
_DATA	ENDS
;	COMDAT ??_C@_04HGKCMEGH@?4pyd?$AA@
CONST	SEGMENT
??_C@_04HGKCMEGH@?4pyd?$AA@ DB '.pyd', 00H		; `string'
CONST	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
EXTRN	__imp_tolower:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\dynload_win.c
pdata	SEGMENT
$pdata$strcasecmp DD imagerel strcasecmp
	DD	imagerel strcasecmp+84
	DD	imagerel $unwind$strcasecmp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$strcasecmp DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT strcasecmp
_TEXT	SEGMENT
string1$ = 48
string2$ = 56
strcasecmp PROC						; COMDAT

; 34   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f1	 mov	 rsi, rcx
  00012	48 8b fa	 mov	 rdi, rdx

; 42   :     } while (first && first == second);

  00015	48 2b f2	 sub	 rsi, rdx
  00018	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@strcasecmp:

; 35   :     int first, second;
; 36   : 
; 37   :     do {
; 38   :         first  = tolower(*string1);

  00020	0f be 0c 3e	 movsx	 ecx, BYTE PTR [rsi+rdi]
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tolower

; 39   :         second = tolower(*string2);

  0002a	0f be 0f	 movsx	 ecx, BYTE PTR [rdi]
  0002d	8b d8		 mov	 ebx, eax
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tolower

; 40   :         string1++;
; 41   :         string2++;

  00035	48 ff c7	 inc	 rdi

; 42   :     } while (first && first == second);

  00038	85 db		 test	 ebx, ebx
  0003a	74 04		 je	 SHORT $LN1@strcasecmp
  0003c	3b d8		 cmp	 ebx, eax
  0003e	74 e0		 je	 SHORT $LL4@strcasecmp
$LN1@strcasecmp:

; 43   : 
; 44   :     return (first - second);
; 45   : }

  00040	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00045	2b d8		 sub	 ebx, eax
  00047	8b c3		 mov	 eax, ebx
  00049	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00052	5f		 pop	 rdi
  00053	c3		 ret	 0
strcasecmp ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@CPIKMFDO@python3?4dll?$AA@		; `string'
PUBLIC	??_C@_06OIODPPHE@python?$AA@			; `string'
PUBLIC	??_C@_04KNAEGPCG@PE?$AA?$AA?$AA@		; `string'
EXTRN	__imp_strncmp:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetPythonImport DD imagerel GetPythonImport
	DD	imagerel GetPythonImport+308
	DD	imagerel $unwind$GetPythonImport
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetPythonImport DD 0a6f01H
	DD	09746fH
	DD	08646aH
	DD	075460H
	DD	06345bH
	DD	0c0023206H
xdata	ENDS
;	COMDAT ??_C@_0M@CPIKMFDO@python3?4dll?$AA@
CONST	SEGMENT
??_C@_0M@CPIKMFDO@python3?4dll?$AA@ DB 'python3.dll', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06OIODPPHE@python?$AA@
CONST	SEGMENT
??_C@_06OIODPPHE@python?$AA@ DB 'python', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KNAEGPCG@PE?$AA?$AA?$AA@
CONST	SEGMENT
??_C@_04KNAEGPCG@PE?$AA?$AA?$AA@ DB 'PE', 00H, 00H, 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT GetPythonImport
_TEXT	SEGMENT
hModule$ = 48
GetPythonImport PROC					; COMDAT

; 70   : {

  00000	41 54		 push	 r12
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	4c 8b e1	 mov	 r12, rcx

; 71   :     unsigned char *dllbase, *import_data, *import_name;
; 72   :     DWORD pe_offset, opt_offset;
; 73   :     WORD opt_magic;
; 74   :     int num_dict_off, import_off;
; 75   : 
; 76   :     /* Safety check input */
; 77   :     if (hModule == NULL) {

  00009	48 85 c9	 test	 rcx, rcx
  0000c	75 09		 jne	 SHORT $LN17@GetPythonI
$LN31@GetPythonI:

; 78   :         return NULL;

  0000e	33 c0		 xor	 eax, eax

; 174  : }

  00010	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00014	41 5c		 pop	 r12
  00016	c3		 ret	 0
$LN17@GetPythonI:

; 79   :     }
; 80   : 
; 81   :     /* Module instance is also the base load address.  First portion of
; 82   :        memory is the MS-DOS loader, which holds the offset to the PE
; 83   :        header (from the load base) at 0x3C */
; 84   :     dllbase = (unsigned char *)hModule;
; 85   :     pe_offset = DWORD_AT(dllbase + 0x3C);

  00017	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]

; 86   : 
; 87   :     /* The PE signature must be "PE\0\0" */
; 88   :     if (memcmp(dllbase+pe_offset,"PE\0\0",4)) {

  0001a	42 8b 04 21	 mov	 eax, DWORD PTR [rcx+r12]
  0001e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ??_C@_04KNAEGPCG@PE?$AA?$AA?$AA@

; 89   :         return NULL;

  00024	75 e8		 jne	 SHORT $LN31@GetPythonI

; 90   :     }
; 91   : 
; 92   :     /* Following the PE signature is the standard COFF header (20
; 93   :        bytes) and then the optional header.  The optional header starts
; 94   :        with a magic value of 0x10B for PE32 or 0x20B for PE32+ (PE32+
; 95   :        uses 64-bits for some fields).  It might also be 0x107 for a ROM
; 96   :        image, but we don't process that here.
; 97   : 
; 98   :        The optional header ends with a data dictionary that directly
; 99   :        points to certain types of data, among them the import entries
; 100  :        (in the second table entry). Based on the header type, we
; 101  :        determine offsets for the data dictionary count and the entry
; 102  :        within the dictionary pointing to the imports. */
; 103  : 
; 104  :     opt_offset = pe_offset + 4 + 20;

  00026	8d 41 18	 lea	 eax, DWORD PTR [rcx+24]

; 105  :     opt_magic = WORD_AT(dllbase+opt_offset);
; 106  :     if (opt_magic == 0x10B) {

  00029	ba 0b 01 00 00	 mov	 edx, 267		; 0000010bH
  0002e	8b c8		 mov	 ecx, eax
  00030	42 0f b7 04 20	 movzx	 eax, WORD PTR [rax+r12]
  00035	66 3b c2	 cmp	 ax, dx
  00038	75 0a		 jne	 SHORT $LN15@GetPythonI

; 107  :         /* PE32 */
; 108  :         num_dict_off = 92;

  0003a	b8 5c 00 00 00	 mov	 eax, 92			; 0000005cH

; 109  :         import_off   = 104;

  0003f	8d 50 0c	 lea	 edx, QWORD PTR [rax+12]
  00042	eb 12		 jmp	 SHORT $LN12@GetPythonI
$LN15@GetPythonI:

; 110  :     } else if (opt_magic == 0x20B) {

  00044	ba 0b 02 00 00	 mov	 edx, 523		; 0000020bH
  00049	66 3b c2	 cmp	 ax, dx
  0004c	75 c0		 jne	 SHORT $LN31@GetPythonI

; 111  :         /* PE32+ */
; 112  :         num_dict_off = 108;

  0004e	b8 6c 00 00 00	 mov	 eax, 108		; 0000006cH

; 113  :         import_off   = 120;

  00053	8d 50 0c	 lea	 edx, QWORD PTR [rax+12]
$LN12@GetPythonI:

; 114  :     } else {
; 115  :         /* Unsupported */
; 116  :         return NULL;
; 117  :     }
; 118  : 
; 119  :     /* Now if an import table exists, offset to it and walk the list of
; 120  :        imports.  The import table is an array (ending when an entry has
; 121  :        empty values) of structures (20 bytes each), which contains (at
; 122  :        offset 12) a relative address (to the module base) at which a
; 123  :        string constant holding the import name is located. */
; 124  : 
; 125  :     if (DWORD_AT(dllbase + opt_offset + num_dict_off) >= 2) {

  00056	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0005b	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  00060	48 98		 cdqe
  00062	48 03 c1	 add	 rax, rcx
  00065	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  0006a	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  0006f	42 83 3c 20 02	 cmp	 DWORD PTR [rax+r12], 2
  00074	0f 82 9d 00 00
	00		 jb	 $LN8@GetPythonI

; 126  :         /* We have at least 2 tables - the import table is the second
; 127  :            one.  But still it may be that the table size is zero */
; 128  :         if (0 == DWORD_AT(dllbase + opt_offset + import_off + sizeof(DWORD)))

  0007a	48 63 c2	 movsxd	 rax, edx
  0007d	48 03 c1	 add	 rax, rcx
  00080	42 83 7c 20 04
	00		 cmp	 DWORD PTR [rax+r12+4], 0

; 129  :             return NULL;

  00086	0f 84 8b 00 00
	00		 je	 $LN8@GetPythonI

; 130  :         import_data = dllbase + DWORD_AT(dllbase +
; 131  :                                          opt_offset +
; 132  :                                          import_off);

  0008c	42 8b 1c 20	 mov	 ebx, DWORD PTR [rax+r12]
  00090	49 03 dc	 add	 rbx, r12

; 133  :         while (DWORD_AT(import_data)) {

  00093	83 3b 00	 cmp	 DWORD PTR [rbx], 0
  00096	74 7f		 je	 SHORT $LN8@GetPythonI
  00098	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL9@GetPythonI:

; 134  :             import_name = dllbase + DWORD_AT(import_data+12);

  000a0	8b 6b 0c	 mov	 ebp, DWORD PTR [rbx+12]

; 135  :             if (strlen(import_name) >= 6 &&
; 136  :                 !strncmp(import_name,"python",6)) {

  000a3	48 83 c9 ff	 or	 rcx, -1
  000a7	33 c0		 xor	 eax, eax
  000a9	49 03 ec	 add	 rbp, r12
  000ac	48 8b fd	 mov	 rdi, rbp
  000af	f2 ae		 repne scasb
  000b1	48 f7 d1	 not	 rcx
  000b4	48 ff c9	 dec	 rcx
  000b7	48 83 f9 06	 cmp	 rcx, 6
  000bb	72 51		 jb	 SHORT $LN3@GetPythonI
  000bd	44 8d 40 06	 lea	 r8d, QWORD PTR [rax+6]
  000c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06OIODPPHE@python?$AA@
  000c8	48 8b cd	 mov	 rcx, rbp
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  000d1	85 c0		 test	 eax, eax
  000d3	75 39		 jne	 SHORT $LN3@GetPythonI

; 137  :                 char *pch;
; 138  : 
; 139  : #ifndef _DEBUG
; 140  :                 /* In a release version, don't claim that python3.dll is
; 141  :                    a Python DLL. */
; 142  :                 if (strcmp(import_name, "python3.dll") == 0) {

  000d5	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0M@CPIKMFDO@python3?4dll?$AA@
  000dc	48 8b f5	 mov	 rsi, rbp
  000df	b9 0c 00 00 00	 mov	 ecx, 12
  000e4	f3 a6		 repe cmpsb

; 143  :                     import_data += 20;
; 144  :                     continue;

  000e6	74 26		 je	 SHORT $LN3@GetPythonI

; 145  :                 }
; 146  : #endif
; 147  : 
; 148  :                 /* Ensure python prefix is followed only
; 149  :                    by numbers to the end of the basename */
; 150  :                 pch = import_name + 6;
; 151  : #ifdef _DEBUG
; 152  :                 while (*pch && pch[0] != '_' && pch[1] != 'd' && pch[2] != '.') {
; 153  : #else
; 154  :                 while (*pch && *pch != '.') {

  000e8	0f b6 45 06	 movzx	 eax, BYTE PTR [rbp+6]
  000ec	48 8d 4d 06	 lea	 rcx, QWORD PTR [rbp+6]
  000f0	84 c0		 test	 al, al
  000f2	74 15		 je	 SHORT $LN23@GetPythonI
$LL5@GetPythonI:
  000f4	3c 2e		 cmp	 al, 46			; 0000002eH
  000f6	74 11		 je	 SHORT $LN23@GetPythonI

; 155  : #endif
; 156  :                     if (*pch >= '0' && *pch <= '9') {

  000f8	2c 30		 sub	 al, 48			; 00000030H
  000fa	3c 09		 cmp	 al, 9
  000fc	77 10		 ja	 SHORT $LN3@GetPythonI

; 157  :                         pch++;

  000fe	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00102	48 ff c1	 inc	 rcx
  00105	84 c0		 test	 al, al
  00107	75 eb		 jne	 SHORT $LL5@GetPythonI
$LN23@GetPythonI:

; 158  :                     } else {
; 159  :                         pch = NULL;
; 160  :                         break;
; 161  :                     }
; 162  :                 }
; 163  : 
; 164  :                 if (pch) {
; 165  :                     /* Found it - return the name */
; 166  :                     return import_name;

  00109	48 8b c5	 mov	 rax, rbp
  0010c	eb 0b		 jmp	 SHORT $LN30@GetPythonI
$LN3@GetPythonI:

; 167  :                 }
; 168  :             }
; 169  :             import_data += 20;

  0010e	48 83 c3 14	 add	 rbx, 20
  00112	83 3b 00	 cmp	 DWORD PTR [rbx], 0
  00115	75 89		 jne	 SHORT $LL9@GetPythonI
$LN8@GetPythonI:

; 170  :         }
; 171  :     }
; 172  : 
; 173  :     return NULL;

  00117	33 c0		 xor	 eax, eax
$LN30@GetPythonI:
  00119	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0011e	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00123	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00128	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 174  : }

  0012d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00131	41 5c		 pop	 r12
  00133	c3		 ret	 0
GetPythonImport ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DM@LKDKPELF@Module?5use?5of?5?$CF?4150s?5conflicts?5w@ ; `string'
PUBLIC	??_C@_0P@OCEPOFGM@python?$CFd?$CFd?4dll?$AA@	; `string'
PUBLIC	??_C@_0BC@HIMEBECO@DLL?5load?5failed?3?5?$AA@	; `string'
PUBLIC	??_C@_0CD@DECNJACN@DLL?5load?5failed?5with?5error?5code?5@ ; `string'
PUBLIC	??_C@_0O@DMGNPJAA@PyInit_?$CF?4200s?$AA@	; `string'
PUBLIC	_PyImport_GetDynLoadWindows
EXTRN	__imp_GetProcAddress:PROC
EXTRN	__imp_FreeLibrary:PROC
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_ImportError:QWORD
EXTRN	PyErr_SetImportError:PROC
EXTRN	PyUnicode_AppendAndDel:PROC
EXTRN	PyUnicode_FromWideChar:PROC
EXTRN	PyUnicode_FromString:PROC
EXTRN	PyUnicode_FromFormat:PROC
EXTRN	__imp_FormatMessageW:PROC
EXTRN	__imp_GetLastError:PROC
EXTRN	__imp_LoadLibraryExW:PROC
EXTRN	__imp_SetErrorMode:PROC
EXTRN	PyOS_snprintf:PROC
EXTRN	PyUnicode_AsUnicode:PROC
EXTRN	_Py_CheckPython3:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyImport_GetDynLoadWindows DD imagerel $LN16
	DD	imagerel $LN16+133
	DD	imagerel $unwind$_PyImport_GetDynLoadWindows
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$_PyImport_GetDynLoadWindows DD imagerel $LN16+133
	DD	imagerel $LN16+331
	DD	imagerel $chain$1$_PyImport_GetDynLoadWindows
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_PyImport_GetDynLoadWindows DD imagerel $LN16+331
	DD	imagerel $LN16+531
	DD	imagerel $chain$2$_PyImport_GetDynLoadWindows
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_PyImport_GetDynLoadWindows DD 021H
	DD	imagerel $LN16
	DD	imagerel $LN16+133
	DD	imagerel $unwind$_PyImport_GetDynLoadWindows
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$_PyImport_GetDynLoadWindows DD 020821H
	DD	06fc408H
	DD	imagerel $LN16
	DD	imagerel $LN16+133
	DD	imagerel $unwind$_PyImport_GetDynLoadWindows
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyImport_GetDynLoadWindows DD 075001H
	DD	06e3450H
	DD	06a010bH
	DD	060037004H
	DD	05002H
xdata	ENDS
;	COMDAT ??_C@_0DM@LKDKPELF@Module?5use?5of?5?$CF?4150s?5conflicts?5w@
CONST	SEGMENT
??_C@_0DM@LKDKPELF@Module?5use?5of?5?$CF?4150s?5conflicts?5w@ DB 'Module '
	DB	'use of %.150s conflicts with this version of Python.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OCEPOFGM@python?$CFd?$CFd?4dll?$AA@
CONST	SEGMENT
??_C@_0P@OCEPOFGM@python?$CFd?$CFd?4dll?$AA@ DB 'python%d%d.dll', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HIMEBECO@DLL?5load?5failed?3?5?$AA@
CONST	SEGMENT
??_C@_0BC@HIMEBECO@DLL?5load?5failed?3?5?$AA@ DB 'DLL load failed: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@DECNJACN@DLL?5load?5failed?5with?5error?5code?5@
CONST	SEGMENT
??_C@_0CD@DECNJACN@DLL?5load?5failed?5with?5error?5code?5@ DB 'DLL load f'
	DB	'ailed with error code %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DMGNPJAA@PyInit_?$CF?4200s?$AA@
CONST	SEGMENT
??_C@_0O@DMGNPJAA@PyInit_?$CF?4200s?$AA@ DB 'PyInit_%.200s', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyImport_GetDynLoadWindows
_TEXT	SEGMENT
buffer$120477 = 64
theInfo$120454 = 64
funcname$ = 576
shortname$ = 880
pathname$ = 888
fp$ = 896
message$120452 = 904
_PyImport_GetDynLoadWindows PROC			; COMDAT

; 178  : {

$LN16:
  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 81 ec 50 03
	00 00		 sub	 rsp, 848		; 00000350H
  0000b	48 8b f2	 mov	 rsi, rdx
  0000e	48 8b e9	 mov	 rbp, rcx

; 179  :     dl_funcptr p;
; 180  :     char funcname[258], *import_python;
; 181  :     wchar_t *wpathname;
; 182  : 
; 183  : #ifndef _DEBUG
; 184  :     _Py_CheckPython3();

  00011	e8 00 00 00 00	 call	 _Py_CheckPython3

; 185  : #endif
; 186  : 
; 187  :     wpathname = PyUnicode_AsUnicode(pathname);

  00016	48 8b ce	 mov	 rcx, rsi
  00019	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  0001e	48 8b f8	 mov	 rdi, rax

; 188  :     if (wpathname == NULL)

  00021	48 85 c0	 test	 rax, rax
  00024	75 0b		 jne	 SHORT $LN12@PyImport_G

; 294  :     }
; 295  : 
; 296  :     return p;
; 297  : }

  00026	48 81 c4 50 03
	00 00		 add	 rsp, 848		; 00000350H
  0002d	5f		 pop	 rdi
  0002e	5e		 pop	 rsi
  0002f	5d		 pop	 rbp
  00030	c3		 ret	 0
$LN12@PyImport_G:

; 189  :         return NULL;
; 190  : 
; 191  :     PyOS_snprintf(funcname, sizeof(funcname), "PyInit_%.200s", shortname);

  00031	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@DMGNPJAA@PyInit_?$CF?4200s?$AA@
  00038	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR funcname$[rsp]
  00040	4c 8b cd	 mov	 r9, rbp
  00043	ba 02 01 00 00	 mov	 edx, 258		; 00000102H
  00048	48 89 9c 24 70
	03 00 00	 mov	 QWORD PTR [rsp+880], rbx
  00050	e8 00 00 00 00	 call	 PyOS_snprintf

; 192  : 
; 193  :     {
; 194  :         HINSTANCE hDLL = NULL;
; 195  :         unsigned int old_mode;
; 196  : #if HAVE_SXS
; 197  :         ULONG_PTR cookie = 0;
; 198  : #endif
; 199  : 
; 200  :         /* Don't display a message box when Python can't load a DLL */
; 201  :         old_mode = SetErrorMode(SEM_FAILCRITICALERRORS);

  00055	b9 01 00 00 00	 mov	 ecx, 1
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetErrorMode

; 202  : 
; 203  : #if HAVE_SXS
; 204  :         cookie = _Py_ActivateActCtx();
; 205  : #endif
; 206  :         /* We use LoadLibraryEx so Windows looks for dependent DLLs
; 207  :             in directory of pathname first. */
; 208  :         /* XXX This call doesn't exist in Windows CE */
; 209  :         hDLL = LoadLibraryExW(wpathname, NULL,
; 210  :                               LOAD_WITH_ALTERED_SEARCH_PATH);

  00060	33 d2		 xor	 edx, edx
  00062	48 8b cf	 mov	 rcx, rdi
  00065	44 8d 42 08	 lea	 r8d, QWORD PTR [rdx+8]
  00069	8b d8		 mov	 ebx, eax
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryExW

; 211  : #if HAVE_SXS
; 212  :         _Py_DeactivateActCtx(cookie);
; 213  : #endif
; 214  : 
; 215  :         /* restore old error mode settings */
; 216  :         SetErrorMode(old_mode);

  00071	8b cb		 mov	 ecx, ebx
  00073	48 8b f8	 mov	 rdi, rax
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetErrorMode

; 217  : 
; 218  :         if (hDLL==NULL){

  0007c	48 85 ff	 test	 rdi, rdi
  0007f	0f 85 02 01 00
	00		 jne	 $LN11@PyImport_G

; 219  :             PyObject *message;
; 220  :             unsigned int errorCode;
; 221  : 
; 222  :             /* Get an error string from Win32 error code */
; 223  :             wchar_t theInfo[256]; /* Pointer to error text
; 224  :                                   from system */
; 225  :             int theLength; /* Length of error text */
; 226  : 
; 227  :             errorCode = GetLastError();

  00085	4c 89 a4 24 78
	03 00 00	 mov	 QWORD PTR [rsp+888], r12
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError

; 228  : 
; 229  :             theLength = FormatMessageW(
; 230  :                 FORMAT_MESSAGE_FROM_SYSTEM |
; 231  :                 FORMAT_MESSAGE_IGNORE_INSERTS, /* flags */
; 232  :                 NULL, /* message source */
; 233  :                 errorCode, /* the message (error) ID */
; 234  :                 MAKELANGID(LANG_NEUTRAL,
; 235  :                            SUBLANG_DEFAULT),
; 236  :                            /* Default language */
; 237  :                 theInfo, /* the buffer */
; 238  :                 sizeof(theInfo) / sizeof(wchar_t), /* size in wchars */
; 239  :                 NULL); /* no additional format args. */

  00093	45 33 e4	 xor	 r12d, r12d
  00096	8b f8		 mov	 edi, eax
  00098	48 8d 44 24 40	 lea	 rax, QWORD PTR theInfo$120454[rsp]
  0009d	4c 89 64 24 30	 mov	 QWORD PTR [rsp+48], r12
  000a2	41 b9 00 04 00
	00		 mov	 r9d, 1024		; 00000400H
  000a8	33 d2		 xor	 edx, edx
  000aa	b9 00 12 00 00	 mov	 ecx, 4608		; 00001200H
  000af	44 8b c7	 mov	 r8d, edi
  000b2	c7 44 24 28 00
	01 00 00	 mov	 DWORD PTR [rsp+40], 256	; 00000100H
  000ba	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FormatMessageW
  000c5	48 63 d8	 movsxd	 rbx, eax

; 240  : 
; 241  :             /* Problem: could not get the error message.
; 242  :                This should not happen if called correctly. */
; 243  :             if (theLength == 0) {

  000c8	85 c0		 test	 eax, eax
  000ca	75 18		 jne	 SHORT $LN10@PyImport_G

; 244  :                 message = PyUnicode_FromFormat(
; 245  :                     "DLL load failed with error code %d",
; 246  :                     errorCode);

  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@DECNJACN@DLL?5load?5failed?5with?5error?5code?5@
  000d3	8b d7		 mov	 edx, edi
  000d5	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  000da	48 89 84 24 88
	03 00 00	 mov	 QWORD PTR message$120452[rsp], rax

; 247  :             } else {

  000e2	eb 5a		 jmp	 SHORT $LN9@PyImport_G
$LN10@PyImport_G:

; 248  :                 /* For some reason a \r\n
; 249  :                    is appended to the text */
; 250  :                 if (theLength >= 2 &&
; 251  :                     theInfo[theLength-2] == '\r' &&
; 252  :                     theInfo[theLength-1] == '\n') {

  000e4	83 fb 02	 cmp	 ebx, 2
  000e7	7c 1c		 jl	 SHORT $LN8@PyImport_G
  000e9	66 83 7c 5c 3c
	0d		 cmp	 WORD PTR theInfo$120454[rsp+rbx*2-4], 13
  000ef	75 14		 jne	 SHORT $LN8@PyImport_G
  000f1	66 83 7c 5c 3e
	0a		 cmp	 WORD PTR theInfo$120454[rsp+rbx*2-2], 10
  000f7	75 0c		 jne	 SHORT $LN8@PyImport_G

; 253  :                     theLength -= 2;

  000f9	83 eb 02	 sub	 ebx, 2

; 254  :                     theInfo[theLength] = '\0';

  000fc	48 63 c3	 movsxd	 rax, ebx
  000ff	66 44 89 64 44
	40		 mov	 WORD PTR theInfo$120454[rsp+rax*2], r12w
$LN8@PyImport_G:

; 255  :                 }
; 256  :                 message = PyUnicode_FromString(
; 257  :                     "DLL load failed: ");

  00105	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@HIMEBECO@DLL?5load?5failed?3?5?$AA@
  0010c	e8 00 00 00 00	 call	 PyUnicode_FromString

; 258  : 
; 259  :                 PyUnicode_AppendAndDel(&message,
; 260  :                     PyUnicode_FromWideChar(
; 261  :                         theInfo,
; 262  :                         theLength));

  00111	48 8d 4c 24 40	 lea	 rcx, QWORD PTR theInfo$120454[rsp]
  00116	48 63 d3	 movsxd	 rdx, ebx
  00119	48 89 84 24 88
	03 00 00	 mov	 QWORD PTR message$120452[rsp], rax
  00121	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
  00126	48 8d 8c 24 88
	03 00 00	 lea	 rcx, QWORD PTR message$120452[rsp]
  0012e	48 8b d0	 mov	 rdx, rax
  00131	e8 00 00 00 00	 call	 PyUnicode_AppendAndDel
  00136	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR message$120452[rsp]
$LN9@PyImport_G:

; 263  :             }
; 264  :             if (message != NULL) {

  0013e	4c 8b a4 24 78
	03 00 00	 mov	 r12, QWORD PTR [rsp+888]
  00146	48 85 c0	 test	 rax, rax
  00149	74 38		 je	 SHORT $LN7@PyImport_G

; 265  :                 PyObject *shortname_obj = PyUnicode_FromString(shortname);

  0014b	48 8b cd	 mov	 rcx, rbp
  0014e	e8 00 00 00 00	 call	 PyUnicode_FromString

; 266  :                 PyErr_SetImportError(message, shortname_obj, pathname);

  00153	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR message$120452[rsp]
  0015b	4c 8b c6	 mov	 r8, rsi
  0015e	48 8b d0	 mov	 rdx, rax
  00161	48 8b d8	 mov	 rbx, rax
  00164	e8 00 00 00 00	 call	 PyErr_SetImportError

; 267  :                 Py_XDECREF(shortname_obj);

  00169	48 85 db	 test	 rbx, rbx
  0016c	74 08		 je	 SHORT $LN5@PyImport_G
  0016e	48 8b cb	 mov	 rcx, rbx
  00171	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@PyImport_G:

; 268  :                 Py_DECREF(message);

  00176	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR message$120452[rsp]
  0017e	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@PyImport_G:

; 269  :             }
; 270  :             return NULL;

  00183	33 c0		 xor	 eax, eax
  00185	eb 79		 jmp	 SHORT $LN15@PyImport_G
$LN11@PyImport_G:

; 271  :         } else {
; 272  :             char buffer[256];
; 273  : 
; 274  :             PyOS_snprintf(buffer, sizeof(buffer),
; 275  : #ifdef _DEBUG
; 276  :                           "python%d%d_d.dll",
; 277  : #else
; 278  :                           "python%d%d.dll",
; 279  : #endif
; 280  :                           PY_MAJOR_VERSION,PY_MINOR_VERSION);

  00187	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0P@OCEPOFGM@python?$CFd?$CFd?4dll?$AA@
  0018e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buffer$120477[rsp]
  00193	41 b9 03 00 00
	00		 mov	 r9d, 3
  00199	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0019e	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  001a6	e8 00 00 00 00	 call	 PyOS_snprintf

; 281  :             import_python = GetPythonImport(hDLL);

  001ab	48 8b cf	 mov	 rcx, rdi
  001ae	e8 00 00 00 00	 call	 GetPythonImport
  001b3	48 8b d8	 mov	 rbx, rax

; 282  : 
; 283  :             if (import_python &&
; 284  :                 strcasecmp(buffer,import_python)) {

  001b6	48 85 c0	 test	 rax, rax
  001b9	74 34		 je	 SHORT $LN1@PyImport_G
  001bb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buffer$120477[rsp]
  001c0	48 8b d0	 mov	 rdx, rax
  001c3	e8 00 00 00 00	 call	 strcasecmp
  001c8	85 c0		 test	 eax, eax
  001ca	74 23		 je	 SHORT $LN1@PyImport_G

; 285  :                 PyErr_Format(PyExc_ImportError,
; 286  :                              "Module use of %.150s conflicts "
; 287  :                              "with this version of Python.",
; 288  :                              import_python);

  001cc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ImportError
  001d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DM@LKDKPELF@Module?5use?5of?5?$CF?4150s?5conflicts?5w@
  001da	4c 8b c3	 mov	 r8, rbx
  001dd	e8 00 00 00 00	 call	 PyErr_Format

; 289  :                 FreeLibrary(hDLL);

  001e2	48 8b cf	 mov	 rcx, rdi
  001e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FreeLibrary

; 290  :                 return NULL;

  001eb	33 c0		 xor	 eax, eax
  001ed	eb 11		 jmp	 SHORT $LN15@PyImport_G
$LN1@PyImport_G:

; 291  :             }
; 292  :         }
; 293  :         p = GetProcAddress(hDLL, funcname);

  001ef	48 8d 94 24 40
	02 00 00	 lea	 rdx, QWORD PTR funcname$[rsp]
  001f7	48 8b cf	 mov	 rcx, rdi
  001fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
$LN15@PyImport_G:
  00200	48 8b 9c 24 70
	03 00 00	 mov	 rbx, QWORD PTR [rsp+880]

; 294  :     }
; 295  : 
; 296  :     return p;
; 297  : }

  00208	48 81 c4 50 03
	00 00		 add	 rsp, 848		; 00000350H
  0020f	5f		 pop	 rdi
  00210	5e		 pop	 rsi
  00211	5d		 pop	 rbp
  00212	c3		 ret	 0
_PyImport_GetDynLoadWindows ENDP
_TEXT	ENDS
END
