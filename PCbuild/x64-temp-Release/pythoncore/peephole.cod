; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
EXTRN	PyList_Append:PROC
EXTRN	PyFrozenSet_New:PROC
EXTRN	PyTuple_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$tuple_of_constants DD imagerel tuple_of_constants
	DD	imagerel tuple_of_constants+71
	DD	imagerel $unwind$tuple_of_constants
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$tuple_of_constants DD imagerel tuple_of_constants+71
	DD	imagerel tuple_of_constants+163
	DD	imagerel $chain$2$tuple_of_constants
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$tuple_of_constants DD imagerel tuple_of_constants+163
	DD	imagerel tuple_of_constants+278
	DD	imagerel $chain$3$tuple_of_constants
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$tuple_of_constants DD 021H
	DD	imagerel tuple_of_constants
	DD	imagerel tuple_of_constants+71
	DD	imagerel $unwind$tuple_of_constants
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$tuple_of_constants DD 020521H
	DD	0dd405H
	DD	imagerel tuple_of_constants
	DD	imagerel tuple_of_constants+71
	DD	imagerel $unwind$tuple_of_constants
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tuple_of_constants DD 0a3e01H
	DD	0ee43eH
	DD	0c3439H
	DD	0f008520cH
	DD	07004c006H
	DD	050026003H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\peephole.c
xdata	ENDS
;	COMDAT tuple_of_constants
_TEXT	SEGMENT
codestr$ = 96
n$ = 104
consts$ = 112
objs$ = 120
tuple_of_constants PROC					; COMDAT

; 96   : {

  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	41 54		 push	 r12
  00006	41 57		 push	 r15
  00008	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000c	4c 8b e1	 mov	 r12, rcx

; 97   :     PyObject *newconst, *constant;
; 98   :     Py_ssize_t i, len_consts;
; 99   : 
; 100  :     /* Pre-conditions */
; 101  :     assert(PyList_CheckExact(consts));
; 102  : 
; 103  :     /* Buildup new tuple of constants */
; 104  :     newconst = PyTuple_New(n);

  0000f	48 8b ca	 mov	 rcx, rdx
  00012	49 8b f9	 mov	 rdi, r9
  00015	4d 8b f8	 mov	 r15, r8
  00018	48 8b ea	 mov	 rbp, rdx
  0001b	e8 00 00 00 00	 call	 PyTuple_New
  00020	48 8b f0	 mov	 rsi, rax

; 105  :     if (newconst == NULL)

  00023	48 85 c0	 test	 rax, rax
  00026	75 0c		 jne	 SHORT $LN7@tuple_of_c

; 136  : }

  00028	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002c	41 5f		 pop	 r15
  0002e	41 5c		 pop	 r12
  00030	5f		 pop	 rdi
  00031	5e		 pop	 rsi
  00032	5d		 pop	 rbp
  00033	c3		 ret	 0
$LN7@tuple_of_c:
  00034	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  00039	4c 89 74 24 70	 mov	 QWORD PTR [rsp+112], r14

; 106  :         return 0;
; 107  :     len_consts = PyList_GET_SIZE(consts);

  0003e	4d 8b 77 60	 mov	 r14, QWORD PTR [r15+96]

; 108  :     for (i=0 ; i<n ; i++) {

  00042	48 85 ed	 test	 rbp, rbp
  00045	7e 5c		 jle	 SHORT $LN4@tuple_of_c
  00047	4c 89 6c 24 68	 mov	 QWORD PTR [rsp+104], r13
  0004c	4c 8b e8	 mov	 r13, rax
  0004f	4c 2b ef	 sub	 r13, rdi
$LL6@tuple_of_c:

; 109  :         constant = objs[i];

  00052	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]

; 110  :         Py_INCREF(constant);

  00055	e8 00 00 00 00	 call	 _Py_PXCTX
  0005a	85 c0		 test	 eax, eax
  0005c	75 32		 jne	 SHORT $LN11@tuple_of_c
  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00065	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0006c	4c 8b cb	 mov	 r9, rbx
  0006f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00075	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0007d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00082	85 c0		 test	 eax, eax
  00084	75 06		 jne	 SHORT $LN10@tuple_of_c
  00086	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0008a	74 04		 je	 SHORT $LN11@tuple_of_c
$LN10@tuple_of_c:
  0008c	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN11@tuple_of_c:

; 111  :         PyTuple_SET_ITEM(newconst, i, constant);

  00090	49 89 5c 3d 70	 mov	 QWORD PTR [r13+rdi+112], rbx
  00095	48 83 c7 08	 add	 rdi, 8
  00099	48 ff cd	 dec	 rbp
  0009c	75 b4		 jne	 SHORT $LL6@tuple_of_c
  0009e	4c 8b 6c 24 68	 mov	 r13, QWORD PTR [rsp+104]
$LN4@tuple_of_c:

; 112  :     }
; 113  : 
; 114  :     /* If it's a BUILD_SET, use the PyTuple we just built to create a
; 115  :       PyFrozenSet, and use that as the constant instead: */
; 116  :     if (codestr[0] == BUILD_SET) {

  000a3	41 80 3c 24 68	 cmp	 BYTE PTR [r12], 104	; 00000068H
  000a8	75 1b		 jne	 SHORT $LN2@tuple_of_c

; 117  :         PyObject *tuple = newconst;
; 118  :         newconst = PyFrozenSet_New(tuple);

  000aa	48 8b ce	 mov	 rcx, rsi
  000ad	48 8b de	 mov	 rbx, rsi
  000b0	e8 00 00 00 00	 call	 PyFrozenSet_New

; 119  :         Py_DECREF(tuple);

  000b5	48 8b cb	 mov	 rcx, rbx
  000b8	48 8b f0	 mov	 rsi, rax
  000bb	e8 00 00 00 00	 call	 _Py_DecRef

; 120  :         if (newconst == NULL)

  000c0	48 85 f6	 test	 rsi, rsi

; 121  :             return 0;

  000c3	74 17		 je	 SHORT $LN18@tuple_of_c
$LN2@tuple_of_c:

; 122  :     }
; 123  : 
; 124  :     /* Append folded constant onto consts */
; 125  :     if (PyList_Append(consts, newconst)) {

  000c5	48 8b d6	 mov	 rdx, rsi
  000c8	49 8b cf	 mov	 rcx, r15
  000cb	e8 00 00 00 00	 call	 PyList_Append

; 126  :         Py_DECREF(newconst);

  000d0	48 8b ce	 mov	 rcx, rsi
  000d3	85 c0		 test	 eax, eax
  000d5	74 09		 je	 SHORT $LN1@tuple_of_c
  000d7	e8 00 00 00 00	 call	 _Py_DecRef
$LN18@tuple_of_c:

; 127  :         return 0;

  000dc	33 c0		 xor	 eax, eax
  000de	eb 20		 jmp	 SHORT $LN17@tuple_of_c
$LN1@tuple_of_c:

; 128  :     }
; 129  :     Py_DECREF(newconst);

  000e0	e8 00 00 00 00	 call	 _Py_DecRef

; 130  : 
; 131  :     /* Write NOPs over old LOAD_CONSTS and
; 132  :        add a new LOAD_CONST newconst on top of the BUILD_TUPLE n */
; 133  :     codestr[0] = LOAD_CONST;
; 134  :     SETARG(codestr, 0, len_consts);

  000e5	49 8b c6	 mov	 rax, r14
  000e8	41 c6 04 24 64	 mov	 BYTE PTR [r12], 100	; 00000064H
  000ed	48 c1 f8 08	 sar	 rax, 8
  000f1	45 88 74 24 01	 mov	 BYTE PTR [r12+1], r14b
  000f6	41 88 44 24 02	 mov	 BYTE PTR [r12+2], al

; 135  :     return 1;

  000fb	b8 01 00 00 00	 mov	 eax, 1
$LN17@tuple_of_c:
  00100	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00105	4c 8b 74 24 70	 mov	 r14, QWORD PTR [rsp+112]

; 136  : }

  0010a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0010e	41 5f		 pop	 r15
  00110	41 5c		 pop	 r12
  00112	5f		 pop	 rdi
  00113	5e		 pop	 rsi
  00114	5d		 pop	 rbp
  00115	c3		 ret	 0
tuple_of_constants ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CN@FPKFFBGO@unexpected?5binary?5operation?5?$CFd?5o@ ; `string'
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_SystemError:QWORD
EXTRN	PyObject_Size:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_KeyboardInterrupt:QWORD
EXTRN	PyNumber_Or:PROC
EXTRN	PyNumber_Xor:PROC
EXTRN	PyNumber_And:PROC
EXTRN	PyNumber_Rshift:PROC
EXTRN	PyNumber_Lshift:PROC
EXTRN	PyObject_GetItem:PROC
EXTRN	PyNumber_Subtract:PROC
EXTRN	PyNumber_Add:PROC
EXTRN	PyNumber_Remainder:PROC
EXTRN	PyNumber_FloorDivide:PROC
EXTRN	PyNumber_TrueDivide:PROC
EXTRN	PyNumber_Multiply:PROC
EXTRN	PyNumber_Power:PROC
EXTRN	_Py_NoneStruct:BYTE
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$fold_binops_on_constants DD imagerel fold_binops_on_constants
	DD	imagerel fold_binops_on_constants+261
	DD	imagerel $unwind$fold_binops_on_constants
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$fold_binops_on_constants DD imagerel fold_binops_on_constants+261
	DD	imagerel fold_binops_on_constants+310
	DD	imagerel $chain$0$fold_binops_on_constants
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$fold_binops_on_constants DD imagerel fold_binops_on_constants+310
	DD	imagerel fold_binops_on_constants+342
	DD	imagerel $chain$1$fold_binops_on_constants
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$fold_binops_on_constants DD imagerel fold_binops_on_constants+342
	DD	imagerel fold_binops_on_constants+371
	DD	imagerel $chain$2$fold_binops_on_constants
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$fold_binops_on_constants DD imagerel fold_binops_on_constants+371
	DD	imagerel fold_binops_on_constants+516
	DD	imagerel $chain$3$fold_binops_on_constants
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$fold_binops_on_constants DD 021H
	DD	imagerel fold_binops_on_constants
	DD	imagerel fold_binops_on_constants+261
	DD	imagerel $unwind$fold_binops_on_constants
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$fold_binops_on_constants DD 020021H
	DD	067400H
	DD	imagerel fold_binops_on_constants
	DD	imagerel fold_binops_on_constants+261
	DD	imagerel $unwind$fold_binops_on_constants
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$fold_binops_on_constants DD 021H
	DD	imagerel fold_binops_on_constants
	DD	imagerel fold_binops_on_constants+261
	DD	imagerel $unwind$fold_binops_on_constants
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$fold_binops_on_constants DD 020521H
	DD	067405H
	DD	imagerel fold_binops_on_constants
	DD	imagerel fold_binops_on_constants+261
	DD	imagerel $unwind$fold_binops_on_constants
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fold_binops_on_constants DD 060f01H
	DD	08540fH
	DD	07340fH
	DD	0600b320fH
xdata	ENDS
;	COMDAT ??_C@_0CN@FPKFFBGO@unexpected?5binary?5operation?5?$CFd?5o@
CONST	SEGMENT
??_C@_0CN@FPKFFBGO@unexpected?5binary?5operation?5?$CFd?5o@ DB 'unexpecte'
	DB	'd binary operation %d on a constant', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT fold_binops_on_constants
_TEXT	SEGMENT
codestr$ = 48
consts$ = 56
objs$ = 64
fold_binops_on_constants PROC				; COMDAT

; 150  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f1	 mov	 rsi, rcx

; 151  :     PyObject *newconst, *v, *w;
; 152  :     Py_ssize_t len_consts, size;
; 153  :     int opcode;
; 154  : 
; 155  :     /* Pre-conditions */
; 156  :     assert(PyList_CheckExact(consts));
; 157  : 
; 158  :     /* Create new constant */
; 159  :     v = objs[0];

  00012	49 8b 08	 mov	 rcx, QWORD PTR [r8]
  00015	48 8b ea	 mov	 rbp, rdx

; 160  :     w = objs[1];
; 161  :     opcode = codestr[0];

  00018	44 0f b6 0e	 movzx	 r9d, BYTE PTR [rsi]
  0001c	49 8b 50 08	 mov	 rdx, QWORD PTR [r8+8]

; 162  :     switch (opcode) {

  00020	41 8d 41 ed	 lea	 eax, DWORD PTR [r9-19]
  00024	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00027	0f 87 46 01 00
	00		 ja	 $LN8@fold_binop
  0002d	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:__ImageBase
  00034	48 98		 cdqe
  00036	41 0f b6 84 02
	00 00 00 00	 movzx	 eax, BYTE PTR $LN26@fold_binop[r10+rax]
  0003f	45 8b 84 82 00
	00 00 00	 mov	 r8d, DWORD PTR $LN27@fold_binop[r10+rax*4]
  00047	4d 03 c2	 add	 r8, r10
  0004a	41 ff e0	 jmp	 r8
$LN21@fold_binop:

; 163  :         case BINARY_POWER:
; 164  :             newconst = PyNumber_Power(v, w, Py_None);

  0004d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_NoneStruct
  00054	e8 00 00 00 00	 call	 PyNumber_Power

; 165  :             break;

  00059	eb 52		 jmp	 SHORT $LN29@fold_binop
$LN20@fold_binop:

; 166  :         case BINARY_MULTIPLY:
; 167  :             newconst = PyNumber_Multiply(v, w);

  0005b	e8 00 00 00 00	 call	 PyNumber_Multiply

; 168  :             break;

  00060	eb 4b		 jmp	 SHORT $LN29@fold_binop
$LN19@fold_binop:

; 169  :         case BINARY_TRUE_DIVIDE:
; 170  :             newconst = PyNumber_TrueDivide(v, w);

  00062	e8 00 00 00 00	 call	 PyNumber_TrueDivide

; 171  :             break;

  00067	eb 44		 jmp	 SHORT $LN29@fold_binop
$LN18@fold_binop:

; 172  :         case BINARY_FLOOR_DIVIDE:
; 173  :             newconst = PyNumber_FloorDivide(v, w);

  00069	e8 00 00 00 00	 call	 PyNumber_FloorDivide

; 174  :             break;

  0006e	eb 3d		 jmp	 SHORT $LN29@fold_binop
$LN17@fold_binop:

; 175  :         case BINARY_MODULO:
; 176  :             newconst = PyNumber_Remainder(v, w);

  00070	e8 00 00 00 00	 call	 PyNumber_Remainder

; 177  :             break;

  00075	eb 36		 jmp	 SHORT $LN29@fold_binop
$LN16@fold_binop:

; 178  :         case BINARY_ADD:
; 179  :             newconst = PyNumber_Add(v, w);

  00077	e8 00 00 00 00	 call	 PyNumber_Add

; 180  :             break;

  0007c	eb 2f		 jmp	 SHORT $LN29@fold_binop
$LN15@fold_binop:

; 181  :         case BINARY_SUBTRACT:
; 182  :             newconst = PyNumber_Subtract(v, w);

  0007e	e8 00 00 00 00	 call	 PyNumber_Subtract

; 183  :             break;

  00083	eb 28		 jmp	 SHORT $LN29@fold_binop
$LN14@fold_binop:

; 184  :         case BINARY_SUBSCR:
; 185  :             newconst = PyObject_GetItem(v, w);

  00085	e8 00 00 00 00	 call	 PyObject_GetItem

; 186  :             break;

  0008a	eb 21		 jmp	 SHORT $LN29@fold_binop
$LN13@fold_binop:

; 187  :         case BINARY_LSHIFT:
; 188  :             newconst = PyNumber_Lshift(v, w);

  0008c	e8 00 00 00 00	 call	 PyNumber_Lshift

; 189  :             break;

  00091	eb 1a		 jmp	 SHORT $LN29@fold_binop
$LN12@fold_binop:

; 190  :         case BINARY_RSHIFT:
; 191  :             newconst = PyNumber_Rshift(v, w);

  00093	e8 00 00 00 00	 call	 PyNumber_Rshift

; 192  :             break;

  00098	eb 13		 jmp	 SHORT $LN29@fold_binop
$LN11@fold_binop:

; 193  :         case BINARY_AND:
; 194  :             newconst = PyNumber_And(v, w);

  0009a	e8 00 00 00 00	 call	 PyNumber_And

; 195  :             break;

  0009f	eb 0c		 jmp	 SHORT $LN29@fold_binop
$LN10@fold_binop:

; 196  :         case BINARY_XOR:
; 197  :             newconst = PyNumber_Xor(v, w);

  000a1	e8 00 00 00 00	 call	 PyNumber_Xor

; 198  :             break;

  000a6	eb 05		 jmp	 SHORT $LN29@fold_binop
$LN9@fold_binop:

; 199  :         case BINARY_OR:
; 200  :             newconst = PyNumber_Or(v, w);

  000a8	e8 00 00 00 00	 call	 PyNumber_Or
$LN29@fold_binop:
  000ad	48 8b d8	 mov	 rbx, rax

; 207  :             return 0;
; 208  :     }
; 209  :     if (newconst == NULL) {

  000b0	48 85 c0	 test	 rax, rax
  000b3	75 27		 jne	 SHORT $LN7@fold_binop

; 210  :         if(!PyErr_ExceptionMatches(PyExc_KeyboardInterrupt))

  000b5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyboardInterrupt
  000bc	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  000c1	85 c0		 test	 eax, eax
  000c3	75 05		 jne	 SHORT $LN6@fold_binop

; 211  :             PyErr_Clear();

  000c5	e8 00 00 00 00	 call	 PyErr_Clear
$LN6@fold_binop:

; 212  :         return 0;

  000ca	33 c0		 xor	 eax, eax

; 236  : }

  000cc	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000d1	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000d6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000da	5e		 pop	 rsi
  000db	c3		 ret	 0
$LN7@fold_binop:

; 213  :     }
; 214  :     size = PyObject_Size(newconst);

  000dc	48 8b cb	 mov	 rcx, rbx
  000df	e8 00 00 00 00	 call	 PyObject_Size

; 215  :     if (size == -1) {

  000e4	48 83 f8 ff	 cmp	 rax, -1
  000e8	75 4c		 jne	 SHORT $LN5@fold_binop

; 216  :         if (PyErr_ExceptionMatches(PyExc_KeyboardInterrupt))

  000ea	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyboardInterrupt
  000f1	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  000f6	85 c0		 test	 eax, eax

; 217  :             return 0;

  000f8	75 d0		 jne	 SHORT $LN6@fold_binop

; 218  :         PyErr_Clear();

  000fa	e8 00 00 00 00	 call	 PyErr_Clear
$LN2@fold_binop:

; 222  :     }
; 223  : 
; 224  :     /* Append folded constant into consts table */
; 225  :     len_consts = PyList_GET_SIZE(consts);
; 226  :     if (PyList_Append(consts, newconst)) {

  000ff	48 8b d3	 mov	 rdx, rbx
  00102	48 8b cd	 mov	 rcx, rbp
  00105	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0010a	48 8b 7d 60	 mov	 rdi, QWORD PTR [rbp+96]
  0010e	e8 00 00 00 00	 call	 PyList_Append

; 227  :         Py_DECREF(newconst);

  00113	48 8b cb	 mov	 rcx, rbx
  00116	85 c0		 test	 eax, eax
  00118	74 3c		 je	 SHORT $LN1@fold_binop
  0011a	e8 00 00 00 00	 call	 _Py_DecRef

; 228  :         return 0;

  0011f	33 c0		 xor	 eax, eax
$LN28@fold_binop:
  00121	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 236  : }

  00126	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0012b	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00130	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00134	5e		 pop	 rsi
  00135	c3		 ret	 0
$LN5@fold_binop:

; 219  :     } else if (size > 20) {

  00136	48 83 f8 14	 cmp	 rax, 20
  0013a	7e c3		 jle	 SHORT $LN2@fold_binop

; 220  :         Py_DECREF(newconst);

  0013c	48 8b cb	 mov	 rcx, rbx
  0013f	e8 00 00 00 00	 call	 _Py_DecRef

; 221  :         return 0;

  00144	33 c0		 xor	 eax, eax

; 236  : }

  00146	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0014b	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00150	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00154	5e		 pop	 rsi
  00155	c3		 ret	 0
$LN1@fold_binop:

; 229  :     }
; 230  :     Py_DECREF(newconst);

  00156	e8 00 00 00 00	 call	 _Py_DecRef

; 231  : 
; 232  :     /* Write NOP NOP NOP NOP LOAD_CONST newconst */
; 233  :     codestr[-2] = LOAD_CONST;
; 234  :     SETARG(codestr, -2, len_consts);

  0015b	48 8b c7	 mov	 rax, rdi
  0015e	c6 46 fe 64	 mov	 BYTE PTR [rsi-2], 100	; 00000064H
  00162	48 c1 f8 08	 sar	 rax, 8
  00166	40 88 7e ff	 mov	 BYTE PTR [rsi-1], dil
  0016a	88 06		 mov	 BYTE PTR [rsi], al

; 235  :     return 1;

  0016c	b8 01 00 00 00	 mov	 eax, 1
  00171	eb ae		 jmp	 SHORT $LN28@fold_binop
$LN8@fold_binop:

; 201  :             break;
; 202  :         default:
; 203  :             /* Called with an unknown opcode */
; 204  :             PyErr_Format(PyExc_SystemError,
; 205  :                  "unexpected binary operation %d on a constant",
; 206  :                      opcode);

  00173	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0017a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@FPKFFBGO@unexpected?5binary?5operation?5?$CFd?5o@
  00181	45 8b c1	 mov	 r8d, r9d
  00184	e8 00 00 00 00	 call	 PyErr_Format

; 236  : }

  00189	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0018e	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00193	33 c0		 xor	 eax, eax
  00195	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00199	5e		 pop	 rsi
  0019a	c3		 ret	 0
  0019b	90		 npad	 1
$LN27@fold_binop:
  0019c	00 00 00 00	 DD	 $LN21@fold_binop
  001a0	00 00 00 00	 DD	 $LN20@fold_binop
  001a4	00 00 00 00	 DD	 $LN17@fold_binop
  001a8	00 00 00 00	 DD	 $LN16@fold_binop
  001ac	00 00 00 00	 DD	 $LN15@fold_binop
  001b0	00 00 00 00	 DD	 $LN14@fold_binop
  001b4	00 00 00 00	 DD	 $LN18@fold_binop
  001b8	00 00 00 00	 DD	 $LN19@fold_binop
  001bc	00 00 00 00	 DD	 $LN13@fold_binop
  001c0	00 00 00 00	 DD	 $LN12@fold_binop
  001c4	00 00 00 00	 DD	 $LN11@fold_binop
  001c8	00 00 00 00	 DD	 $LN10@fold_binop
  001cc	00 00 00 00	 DD	 $LN9@fold_binop
  001d0	00 00 00 00	 DD	 $LN8@fold_binop
$LN26@fold_binop:
  001d4	00		 DB	 0
  001d5	01		 DB	 1
  001d6	0d		 DB	 13
  001d7	02		 DB	 2
  001d8	03		 DB	 3
  001d9	04		 DB	 4
  001da	05		 DB	 5
  001db	06		 DB	 6
  001dc	07		 DB	 7
  001dd	0d		 DB	 13
  001de	0d		 DB	 13
  001df	0d		 DB	 13
  001e0	0d		 DB	 13
  001e1	0d		 DB	 13
  001e2	0d		 DB	 13
  001e3	0d		 DB	 13
  001e4	0d		 DB	 13
  001e5	0d		 DB	 13
  001e6	0d		 DB	 13
  001e7	0d		 DB	 13
  001e8	0d		 DB	 13
  001e9	0d		 DB	 13
  001ea	0d		 DB	 13
  001eb	0d		 DB	 13
  001ec	0d		 DB	 13
  001ed	0d		 DB	 13
  001ee	0d		 DB	 13
  001ef	0d		 DB	 13
  001f0	0d		 DB	 13
  001f1	0d		 DB	 13
  001f2	0d		 DB	 13
  001f3	0d		 DB	 13
  001f4	0d		 DB	 13
  001f5	0d		 DB	 13
  001f6	0d		 DB	 13
  001f7	0d		 DB	 13
  001f8	0d		 DB	 13
  001f9	0d		 DB	 13
  001fa	0d		 DB	 13
  001fb	0d		 DB	 13
  001fc	0d		 DB	 13
  001fd	0d		 DB	 13
  001fe	0d		 DB	 13
  001ff	08		 DB	 8
  00200	09		 DB	 9
  00201	0a		 DB	 10
  00202	0b		 DB	 11
  00203	0c		 DB	 12
fold_binops_on_constants ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@NBMLINOO@unexpected?5unary?5operation?5?$CFd?5on@ ; `string'
EXTRN	PyNumber_Positive:PROC
EXTRN	PyNumber_Negative:PROC
EXTRN	PyNumber_Invert:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fold_unaryops_on_constants DD imagerel fold_unaryops_on_constants
	DD	imagerel fold_unaryops_on_constants+246
	DD	imagerel $unwind$fold_unaryops_on_constants
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fold_unaryops_on_constants DD 08ab01H
	DD	0664abH
	DD	08540fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0CM@NBMLINOO@unexpected?5unary?5operation?5?$CFd?5on@
CONST	SEGMENT
??_C@_0CM@NBMLINOO@unexpected?5unary?5operation?5?$CFd?5on@ DB 'unexpecte'
	DB	'd unary operation %d on a constant', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT fold_unaryops_on_constants
_TEXT	SEGMENT
codestr$ = 48
consts$ = 56
v$ = 64
fold_unaryops_on_constants PROC				; COMDAT

; 240  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f9	 mov	 rdi, rcx

; 241  :     PyObject *newconst;
; 242  :     Py_ssize_t len_consts;
; 243  :     int opcode;
; 244  : 
; 245  :     /* Pre-conditions */
; 246  :     assert(PyList_CheckExact(consts));
; 247  :     assert(codestr[0] == LOAD_CONST);
; 248  : 
; 249  :     /* Create new constant */
; 250  :     opcode = codestr[3];

  00012	0f b6 49 03	 movzx	 ecx, BYTE PTR [rcx+3]
  00016	48 8b ea	 mov	 rbp, rdx

; 251  :     switch (opcode) {

  00019	44 8b c9	 mov	 r9d, ecx
  0001c	41 83 e9 0a	 sub	 r9d, 10
  00020	74 47		 je	 SHORT $LN5@fold_unary
  00022	41 ff c9	 dec	 r9d
  00025	74 38		 je	 SHORT $LN7@fold_unary
  00027	41 83 f9 04	 cmp	 r9d, 4
  0002b	74 28		 je	 SHORT $LN6@fold_unary

; 260  :             break;
; 261  :         default:
; 262  :             /* Called with an unknown opcode */
; 263  :             PyErr_Format(PyExc_SystemError,
; 264  :                  "unexpected unary operation %d on a constant",
; 265  :                      opcode);

  0002d	44 8b c1	 mov	 r8d, ecx
  00030	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@NBMLINOO@unexpected?5unary?5operation?5?$CFd?5on@
  0003e	e8 00 00 00 00	 call	 PyErr_Format

; 266  :             return 0;

  00043	33 c0		 xor	 eax, eax

; 287  : }

  00045	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0004a	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0004f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00053	5f		 pop	 rdi
  00054	c3		 ret	 0
$LN6@fold_unary:

; 255  :         case UNARY_INVERT:
; 256  :             newconst = PyNumber_Invert(v);

  00055	49 8b c8	 mov	 rcx, r8
  00058	e8 00 00 00 00	 call	 PyNumber_Invert

; 257  :             break;

  0005d	eb 12		 jmp	 SHORT $LN13@fold_unary
$LN7@fold_unary:

; 252  :         case UNARY_NEGATIVE:
; 253  :             newconst = PyNumber_Negative(v);

  0005f	49 8b c8	 mov	 rcx, r8
  00062	e8 00 00 00 00	 call	 PyNumber_Negative

; 254  :             break;

  00067	eb 08		 jmp	 SHORT $LN13@fold_unary
$LN5@fold_unary:

; 258  :         case UNARY_POSITIVE:
; 259  :             newconst = PyNumber_Positive(v);

  00069	49 8b c8	 mov	 rcx, r8
  0006c	e8 00 00 00 00	 call	 PyNumber_Positive
$LN13@fold_unary:
  00071	48 8b d8	 mov	 rbx, rax

; 267  :     }
; 268  :     if (newconst == NULL) {

  00074	48 85 c0	 test	 rax, rax
  00077	75 27		 jne	 SHORT $LN3@fold_unary

; 269  :         if(!PyErr_ExceptionMatches(PyExc_KeyboardInterrupt))

  00079	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyboardInterrupt
  00080	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00085	85 c0		 test	 eax, eax
  00087	75 05		 jne	 SHORT $LN2@fold_unary

; 270  :             PyErr_Clear();

  00089	e8 00 00 00 00	 call	 PyErr_Clear
$LN2@fold_unary:

; 271  :         return 0;

  0008e	33 c0		 xor	 eax, eax

; 287  : }

  00090	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00095	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0009a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009e	5f		 pop	 rdi
  0009f	c3		 ret	 0
$LN3@fold_unary:

; 272  :     }
; 273  : 
; 274  :     /* Append folded constant into consts table */
; 275  :     len_consts = PyList_GET_SIZE(consts);
; 276  :     if (PyList_Append(consts, newconst)) {

  000a0	48 8b d3	 mov	 rdx, rbx
  000a3	48 8b cd	 mov	 rcx, rbp
  000a6	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  000ab	48 8b 75 60	 mov	 rsi, QWORD PTR [rbp+96]
  000af	e8 00 00 00 00	 call	 PyList_Append

; 277  :         Py_DECREF(newconst);

  000b4	48 8b cb	 mov	 rcx, rbx
  000b7	85 c0		 test	 eax, eax
  000b9	74 09		 je	 SHORT $LN1@fold_unary
  000bb	e8 00 00 00 00	 call	 _Py_DecRef

; 278  :         return 0;

  000c0	33 c0		 xor	 eax, eax
  000c2	eb 1d		 jmp	 SHORT $LN12@fold_unary
$LN1@fold_unary:

; 279  :     }
; 280  :     Py_DECREF(newconst);

  000c4	e8 00 00 00 00	 call	 _Py_DecRef

; 281  : 
; 282  :     /* Write NOP LOAD_CONST newconst */
; 283  :     codestr[0] = NOP;
; 284  :     codestr[1] = LOAD_CONST;
; 285  :     SETARG(codestr, 1, len_consts);

  000c9	48 8b c6	 mov	 rax, rsi
  000cc	66 c7 07 09 64	 mov	 WORD PTR [rdi], 25609	; 00006409H
  000d1	48 c1 f8 08	 sar	 rax, 8
  000d5	40 88 77 02	 mov	 BYTE PTR [rdi+2], sil
  000d9	88 47 03	 mov	 BYTE PTR [rdi+3], al

; 286  :     return 1;

  000dc	b8 01 00 00 00	 mov	 eax, 1
$LN12@fold_unary:

; 287  : }

  000e1	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  000e6	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000eb	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000f0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f4	5f		 pop	 rdi
  000f5	c3		 ret	 0
fold_unaryops_on_constants ENDP
_TEXT	ENDS
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyMem_Malloc:PROC
EXTRN	memset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$markblocks DD imagerel markblocks
	DD	imagerel markblocks+363
	DD	imagerel $unwind$markblocks
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$markblocks DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT markblocks
_TEXT	SEGMENT
code$ = 48
len$ = 56
markblocks PROC						; COMDAT

; 291  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 292  :     unsigned int *blocks = (unsigned int *)PyMem_Malloc(len*sizeof(int));

  0001a	48 8d 34 95 00
	00 00 00	 lea	 rsi, QWORD PTR [rdx*4]
  00022	4c 8b e1	 mov	 r12, rcx
  00025	48 8b fa	 mov	 rdi, rdx
  00028	48 8b ce	 mov	 rcx, rsi
  0002b	e8 00 00 00 00	 call	 PyMem_Malloc

; 293  :     int i,j, opcode, blockcnt = 0;

  00030	33 db		 xor	 ebx, ebx
  00032	48 8b e8	 mov	 rbp, rax

; 294  : 
; 295  :     if (blocks == NULL) {

  00035	48 85 c0	 test	 rax, rax
  00038	75 0c		 jne	 SHORT $LN10@markblocks

; 296  :         PyErr_NoMemory();

  0003a	e8 00 00 00 00	 call	 PyErr_NoMemory

; 297  :         return NULL;

  0003f	33 c0		 xor	 eax, eax
  00041	e9 cf 00 00 00	 jmp	 $LN11@markblocks
$LN10@markblocks:

; 298  :     }
; 299  :     memset(blocks, 0, len*sizeof(int));

  00046	4c 8b c6	 mov	 r8, rsi
  00049	33 d2		 xor	 edx, edx
  0004b	48 8b c8	 mov	 rcx, rax
  0004e	e8 00 00 00 00	 call	 memset

; 300  : 
; 301  :     /* Mark labels in the first pass */
; 302  :     for (i=0 ; i<len ; i+=CODESIZE(opcode)) {

  00053	44 8b db	 mov	 r11d, ebx
  00056	48 85 ff	 test	 rdi, rdi
  00059	0f 8e 91 00 00
	00		 jle	 $LN7@markblocks
  0005f	4c 8b c3	 mov	 r8, rbx
  00062	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:__ImageBase
  00069	41 ba 03 00 00
	00		 mov	 r10d, 3
  0006f	90		 npad	 1
$LL9@markblocks:

; 303  :         opcode = code[i];

  00070	43 0f b6 14 20	 movzx	 edx, BYTE PTR [r8+r12]

; 304  :         switch (opcode) {

  00075	8d 42 a3	 lea	 eax, DWORD PTR [rdx-93]
  00078	83 f8 32	 cmp	 eax, 50			; 00000032H
  0007b	77 5c		 ja	 SHORT $LN8@markblocks
  0007d	48 98		 cdqe
  0007f	0f b6 84 06 00
	00 00 00	 movzx	 eax, BYTE PTR $LN19@markblocks[rsi+rax]
  00087	8b 8c 86 00 00
	00 00		 mov	 ecx, DWORD PTR $LN20@markblocks[rsi+rax*4]
  0008e	48 03 ce	 add	 rcx, rsi
  00091	ff e1		 jmp	 rcx
$LN4@markblocks:

; 305  :             case FOR_ITER:
; 306  :             case JUMP_FORWARD:
; 307  :             case JUMP_IF_FALSE_OR_POP:
; 308  :             case JUMP_IF_TRUE_OR_POP:
; 309  :             case POP_JUMP_IF_FALSE:
; 310  :             case POP_JUMP_IF_TRUE:
; 311  :             case JUMP_ABSOLUTE:
; 312  :             case CONTINUE_LOOP:
; 313  :             case SETUP_LOOP:
; 314  :             case SETUP_EXCEPT:
; 315  :             case SETUP_FINALLY:
; 316  :             case SETUP_WITH:
; 317  :                 j = GETJUMPTGT(code, i);

  00093	80 fa 71	 cmp	 dl, 113			; 00000071H
  00096	74 1d		 je	 SHORT $LN13@markblocks
  00098	80 fa 77	 cmp	 dl, 119			; 00000077H
  0009b	74 18		 je	 SHORT $LN13@markblocks
  0009d	80 fa 72	 cmp	 dl, 114			; 00000072H
  000a0	74 13		 je	 SHORT $LN13@markblocks
  000a2	80 fa 73	 cmp	 dl, 115			; 00000073H
  000a5	74 0e		 je	 SHORT $LN13@markblocks
  000a7	80 fa 6f	 cmp	 dl, 111			; 0000006fH
  000aa	74 09		 je	 SHORT $LN13@markblocks
  000ac	45 8d 4b 03	 lea	 r9d, DWORD PTR [r11+3]
  000b0	80 fa 70	 cmp	 dl, 112			; 00000070H
  000b3	75 03		 jne	 SHORT $LN14@markblocks
$LN13@markblocks:
  000b5	44 8b cb	 mov	 r9d, ebx
$LN14@markblocks:

; 318  :                 blocks[j] = 1;

  000b8	43 0f b6 44 20
	01		 movzx	 eax, BYTE PTR [r8+r12+1]
  000be	43 0f b6 4c 20
	02		 movzx	 ecx, BYTE PTR [r8+r12+2]
  000c4	48 c1 e1 08	 shl	 rcx, 8
  000c8	48 03 c8	 add	 rcx, rax
  000cb	49 63 c1	 movsxd	 rax, r9d
  000ce	48 03 c8	 add	 rcx, rax
  000d1	c7 44 8d 00 01
	00 00 00	 mov	 DWORD PTR [rbp+rcx*4], 1
$LN8@markblocks:

; 300  : 
; 301  :     /* Mark labels in the first pass */
; 302  :     for (i=0 ; i<len ; i+=CODESIZE(opcode)) {

  000d9	83 fa 5a	 cmp	 edx, 90			; 0000005aH
  000dc	b8 01 00 00 00	 mov	 eax, 1
  000e1	41 0f 4d c2	 cmovge	 eax, r10d
  000e5	44 03 d8	 add	 r11d, eax
  000e8	4d 63 c3	 movsxd	 r8, r11d
  000eb	4c 3b c7	 cmp	 r8, rdi
  000ee	7c 80		 jl	 SHORT $LL9@markblocks
$LN7@markblocks:

; 319  :                 break;
; 320  :         }
; 321  :     }
; 322  :     /* Build block numbers in the second pass */
; 323  :     for (i=0 ; i<len ; i++) {

  000f0	8b d3		 mov	 edx, ebx
  000f2	48 85 ff	 test	 rdi, rdi
  000f5	7e 1b		 jle	 SHORT $LN1@markblocks
  000f7	48 8b cd	 mov	 rcx, rbp
  000fa	66 0f 1f 44 00
	00		 npad	 6
$LL3@markblocks:

; 324  :         blockcnt += blocks[i];          /* increment blockcnt over labels */
; 325  :         blocks[i] = blockcnt;

  00100	01 19		 add	 DWORD PTR [rcx], ebx
  00102	8b 19		 mov	 ebx, DWORD PTR [rcx]
  00104	ff c2		 inc	 edx
  00106	48 63 c2	 movsxd	 rax, edx
  00109	48 83 c1 04	 add	 rcx, 4
  0010d	48 3b c7	 cmp	 rax, rdi
  00110	7c ee		 jl	 SHORT $LL3@markblocks
$LN1@markblocks:

; 326  :     }
; 327  :     return blocks;

  00112	48 8b c5	 mov	 rax, rbp
$LN11@markblocks:

; 328  : }

  00115	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0011a	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0011f	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00124	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00129	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0012d	41 5c		 pop	 r12
  0012f	c3		 ret	 0
$LN20@markblocks:
  00130	00 00 00 00	 DD	 $LN4@markblocks
  00134	00 00 00 00	 DD	 $LN8@markblocks
$LN19@markblocks:
  00138	00		 DB	 0
  00139	01		 DB	 1
  0013a	01		 DB	 1
  0013b	01		 DB	 1
  0013c	01		 DB	 1
  0013d	01		 DB	 1
  0013e	01		 DB	 1
  0013f	01		 DB	 1
  00140	01		 DB	 1
  00141	01		 DB	 1
  00142	01		 DB	 1
  00143	01		 DB	 1
  00144	01		 DB	 1
  00145	01		 DB	 1
  00146	01		 DB	 1
  00147	01		 DB	 1
  00148	01		 DB	 1
  00149	00		 DB	 0
  0014a	00		 DB	 0
  0014b	00		 DB	 0
  0014c	00		 DB	 0
  0014d	00		 DB	 0
  0014e	00		 DB	 0
  0014f	01		 DB	 1
  00150	01		 DB	 1
  00151	01		 DB	 1
  00152	00		 DB	 0
  00153	00		 DB	 0
  00154	00		 DB	 0
  00155	00		 DB	 0
  00156	01		 DB	 1
  00157	01		 DB	 1
  00158	01		 DB	 1
  00159	01		 DB	 1
  0015a	01		 DB	 1
  0015b	01		 DB	 1
  0015c	01		 DB	 1
  0015d	01		 DB	 1
  0015e	01		 DB	 1
  0015f	01		 DB	 1
  00160	01		 DB	 1
  00161	01		 DB	 1
  00162	01		 DB	 1
  00163	01		 DB	 1
  00164	01		 DB	 1
  00165	01		 DB	 1
  00166	01		 DB	 1
  00167	01		 DB	 1
  00168	01		 DB	 1
  00169	01		 DB	 1
  0016a	00		 DB	 0
markblocks ENDP
_TEXT	ENDS
PUBLIC	??_C@_05MKDOIIA@False?$AA@			; `string'
PUBLIC	??_C@_04HPMIDMKH@True?$AA@			; `string'
PUBLIC	??_C@_04OHJIHAFH@None?$AA@			; `string'
EXTRN	_Py_FalseStruct:BYTE
EXTRN	_Py_TrueStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_global DD imagerel load_global
	DD	imagerel load_global+233
	DD	imagerel $unwind$load_global
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_global DD 082c01H
	DD	07742cH
	DD	066427H
	DD	08340aH
	DD	05006320aH
xdata	ENDS
;	COMDAT ??_C@_05MKDOIIA@False?$AA@
CONST	SEGMENT
??_C@_05MKDOIIA@False?$AA@ DB 'False', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HPMIDMKH@True?$AA@
CONST	SEGMENT
??_C@_04HPMIDMKH@True?$AA@ DB 'True', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHJIHAFH@None?$AA@
CONST	SEGMENT
??_C@_04OHJIHAFH@None?$AA@ DB 'None', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT load_global
_TEXT	SEGMENT
codestr$ = 48
i$ = 56
name$ = 64
consts$ = 72
load_global PROC					; COMDAT

; 334  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	48 8b e9	 mov	 rbp, rcx

; 335  :     Py_ssize_t j;
; 336  :     PyObject *obj;
; 337  :     if (name == NULL)

  00010	4d 85 c0	 test	 r8, r8
  00013	75 0d		 jne	 SHORT $LN13@load_globa

; 338  :         return 0;

  00015	33 c0		 xor	 eax, eax

; 359  : }

  00017	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5d		 pop	 rbp
  00021	c3		 ret	 0
$LN13@load_globa:
  00022	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00027	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi

; 339  :     if (strcmp(name, "None") == 0)

  0002c	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_04OHJIHAFH@None?$AA@
  00033	49 8b f0	 mov	 rsi, r8
  00036	b9 05 00 00 00	 mov	 ecx, 5
  0003b	f3 a6		 repe cmpsb
  0003d	75 09		 jne	 SHORT $LN12@load_globa

; 340  :         obj = Py_None;

  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct
  00046	eb 36		 jmp	 SHORT $LN7@load_globa
$LN12@load_globa:

; 341  :     else if (strcmp(name, "True") == 0)

  00048	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_04HPMIDMKH@True?$AA@
  0004f	49 8b f0	 mov	 rsi, r8
  00052	b9 05 00 00 00	 mov	 ecx, 5
  00057	f3 a6		 repe cmpsb
  00059	75 09		 jne	 SHORT $LN10@load_globa

; 342  :         obj = Py_True;

  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_TrueStruct
  00062	eb 1a		 jmp	 SHORT $LN7@load_globa
$LN10@load_globa:

; 343  :     else if (strcmp(name, "False") == 0)

  00064	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_05MKDOIIA@False?$AA@
  0006b	49 8b f0	 mov	 rsi, r8
  0006e	b9 06 00 00 00	 mov	 ecx, 6
  00073	f3 a6		 repe cmpsb
  00075	75 5b		 jne	 SHORT $LN8@load_globa

; 344  :         obj = Py_False;

  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_FalseStruct
$LN7@load_globa:

; 347  :     for (j = 0; j < PyList_GET_SIZE(consts); j++) {

  0007e	49 8b 49 60	 mov	 rcx, QWORD PTR [r9+96]
  00082	33 ff		 xor	 edi, edi
  00084	48 85 c9	 test	 rcx, rcx
  00087	7e 18		 jle	 SHORT $LN19@load_globa
  00089	49 8b 41 70	 mov	 rax, QWORD PTR [r9+112]
  0008d	0f 1f 00	 npad	 3
$LL6@load_globa:

; 348  :         if (PyList_GET_ITEM(consts, j) == obj)

  00090	48 39 10	 cmp	 QWORD PTR [rax], rdx
  00093	74 0c		 je	 SHORT $LN19@load_globa

; 347  :     for (j = 0; j < PyList_GET_SIZE(consts); j++) {

  00095	48 ff c7	 inc	 rdi
  00098	48 83 c0 08	 add	 rax, 8
  0009c	48 3b f9	 cmp	 rdi, rcx
  0009f	7c ef		 jl	 SHORT $LL6@load_globa
$LN19@load_globa:

; 349  :             break;
; 350  :     }
; 351  :     if (j == PyList_GET_SIZE(consts)) {

  000a1	48 3b f9	 cmp	 rdi, rcx
  000a4	75 11		 jne	 SHORT $LN1@load_globa

; 352  :         if (PyList_Append(consts, obj) < 0)

  000a6	49 8b c9	 mov	 rcx, r9
  000a9	e8 00 00 00 00	 call	 PyList_Append
  000ae	85 c0		 test	 eax, eax
  000b0	79 05		 jns	 SHORT $LN1@load_globa

; 353  :             return -1;

  000b2	83 c8 ff	 or	 eax, -1
  000b5	eb 1d		 jmp	 SHORT $LN21@load_globa
$LN1@load_globa:

; 354  :     }
; 355  :     assert(PyList_GET_ITEM(consts, j) == obj);
; 356  :     codestr[i] = LOAD_CONST;
; 357  :     SETARG(codestr, i, j);

  000b7	48 8b c7	 mov	 rax, rdi
  000ba	c6 04 2b 64	 mov	 BYTE PTR [rbx+rbp], 100	; 00000064H
  000be	40 88 7c 2b 01	 mov	 BYTE PTR [rbx+rbp+1], dil
  000c3	48 c1 f8 08	 sar	 rax, 8
  000c7	88 44 2b 02	 mov	 BYTE PTR [rbx+rbp+2], al

; 358  :     return 1;

  000cb	b8 01 00 00 00	 mov	 eax, 1
  000d0	eb 02		 jmp	 SHORT $LN21@load_globa
$LN8@load_globa:

; 345  :     else
; 346  :         return 0;

  000d2	33 c0		 xor	 eax, eax
$LN21@load_globa:
  000d4	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  000d9	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 359  : }

  000de	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e7	5d		 pop	 rbp
  000e8	c3		 ret	 0
load_global ENDP
_TEXT	ENDS
PUBLIC	PyCode_Optimize
EXTRN	PyMem_Free:PROC
EXTRN	PyBytes_FromStringAndSize:PROC
EXTRN	PyObject_IsTrue:PROC
EXTRN	PyMem_Realloc:PROC
EXTRN	PyUnicode_AsUTF8:PROC
EXTRN	__imp_memchr:PROC
EXTRN	PyErr_Occurred:PROC
EXTRN	memcpy:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyCode_Optimize DD imagerel $LN293
	DD	imagerel $LN293+3803
	DD	imagerel $unwind$PyCode_Optimize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCode_Optimize DD 0a2601H
	DD	01b3426H
	DD	0f01ff226H
	DD	0d01be01dH
	DD	07017c019H
	DD	050156016H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\peephole.c
xdata	ENDS
;	COMDAT PyCode_Optimize
_TEXT	SEGMENT
const_stack$1$ = 48
in_consts$1$ = 56
blocks$1$ = 64
load_const_stack$1$ = 72
const_stack_size$1$ = 80
addrmap$1$ = 88
codelen$1$ = 96
lineno$1$ = 104
tv1622 = 112
code$ = 192
consts$ = 200
names$ = 208
lineno_obj$ = 216
PyCode_Optimize PROC					; COMDAT

; 381  : {

$LN293:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	56		 push	 rsi
  00016	57		 push	 rdi
  00017	41 54		 push	 r12
  00019	41 55		 push	 r13
  0001b	41 56		 push	 r14
  0001d	41 57		 push	 r15
  0001f	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 382  :     Py_ssize_t i, j, codelen;
; 383  :     int nops, h, adj;
; 384  :     int tgt, tgttgt, opcode;
; 385  :     unsigned char *codestr = NULL;

  00026	33 db		 xor	 ebx, ebx
  00028	49 8b f1	 mov	 rsi, r9
  0002b	4c 8b e1	 mov	 r12, rcx
  0002e	8b fb		 mov	 edi, ebx

; 386  :     unsigned char *lineno;
; 387  :     int *addrmap = NULL;

  00030	44 8b eb	 mov	 r13d, ebx

; 388  :     int new_line, cum_orig_line, last_line, tabsiz;
; 389  :     PyObject **const_stack = NULL;

  00033	48 89 5c 24 30	 mov	 QWORD PTR const_stack$1$[rsp], rbx

; 390  :     Py_ssize_t *load_const_stack = NULL;

  00038	44 8b f3	 mov	 r14d, ebx

; 391  :     Py_ssize_t const_stack_top = -1;
; 392  :     Py_ssize_t const_stack_size = 0;
; 393  :     int in_consts = 0;  /* whether we are in a LOAD_CONST sequence */
; 394  :     unsigned int *blocks = NULL;

  0003b	48 89 5c 24 40	 mov	 QWORD PTR blocks$1$[rsp], rbx
  00040	49 83 cf ff	 or	 r15, -1

; 395  :     char *name;
; 396  : 
; 397  :     /* Bail out if an exception is set */
; 398  :     if (PyErr_Occurred())

  00044	e8 00 00 00 00	 call	 PyErr_Occurred
  00049	48 85 c0	 test	 rax, rax
  0004c	0f 85 7b 0c 00
	00		 jne	 $exitError$21750

; 399  :         goto exitError;
; 400  : 
; 401  :     /* Bypass optimization when the lineno table is too complex */
; 402  :     assert(PyBytes_Check(lineno_obj));
; 403  :     lineno = (unsigned char*)PyBytes_AS_STRING(lineno_obj);
; 404  :     tabsiz = PyBytes_GET_SIZE(lineno_obj);
; 405  :     if (memchr(lineno, 255, tabsiz) != NULL)

  00052	48 63 46 60	 movsxd	 rax, DWORD PTR [rsi+96]
  00056	48 8d 6e 78	 lea	 rbp, QWORD PTR [rsi+120]
  0005a	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  0005f	4c 8b c0	 mov	 r8, rax
  00062	48 8b cd	 mov	 rcx, rbp
  00065	48 89 6c 24 68	 mov	 QWORD PTR lineno$1$[rsp], rbp
  0006a	48 89 44 24 70	 mov	 QWORD PTR tv1622[rsp], rax
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00075	48 85 c0	 test	 rax, rax
  00078	0f 85 ac 0c 00
	00		 jne	 $LN4@PyCode_Opt

; 406  :         goto exitUnchanged;
; 407  : 
; 408  :     /* Avoid situations where jump retargeting could overflow */
; 409  :     assert(PyBytes_Check(code));
; 410  :     codelen = PyBytes_GET_SIZE(code);

  0007e	49 8b 74 24 60	 mov	 rsi, QWORD PTR [r12+96]
  00083	48 89 74 24 60	 mov	 QWORD PTR codelen$1$[rsp], rsi

; 411  :     if (codelen > 32700)

  00088	48 81 fe bc 7f
	00 00		 cmp	 rsi, 32700		; 00007fbcH
  0008f	0f 8f 95 0c 00
	00		 jg	 $LN4@PyCode_Opt

; 412  :         goto exitUnchanged;
; 413  : 
; 414  :     /* Make a modifiable copy of the code string */
; 415  :     codestr = (unsigned char *)PyMem_Malloc(codelen);

  00095	48 8b ce	 mov	 rcx, rsi
  00098	e8 00 00 00 00	 call	 PyMem_Malloc
  0009d	48 8b f8	 mov	 rdi, rax

; 416  :     if (codestr == NULL)

  000a0	48 85 c0	 test	 rax, rax
  000a3	0f 84 24 0c 00
	00		 je	 $exitError$21750

; 417  :         goto exitError;
; 418  :     codestr = (unsigned char *)memcpy(codestr,
; 419  :                                       PyBytes_AS_STRING(code), codelen);

  000a9	49 8d 54 24 78	 lea	 rdx, QWORD PTR [r12+120]
  000ae	4c 8b c6	 mov	 r8, rsi
  000b1	48 8b c8	 mov	 rcx, rax
  000b4	e8 00 00 00 00	 call	 memcpy
  000b9	48 8b c7	 mov	 rax, rdi

; 420  : 
; 421  :     /* Verify that RETURN_VALUE terminates the codestring.      This allows
; 422  :        the various transformation patterns to look ahead several
; 423  :        instructions without additional checks to make sure they are not
; 424  :        looking beyond the end of the code string.
; 425  :     */
; 426  :     if (codestr[codelen-1] != RETURN_VALUE)

  000bc	80 7c 06 ff 53	 cmp	 BYTE PTR [rsi+rax-1], 83 ; 00000053H
  000c1	0f 85 56 0c 00
	00		 jne	 $LN6@PyCode_Opt

; 427  :         goto exitUnchanged;
; 428  : 
; 429  :     /* Mapping to new jump targets after NOPs are removed */
; 430  :     addrmap = (int *)PyMem_Malloc(codelen * sizeof(int));

  000c7	48 8d 0c b5 00
	00 00 00	 lea	 rcx, QWORD PTR [rsi*4]
  000cf	e8 00 00 00 00	 call	 PyMem_Malloc
  000d4	48 89 44 24 58	 mov	 QWORD PTR addrmap$1$[rsp], rax

; 431  :     if (addrmap == NULL)

  000d9	48 85 c0	 test	 rax, rax
  000dc	0f 84 e8 0b 00
	00		 je	 $LN272@PyCode_Opt

; 432  :         goto exitError;
; 433  : 
; 434  :     blocks = markblocks(codestr, codelen);

  000e2	48 8b d6	 mov	 rdx, rsi
  000e5	48 8b cf	 mov	 rcx, rdi
  000e8	e8 00 00 00 00	 call	 markblocks
  000ed	48 89 44 24 40	 mov	 QWORD PTR blocks$1$[rsp], rax

; 435  :     if (blocks == NULL)

  000f2	48 85 c0	 test	 rax, rax
  000f5	0f 84 e1 05 00
	00		 je	 $LN270@PyCode_Opt

; 436  :         goto exitError;
; 437  :     assert(PyList_Check(consts));
; 438  : 
; 439  :     CONST_STACK_CREATE();

  000fb	41 bc 00 01 00
	00		 mov	 r12d, 256		; 00000100H
  00101	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00106	4c 89 64 24 50	 mov	 QWORD PTR const_stack_size$1$[rsp], r12
  0010b	e8 00 00 00 00	 call	 PyMem_Malloc
  00110	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00115	4c 8b e8	 mov	 r13, rax
  00118	48 89 44 24 30	 mov	 QWORD PTR const_stack$1$[rsp], rax
  0011d	e8 00 00 00 00	 call	 PyMem_Malloc
  00122	4c 8b f0	 mov	 r14, rax
  00125	48 89 44 24 48	 mov	 QWORD PTR load_const_stack$1$[rsp], rax
  0012a	4d 85 ed	 test	 r13, r13
  0012d	0f 84 a4 05 00
	00		 je	 $LN120@PyCode_Opt
  00133	48 85 c0	 test	 rax, rax
  00136	0f 84 9b 05 00
	00		 je	 $LN120@PyCode_Opt

; 440  : 
; 441  :     for (i=0 ; i<codelen ; i += CODESIZE(codestr[i])) {

  0013c	4c 8b 54 24 60	 mov	 r10, QWORD PTR codelen$1$[rsp]
  00141	8b f3		 mov	 esi, ebx
  00143	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:__ImageBase
  0014a	44 8d 4b 03	 lea	 r9d, QWORD PTR [rbx+3]
  0014e	4d 85 d2	 test	 r10, r10
  00151	0f 8e db 09 00
	00		 jle	 $LN142@PyCode_Opt
$LN277@PyCode_Opt:
  00157	4c 8b 4c 24 40	 mov	 r9, QWORD PTR blocks$1$[rsp]
  0015c	44 8b c3	 mov	 r8d, ebx
$LN275@PyCode_Opt:
  0015f	b9 03 00 00 00	 mov	 ecx, 3
$LN288@PyCode_Opt:

; 442  :       reoptimize_current:
; 443  :         opcode = codestr[i];

  00164	0f b6 2c 3e	 movzx	 ebp, BYTE PTR [rsi+rdi]

; 444  : 
; 445  :         if (!in_consts) {

  00168	45 85 c0	 test	 r8d, r8d
  0016b	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00172	4c 0f 44 f8	 cmove	 r15, rax
  00176	4c 8d 2c 3e	 lea	 r13, QWORD PTR [rsi+rdi]

; 446  :             CONST_STACK_RESET();
; 447  :         }
; 448  :         in_consts = 0;
; 449  : 
; 450  :         switch (opcode) {

  0017a	8d 45 f6	 lea	 eax, DWORD PTR [rbp-10]
  0017d	48 ba ff ff ff
	ff ff ff ff 0f	 mov	 rdx, 1152921504606846975 ; 0fffffffffffffffH
  00187	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$reoptimize_current$21797:
  00190	44 8b c3	 mov	 r8d, ebx
  00193	3d 86 00 00 00	 cmp	 eax, 134		; 00000086H
  00198	0f 87 32 06 00
	00		 ja	 $LN232@PyCode_Opt
  0019e	48 98		 cdqe
  001a0	41 0f b6 84 03
	00 00 00 00	 movzx	 eax, BYTE PTR $LN222@PyCode_Opt[r11+rax]
  001a9	41 8b 8c 83 00
	00 00 00	 mov	 ecx, DWORD PTR $LN223@PyCode_Opt[r11+rax*4]
  001b1	49 03 cb	 add	 rcx, r11
  001b4	ff e1		 jmp	 rcx
$LN135@PyCode_Opt:

; 451  :             /* Replace UNARY_NOT POP_JUMP_IF_FALSE
; 452  :                with    POP_JUMP_IF_TRUE */
; 453  :             case UNARY_NOT:
; 454  :                 if (codestr[i+1] != POP_JUMP_IF_FALSE
; 455  :                     || !ISBASICBLOCK(blocks,i,4))

  001b6	80 7c 3e 01 72	 cmp	 BYTE PTR [rsi+rdi+1], 114 ; 00000072H
  001bb	0f 85 8a 03 00
	00		 jne	 $LN241@PyCode_Opt
  001c1	41 8b 44 b1 0c	 mov	 eax, DWORD PTR [r9+rsi*4+12]
  001c6	41 39 04 b1	 cmp	 DWORD PTR [r9+rsi*4], eax
  001ca	0f 85 7b 03 00
	00		 jne	 $LN241@PyCode_Opt

; 456  :                     continue;
; 457  :                 j = GETARG(codestr, i+1);

  001d0	0f b6 44 3e 02	 movzx	 eax, BYTE PTR [rsi+rdi+2]
  001d5	0f b6 4c 3e 03	 movzx	 ecx, BYTE PTR [rsi+rdi+3]

; 458  :                 codestr[i] = POP_JUMP_IF_TRUE;

  001da	41 c6 45 00 73	 mov	 BYTE PTR [r13], 115	; 00000073H
  001df	c1 e1 08	 shl	 ecx, 8

; 459  :                 SETARG(codestr, i, j);
; 460  :                 codestr[i+3] = NOP;

  001e2	c6 44 3e 03 09	 mov	 BYTE PTR [rsi+rdi+3], 9
  001e7	03 c8		 add	 ecx, eax
  001e9	48 63 d1	 movsxd	 rdx, ecx
  001ec	48 8b c2	 mov	 rax, rdx
  001ef	88 54 3e 01	 mov	 BYTE PTR [rsi+rdi+1], dl
  001f3	48 c1 f8 08	 sar	 rax, 8
  001f7	88 44 3e 02	 mov	 BYTE PTR [rsi+rdi+2], al

; 461  :                 goto reoptimize_current;

  001fb	e9 5f ff ff ff	 jmp	 $LN275@PyCode_Opt
$LN56@PyCode_Opt:

; 599  : 
; 600  :                 /* Simplify conditional jump to conditional jump where the
; 601  :                    result of the first test implies the success of a similar
; 602  :                    test or the failure of the opposite test.
; 603  :                    Arises in code like:
; 604  :                    "if a and b:"
; 605  :                    "if a or b:"
; 606  :                    "a and b or c"
; 607  :                    "(a and b) and c"
; 608  :                    x:JUMP_IF_FALSE_OR_POP y   y:JUMP_IF_FALSE_OR_POP z
; 609  :                       -->  x:JUMP_IF_FALSE_OR_POP z
; 610  :                    x:JUMP_IF_FALSE_OR_POP y   y:JUMP_IF_TRUE_OR_POP z
; 611  :                       -->  x:POP_JUMP_IF_FALSE y+3
; 612  :                    where y+3 is the instruction following the second test.
; 613  :                 */
; 614  :             case JUMP_IF_FALSE_OR_POP:
; 615  :             case JUMP_IF_TRUE_OR_POP:
; 616  :                 tgt = GETJUMPTGT(codestr, i);

  00200	40 80 fd 71	 cmp	 bpl, 113		; 00000071H
  00204	74 22		 je	 SHORT $LN186@PyCode_Opt
  00206	40 80 fd 77	 cmp	 bpl, 119		; 00000077H
  0020a	74 1c		 je	 SHORT $LN186@PyCode_Opt
  0020c	40 80 fd 72	 cmp	 bpl, 114		; 00000072H
  00210	74 16		 je	 SHORT $LN186@PyCode_Opt
  00212	40 80 fd 73	 cmp	 bpl, 115		; 00000073H
  00216	74 10		 je	 SHORT $LN186@PyCode_Opt
  00218	40 80 fd 6f	 cmp	 bpl, 111		; 0000006fH
  0021c	74 0a		 je	 SHORT $LN186@PyCode_Opt
  0021e	48 8d 4e 03	 lea	 rcx, QWORD PTR [rsi+3]
  00222	40 80 fd 70	 cmp	 bpl, 112		; 00000070H
  00226	75 03		 jne	 SHORT $LN187@PyCode_Opt
$LN186@PyCode_Opt:
  00228	48 8b cb	 mov	 rcx, rbx
$LN187@PyCode_Opt:
  0022b	0f b6 44 3e 02	 movzx	 eax, BYTE PTR [rsi+rdi+2]
  00230	44 0f b6 44 3e
	01		 movzx	 r8d, BYTE PTR [rsi+rdi+1]
  00236	c1 e0 08	 shl	 eax, 8
  00239	03 c1		 add	 eax, ecx
  0023b	44 03 c0	 add	 r8d, eax

; 617  :                 j = codestr[tgt];

  0023e	4d 63 c8	 movsxd	 r9, r8d
  00241	41 0f b6 14 39	 movzx	 edx, BYTE PTR [r9+rdi]

; 618  :                 if (CONDITIONAL_JUMP(j)) {

  00246	48 83 fa 72	 cmp	 rdx, 114		; 00000072H
  0024a	74 16		 je	 SHORT $LN54@PyCode_Opt
  0024c	48 83 fa 73	 cmp	 rdx, 115		; 00000073H
  00250	74 1e		 je	 SHORT $LN188@PyCode_Opt
  00252	48 83 fa 6f	 cmp	 rdx, 111		; 0000006fH
  00256	74 0a		 je	 SHORT $LN54@PyCode_Opt
  00258	48 83 fa 70	 cmp	 rdx, 112		; 00000070H
  0025c	0f 85 05 07 00
	00		 jne	 $LN269@PyCode_Opt
$LN54@PyCode_Opt:

; 619  :                     /* NOTE: all possible jumps here are
; 620  :                        absolute! */
; 621  :                     if (JUMPS_ON_TRUE(j) == JUMPS_ON_TRUE(opcode)) {

  00262	48 83 fa 73	 cmp	 rdx, 115		; 00000073H
  00266	74 08		 je	 SHORT $LN188@PyCode_Opt
  00268	8b cb		 mov	 ecx, ebx
  0026a	48 83 fa 70	 cmp	 rdx, 112		; 00000070H
  0026e	75 05		 jne	 SHORT $LN191@PyCode_Opt
$LN188@PyCode_Opt:
  00270	b9 01 00 00 00	 mov	 ecx, 1
$LN191@PyCode_Opt:
  00275	83 fd 73	 cmp	 ebp, 115		; 00000073H
  00278	74 07		 je	 SHORT $LN189@PyCode_Opt
  0027a	8b c3		 mov	 eax, ebx
  0027c	83 fd 70	 cmp	 ebp, 112		; 00000070H
  0027f	75 05		 jne	 SHORT $LN190@PyCode_Opt
$LN189@PyCode_Opt:
  00281	b8 01 00 00 00	 mov	 eax, 1
$LN190@PyCode_Opt:
  00286	3b c8		 cmp	 ecx, eax
  00288	75 51		 jne	 SHORT $LN53@PyCode_Opt

; 622  :                         /* The second jump will be
; 623  :                            taken iff the first is. */
; 624  :                         tgttgt = GETJUMPTGT(codestr, tgt);

  0028a	80 fa 71	 cmp	 dl, 113			; 00000071H
  0028d	74 1f		 je	 SHORT $LN192@PyCode_Opt
  0028f	80 fa 77	 cmp	 dl, 119			; 00000077H
  00292	74 1a		 je	 SHORT $LN192@PyCode_Opt
  00294	80 fa 72	 cmp	 dl, 114			; 00000072H
  00297	74 15		 je	 SHORT $LN192@PyCode_Opt
  00299	80 fa 73	 cmp	 dl, 115			; 00000073H
  0029c	74 10		 je	 SHORT $LN192@PyCode_Opt
  0029e	80 fa 6f	 cmp	 dl, 111			; 0000006fH
  002a1	74 0b		 je	 SHORT $LN192@PyCode_Opt
  002a3	80 fa 70	 cmp	 dl, 112			; 00000070H
  002a6	74 06		 je	 SHORT $LN192@PyCode_Opt
  002a8	41 83 c0 03	 add	 r8d, 3
  002ac	eb 03		 jmp	 SHORT $LN193@PyCode_Opt
$LN192@PyCode_Opt:
  002ae	44 8b c3	 mov	 r8d, ebx
$LN193@PyCode_Opt:
  002b1	41 0f b6 44 39
	02		 movzx	 eax, BYTE PTR [r9+rdi+2]
  002b7	41 0f b6 4c 39
	01		 movzx	 ecx, BYTE PTR [r9+rdi+1]

; 625  :                         /* The current opcode inherits
; 626  :                            its target's stack behaviour */
; 627  :                         codestr[i] = j;

  002bd	41 88 55 00	 mov	 BYTE PTR [r13], dl
  002c1	c1 e0 08	 shl	 eax, 8
  002c4	41 03 c0	 add	 eax, r8d
  002c7	03 c8		 add	 ecx, eax

; 628  :                         SETARG(codestr, i, tgttgt);

  002c9	8b c1		 mov	 eax, ecx
  002cb	88 4c 3e 01	 mov	 BYTE PTR [rsi+rdi+1], cl
  002cf	c1 f8 08	 sar	 eax, 8

; 642  :                         SETARG(codestr, i, (tgt + 3));

  002d2	88 44 3e 02	 mov	 BYTE PTR [rsi+rdi+2], al

; 643  :                         goto reoptimize_current;

  002d6	e9 7c fe ff ff	 jmp	 $LN277@PyCode_Opt
$LN53@PyCode_Opt:

; 629  :                         goto reoptimize_current;
; 630  :                     } else {
; 631  :                         /* The second jump is not taken
; 632  :                            if the first is (so jump past
; 633  :                            it), and all conditional
; 634  :                            jumps pop their argument when
; 635  :                            they're not taken (so change
; 636  :                            the first jump to pop its
; 637  :                            argument when it's taken). */
; 638  :                         if (JUMPS_ON_TRUE(opcode))

  002db	83 fd 73	 cmp	 ebp, 115		; 00000073H
  002de	74 0c		 je	 SHORT $LN50@PyCode_Opt
  002e0	83 fd 70	 cmp	 ebp, 112		; 00000070H
  002e3	74 07		 je	 SHORT $LN50@PyCode_Opt

; 640  :                         else
; 641  :                             codestr[i] = POP_JUMP_IF_FALSE;

  002e5	41 c6 45 00 72	 mov	 BYTE PTR [r13], 114	; 00000072H
  002ea	eb 05		 jmp	 SHORT $LN49@PyCode_Opt
$LN50@PyCode_Opt:

; 639  :                             codestr[i] = POP_JUMP_IF_TRUE;

  002ec	41 c6 45 00 73	 mov	 BYTE PTR [r13], 115	; 00000073H
$LN49@PyCode_Opt:

; 642  :                         SETARG(codestr, i, (tgt + 3));

  002f1	41 8d 40 03	 lea	 eax, DWORD PTR [r8+3]
  002f5	c1 f8 08	 sar	 eax, 8
  002f8	41 80 c0 03	 add	 r8b, 3
  002fc	44 88 44 3e 01	 mov	 BYTE PTR [rsi+rdi+1], r8b
  00301	88 44 3e 02	 mov	 BYTE PTR [rsi+rdi+2], al

; 643  :                         goto reoptimize_current;

  00305	e9 4d fe ff ff	 jmp	 $LN277@PyCode_Opt
$LN132@PyCode_Opt:

; 462  : 
; 463  :                 /* not a is b -->  a is not b
; 464  :                    not a in b -->  a not in b
; 465  :                    not a is not b -->  a is b
; 466  :                    not a not in b -->  a in b
; 467  :                 */
; 468  :             case COMPARE_OP:
; 469  :                 j = GETARG(codestr, i);

  0030a	0f b6 44 3e 01	 movzx	 eax, BYTE PTR [rsi+rdi+1]
  0030f	0f b6 4c 3e 02	 movzx	 ecx, BYTE PTR [rsi+rdi+2]
  00314	c1 e1 08	 shl	 ecx, 8
  00317	03 c8		 add	 ecx, eax
  00319	48 63 d1	 movsxd	 rdx, ecx

; 470  :                 if (j < 6  ||  j > 9  ||
; 471  :                     codestr[i+3] != UNARY_NOT  ||
; 472  :                     !ISBASICBLOCK(blocks,i,4))

  0031c	48 8d 42 fa	 lea	 rax, QWORD PTR [rdx-6]
  00320	48 83 f8 03	 cmp	 rax, 3
  00324	0f 87 21 02 00
	00		 ja	 $LN241@PyCode_Opt
  0032a	80 7c 3e 03 0c	 cmp	 BYTE PTR [rsi+rdi+3], 12
  0032f	0f 85 16 02 00
	00		 jne	 $LN241@PyCode_Opt
  00335	41 8b 44 b1 0c	 mov	 eax, DWORD PTR [r9+rsi*4+12]

; 476  :                 break;

  0033a	4c 8b 6c 24 30	 mov	 r13, QWORD PTR const_stack$1$[rsp]
  0033f	b9 03 00 00 00	 mov	 ecx, 3
  00344	41 39 04 b1	 cmp	 DWORD PTR [r9+rsi*4], eax
  00348	0f 85 b9 07 00
	00		 jne	 $LN143@PyCode_Opt

; 473  :                     continue;
; 474  :                 SETARG(codestr, i, (j^1));
; 475  :                 codestr[i+3] = NOP;

  0034e	48 8b c2	 mov	 rax, rdx
  00351	c6 44 3e 03 09	 mov	 BYTE PTR [rsi+rdi+3], 9
  00356	48 c1 f8 08	 sar	 rax, 8
  0035a	80 f2 01	 xor	 dl, 1
  0035d	88 54 3e 01	 mov	 BYTE PTR [rsi+rdi+1], dl
  00361	88 44 3e 02	 mov	 BYTE PTR [rsi+rdi+2], al

; 476  :                 break;

  00365	e9 9d 07 00 00	 jmp	 $LN143@PyCode_Opt
$LN129@PyCode_Opt:

; 477  : 
; 478  :                 /* Replace LOAD_GLOBAL/LOAD_NAME None/True/False
; 479  :                    with LOAD_CONST None/True/False */
; 480  :             case LOAD_NAME:
; 481  :             case LOAD_GLOBAL:
; 482  :                 j = GETARG(codestr, i);

  0036a	0f b6 4c 3e 02	 movzx	 ecx, BYTE PTR [rsi+rdi+2]
  0036f	0f b6 44 3e 01	 movzx	 eax, BYTE PTR [rsi+rdi+1]
  00374	c1 e1 08	 shl	 ecx, 8
  00377	03 c8		 add	 ecx, eax

; 483  :                 name = _PyUnicode_AsString(PyTuple_GET_ITEM(names, j));

  00379	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR names$[rsp]
  00381	48 63 c9	 movsxd	 rcx, ecx
  00384	48 8b 4c c8 70	 mov	 rcx, QWORD PTR [rax+rcx*8+112]
  00389	e8 00 00 00 00	 call	 PyUnicode_AsUTF8

; 484  :                 h = load_global(codestr, i, name, consts);

  0038e	48 8b ac 24 c8
	00 00 00	 mov	 rbp, QWORD PTR consts$[rsp]
  00396	48 8b d6	 mov	 rdx, rsi
  00399	4c 8b cd	 mov	 r9, rbp
  0039c	4c 8b c0	 mov	 r8, rax
  0039f	48 8b cf	 mov	 rcx, rdi
  003a2	e8 00 00 00 00	 call	 load_global

; 485  :                 if (h < 0)

  003a7	85 c0		 test	 eax, eax
  003a9	0f 88 2d 03 00
	00		 js	 $LN270@PyCode_Opt

; 486  :                     goto exitError;
; 487  :                 else if (h == 0)

  003af	0f 84 3b 07 00
	00		 je	 $LN263@PyCode_Opt

; 488  :                     continue;
; 489  :                 CONST_STACK_PUSH_OP(i);

  003b5	0f b6 44 3e 01	 movzx	 eax, BYTE PTR [rsi+rdi+1]
  003ba	0f b6 4c 3e 02	 movzx	 ecx, BYTE PTR [rsi+rdi+2]
  003bf	48 c1 e1 08	 shl	 rcx, 8
  003c3	48 03 c8	 add	 rcx, rax
  003c6	48 8b 45 70	 mov	 rax, QWORD PTR [rbp+112]
  003ca	49 ff c7	 inc	 r15
  003cd	48 8b 2c c8	 mov	 rbp, QWORD PTR [rax+rcx*8]
$LN292@PyCode_Opt:
  003d1	4d 3b fc	 cmp	 r15, r12
  003d4	0f 8c 14 03 00
	00		 jl	 $LN265@PyCode_Opt
  003da	4d 03 e4	 add	 r12, r12
  003dd	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  003e7	4c 89 64 24 50	 mov	 QWORD PTR const_stack_size$1$[rsp], r12
  003ec	4c 3b e0	 cmp	 r12, rax
  003ef	76 0a		 jbe	 SHORT $LN160@PyCode_Opt
  003f1	4c 8b eb	 mov	 r13, rbx
  003f4	48 89 5c 24 30	 mov	 QWORD PTR const_stack$1$[rsp], rbx
  003f9	eb 24		 jmp	 SHORT $LN161@PyCode_Opt
$LN160@PyCode_Opt:
  003fb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR const_stack$1$[rsp]
  00400	4a 8d 14 e5 00
	00 00 00	 lea	 rdx, QWORD PTR [r12*8]
  00408	e8 00 00 00 00	 call	 PyMem_Realloc
  0040d	4c 8b e8	 mov	 r13, rax
  00410	48 89 44 24 30	 mov	 QWORD PTR const_stack$1$[rsp], rax
  00415	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
$LN161@PyCode_Opt:
  0041f	4c 3b e0	 cmp	 r12, rax
  00422	0f 86 3e 04 00
	00		 jbe	 $LN178@PyCode_Opt
  00428	4c 8b f3	 mov	 r14, rbx
  0042b	e9 98 02 00 00	 jmp	 $LN283@PyCode_Opt
$LN118@PyCode_Opt:

; 490  :                 break;
; 491  : 
; 492  :                 /* Skip over LOAD_CONST trueconst
; 493  :                    POP_JUMP_IF_FALSE xx. This improves
; 494  :                    "while 1" performance. */
; 495  :             case LOAD_CONST:
; 496  :                 CONST_STACK_PUSH_OP(i);

  00430	0f b6 44 3e 01	 movzx	 eax, BYTE PTR [rsi+rdi+1]
  00435	0f b6 4c 3e 02	 movzx	 ecx, BYTE PTR [rsi+rdi+2]
  0043a	4c 8b 9c 24 c8
	00 00 00	 mov	 r11, QWORD PTR consts$[rsp]
  00442	48 c1 e1 08	 shl	 rcx, 8
  00446	49 ff c7	 inc	 r15
  00449	48 03 c8	 add	 rcx, rax
  0044c	49 8b 43 70	 mov	 rax, QWORD PTR [r11+112]
  00450	48 8b 2c c8	 mov	 rbp, QWORD PTR [rax+rcx*8]
  00454	4d 3b fc	 cmp	 r15, r12
  00457	0f 8c f8 00 00
	00		 jl	 $LN240@PyCode_Opt
  0045d	4d 03 e4	 add	 r12, r12
  00460	4c 89 64 24 50	 mov	 QWORD PTR const_stack_size$1$[rsp], r12
  00465	4c 3b e2	 cmp	 r12, rdx
  00468	76 07		 jbe	 SHORT $LN164@PyCode_Opt
  0046a	48 89 5c 24 30	 mov	 QWORD PTR const_stack$1$[rsp], rbx
  0046f	eb 21		 jmp	 SHORT $LN165@PyCode_Opt
$LN164@PyCode_Opt:
  00471	48 8b 4c 24 30	 mov	 rcx, QWORD PTR const_stack$1$[rsp]
  00476	4a 8d 14 e5 00
	00 00 00	 lea	 rdx, QWORD PTR [r12*8]
  0047e	e8 00 00 00 00	 call	 PyMem_Realloc
  00483	48 ba ff ff ff
	ff ff ff ff 0f	 mov	 rdx, 1152921504606846975 ; 0fffffffffffffffH
  0048d	48 89 44 24 30	 mov	 QWORD PTR const_stack$1$[rsp], rax
$LN165@PyCode_Opt:
  00492	4c 3b e2	 cmp	 r12, rdx
  00495	76 05		 jbe	 SHORT $LN166@PyCode_Opt
  00497	4c 8b f3	 mov	 r14, rbx
  0049a	eb 13		 jmp	 SHORT $LN280@PyCode_Opt
$LN166@PyCode_Opt:
  0049c	4a 8d 14 e5 00
	00 00 00	 lea	 rdx, QWORD PTR [r12*8]
  004a4	49 8b ce	 mov	 rcx, r14
  004a7	e8 00 00 00 00	 call	 PyMem_Realloc
  004ac	4c 8b f0	 mov	 r14, rax
$LN280@PyCode_Opt:
  004af	48 8b 44 24 30	 mov	 rax, QWORD PTR const_stack$1$[rsp]
  004b4	4c 89 74 24 48	 mov	 QWORD PTR load_const_stack$1$[rsp], r14
  004b9	48 85 c0	 test	 rax, rax
  004bc	0f 84 15 02 00
	00		 je	 $LN120@PyCode_Opt
  004c2	4d 85 f6	 test	 r14, r14
  004c5	0f 84 0c 02 00
	00		 je	 $LN120@PyCode_Opt

; 694  :                     memset(codestr+i+1, NOP, 4);
; 695  :                 else if (UNCONDITIONAL_JUMP(codestr[i+1]) &&

  004cb	4c 8b 54 24 60	 mov	 r10, QWORD PTR codelen$1$[rsp]
  004d0	4c 8b 9c 24 c8
	00 00 00	 mov	 r11, QWORD PTR consts$[rsp]
$LN114@PyCode_Opt:

; 490  :                 break;
; 491  : 
; 492  :                 /* Skip over LOAD_CONST trueconst
; 493  :                    POP_JUMP_IF_FALSE xx. This improves
; 494  :                    "while 1" performance. */
; 495  :             case LOAD_CONST:
; 496  :                 CONST_STACK_PUSH_OP(i);

  004d8	4c 8b 4c 24 40	 mov	 r9, QWORD PTR blocks$1$[rsp]
  004dd	4b 89 34 fe	 mov	 QWORD PTR [r14+r15*8], rsi
  004e1	4a 89 2c f8	 mov	 QWORD PTR [rax+r15*8], rbp

; 497  :                 j = GETARG(codestr, i);

  004e5	0f b6 4c 3e 02	 movzx	 ecx, BYTE PTR [rsi+rdi+2]
  004ea	0f b6 44 3e 01	 movzx	 eax, BYTE PTR [rsi+rdi+1]
  004ef	41 b8 01 00 00
	00		 mov	 r8d, 1
  004f5	c1 e1 08	 shl	 ecx, 8
  004f8	44 89 44 24 38	 mov	 DWORD PTR in_consts$1$[rsp], r8d
  004fd	03 c8		 add	 ecx, eax

; 498  :                 if (codestr[i+3] != POP_JUMP_IF_FALSE  ||
; 499  :                     !ISBASICBLOCK(blocks,i,6)  ||
; 500  :                     !PyObject_IsTrue(PyList_GET_ITEM(consts, j)))

  004ff	80 7c 3e 03 72	 cmp	 BYTE PTR [rsi+rdi+3], 114 ; 00000072H
  00504	48 63 d1	 movsxd	 rdx, ecx
  00507	75 42		 jne	 SHORT $LN241@PyCode_Opt
  00509	41 8b 44 b1 14	 mov	 eax, DWORD PTR [r9+rsi*4+20]
  0050e	41 39 04 b1	 cmp	 DWORD PTR [r9+rsi*4], eax
  00512	75 37		 jne	 SHORT $LN241@PyCode_Opt
  00514	49 8b 4b 70	 mov	 rcx, QWORD PTR [r11+112]
  00518	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  0051c	e8 00 00 00 00	 call	 PyObject_IsTrue

; 504  :                 break;

  00521	4c 8b 54 24 60	 mov	 r10, QWORD PTR codelen$1$[rsp]
  00526	44 8b 44 24 38	 mov	 r8d, DWORD PTR in_consts$1$[rsp]
  0052b	4c 8b 4c 24 40	 mov	 r9, QWORD PTR blocks$1$[rsp]
  00530	85 c0		 test	 eax, eax
  00532	74 17		 je	 SHORT $LN241@PyCode_Opt

; 501  :                     continue;
; 502  :                 memset(codestr+i, NOP, 6);
; 503  :                 CONST_STACK_RESET();

  00534	48 b9 09 09 09
	09 09 09 09 09	 mov	 rcx, 651061555542690057	; 0909090909090909H
  0053e	49 83 cf ff	 or	 r15, -1
  00542	41 89 4d 00	 mov	 DWORD PTR [r13], ecx
  00546	66 41 89 4d 04	 mov	 WORD PTR [r13+4], cx
$LN241@PyCode_Opt:

; 504  :                 break;

  0054b	4c 8b 6c 24 30	 mov	 r13, QWORD PTR const_stack$1$[rsp]
  00550	e9 ad 05 00 00	 jmp	 $LN281@PyCode_Opt
$LN240@PyCode_Opt:

; 518  :                 assert((h >= 0 || CONST_STACK_LEN() < j));
; 519  :                 if (h >= 0 && j > 0 && j <= CONST_STACK_LEN() &&
; 520  :                     ((opcode == BUILD_TUPLE &&
; 521  :                       ISBASICBLOCK(blocks, h, i-h+3)) ||
; 522  :                      ((opcode == BUILD_LIST || opcode == BUILD_SET) &&
; 523  :                       codestr[i+3]==COMPARE_OP &&
; 524  :                       ISBASICBLOCK(blocks, h, i-h+6) &&
; 525  :                       (GETARG(codestr,i+3)==6 ||
; 526  :                        GETARG(codestr,i+3)==7))) &&
; 527  :                     tuple_of_constants(&codestr[i], j, consts, CONST_STACK_LASTN(j))) {

  00555	48 8b 44 24 30	 mov	 rax, QWORD PTR const_stack$1$[rsp]
  0055a	e9 79 ff ff ff	 jmp	 $LN114@PyCode_Opt
$LN107@PyCode_Opt:

; 505  : 
; 506  :                 /* Try to fold tuples of constants (includes a case for lists and sets
; 507  :                    which are only used for "in" and "not in" tests).
; 508  :                    Skip over BUILD_SEQN 1 UNPACK_SEQN 1.
; 509  :                    Replace BUILD_SEQN 2 UNPACK_SEQN 2 with ROT2.
; 510  :                    Replace BUILD_SEQN 3 UNPACK_SEQN 3 with ROT3 ROT2. */
; 511  :             case BUILD_TUPLE:
; 512  :             case BUILD_LIST:
; 513  :             case BUILD_SET:
; 514  :                 j = GETARG(codestr, i);

  0055f	0f b6 4c 3e 02	 movzx	 ecx, BYTE PTR [rsi+rdi+2]
  00564	0f b6 44 3e 01	 movzx	 eax, BYTE PTR [rsi+rdi+1]
  00569	c1 e1 08	 shl	 ecx, 8
  0056c	03 c8		 add	 ecx, eax
  0056e	4c 63 e1	 movsxd	 r12, ecx

; 515  :                 if (j == 0)

  00571	0f 84 f1 01 00
	00		 je	 $LN228@PyCode_Opt

; 516  :                     break;
; 517  :                 h = CONST_STACK_OP_LASTN(j);

  00577	49 8d 44 24 ff	 lea	 rax, QWORD PTR [r12-1]
  0057c	4c 3b f8	 cmp	 r15, rax
  0057f	0f 8c 98 01 00
	00		 jl	 $LN105@PyCode_Opt
  00585	48 8b 44 24 48	 mov	 rax, QWORD PTR load_const_stack$1$[rsp]
  0058a	4d 8b f7	 mov	 r14, r15
  0058d	4d 2b f4	 sub	 r14, r12
  00590	4a 63 4c f0 08	 movsxd	 rcx, DWORD PTR [rax+r14*8+8]

; 518  :                 assert((h >= 0 || CONST_STACK_LEN() < j));
; 519  :                 if (h >= 0 && j > 0 && j <= CONST_STACK_LEN() &&
; 520  :                     ((opcode == BUILD_TUPLE &&
; 521  :                       ISBASICBLOCK(blocks, h, i-h+3)) ||
; 522  :                      ((opcode == BUILD_LIST || opcode == BUILD_SET) &&
; 523  :                       codestr[i+3]==COMPARE_OP &&
; 524  :                       ISBASICBLOCK(blocks, h, i-h+6) &&
; 525  :                       (GETARG(codestr,i+3)==6 ||
; 526  :                        GETARG(codestr,i+3)==7))) &&
; 527  :                     tuple_of_constants(&codestr[i], j, consts, CONST_STACK_LASTN(j))) {

  00595	85 c9		 test	 ecx, ecx
  00597	0f 88 7d 01 00
	00		 js	 $LN238@PyCode_Opt
  0059d	4d 85 e4	 test	 r12, r12
  005a0	0f 8e 74 01 00
	00		 jle	 $LN238@PyCode_Opt
  005a6	49 8d 47 01	 lea	 rax, QWORD PTR [r15+1]
  005aa	4c 3b e0	 cmp	 r12, rax
  005ad	7f 17		 jg	 SHORT $LN234@PyCode_Opt
  005af	83 fd 66	 cmp	 ebp, 102		; 00000066H
  005b2	75 1c		 jne	 SHORT $LN103@PyCode_Opt
  005b4	41 8b 44 b1 08	 mov	 eax, DWORD PTR [r9+rsi*4+8]
  005b9	4c 8b e9	 mov	 r13, rcx
  005bc	41 39 04 89	 cmp	 DWORD PTR [r9+rcx*4], eax
  005c0	74 46		 je	 SHORT $LN101@PyCode_Opt
$LN226@PyCode_Opt:
  005c2	4c 8d 2c 3e	 lea	 r13, QWORD PTR [rsi+rdi]
$LN234@PyCode_Opt:
  005c6	4c 8b 74 24 48	 mov	 r14, QWORD PTR load_const_stack$1$[rsp]
  005cb	e9 4d 01 00 00	 jmp	 $LN105@PyCode_Opt
$LN103@PyCode_Opt:
  005d0	83 fd 67	 cmp	 ebp, 103		; 00000067H
  005d3	74 05		 je	 SHORT $LN102@PyCode_Opt
  005d5	83 fd 68	 cmp	 ebp, 104		; 00000068H
  005d8	75 ec		 jne	 SHORT $LN234@PyCode_Opt
$LN102@PyCode_Opt:
  005da	80 7c 3e 03 6b	 cmp	 BYTE PTR [rsi+rdi+3], 107 ; 0000006bH
  005df	75 e5		 jne	 SHORT $LN234@PyCode_Opt
  005e1	41 8b 44 b1 14	 mov	 eax, DWORD PTR [r9+rsi*4+20]
  005e6	4c 8b e9	 mov	 r13, rcx
  005e9	41 39 04 89	 cmp	 DWORD PTR [r9+rcx*4], eax
  005ed	75 d3		 jne	 SHORT $LN226@PyCode_Opt
  005ef	0f b6 54 3e 05	 movzx	 edx, BYTE PTR [rsi+rdi+5]
  005f4	0f b6 44 3e 04	 movzx	 eax, BYTE PTR [rsi+rdi+4]
  005f9	c1 e2 08	 shl	 edx, 8
  005fc	03 d0		 add	 edx, eax
  005fe	83 fa 06	 cmp	 edx, 6
  00601	74 05		 je	 SHORT $LN101@PyCode_Opt
  00603	83 fa 07	 cmp	 edx, 7
  00606	75 ba		 jne	 SHORT $LN226@PyCode_Opt
$LN101@PyCode_Opt:
  00608	48 8b 44 24 30	 mov	 rax, QWORD PTR const_stack$1$[rsp]
  0060d	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR consts$[rsp]
  00615	48 8d 0c 3e	 lea	 rcx, QWORD PTR [rsi+rdi]
  00619	4e 8d 4c f0 08	 lea	 r9, QWORD PTR [rax+r14*8+8]
  0061e	49 8b d4	 mov	 rdx, r12
  00621	e8 00 00 00 00	 call	 tuple_of_constants
  00626	85 c0		 test	 eax, eax
  00628	0f 84 d9 00 00
	00		 je	 $LN225@PyCode_Opt

; 528  :                     assert(codestr[i] == LOAD_CONST);
; 529  :                     memset(&codestr[h], NOP, i - h);

  0062e	4c 8b c6	 mov	 r8, rsi
  00631	49 8d 4c 3d 00	 lea	 rcx, QWORD PTR [r13+rdi]
  00636	ba 09 00 00 00	 mov	 edx, 9
  0063b	4d 2b c5	 sub	 r8, r13
  0063e	e8 00 00 00 00	 call	 memset

; 530  :                     CONST_STACK_POP(j);
; 531  :                     CONST_STACK_PUSH_OP(i);

  00643	0f b6 44 3e 01	 movzx	 eax, BYTE PTR [rsi+rdi+1]
  00648	44 0f b6 5c 3e
	02		 movzx	 r11d, BYTE PTR [rsi+rdi+2]
  0064e	4c 8b 64 24 50	 mov	 r12, QWORD PTR const_stack_size$1$[rsp]
  00653	49 c1 e3 08	 shl	 r11, 8
  00657	4d 8d 7e 01	 lea	 r15, QWORD PTR [r14+1]
  0065b	4c 03 d8	 add	 r11, rax
  0065e	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR consts$[rsp]
  00666	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0066a	4a 8b 2c d8	 mov	 rbp, QWORD PTR [rax+r11*8]
  0066e	4d 3b fc	 cmp	 r15, r12
  00671	7c 76		 jl	 SHORT $LN239@PyCode_Opt
  00673	4d 03 e4	 add	 r12, r12
  00676	49 be ff ff ff
	ff ff ff ff 0f	 mov	 r14, 1152921504606846975 ; 0fffffffffffffffH
  00680	4c 89 64 24 50	 mov	 QWORD PTR const_stack_size$1$[rsp], r12
  00685	4d 3b e6	 cmp	 r12, r14
  00688	76 05		 jbe	 SHORT $LN170@PyCode_Opt
  0068a	4c 8b eb	 mov	 r13, rbx
  0068d	eb 15		 jmp	 SHORT $LN282@PyCode_Opt
$LN170@PyCode_Opt:
  0068f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR const_stack$1$[rsp]
  00694	4a 8d 14 e5 00
	00 00 00	 lea	 rdx, QWORD PTR [r12*8]
  0069c	e8 00 00 00 00	 call	 PyMem_Realloc
  006a1	4c 8b e8	 mov	 r13, rax
$LN282@PyCode_Opt:
  006a4	4c 89 6c 24 30	 mov	 QWORD PTR const_stack$1$[rsp], r13
  006a9	4d 3b e6	 cmp	 r12, r14
  006ac	76 05		 jbe	 SHORT $LN172@PyCode_Opt
  006ae	4c 8b f3	 mov	 r14, rbx
  006b1	eb 15		 jmp	 SHORT $LN283@PyCode_Opt
$LN172@PyCode_Opt:
  006b3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR load_const_stack$1$[rsp]
$LN291@PyCode_Opt:
  006b8	4a 8d 14 e5 00
	00 00 00	 lea	 rdx, QWORD PTR [r12*8]
  006c0	e8 00 00 00 00	 call	 PyMem_Realloc
  006c5	4c 8b f0	 mov	 r14, rax
$LN283@PyCode_Opt:
  006c8	4c 89 74 24 48	 mov	 QWORD PTR load_const_stack$1$[rsp], r14
  006cd	4d 85 ed	 test	 r13, r13
  006d0	74 05		 je	 SHORT $LN120@PyCode_Opt
  006d2	4d 85 f6	 test	 r14, r14
  006d5	75 1c		 jne	 SHORT $LN93@PyCode_Opt
$LN120@PyCode_Opt:

; 488  :                     continue;
; 489  :                 CONST_STACK_PUSH_OP(i);

  006d7	e8 00 00 00 00	 call	 PyErr_NoMemory
$LN270@PyCode_Opt:
  006dc	4c 8b 6c 24 58	 mov	 r13, QWORD PTR addrmap$1$[rsp]

; 758  : 
; 759  :  exitError:
; 760  :     code = NULL;

  006e1	4c 8b e3	 mov	 r12, rbx
  006e4	e9 f6 05 00 00	 jmp	 $exitUnchanged$21759
$LN239@PyCode_Opt:

; 518  :                 assert((h >= 0 || CONST_STACK_LEN() < j));
; 519  :                 if (h >= 0 && j > 0 && j <= CONST_STACK_LEN() &&
; 520  :                     ((opcode == BUILD_TUPLE &&
; 521  :                       ISBASICBLOCK(blocks, h, i-h+3)) ||
; 522  :                      ((opcode == BUILD_LIST || opcode == BUILD_SET) &&
; 523  :                       codestr[i+3]==COMPARE_OP &&
; 524  :                       ISBASICBLOCK(blocks, h, i-h+6) &&
; 525  :                       (GETARG(codestr,i+3)==6 ||
; 526  :                        GETARG(codestr,i+3)==7))) &&
; 527  :                     tuple_of_constants(&codestr[i], j, consts, CONST_STACK_LASTN(j))) {

  006e9	4c 8b 74 24 48	 mov	 r14, QWORD PTR load_const_stack$1$[rsp]
$LN265@PyCode_Opt:
  006ee	4c 8b 6c 24 30	 mov	 r13, QWORD PTR const_stack$1$[rsp]
$LN93@PyCode_Opt:

; 530  :                     CONST_STACK_POP(j);
; 531  :                     CONST_STACK_PUSH_OP(i);

  006f3	4b 89 34 fe	 mov	 QWORD PTR [r14+r15*8], rsi
  006f7	41 b8 01 00 00
	00		 mov	 r8d, 1
  006fd	4b 89 6c fd 00	 mov	 QWORD PTR [r13+r15*8], rbp

; 532  :                     break;

  00702	e9 f1 03 00 00	 jmp	 $LN279@PyCode_Opt
$LN225@PyCode_Opt:
  00707	4c 8b 74 24 48	 mov	 r14, QWORD PTR load_const_stack$1$[rsp]
  0070c	4c 8b 54 24 60	 mov	 r10, QWORD PTR codelen$1$[rsp]
  00711	4c 8d 2c 3e	 lea	 r13, QWORD PTR [rsi+rdi]
  00715	44 8b c3	 mov	 r8d, ebx
  00718	eb 03		 jmp	 SHORT $LN105@PyCode_Opt
$LN238@PyCode_Opt:

; 518  :                 assert((h >= 0 || CONST_STACK_LEN() < j));
; 519  :                 if (h >= 0 && j > 0 && j <= CONST_STACK_LEN() &&
; 520  :                     ((opcode == BUILD_TUPLE &&
; 521  :                       ISBASICBLOCK(blocks, h, i-h+3)) ||
; 522  :                      ((opcode == BUILD_LIST || opcode == BUILD_SET) &&
; 523  :                       codestr[i+3]==COMPARE_OP &&
; 524  :                       ISBASICBLOCK(blocks, h, i-h+6) &&
; 525  :                       (GETARG(codestr,i+3)==6 ||
; 526  :                        GETARG(codestr,i+3)==7))) &&
; 527  :                     tuple_of_constants(&codestr[i], j, consts, CONST_STACK_LASTN(j))) {

  0071a	4c 8b f0	 mov	 r14, rax
$LN105@PyCode_Opt:

; 533  :                 }
; 534  :                 if (codestr[i+3] != UNPACK_SEQUENCE  ||
; 535  :                     !ISBASICBLOCK(blocks,i,6) ||
; 536  :                     j != GETARG(codestr, i+3) ||
; 537  :                     opcode == BUILD_SET)

  0071d	80 7c 3e 03 5c	 cmp	 BYTE PTR [rsi+rdi+3], 92 ; 0000005cH
  00722	4c 8b 4c 24 40	 mov	 r9, QWORD PTR blocks$1$[rsp]
  00727	75 3f		 jne	 SHORT $LN228@PyCode_Opt
  00729	41 8b 44 b1 14	 mov	 eax, DWORD PTR [r9+rsi*4+20]
  0072e	41 39 04 b1	 cmp	 DWORD PTR [r9+rsi*4], eax
  00732	75 34		 jne	 SHORT $LN228@PyCode_Opt
  00734	0f b6 44 3e 04	 movzx	 eax, BYTE PTR [rsi+rdi+4]
  00739	0f b6 4c 3e 05	 movzx	 ecx, BYTE PTR [rsi+rdi+5]
  0073e	c1 e1 08	 shl	 ecx, 8
  00741	03 c1		 add	 eax, ecx
  00743	48 98		 cdqe
  00745	4c 3b e0	 cmp	 r12, rax
  00748	75 1e		 jne	 SHORT $LN228@PyCode_Opt
  0074a	83 fd 68	 cmp	 ebp, 104		; 00000068H
  0074d	74 19		 je	 SHORT $LN228@PyCode_Opt

; 538  :                     continue;
; 539  :                 if (j == 1) {

  0074f	49 83 fc 01	 cmp	 r12, 1
  00753	75 22		 jne	 SHORT $LN89@PyCode_Opt

; 540  :                     memset(codestr+i, NOP, 6);

  00755	48 b9 09 09 09
	09 09 09 09 09	 mov	 rcx, 651061555542690057	; 0909090909090909H
  0075f	41 89 4d 00	 mov	 DWORD PTR [r13], ecx
  00763	66 41 89 4d 04	 mov	 WORD PTR [r13+4], cx
$LN228@PyCode_Opt:
  00768	4c 8b 64 24 50	 mov	 r12, QWORD PTR const_stack_size$1$[rsp]
  0076d	4c 8b 6c 24 30	 mov	 r13, QWORD PTR const_stack$1$[rsp]
  00772	e9 8b 03 00 00	 jmp	 $LN281@PyCode_Opt
$LN89@PyCode_Opt:

; 541  :                 } else if (j == 2) {

  00777	49 83 fc 02	 cmp	 r12, 2
  0077b	75 29		 jne	 SHORT $LN87@PyCode_Opt

; 542  :                     codestr[i] = ROT_TWO;

  0077d	45 88 65 00	 mov	 BYTE PTR [r13], r12b

; 543  :                     memset(codestr+i+1, NOP, 5);
; 544  :                     CONST_STACK_RESET();
; 545  :                 } else if (j == 3) {

  00781	4c 8b 64 24 50	 mov	 r12, QWORD PTR const_stack_size$1$[rsp]
  00786	4c 8b 6c 24 30	 mov	 r13, QWORD PTR const_stack$1$[rsp]
  0078b	48 b9 09 09 09
	09 09 09 09 09	 mov	 rcx, 651061555542690057	; 0909090909090909H
  00795	49 83 cf ff	 or	 r15, -1
  00799	89 4c 3e 01	 mov	 DWORD PTR [rsi+rdi+1], ecx
  0079d	88 4c 3e 05	 mov	 BYTE PTR [rsi+rdi+5], cl
  007a1	e9 5c 03 00 00	 jmp	 $LN281@PyCode_Opt
$LN87@PyCode_Opt:

; 550  :                 }
; 551  :                 break;

  007a6	b9 03 00 00 00	 mov	 ecx, 3
  007ab	4c 3b e1	 cmp	 r12, rcx
  007ae	4c 8b 64 24 50	 mov	 r12, QWORD PTR const_stack_size$1$[rsp]
  007b3	75 1b		 jne	 SHORT $LN232@PyCode_Opt

; 546  :                     codestr[i] = ROT_THREE;

  007b5	48 b8 09 09 09
	09 09 09 09 09	 mov	 rax, 651061555542690057	; 0909090909090909H
  007bf	41 88 4d 00	 mov	 BYTE PTR [r13], cl

; 547  :                     codestr[i+1] = ROT_TWO;

  007c3	c6 44 3e 01 02	 mov	 BYTE PTR [rsi+rdi+1], 2

; 548  :                     memset(codestr+i+2, NOP, 4);

  007c8	89 44 3e 02	 mov	 DWORD PTR [rsi+rdi+2], eax

; 549  :                     CONST_STACK_RESET();

  007cc	49 83 cf ff	 or	 r15, -1
$LN232@PyCode_Opt:

; 550  :                 }
; 551  :                 break;

  007d0	4c 8b 6c 24 30	 mov	 r13, QWORD PTR const_stack$1$[rsp]
  007d5	e9 2d 03 00 00	 jmp	 $LN143@PyCode_Opt
$LN78@PyCode_Opt:

; 552  : 
; 553  :                 /* Fold binary ops on constants.
; 554  :                    LOAD_CONST c1 LOAD_CONST c2 BINOP -->  LOAD_CONST binop(c1,c2) */
; 555  :             case BINARY_POWER:
; 556  :             case BINARY_MULTIPLY:
; 557  :             case BINARY_TRUE_DIVIDE:
; 558  :             case BINARY_FLOOR_DIVIDE:
; 559  :             case BINARY_MODULO:
; 560  :             case BINARY_ADD:
; 561  :             case BINARY_SUBTRACT:
; 562  :             case BINARY_SUBSCR:
; 563  :             case BINARY_LSHIFT:
; 564  :             case BINARY_RSHIFT:
; 565  :             case BINARY_AND:
; 566  :             case BINARY_XOR:
; 567  :             case BINARY_OR:
; 568  :                 /* NOTE: LOAD_CONST is saved at `i-2` since it has an arg
; 569  :                    while BINOP hasn't */
; 570  :                 h = CONST_STACK_OP_LASTN(2);

  007da	49 83 ff 01	 cmp	 r15, 1
  007de	0f 8c 67 fd ff
	ff		 jl	 $LN241@PyCode_Opt
  007e4	4b 63 44 fe f8	 movsxd	 rax, DWORD PTR [r14+r15*8-8]

; 571  :                 assert((h >= 0 || CONST_STACK_LEN() < 2));
; 572  :                 if (h >= 0 &&
; 573  :                     ISBASICBLOCK(blocks, h, i-h+1)  &&
; 574  :                     fold_binops_on_constants(&codestr[i], consts, CONST_STACK_LASTN(2))) {

  007e9	85 c0		 test	 eax, eax
  007eb	0f 88 5a fd ff
	ff		 js	 $LN241@PyCode_Opt
  007f1	48 8b e8	 mov	 rbp, rax
  007f4	41 8b 04 b1	 mov	 eax, DWORD PTR [r9+rsi*4]
  007f8	41 39 04 a9	 cmp	 DWORD PTR [r9+rbp*4], eax
  007fc	0f 85 49 fd ff
	ff		 jne	 $LN241@PyCode_Opt
  00802	48 8b 44 24 30	 mov	 rax, QWORD PTR const_stack$1$[rsp]
  00807	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR consts$[rsp]
  0080f	49 8b cd	 mov	 rcx, r13
  00812	4e 8d 44 f8 f8	 lea	 r8, QWORD PTR [rax+r15*8-8]
  00817	e8 00 00 00 00	 call	 fold_binops_on_constants
  0081c	85 c0		 test	 eax, eax
  0081e	0f 84 cc 02 00
	00		 je	 $LN263@PyCode_Opt

; 575  :                     i -= 2;

  00824	48 83 ee 02	 sub	 rsi, 2

; 576  :                     memset(&codestr[h], NOP, i - h);

  00828	48 8d 0c 2f	 lea	 rcx, QWORD PTR [rdi+rbp]
  0082c	ba 09 00 00 00	 mov	 edx, 9
  00831	4c 8b c6	 mov	 r8, rsi
  00834	4c 2b c5	 sub	 r8, rbp
  00837	e8 00 00 00 00	 call	 memset

; 577  :                     assert(codestr[i] == LOAD_CONST);
; 578  :                     CONST_STACK_POP(2);
; 579  :                     CONST_STACK_PUSH_OP(i);

  0083c	0f b6 44 3e 01	 movzx	 eax, BYTE PTR [rsi+rdi+1]
  00841	44 0f b6 5c 3e
	02		 movzx	 r11d, BYTE PTR [rsi+rdi+2]
  00847	49 c1 e3 08	 shl	 r11, 8
  0084b	4c 03 d8	 add	 r11, rax
  0084e	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR consts$[rsp]
  00856	49 ff cf	 dec	 r15
  00859	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0085d	4a 8b 2c d8	 mov	 rbp, QWORD PTR [rax+r11*8]
  00861	e9 6b fb ff ff	 jmp	 $LN292@PyCode_Opt
$LN178@PyCode_Opt:
  00866	49 8b ce	 mov	 rcx, r14
  00869	e9 4a fe ff ff	 jmp	 $LN291@PyCode_Opt
$LN67@PyCode_Opt:

; 580  :                 }
; 581  :                 break;
; 582  : 
; 583  :                 /* Fold unary ops on constants.
; 584  :                    LOAD_CONST c1  UNARY_OP -->                  LOAD_CONST unary_op(c) */
; 585  :             case UNARY_NEGATIVE:
; 586  :             case UNARY_INVERT:
; 587  :             case UNARY_POSITIVE:
; 588  :                 h = CONST_STACK_OP_LASTN(1);

  0086e	4d 85 ff	 test	 r15, r15
  00871	0f 88 d4 fc ff
	ff		 js	 $LN241@PyCode_Opt
  00877	4b 63 04 fe	 movsxd	 rax, DWORD PTR [r14+r15*8]

; 589  :                 assert((h >= 0 || CONST_STACK_LEN() < 1));
; 590  :                 if (h >= 0 &&
; 591  :                     ISBASICBLOCK(blocks, h, i-h+1)  &&
; 592  :                     fold_unaryops_on_constants(&codestr[i-3], consts, CONST_STACK_TOP())) {

  0087b	85 c0		 test	 eax, eax
  0087d	0f 88 c8 fc ff
	ff		 js	 $LN241@PyCode_Opt
  00883	4c 8b 6c 24 30	 mov	 r13, QWORD PTR const_stack$1$[rsp]
  00888	48 8b c8	 mov	 rcx, rax
  0088b	41 8b 04 b1	 mov	 eax, DWORD PTR [r9+rsi*4]
  0088f	41 39 04 89	 cmp	 DWORD PTR [r9+rcx*4], eax
  00893	0f 85 69 02 00
	00		 jne	 $LN281@PyCode_Opt
  00899	48 8b ac 24 c8
	00 00 00	 mov	 rbp, QWORD PTR consts$[rsp]
  008a1	4f 8b 44 fd 00	 mov	 r8, QWORD PTR [r13+r15*8]
  008a6	48 8d 4c 3e fd	 lea	 rcx, QWORD PTR [rsi+rdi-3]
  008ab	48 8b d5	 mov	 rdx, rbp
  008ae	e8 00 00 00 00	 call	 fold_unaryops_on_constants
  008b3	85 c0		 test	 eax, eax
  008b5	0f 84 3a 02 00
	00		 je	 $LN266@PyCode_Opt

; 593  :                     i -= 2;
; 594  :                     assert(codestr[i] == LOAD_CONST);
; 595  :                     CONST_STACK_POP(1);
; 596  :                     CONST_STACK_PUSH_OP(i);

  008bb	0f b6 44 3e ff	 movzx	 eax, BYTE PTR [rsi+rdi-1]
  008c0	0f b6 0c 3e	 movzx	 ecx, BYTE PTR [rsi+rdi]
  008c4	48 83 ee 02	 sub	 rsi, 2
  008c8	48 c1 e1 08	 shl	 rcx, 8
  008cc	48 03 c8	 add	 rcx, rax
  008cf	48 8b 45 70	 mov	 rax, QWORD PTR [rbp+112]
  008d3	48 8b 2c c8	 mov	 rbp, QWORD PTR [rax+rcx*8]
  008d7	4d 3b fc	 cmp	 r15, r12
  008da	7c 77		 jl	 SHORT $LN58@PyCode_Opt
  008dc	4d 03 e4	 add	 r12, r12
  008df	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  008e9	4c 89 64 24 50	 mov	 QWORD PTR const_stack_size$1$[rsp], r12
  008ee	4c 3b e0	 cmp	 r12, rax
  008f1	76 0a		 jbe	 SHORT $LN182@PyCode_Opt
  008f3	4c 8b eb	 mov	 r13, rbx
  008f6	48 89 5c 24 30	 mov	 QWORD PTR const_stack$1$[rsp], rbx
  008fb	eb 22		 jmp	 SHORT $LN183@PyCode_Opt
$LN182@PyCode_Opt:
  008fd	4a 8d 14 e5 00
	00 00 00	 lea	 rdx, QWORD PTR [r12*8]
  00905	49 8b cd	 mov	 rcx, r13
  00908	e8 00 00 00 00	 call	 PyMem_Realloc
  0090d	4c 8b e8	 mov	 r13, rax
  00910	48 89 44 24 30	 mov	 QWORD PTR const_stack$1$[rsp], rax
  00915	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
$LN183@PyCode_Opt:
  0091f	4c 3b e0	 cmp	 r12, rax
  00922	76 05		 jbe	 SHORT $LN184@PyCode_Opt
  00924	4c 8b f3	 mov	 r14, rbx
  00927	eb 13		 jmp	 SHORT $LN285@PyCode_Opt
$LN184@PyCode_Opt:
  00929	4a 8d 14 e5 00
	00 00 00	 lea	 rdx, QWORD PTR [r12*8]
  00931	49 8b ce	 mov	 rcx, r14
  00934	e8 00 00 00 00	 call	 PyMem_Realloc
  00939	4c 8b f0	 mov	 r14, rax
$LN285@PyCode_Opt:
  0093c	4c 89 74 24 48	 mov	 QWORD PTR load_const_stack$1$[rsp], r14
  00941	4d 85 ed	 test	 r13, r13
  00944	0f 84 8d fd ff
	ff		 je	 $LN120@PyCode_Opt
  0094a	4d 85 f6	 test	 r14, r14
  0094d	0f 84 84 fd ff
	ff		 je	 $LN120@PyCode_Opt
$LN58@PyCode_Opt:
  00953	4b 89 34 fe	 mov	 QWORD PTR [r14+r15*8], rsi
  00957	41 b8 01 00 00
	00		 mov	 r8d, 1
  0095d	4b 89 6c fd 00	 mov	 QWORD PTR [r13+r15*8], rbp

; 597  :                 }
; 598  :                 break;

  00962	e9 91 01 00 00	 jmp	 $LN279@PyCode_Opt
$LN269@PyCode_Opt:

; 694  :                     memset(codestr+i+1, NOP, 4);
; 695  :                 else if (UNCONDITIONAL_JUMP(codestr[i+1]) &&

  00967	44 8b c3	 mov	 r8d, ebx
$LN52@PyCode_Opt:

; 644  :                     }
; 645  :                 }
; 646  :                 /* Intentional fallthrough */
; 647  : 
; 648  :                 /* Replace jumps to unconditional jumps */
; 649  :             case POP_JUMP_IF_FALSE:
; 650  :             case POP_JUMP_IF_TRUE:
; 651  :             case FOR_ITER:
; 652  :             case JUMP_FORWARD:
; 653  :             case JUMP_ABSOLUTE:
; 654  :             case CONTINUE_LOOP:
; 655  :             case SETUP_LOOP:
; 656  :             case SETUP_EXCEPT:
; 657  :             case SETUP_FINALLY:
; 658  :             case SETUP_WITH:
; 659  :                 tgt = GETJUMPTGT(codestr, i);

  0096a	40 80 fd 71	 cmp	 bpl, 113		; 00000071H
  0096e	74 22		 je	 SHORT $LN194@PyCode_Opt
  00970	40 80 fd 77	 cmp	 bpl, 119		; 00000077H
  00974	74 1c		 je	 SHORT $LN194@PyCode_Opt
  00976	40 80 fd 72	 cmp	 bpl, 114		; 00000072H
  0097a	74 16		 je	 SHORT $LN194@PyCode_Opt
  0097c	40 80 fd 73	 cmp	 bpl, 115		; 00000073H
  00980	74 10		 je	 SHORT $LN194@PyCode_Opt
  00982	40 80 fd 6f	 cmp	 bpl, 111		; 0000006fH
  00986	74 0a		 je	 SHORT $LN194@PyCode_Opt
  00988	48 8d 4e 03	 lea	 rcx, QWORD PTR [rsi+3]
  0098c	40 80 fd 70	 cmp	 bpl, 112		; 00000070H
  00990	75 03		 jne	 SHORT $LN195@PyCode_Opt
$LN194@PyCode_Opt:
  00992	48 8b cb	 mov	 rcx, rbx
$LN195@PyCode_Opt:
  00995	0f b6 44 3e 02	 movzx	 eax, BYTE PTR [rsi+rdi+2]
  0099a	0f b6 54 3e 01	 movzx	 edx, BYTE PTR [rsi+rdi+1]
  0099f	c1 e0 08	 shl	 eax, 8
  009a2	03 c1		 add	 eax, ecx
  009a4	03 d0		 add	 edx, eax

; 660  :                 /* Replace JUMP_* to a RETURN into just a RETURN */
; 661  :                 if (UNCONDITIONAL_JUMP(opcode) &&
; 662  :                     codestr[tgt] == RETURN_VALUE) {

  009a6	83 fd 71	 cmp	 ebp, 113		; 00000071H
  009a9	74 05		 je	 SHORT $LN46@PyCode_Opt
  009ab	83 fd 6e	 cmp	 ebp, 110		; 0000006eH
  009ae	75 27		 jne	 SHORT $LN47@PyCode_Opt
$LN46@PyCode_Opt:
  009b0	48 63 c2	 movsxd	 rax, edx
  009b3	80 3c 38 53	 cmp	 BYTE PTR [rax+rdi], 83	; 00000053H
  009b7	75 1e		 jne	 SHORT $LN47@PyCode_Opt

; 663  :                     codestr[i] = RETURN_VALUE;
; 664  :                     memset(codestr+i+1, NOP, 2);

  009b9	48 b8 09 09 09
	09 09 09 09 09	 mov	 rax, 651061555542690057	; 0909090909090909H
  009c3	41 c6 45 00 53	 mov	 BYTE PTR [r13], 83	; 00000053H
  009c8	66 89 44 3e 01	 mov	 WORD PTR [rsi+rdi+1], ax
$LN262@PyCode_Opt:

; 665  :                     continue;

  009cd	4c 8b 6c 24 30	 mov	 r13, QWORD PTR const_stack$1$[rsp]
  009d2	e9 26 01 00 00	 jmp	 $LN286@PyCode_Opt
$LN47@PyCode_Opt:

; 666  :                 }
; 667  :                 if (!UNCONDITIONAL_JUMP(codestr[tgt]))

  009d7	48 63 ca	 movsxd	 rcx, edx
  009da	0f b6 04 39	 movzx	 eax, BYTE PTR [rcx+rdi]
  009de	3c 71		 cmp	 al, 113			; 00000071H
  009e0	74 21		 je	 SHORT $LN196@PyCode_Opt
  009e2	3c 6e		 cmp	 al, 110			; 0000006eH
  009e4	75 e7		 jne	 SHORT $LN262@PyCode_Opt

; 668  :                     continue;
; 669  :                 tgttgt = GETJUMPTGT(codestr, tgt);

  009e6	3c 71		 cmp	 al, 113			; 00000071H
  009e8	74 19		 je	 SHORT $LN196@PyCode_Opt
  009ea	3c 77		 cmp	 al, 119			; 00000077H
  009ec	74 15		 je	 SHORT $LN196@PyCode_Opt
  009ee	3c 72		 cmp	 al, 114			; 00000072H
  009f0	74 11		 je	 SHORT $LN196@PyCode_Opt
  009f2	3c 73		 cmp	 al, 115			; 00000073H
  009f4	74 0d		 je	 SHORT $LN196@PyCode_Opt
  009f6	3c 6f		 cmp	 al, 111			; 0000006fH
  009f8	74 09		 je	 SHORT $LN196@PyCode_Opt
  009fa	3c 70		 cmp	 al, 112			; 00000070H
  009fc	74 05		 je	 SHORT $LN196@PyCode_Opt
  009fe	83 c2 03	 add	 edx, 3
  00a01	eb 02		 jmp	 SHORT $LN197@PyCode_Opt
$LN196@PyCode_Opt:
  00a03	8b d3		 mov	 edx, ebx
$LN197@PyCode_Opt:
  00a05	0f b6 44 39 02	 movzx	 eax, BYTE PTR [rcx+rdi+2]
  00a0a	0f b6 4c 39 01	 movzx	 ecx, BYTE PTR [rcx+rdi+1]
  00a0f	c1 e0 08	 shl	 eax, 8
  00a12	03 c2		 add	 eax, edx
  00a14	03 c8		 add	 ecx, eax

; 670  :                 if (opcode == JUMP_FORWARD) /* JMP_ABS can go backwards */

  00a16	83 fd 6e	 cmp	 ebp, 110		; 0000006eH
  00a19	75 07		 jne	 SHORT $LN44@PyCode_Opt

; 671  :                     opcode = JUMP_ABSOLUTE;

  00a1b	bd 71 00 00 00	 mov	 ebp, 113		; 00000071H

; 672  :                 if (!ABSOLUTE_JUMP(opcode))

  00a20	eb 27		 jmp	 SHORT $LN43@PyCode_Opt
$LN44@PyCode_Opt:
  00a22	83 fd 71	 cmp	 ebp, 113		; 00000071H
  00a25	74 22		 je	 SHORT $LN43@PyCode_Opt
  00a27	83 fd 77	 cmp	 ebp, 119		; 00000077H
  00a2a	74 1d		 je	 SHORT $LN43@PyCode_Opt
  00a2c	83 fd 72	 cmp	 ebp, 114		; 00000072H
  00a2f	74 18		 je	 SHORT $LN43@PyCode_Opt
  00a31	83 fd 73	 cmp	 ebp, 115		; 00000073H
  00a34	74 13		 je	 SHORT $LN43@PyCode_Opt
  00a36	83 fd 6f	 cmp	 ebp, 111		; 0000006fH
  00a39	74 0e		 je	 SHORT $LN43@PyCode_Opt
  00a3b	83 fd 70	 cmp	 ebp, 112		; 00000070H
  00a3e	74 09		 je	 SHORT $LN43@PyCode_Opt

; 673  :                     tgttgt -= i + 3;     /* Calc relative jump addr */

  00a40	b8 fd ff ff ff	 mov	 eax, -3
  00a45	2b c6		 sub	 eax, esi
  00a47	03 c8		 add	 ecx, eax
$LN43@PyCode_Opt:

; 677  :                 SETARG(codestr, i, tgttgt);
; 678  :                 break;

  00a49	4c 8b 4c 24 40	 mov	 r9, QWORD PTR blocks$1$[rsp]
  00a4e	85 c9		 test	 ecx, ecx
  00a50	0f 88 f5 fa ff
	ff		 js	 $LN241@PyCode_Opt

; 674  :                 if (tgttgt < 0)                           /* No backward relative jumps */
; 675  :                     continue;
; 676  :                 codestr[i] = opcode;

  00a56	8b c1		 mov	 eax, ecx
  00a58	41 88 6d 00	 mov	 BYTE PTR [r13], bpl

; 677  :                 SETARG(codestr, i, tgttgt);
; 678  :                 break;

  00a5c	4c 8b 6c 24 30	 mov	 r13, QWORD PTR const_stack$1$[rsp]
  00a61	c1 f8 08	 sar	 eax, 8
  00a64	88 4c 3e 01	 mov	 BYTE PTR [rsi+rdi+1], cl
  00a68	88 44 3e 02	 mov	 BYTE PTR [rsi+rdi+2], al
  00a6c	e9 91 00 00 00	 jmp	 $LN281@PyCode_Opt
$LN41@PyCode_Opt:

; 679  : 
; 680  :             case EXTENDED_ARG:
; 681  :                 if (codestr[i+3] != MAKE_FUNCTION)

  00a71	80 7c 3e 03 84	 cmp	 BYTE PTR [rsi+rdi+3], 132 ; 00000084H
  00a76	0f 85 56 02 00
	00		 jne	 $LN268@PyCode_Opt

; 682  :                     goto exitUnchanged;
; 683  :                 /* don't visit MAKE_FUNCTION as GETARG will be wrong */
; 684  :                 i += 3;
; 685  :                 break;

  00a7c	4c 8b 6c 24 30	 mov	 r13, QWORD PTR const_stack$1$[rsp]
  00a81	48 83 c6 03	 add	 rsi, 3
  00a85	eb 7b		 jmp	 SHORT $LN281@PyCode_Opt
$LN39@PyCode_Opt:

; 686  : 
; 687  :                 /* Replace RETURN LOAD_CONST None RETURN with just RETURN */
; 688  :                 /* Remove unreachable JUMPs after RETURN */
; 689  :             case RETURN_VALUE:
; 690  :                 if (i+4 >= codelen)

  00a87	48 8d 46 04	 lea	 rax, QWORD PTR [rsi+4]
  00a8b	49 3b c2	 cmp	 rax, r10
  00a8e	0f 8d b7 fa ff
	ff		 jge	 $LN241@PyCode_Opt

; 691  :                     continue;
; 692  :                 if (codestr[i+4] == RETURN_VALUE &&
; 693  :                     ISBASICBLOCK(blocks,i,5))

  00a94	80 7c 3e 04 53	 cmp	 BYTE PTR [rsi+rdi+4], 83 ; 00000053H
  00a99	75 1f		 jne	 SHORT $LN37@PyCode_Opt
  00a9b	41 8b 04 81	 mov	 eax, DWORD PTR [r9+rax*4]
  00a9f	41 39 04 b1	 cmp	 DWORD PTR [r9+rsi*4], eax
  00aa3	75 15		 jne	 SHORT $LN37@PyCode_Opt

; 694  :                     memset(codestr+i+1, NOP, 4);
; 695  :                 else if (UNCONDITIONAL_JUMP(codestr[i+1]) &&

  00aa5	4c 8b 6c 24 30	 mov	 r13, QWORD PTR const_stack$1$[rsp]
  00aaa	48 b8 09 09 09
	09 09 09 09 09	 mov	 rax, 651061555542690057	; 0909090909090909H
  00ab4	89 44 3e 01	 mov	 DWORD PTR [rsi+rdi+1], eax
  00ab8	eb 48		 jmp	 SHORT $LN281@PyCode_Opt
$LN37@PyCode_Opt:

; 696  :                          ISBASICBLOCK(blocks,i,4))

  00aba	0f b6 44 3e 01	 movzx	 eax, BYTE PTR [rsi+rdi+1]
  00abf	3c 71		 cmp	 al, 113			; 00000071H
  00ac1	74 08		 je	 SHORT $LN34@PyCode_Opt
  00ac3	3c 6e		 cmp	 al, 110			; 0000006eH
  00ac5	0f 85 80 fa ff
	ff		 jne	 $LN241@PyCode_Opt
$LN34@PyCode_Opt:
  00acb	41 8b 44 b1 0c	 mov	 eax, DWORD PTR [r9+rsi*4+12]

; 697  :                     memset(codestr+i+1, NOP, 3);

  00ad0	4c 8b 6c 24 30	 mov	 r13, QWORD PTR const_stack$1$[rsp]
  00ad5	41 39 04 b1	 cmp	 DWORD PTR [r9+rsi*4], eax
  00ad9	75 27		 jne	 SHORT $LN281@PyCode_Opt
  00adb	48 b9 09 09 09
	09 09 09 09 09	 mov	 rcx, 651061555542690057	; 0909090909090909H
  00ae5	66 89 4c 3e 01	 mov	 WORD PTR [rsi+rdi+1], cx
  00aea	88 4c 3e 03	 mov	 BYTE PTR [rsi+rdi+3], cl
  00aee	eb 12		 jmp	 SHORT $LN281@PyCode_Opt
$LN263@PyCode_Opt:

; 694  :                     memset(codestr+i+1, NOP, 4);
; 695  :                 else if (UNCONDITIONAL_JUMP(codestr[i+1]) &&

  00af0	4c 8b 6c 24 30	 mov	 r13, QWORD PTR const_stack$1$[rsp]
$LN266@PyCode_Opt:

; 406  :         goto exitUnchanged;
; 407  : 
; 408  :     /* Avoid situations where jump retargeting could overflow */
; 409  :     assert(PyBytes_Check(code));
; 410  :     codelen = PyBytes_GET_SIZE(code);

  00af5	44 8b c3	 mov	 r8d, ebx
$LN279@PyCode_Opt:
  00af8	4c 8b 54 24 60	 mov	 r10, QWORD PTR codelen$1$[rsp]
$LN286@PyCode_Opt:
  00afd	4c 8b 4c 24 40	 mov	 r9, QWORD PTR blocks$1$[rsp]
$LN281@PyCode_Opt:
  00b02	b9 03 00 00 00	 mov	 ecx, 3
$LN143@PyCode_Opt:

; 440  : 
; 441  :     for (i=0 ; i<codelen ; i += CODESIZE(codestr[i])) {

  00b07	80 3c 3e 5a	 cmp	 BYTE PTR [rsi+rdi], 90	; 0000005aH
  00b0b	b8 01 00 00 00	 mov	 eax, 1
  00b10	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:__ImageBase
  00b17	48 0f 43 c1	 cmovae	 rax, rcx
  00b1b	48 03 f0	 add	 rsi, rax
  00b1e	49 3b f2	 cmp	 rsi, r10
  00b21	0f 8c 3d f6 ff
	ff		 jl	 $LN288@PyCode_Opt
  00b27	48 8b 6c 24 68	 mov	 rbp, QWORD PTR lineno$1$[rsp]
  00b2c	41 b9 03 00 00
	00		 mov	 r9d, 3
$LN142@PyCode_Opt:
  00b32	48 8b 74 24 58	 mov	 rsi, QWORD PTR addrmap$1$[rsp]

; 698  :                 break;
; 699  :         }
; 700  :     }
; 701  : 
; 702  :     /* Fixup linenotab */
; 703  :     for (i=0, nops=0 ; i<codelen ; i += CODESIZE(codestr[i])) {

  00b37	48 8b cb	 mov	 rcx, rbx
  00b3a	8b d3		 mov	 edx, ebx
  00b3c	4d 85 d2	 test	 r10, r10
  00b3f	7e 38		 jle	 SHORT $LN31@PyCode_Opt
  00b41	66 66 66 66 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL33@PyCode_Opt:

; 704  :         addrmap[i] = i - nops;

  00b50	8b c1		 mov	 eax, ecx
  00b52	2b c2		 sub	 eax, edx
  00b54	89 04 8e	 mov	 DWORD PTR [rsi+rcx*4], eax

; 705  :         if (codestr[i] == NOP)

  00b57	44 0f b6 04 39	 movzx	 r8d, BYTE PTR [rcx+rdi]
  00b5c	41 80 f8 09	 cmp	 r8b, 9
  00b60	75 02		 jne	 SHORT $LN32@PyCode_Opt

; 706  :             nops++;

  00b62	ff c2		 inc	 edx
$LN32@PyCode_Opt:

; 698  :                 break;
; 699  :         }
; 700  :     }
; 701  : 
; 702  :     /* Fixup linenotab */
; 703  :     for (i=0, nops=0 ; i<codelen ; i += CODESIZE(codestr[i])) {

  00b64	41 80 f8 5a	 cmp	 r8b, 90			; 0000005aH
  00b68	b8 01 00 00 00	 mov	 eax, 1
  00b6d	49 0f 43 c1	 cmovae	 rax, r9
  00b71	48 03 c8	 add	 rcx, rax
  00b74	49 3b ca	 cmp	 rcx, r10
  00b77	7c d7		 jl	 SHORT $LL33@PyCode_Opt
$LN31@PyCode_Opt:

; 709  :     last_line = 0;
; 710  :     for (i=0 ; i < tabsiz ; i+=2) {

  00b79	48 8b 54 24 70	 mov	 rdx, QWORD PTR tv1622[rsp]
  00b7e	44 8b c3	 mov	 r8d, ebx
  00b81	44 8b cb	 mov	 r9d, ebx
  00b84	48 85 d2	 test	 rdx, rdx
  00b87	7e 2b		 jle	 SHORT $LN27@PyCode_Opt

; 707  :     }
; 708  :     cum_orig_line = 0;

  00b89	48 ff ca	 dec	 rdx
  00b8c	48 d1 ea	 shr	 rdx, 1
  00b8f	48 ff c2	 inc	 rdx
$LL29@PyCode_Opt:

; 711  :         cum_orig_line += lineno[i];

  00b92	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  00b96	48 83 c5 02	 add	 rbp, 2
  00b9a	44 03 c0	 add	 r8d, eax

; 712  :         new_line = addrmap[cum_orig_line];

  00b9d	49 63 c0	 movsxd	 rax, r8d
  00ba0	8b 0c 86	 mov	 ecx, DWORD PTR [rsi+rax*4]

; 713  :         assert (new_line - last_line < 255);
; 714  :         lineno[i] =((unsigned char)(new_line - last_line));

  00ba3	0f b6 c1	 movzx	 eax, cl
  00ba6	41 2a c1	 sub	 al, r9b
  00ba9	48 ff ca	 dec	 rdx

; 715  :         last_line = new_line;

  00bac	44 8b c9	 mov	 r9d, ecx
  00baf	88 45 fe	 mov	 BYTE PTR [rbp-2], al
  00bb2	75 de		 jne	 SHORT $LL29@PyCode_Opt
$LN27@PyCode_Opt:

; 716  :     }
; 717  : 
; 718  :     /* Remove NOPs and fixup jump targets */
; 719  :     for (i=0, h=0 ; i<codelen ; ) {

  00bb4	44 8b cb	 mov	 r9d, ebx
  00bb7	48 8b d3	 mov	 rdx, rbx
  00bba	4d 85 d2	 test	 r10, r10
  00bbd	0f 8e bd 00 00
	00		 jle	 $LN25@PyCode_Opt
  00bc3	41 bd 03 00 00
	00		 mov	 r13d, 3
  00bc9	0f 1f 80 00 00
	00 00		 npad	 7
$LL26@PyCode_Opt:

; 720  :         opcode = codestr[i];

  00bd0	44 0f b6 04 3b	 movzx	 r8d, BYTE PTR [rbx+rdi]

; 721  :         switch (opcode) {

  00bd5	41 8d 40 f7	 lea	 eax, DWORD PTR [r8-9]
  00bd9	3d 86 00 00 00	 cmp	 eax, 134		; 00000086H
  00bde	77 64		 ja	 SHORT $LN23@PyCode_Opt
  00be0	48 98		 cdqe
  00be2	41 0f b6 84 03
	00 00 00 00	 movzx	 eax, BYTE PTR $LN220@PyCode_Opt[r11+rax]
  00beb	41 8b 8c 83 00
	00 00 00	 mov	 ecx, DWORD PTR $LN221@PyCode_Opt[r11+rax*4]
  00bf3	49 03 cb	 add	 rcx, r11
  00bf6	ff e1		 jmp	 rcx
$LN22@PyCode_Opt:

; 722  :             case NOP:
; 723  :                 i++;

  00bf8	48 ff c3	 inc	 rbx

; 724  :                 continue;

  00bfb	eb 75		 jmp	 SHORT $LN217@PyCode_Opt
$LN21@PyCode_Opt:

; 725  : 
; 726  :             case JUMP_ABSOLUTE:
; 727  :             case CONTINUE_LOOP:
; 728  :             case POP_JUMP_IF_FALSE:
; 729  :             case POP_JUMP_IF_TRUE:
; 730  :             case JUMP_IF_FALSE_OR_POP:
; 731  :             case JUMP_IF_TRUE_OR_POP:
; 732  :                 j = addrmap[GETARG(codestr, i)];

  00bfd	0f b6 4c 3b 02	 movzx	 ecx, BYTE PTR [rbx+rdi+2]
  00c02	0f b6 44 3b 01	 movzx	 eax, BYTE PTR [rbx+rdi+1]
  00c07	48 c1 e1 08	 shl	 rcx, 8
  00c0b	48 03 c8	 add	 rcx, rax
  00c0e	48 63 0c 8e	 movsxd	 rcx, DWORD PTR [rsi+rcx*4]

; 733  :                 SETARG(codestr, i, j);
; 734  :                 break;

  00c12	eb 21		 jmp	 SHORT $LN289@PyCode_Opt
$LN20@PyCode_Opt:

; 735  : 
; 736  :             case FOR_ITER:
; 737  :             case JUMP_FORWARD:
; 738  :             case SETUP_LOOP:
; 739  :             case SETUP_EXCEPT:
; 740  :             case SETUP_FINALLY:
; 741  :             case SETUP_WITH:
; 742  :                 j = addrmap[GETARG(codestr, i) + i + 3] - addrmap[i] - 3;

  00c14	0f b6 44 3b 02	 movzx	 eax, BYTE PTR [rbx+rdi+2]
  00c19	0f b6 4c 3b 01	 movzx	 ecx, BYTE PTR [rbx+rdi+1]
  00c1e	48 c1 e0 08	 shl	 rax, 8
  00c22	48 03 c3	 add	 rax, rbx
  00c25	48 03 c8	 add	 rcx, rax
  00c28	8b 44 8e 0c	 mov	 eax, DWORD PTR [rsi+rcx*4+12]
  00c2c	2b 04 9e	 sub	 eax, DWORD PTR [rsi+rbx*4]
  00c2f	41 2b c5	 sub	 eax, r13d
  00c32	48 63 c8	 movsxd	 rcx, eax
$LN289@PyCode_Opt:

; 743  :                 SETARG(codestr, i, j);

  00c35	48 8b c1	 mov	 rax, rcx
  00c38	88 4c 3b 01	 mov	 BYTE PTR [rbx+rdi+1], cl
  00c3c	48 c1 f8 08	 sar	 rax, 8
  00c40	88 44 3b 02	 mov	 BYTE PTR [rbx+rdi+2], al
$LN23@PyCode_Opt:

; 744  :                 break;
; 745  :         }
; 746  :         adj = CODESIZE(opcode);

  00c44	41 83 f8 5a	 cmp	 r8d, 90			; 0000005aH
  00c48	b9 01 00 00 00	 mov	 ecx, 1
  00c4d	41 0f 4d cd	 cmovge	 ecx, r13d

; 747  :         while (adj--)

  00c51	85 c9		 test	 ecx, ecx
  00c53	74 1d		 je	 SHORT $LN217@PyCode_Opt

; 744  :                 break;
; 745  :         }
; 746  :         adj = CODESIZE(opcode);

  00c55	44 03 c9	 add	 r9d, ecx
  00c58	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL19@PyCode_Opt:

; 748  :             codestr[h++] = codestr[i++];

  00c60	0f b6 04 3b	 movzx	 eax, BYTE PTR [rbx+rdi]
  00c64	48 ff c2	 inc	 rdx
  00c67	48 ff c3	 inc	 rbx
  00c6a	ff c9		 dec	 ecx
  00c6c	88 44 3a ff	 mov	 BYTE PTR [rdx+rdi-1], al
  00c70	75 ee		 jne	 SHORT $LL19@PyCode_Opt
$LN217@PyCode_Opt:

; 716  :     }
; 717  : 
; 718  :     /* Remove NOPs and fixup jump targets */
; 719  :     for (i=0, h=0 ; i<codelen ; ) {

  00c72	49 3b da	 cmp	 rbx, r10
  00c75	0f 8c 55 ff ff
	ff		 jl	 $LL26@PyCode_Opt
  00c7b	4c 8b 6c 24 30	 mov	 r13, QWORD PTR const_stack$1$[rsp]
$LN25@PyCode_Opt:

; 749  :     }
; 750  :     assert(h + nops == codelen);
; 751  : 
; 752  :     code = PyBytes_FromStringAndSize((char *)codestr, h);

  00c80	49 63 d1	 movsxd	 rdx, r9d
  00c83	48 8b cf	 mov	 rcx, rdi
  00c86	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00c8b	48 8b d8	 mov	 rbx, rax

; 753  :     CONST_STACK_DELETE();

  00c8e	4d 85 ed	 test	 r13, r13
  00c91	74 08		 je	 SHORT $LN14@PyCode_Opt
  00c93	49 8b cd	 mov	 rcx, r13
  00c96	e8 00 00 00 00	 call	 PyMem_Free
$LN14@PyCode_Opt:
  00c9b	4d 85 f6	 test	 r14, r14
  00c9e	74 08		 je	 SHORT $LN16@PyCode_Opt
  00ca0	49 8b ce	 mov	 rcx, r14
  00ca3	e8 00 00 00 00	 call	 PyMem_Free
$LN16@PyCode_Opt:

; 754  :     PyMem_Free(addrmap);

  00ca8	48 8b ce	 mov	 rcx, rsi
  00cab	e8 00 00 00 00	 call	 PyMem_Free

; 755  :     PyMem_Free(codestr);

  00cb0	48 8b cf	 mov	 rcx, rdi
  00cb3	e8 00 00 00 00	 call	 PyMem_Free

; 756  :     PyMem_Free(blocks);

  00cb8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR blocks$1$[rsp]
  00cbd	e8 00 00 00 00	 call	 PyMem_Free

; 757  :     return code;

  00cc2	48 8b c3	 mov	 rax, rbx
  00cc5	e9 a6 00 00 00	 jmp	 $LN154@PyCode_Opt
$LN272@PyCode_Opt:

; 381  : {

  00cca	4c 8b e8	 mov	 r13, rax
$exitError$21750:

; 758  : 
; 759  :  exitError:
; 760  :     code = NULL;

  00ccd	4c 8b e3	 mov	 r12, rbx
  00cd0	eb 0d		 jmp	 SHORT $exitUnchanged$21759
$LN268@PyCode_Opt:

; 381  : {

  00cd2	4c 8b a4 24 c0
	00 00 00	 mov	 r12, QWORD PTR code$[rsp]
  00cda	4c 8b 6c 24 58	 mov	 r13, QWORD PTR addrmap$1$[rsp]
$exitUnchanged$21759:

; 761  : 
; 762  :  exitUnchanged:
; 763  :     CONST_STACK_DELETE();

  00cdf	48 8b 44 24 30	 mov	 rax, QWORD PTR const_stack$1$[rsp]
  00ce4	48 85 c0	 test	 rax, rax
  00ce7	74 08		 je	 SHORT $LN9@PyCode_Opt
  00ce9	48 8b c8	 mov	 rcx, rax
  00cec	e8 00 00 00 00	 call	 PyMem_Free
$LN9@PyCode_Opt:
  00cf1	4d 85 f6	 test	 r14, r14
  00cf4	74 08		 je	 SHORT $LN11@PyCode_Opt
  00cf6	49 8b ce	 mov	 rcx, r14
  00cf9	e8 00 00 00 00	 call	 PyMem_Free
$LN11@PyCode_Opt:

; 764  :     if (blocks != NULL)

  00cfe	48 8b 44 24 40	 mov	 rax, QWORD PTR blocks$1$[rsp]
  00d03	48 85 c0	 test	 rax, rax
  00d06	74 08		 je	 SHORT $LN7@PyCode_Opt

; 765  :         PyMem_Free(blocks);

  00d08	48 8b c8	 mov	 rcx, rax
  00d0b	e8 00 00 00 00	 call	 PyMem_Free
$LN7@PyCode_Opt:

; 766  :     if (addrmap != NULL)

  00d10	4d 85 ed	 test	 r13, r13
  00d13	74 08		 je	 SHORT $LN6@PyCode_Opt

; 767  :         PyMem_Free(addrmap);

  00d15	49 8b cd	 mov	 rcx, r13
  00d18	e8 00 00 00 00	 call	 PyMem_Free
$LN6@PyCode_Opt:

; 768  :     if (codestr != NULL)

  00d1d	48 85 ff	 test	 rdi, rdi
  00d20	74 08		 je	 SHORT $LN4@PyCode_Opt

; 769  :         PyMem_Free(codestr);

  00d22	48 8b cf	 mov	 rcx, rdi
  00d25	e8 00 00 00 00	 call	 PyMem_Free
$LN4@PyCode_Opt:

; 770  :     Py_XINCREF(code);

  00d2a	4d 85 e4	 test	 r12, r12
  00d2d	74 3e		 je	 SHORT $LN3@PyCode_Opt
  00d2f	e8 00 00 00 00	 call	 _Py_PXCTX
  00d34	85 c0		 test	 eax, eax
  00d36	75 35		 jne	 SHORT $LN3@PyCode_Opt
  00d38	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00d3f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00d46	4d 8b cc	 mov	 r9, r12
  00d49	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00d4f	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00d57	e8 00 00 00 00	 call	 _PyParallel_Guard
  00d5c	85 c0		 test	 eax, eax
  00d5e	75 08		 jne	 SHORT $LN198@PyCode_Opt
  00d60	41 f6 44 24 20
	20		 test	 BYTE PTR [r12+32], 32	; 00000020H
  00d66	74 05		 je	 SHORT $LN3@PyCode_Opt
$LN198@PyCode_Opt:
  00d68	49 ff 44 24 50	 inc	 QWORD PTR [r12+80]
$LN3@PyCode_Opt:

; 771  :     return code;

  00d6d	49 8b c4	 mov	 rax, r12
$LN154@PyCode_Opt:

; 772  : }

  00d70	48 8b 9c 24 d8
	00 00 00	 mov	 rbx, QWORD PTR [rsp+216]
  00d78	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00d7f	41 5f		 pop	 r15
  00d81	41 5e		 pop	 r14
  00d83	41 5d		 pop	 r13
  00d85	41 5c		 pop	 r12
  00d87	5f		 pop	 rdi
  00d88	5e		 pop	 rsi
  00d89	5d		 pop	 rbp
  00d8a	c3		 ret	 0
  00d8b	90		 npad	 1
$LN223@PyCode_Opt:
  00d8c	00 00 00 00	 DD	 $LN67@PyCode_Opt
  00d90	00 00 00 00	 DD	 $LN135@PyCode_Opt
  00d94	00 00 00 00	 DD	 $LN78@PyCode_Opt
  00d98	00 00 00 00	 DD	 $LN39@PyCode_Opt
  00d9c	00 00 00 00	 DD	 $LN52@PyCode_Opt
  00da0	00 00 00 00	 DD	 $LN118@PyCode_Opt
  00da4	00 00 00 00	 DD	 $LN129@PyCode_Opt
  00da8	00 00 00 00	 DD	 $LN107@PyCode_Opt
  00dac	00 00 00 00	 DD	 $LN132@PyCode_Opt
  00db0	00 00 00 00	 DD	 $LN56@PyCode_Opt
  00db4	00 00 00 00	 DD	 $LN41@PyCode_Opt
  00db8	00 00 00 00	 DD	 $LN241@PyCode_Opt
$LN222@PyCode_Opt:
  00dbc	00		 DB	 0
  00dbd	00		 DB	 0
  00dbe	01		 DB	 1
  00dbf	0b		 DB	 11
  00dc0	0b		 DB	 11
  00dc1	00		 DB	 0
  00dc2	0b		 DB	 11
  00dc3	0b		 DB	 11
  00dc4	0b		 DB	 11
  00dc5	02		 DB	 2
  00dc6	02		 DB	 2
  00dc7	0b		 DB	 11
  00dc8	02		 DB	 2
  00dc9	02		 DB	 2
  00dca	02		 DB	 2
  00dcb	02		 DB	 2
  00dcc	02		 DB	 2
  00dcd	02		 DB	 2
  00dce	0b		 DB	 11
  00dcf	0b		 DB	 11
  00dd0	0b		 DB	 11
  00dd1	0b		 DB	 11
  00dd2	0b		 DB	 11
  00dd3	0b		 DB	 11
  00dd4	0b		 DB	 11
  00dd5	0b		 DB	 11
  00dd6	0b		 DB	 11
  00dd7	0b		 DB	 11
  00dd8	0b		 DB	 11
  00dd9	0b		 DB	 11
  00dda	0b		 DB	 11
  00ddb	0b		 DB	 11
  00ddc	0b		 DB	 11
  00ddd	0b		 DB	 11
  00dde	0b		 DB	 11
  00ddf	0b		 DB	 11
  00de0	0b		 DB	 11
  00de1	0b		 DB	 11
  00de2	0b		 DB	 11
  00de3	0b		 DB	 11
  00de4	0b		 DB	 11
  00de5	0b		 DB	 11
  00de6	0b		 DB	 11
  00de7	0b		 DB	 11
  00de8	0b		 DB	 11
  00de9	0b		 DB	 11
  00dea	0b		 DB	 11
  00deb	0b		 DB	 11
  00dec	0b		 DB	 11
  00ded	0b		 DB	 11
  00dee	0b		 DB	 11
  00def	0b		 DB	 11
  00df0	02		 DB	 2
  00df1	02		 DB	 2
  00df2	02		 DB	 2
  00df3	02		 DB	 2
  00df4	02		 DB	 2
  00df5	0b		 DB	 11
  00df6	0b		 DB	 11
  00df7	0b		 DB	 11
  00df8	0b		 DB	 11
  00df9	0b		 DB	 11
  00dfa	0b		 DB	 11
  00dfb	0b		 DB	 11
  00dfc	0b		 DB	 11
  00dfd	0b		 DB	 11
  00dfe	0b		 DB	 11
  00dff	0b		 DB	 11
  00e00	0b		 DB	 11
  00e01	0b		 DB	 11
  00e02	0b		 DB	 11
  00e03	0b		 DB	 11
  00e04	0b		 DB	 11
  00e05	03		 DB	 3
  00e06	0b		 DB	 11
  00e07	0b		 DB	 11
  00e08	0b		 DB	 11
  00e09	0b		 DB	 11
  00e0a	0b		 DB	 11
  00e0b	0b		 DB	 11
  00e0c	0b		 DB	 11
  00e0d	0b		 DB	 11
  00e0e	0b		 DB	 11
  00e0f	04		 DB	 4
  00e10	0b		 DB	 11
  00e11	0b		 DB	 11
  00e12	0b		 DB	 11
  00e13	0b		 DB	 11
  00e14	0b		 DB	 11
  00e15	0b		 DB	 11
  00e16	05		 DB	 5
  00e17	06		 DB	 6
  00e18	07		 DB	 7
  00e19	07		 DB	 7
  00e1a	07		 DB	 7
  00e1b	0b		 DB	 11
  00e1c	0b		 DB	 11
  00e1d	08		 DB	 8
  00e1e	0b		 DB	 11
  00e1f	0b		 DB	 11
  00e20	04		 DB	 4
  00e21	09		 DB	 9
  00e22	09		 DB	 9
  00e23	04		 DB	 4
  00e24	04		 DB	 4
  00e25	04		 DB	 4
  00e26	06		 DB	 6
  00e27	0b		 DB	 11
  00e28	0b		 DB	 11
  00e29	04		 DB	 4
  00e2a	04		 DB	 4
  00e2b	04		 DB	 4
  00e2c	04		 DB	 4
  00e2d	0b		 DB	 11
  00e2e	0b		 DB	 11
  00e2f	0b		 DB	 11
  00e30	0b		 DB	 11
  00e31	0b		 DB	 11
  00e32	0b		 DB	 11
  00e33	0b		 DB	 11
  00e34	0b		 DB	 11
  00e35	0b		 DB	 11
  00e36	0b		 DB	 11
  00e37	0b		 DB	 11
  00e38	0b		 DB	 11
  00e39	0b		 DB	 11
  00e3a	0b		 DB	 11
  00e3b	0b		 DB	 11
  00e3c	0b		 DB	 11
  00e3d	0b		 DB	 11
  00e3e	0b		 DB	 11
  00e3f	0b		 DB	 11
  00e40	0b		 DB	 11
  00e41	04		 DB	 4
  00e42	0a		 DB	 10
  00e43	90		 npad	 1
$LN221@PyCode_Opt:
  00e44	00 00 00 00	 DD	 $LN22@PyCode_Opt
  00e48	00 00 00 00	 DD	 $LN20@PyCode_Opt
  00e4c	00 00 00 00	 DD	 $LN21@PyCode_Opt
  00e50	00 00 00 00	 DD	 $LN23@PyCode_Opt
$LN220@PyCode_Opt:
  00e54	00		 DB	 0
  00e55	03		 DB	 3
  00e56	03		 DB	 3
  00e57	03		 DB	 3
  00e58	03		 DB	 3
  00e59	03		 DB	 3
  00e5a	03		 DB	 3
  00e5b	03		 DB	 3
  00e5c	03		 DB	 3
  00e5d	03		 DB	 3
  00e5e	03		 DB	 3
  00e5f	03		 DB	 3
  00e60	03		 DB	 3
  00e61	03		 DB	 3
  00e62	03		 DB	 3
  00e63	03		 DB	 3
  00e64	03		 DB	 3
  00e65	03		 DB	 3
  00e66	03		 DB	 3
  00e67	03		 DB	 3
  00e68	03		 DB	 3
  00e69	03		 DB	 3
  00e6a	03		 DB	 3
  00e6b	03		 DB	 3
  00e6c	03		 DB	 3
  00e6d	03		 DB	 3
  00e6e	03		 DB	 3
  00e6f	03		 DB	 3
  00e70	03		 DB	 3
  00e71	03		 DB	 3
  00e72	03		 DB	 3
  00e73	03		 DB	 3
  00e74	03		 DB	 3
  00e75	03		 DB	 3
  00e76	03		 DB	 3
  00e77	03		 DB	 3
  00e78	03		 DB	 3
  00e79	03		 DB	 3
  00e7a	03		 DB	 3
  00e7b	03		 DB	 3
  00e7c	03		 DB	 3
  00e7d	03		 DB	 3
  00e7e	03		 DB	 3
  00e7f	03		 DB	 3
  00e80	03		 DB	 3
  00e81	03		 DB	 3
  00e82	03		 DB	 3
  00e83	03		 DB	 3
  00e84	03		 DB	 3
  00e85	03		 DB	 3
  00e86	03		 DB	 3
  00e87	03		 DB	 3
  00e88	03		 DB	 3
  00e89	03		 DB	 3
  00e8a	03		 DB	 3
  00e8b	03		 DB	 3
  00e8c	03		 DB	 3
  00e8d	03		 DB	 3
  00e8e	03		 DB	 3
  00e8f	03		 DB	 3
  00e90	03		 DB	 3
  00e91	03		 DB	 3
  00e92	03		 DB	 3
  00e93	03		 DB	 3
  00e94	03		 DB	 3
  00e95	03		 DB	 3
  00e96	03		 DB	 3
  00e97	03		 DB	 3
  00e98	03		 DB	 3
  00e99	03		 DB	 3
  00e9a	03		 DB	 3
  00e9b	03		 DB	 3
  00e9c	03		 DB	 3
  00e9d	03		 DB	 3
  00e9e	03		 DB	 3
  00e9f	03		 DB	 3
  00ea0	03		 DB	 3
  00ea1	03		 DB	 3
  00ea2	03		 DB	 3
  00ea3	03		 DB	 3
  00ea4	03		 DB	 3
  00ea5	03		 DB	 3
  00ea6	03		 DB	 3
  00ea7	03		 DB	 3
  00ea8	01		 DB	 1
  00ea9	03		 DB	 3
  00eaa	03		 DB	 3
  00eab	03		 DB	 3
  00eac	03		 DB	 3
  00ead	03		 DB	 3
  00eae	03		 DB	 3
  00eaf	03		 DB	 3
  00eb0	03		 DB	 3
  00eb1	03		 DB	 3
  00eb2	03		 DB	 3
  00eb3	03		 DB	 3
  00eb4	03		 DB	 3
  00eb5	03		 DB	 3
  00eb6	03		 DB	 3
  00eb7	03		 DB	 3
  00eb8	03		 DB	 3
  00eb9	01		 DB	 1
  00eba	02		 DB	 2
  00ebb	02		 DB	 2
  00ebc	02		 DB	 2
  00ebd	02		 DB	 2
  00ebe	02		 DB	 2
  00ebf	03		 DB	 3
  00ec0	03		 DB	 3
  00ec1	03		 DB	 3
  00ec2	02		 DB	 2
  00ec3	01		 DB	 1
  00ec4	01		 DB	 1
  00ec5	01		 DB	 1
  00ec6	03		 DB	 3
  00ec7	03		 DB	 3
  00ec8	03		 DB	 3
  00ec9	03		 DB	 3
  00eca	03		 DB	 3
  00ecb	03		 DB	 3
  00ecc	03		 DB	 3
  00ecd	03		 DB	 3
  00ece	03		 DB	 3
  00ecf	03		 DB	 3
  00ed0	03		 DB	 3
  00ed1	03		 DB	 3
  00ed2	03		 DB	 3
  00ed3	03		 DB	 3
  00ed4	03		 DB	 3
  00ed5	03		 DB	 3
  00ed6	03		 DB	 3
  00ed7	03		 DB	 3
  00ed8	03		 DB	 3
  00ed9	03		 DB	 3
  00eda	01		 DB	 1
PyCode_Optimize ENDP
_TEXT	ENDS
END
