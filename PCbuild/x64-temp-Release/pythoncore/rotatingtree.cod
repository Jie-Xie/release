; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
random_stream DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
random_value DD	01H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\rotatingtree.c
_DATA	ENDS
;	COMDAT randombits
_TEXT	SEGMENT
bits$ = 8
randombits PROC						; COMDAT

; 17   :     int result;
; 18   :     if (random_stream < (1U << bits)) {

  00000	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR random_stream
  00006	b8 01 00 00 00	 mov	 eax, 1
  0000b	d3 e0		 shl	 eax, cl
  0000d	3b d0		 cmp	 edx, eax
  0000f	73 12		 jae	 SHORT $LN1@randombits

; 19   :         random_value *= 1082527;

  00011	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR random_value
  00017	69 d2 9f 84 10
	00		 imul	 edx, 1082527		; 0010849fH
  0001d	89 15 00 00 00
	00		 mov	 DWORD PTR random_value, edx
$LN1@randombits:

; 20   :         random_stream = random_value;
; 21   :     }
; 22   :     result = random_stream & ((1<<bits)-1);

  00023	ff c8		 dec	 eax
  00025	23 c2		 and	 eax, edx

; 23   :     random_stream >>= bits;

  00027	d3 ea		 shr	 edx, cl
  00029	89 15 00 00 00
	00		 mov	 DWORD PTR random_stream, edx

; 24   :     return result;
; 25   : }

  0002f	c3		 ret	 0
randombits ENDP
_TEXT	ENDS
PUBLIC	RotatingTree_Add
; Function compile flags: /Ogtpy
;	COMDAT RotatingTree_Add
_TEXT	SEGMENT
root$ = 8
node$ = 16
RotatingTree_Add PROC					; COMDAT

; 33   :     while (*root != NULL) {

  00000	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  00004	74 22		 je	 SHORT $LN3@RotatingTr
  00006	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@RotatingTr:

; 34   :         if (KEY_LOWER_THAN(node->key, (*root)->key))

  00010	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00013	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  00016	73 06		 jae	 SHORT $LN2@RotatingTr

; 35   :             root = &((*root)->left);

  00018	48 83 c1 08	 add	 rcx, 8

; 36   :         else

  0001c	eb 04		 jmp	 SHORT $LN1@RotatingTr
$LN2@RotatingTr:

; 37   :             root = &((*root)->right);

  0001e	48 83 c1 10	 add	 rcx, 16
$LN1@RotatingTr:

; 33   :     while (*root != NULL) {

  00022	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  00026	75 e8		 jne	 SHORT $LL4@RotatingTr
$LN3@RotatingTr:

; 38   :     }
; 39   :     node->left = NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax

; 40   :     node->right = NULL;

  0002e	48 89 42 10	 mov	 QWORD PTR [rdx+16], rax

; 41   :     *root = node;

  00032	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 42   : }

  00035	c3		 ret	 0
RotatingTree_Add ENDP
_TEXT	ENDS
PUBLIC	RotatingTree_Get
;	COMDAT pdata
pdata	SEGMENT
$pdata$RotatingTree_Get DD imagerel $LN32
	DD	imagerel $LN32+212
	DD	imagerel $unwind$RotatingTree_Get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RotatingTree_Get DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT RotatingTree_Get
_TEXT	SEGMENT
root$ = 48
key$ = 56
RotatingTree_Get PROC					; COMDAT

; 49   : {

$LN32:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	4c 8b d1	 mov	 r10, rcx

; 50   :     if (randombits(3) != 4) {

  00007	b9 03 00 00 00	 mov	 ecx, 3
  0000c	4c 8b ca	 mov	 r9, rdx
  0000f	e8 00 00 00 00	 call	 randombits
  00014	83 f8 04	 cmp	 eax, 4
  00017	74 2c		 je	 SHORT $LN19@RotatingTr@2

; 51   :         /* Fast path, no rebalancing */
; 52   :         rotating_node_t *node = *root;

  00019	49 8b 02	 mov	 rax, QWORD PTR [r10]

; 53   :         while (node != NULL) {

  0001c	48 85 c0	 test	 rax, rax
  0001f	74 1d		 je	 SHORT $LN17@RotatingTr@2
$LL18@RotatingTr@2:

; 54   :             if (node->key == key)

  00021	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00024	4c 3b c9	 cmp	 r9, rcx
  00027	0f 84 a2 00 00
	00		 je	 $LN10@RotatingTr@2

; 55   :                 return node;
; 56   :             if (KEY_LOWER_THAN(key, node->key))

  0002d	73 06		 jae	 SHORT $LN15@RotatingTr@2

; 57   :                 node = node->left;

  0002f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 58   :             else

  00033	eb 04		 jmp	 SHORT $LN14@RotatingTr@2
$LN15@RotatingTr@2:

; 59   :                 node = node->right;

  00035	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
$LN14@RotatingTr@2:

; 53   :         while (node != NULL) {

  00039	48 85 c0	 test	 rax, rax
  0003c	75 e3		 jne	 SHORT $LL18@RotatingTr@2
$LN17@RotatingTr@2:

; 60   :         }
; 61   :         return NULL;

  0003e	33 c0		 xor	 eax, eax

; 99   :         }
; 100  :     }
; 101  : }

  00040	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00044	c3		 ret	 0
$LN19@RotatingTr@2:

; 62   :     }
; 63   :     else {
; 64   :         rotating_node_t **pnode = root;
; 65   :         rotating_node_t *node = *pnode;

  00045	4d 8b 02	 mov	 r8, QWORD PTR [r10]

; 66   :         rotating_node_t *next;
; 67   :         int rotate;
; 68   :         if (node == NULL)

  00048	4d 85 c0	 test	 r8, r8

; 69   :             return NULL;

  0004b	74 f1		 je	 SHORT $LN17@RotatingTr@2

; 70   :         while (1) {
; 71   :             if (node->key == key)

  0004d	4d 39 08	 cmp	 QWORD PTR [r8], r9
$LN31@RotatingTr@2:
  00050	74 7a		 je	 SHORT $LN26@RotatingTr@2

; 73   :             rotate = !randombits(1);

  00052	b9 01 00 00 00	 mov	 ecx, 1
  00057	e8 00 00 00 00	 call	 randombits
  0005c	45 33 db	 xor	 r11d, r11d
  0005f	85 c0		 test	 eax, eax
  00061	41 0f 94 c3	 sete	 r11b

; 74   :             if (KEY_LOWER_THAN(key, node->key)) {

  00065	4d 3b 08	 cmp	 r9, QWORD PTR [r8]
  00068	73 31		 jae	 SHORT $LN8@RotatingTr@2

; 75   :                 next = node->left;

  0006a	49 8b 48 08	 mov	 rcx, QWORD PTR [r8+8]

; 76   :                 if (next == NULL)

  0006e	48 85 c9	 test	 rcx, rcx
  00071	74 cb		 je	 SHORT $LN17@RotatingTr@2

; 77   :                     return NULL;
; 78   :                 if (rotate) {

  00073	45 85 db	 test	 r11d, r11d
  00076	74 17		 je	 SHORT $LN6@RotatingTr@2

; 79   :                     node->left = next->right;

  00078	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  0007c	49 89 40 08	 mov	 QWORD PTR [r8+8], rax

; 80   :                     next->right = node;

  00080	4c 89 41 10	 mov	 QWORD PTR [rcx+16], r8

; 81   :                     *pnode = next;

  00084	49 89 0a	 mov	 QWORD PTR [r10], rcx
  00087	4c 39 09	 cmp	 QWORD PTR [rcx], r9

; 97   :             }
; 98   :             node = next;

  0008a	4c 8b c1	 mov	 r8, rcx
  0008d	eb c1		 jmp	 SHORT $LN31@RotatingTr@2
$LN6@RotatingTr@2:

; 70   :         while (1) {
; 71   :             if (node->key == key)

  0008f	4c 39 09	 cmp	 QWORD PTR [rcx], r9

; 82   :                 }
; 83   :                 else
; 84   :                     pnode = &(node->left);

  00092	4d 8d 50 08	 lea	 r10, QWORD PTR [r8+8]

; 97   :             }
; 98   :             node = next;

  00096	4c 8b c1	 mov	 r8, rcx
  00099	eb b5		 jmp	 SHORT $LN31@RotatingTr@2
$LN8@RotatingTr@2:

; 85   :             }
; 86   :             else {
; 87   :                 next = node->right;

  0009b	49 8b 48 10	 mov	 rcx, QWORD PTR [r8+16]

; 88   :                 if (next == NULL)

  0009f	48 85 c9	 test	 rcx, rcx
  000a2	74 9a		 je	 SHORT $LN17@RotatingTr@2

; 89   :                     return NULL;
; 90   :                 if (rotate) {

  000a4	45 85 db	 test	 r11d, r11d
  000a7	74 17		 je	 SHORT $LN2@RotatingTr@2

; 91   :                     node->right = next->left;

  000a9	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  000ad	49 89 40 10	 mov	 QWORD PTR [r8+16], rax

; 92   :                     next->left = node;

  000b1	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 93   :                     *pnode = next;

  000b5	49 89 0a	 mov	 QWORD PTR [r10], rcx
  000b8	4c 39 09	 cmp	 QWORD PTR [rcx], r9

; 97   :             }
; 98   :             node = next;

  000bb	4c 8b c1	 mov	 r8, rcx
  000be	eb 90		 jmp	 SHORT $LN31@RotatingTr@2
$LN2@RotatingTr@2:

; 70   :         while (1) {
; 71   :             if (node->key == key)

  000c0	4c 39 09	 cmp	 QWORD PTR [rcx], r9

; 94   :                 }
; 95   :                 else
; 96   :                     pnode = &(node->right);

  000c3	4d 8d 50 10	 lea	 r10, QWORD PTR [r8+16]

; 97   :             }
; 98   :             node = next;

  000c7	4c 8b c1	 mov	 r8, rcx
  000ca	eb 84		 jmp	 SHORT $LN31@RotatingTr@2
$LN26@RotatingTr@2:

; 72   :                 return node;

  000cc	49 8b c0	 mov	 rax, r8
$LN10@RotatingTr@2:

; 99   :         }
; 100  :     }
; 101  : }

  000cf	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000d3	c3		 ret	 0
RotatingTree_Get ENDP
_TEXT	ENDS
PUBLIC	RotatingTree_Enum
;	COMDAT pdata
pdata	SEGMENT
$pdata$RotatingTree_Enum DD imagerel $LN11
	DD	imagerel $LN11+114
	DD	imagerel $unwind$RotatingTree_Enum
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RotatingTree_Enum DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT RotatingTree_Enum
_TEXT	SEGMENT
root$ = 48
enumfn$ = 56
arg$ = 64
RotatingTree_Enum PROC					; COMDAT

; 109  : {

$LN11:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	49 8b f0	 mov	 rsi, r8
  00017	48 8b ea	 mov	 rbp, rdx
  0001a	48 8b f9	 mov	 rdi, rcx

; 110  :     int result;
; 111  :     rotating_node_t *node;
; 112  :     while (root != NULL) {

  0001d	48 85 c9	 test	 rcx, rcx
  00020	74 39		 je	 SHORT $LN3@RotatingTr@3
  00022	66 66 66 66 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL4@RotatingTr@3:

; 113  :         result = RotatingTree_Enum(root->left, enumfn, arg);

  00030	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00034	4c 8b c6	 mov	 r8, rsi
  00037	48 8b d5	 mov	 rdx, rbp
  0003a	e8 00 00 00 00	 call	 RotatingTree_Enum

; 114  :         if (result != 0) return result;

  0003f	85 c0		 test	 eax, eax
  00041	75 1a		 jne	 SHORT $LN5@RotatingTr@3

; 115  :         node = root->right;

  00043	48 8b 5f 10	 mov	 rbx, QWORD PTR [rdi+16]

; 116  :         result = enumfn(root, arg);

  00047	48 8b d6	 mov	 rdx, rsi
  0004a	48 8b cf	 mov	 rcx, rdi
  0004d	ff d5		 call	 rbp

; 117  :         if (result != 0) return result;

  0004f	85 c0		 test	 eax, eax
  00051	75 0a		 jne	 SHORT $LN5@RotatingTr@3

; 118  :         root = node;

  00053	48 8b fb	 mov	 rdi, rbx
  00056	48 85 db	 test	 rbx, rbx
  00059	75 d5		 jne	 SHORT $LL4@RotatingTr@3
$LN3@RotatingTr@3:

; 119  :     }
; 120  :     return 0;

  0005b	33 c0		 xor	 eax, eax
$LN5@RotatingTr@3:

; 121  : }

  0005d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00062	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00067	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0006c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00070	5f		 pop	 rdi
  00071	c3		 ret	 0
RotatingTree_Enum ENDP
_TEXT	ENDS
END
