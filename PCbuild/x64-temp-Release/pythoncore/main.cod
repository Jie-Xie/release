; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0PH@PPPCLIAI@PYTHONHASHSEED?3?5if?5this?5variable@ ; `string'
PUBLIC	??_C@_0BEA@BALBKLFN@PYTHONHOME?5?5?5?3?5alternate?5?$DMprefix@ ; `string'
PUBLIC	??_C@_0BII@FPIDEIJE@file?5?5?5?3?5program?5read?5from?5scrip@ ; `string'
PUBLIC	??_C@_0CFC@NIJOBHPJ@?9u?5?5?5?5?5?3?5unbuffered?5binary?5stdou@ ; `string'
PUBLIC	??_C@_0CCE@ELHEAOKH@?9i?5?5?5?5?5?3?5inspect?5interactively?5a@ ; `string'
PUBLIC	??_C@_0CAO@BDKKHAC@Options?5and?5arguments?5?$CIand?5corre@ ; `string'
PUBLIC	??_C@_0EA@DDFOEECA@usage?3?5?$CFls?5?$FLoption?$FN?5?4?4?4?5?$FL?9c?5cmd?5@ ; `string'
;	COMDAT ??_C@_0PH@PPPCLIAI@PYTHONHASHSEED?3?5if?5this?5variable@
CONST	SEGMENT
??_C@_0PH@PPPCLIAI@PYTHONHASHSEED?3?5if?5this?5variable@ DB 'PYTHONHASHSE'
	DB	'ED: if this variable is set to ''random'', a random value is '
	DB	'used', 0aH, '   to seed the hashes of str, bytes and datetime'
	DB	' objects.  It can also be', 0aH, '   set to an integer in the'
	DB	' range [0,4294967295] to get hash values with a', 0aH, '   pr'
	DB	'edictable seed.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BEA@BALBKLFN@PYTHONHOME?5?5?5?3?5alternate?5?$DMprefix@
CONST	SEGMENT
??_C@_0BEA@BALBKLFN@PYTHONHOME?5?5?5?3?5alternate?5?$DMprefix@ DB 'PYTHON'
	DB	'HOME   : alternate <prefix> directory (or <prefix>%c<exec_pre'
	DB	'fix>).', 0aH, '               The default module search path '
	DB	'uses %s.', 0aH, 'PYTHONCASEOK : ignore case in ''import'' sta'
	DB	'tements (Windows).', 0aH, 'PYTHONIOENCODING: Encoding[:errors'
	DB	'] used for stdin/stdout/stderr.', 0aH, 'PYTHONFAULTHANDLER: d'
	DB	'ump the Python traceback on fatal errors.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BII@FPIDEIJE@file?5?5?5?3?5program?5read?5from?5scrip@
CONST	SEGMENT
??_C@_0BII@FPIDEIJE@file?5?5?5?3?5program?5read?5from?5scrip@ DB 'file   '
	DB	': program read from script file', 0aH, '-      : program read'
	DB	' from stdin (default; interactive mode if a tty)', 0aH, 'arg '
	DB	'...: arguments passed to program in sys.argv[1:]', 0aH, 0aH, 'O'
	DB	'ther environment variables:', 0aH, 'PYTHONSTARTUP: file execu'
	DB	'ted on interactive startup (no default)', 0aH, 'PYTHONPATH   '
	DB	': ''%c''-separated list of directories prefixed to the', 0aH, ' '
	DB	'              default module search path.  The result is sys.'
	DB	'path.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CFC@NIJOBHPJ@?9u?5?5?5?5?5?3?5unbuffered?5binary?5stdou@
CONST	SEGMENT
??_C@_0CFC@NIJOBHPJ@?9u?5?5?5?5?5?3?5unbuffered?5binary?5stdou@ DB '-u   '
	DB	'  : unbuffered binary stdout and stderr, stdin always buffere'
	DB	'd;', 0aH, '         also PYTHONUNBUFFERED=x', 0aH, '         '
	DB	'see man page for details on internal buffering relating to '''
	DB	'-u''', 0aH, '-v     : verbose (trace import statements); also'
	DB	' PYTHONVERBOSE=x', 0aH, '         can be supplied multiple ti'
	DB	'mes to increase verbosity', 0aH, '-V     : print the Python v'
	DB	'ersion number and exit (also --version)', 0aH, '-W arg : warn'
	DB	'ing control; arg is action:message:category:module:lineno', 0aH
	DB	'         also PYTHONWARNINGS=arg', 0aH, '-x     : skip first '
	DB	'line of source, allowing use of non-Unix forms of #!cmd', 0aH
	DB	'-X opt : set implementation-specific option', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CCE@ELHEAOKH@?9i?5?5?5?5?5?3?5inspect?5interactively?5a@
CONST	SEGMENT
??_C@_0CCE@ELHEAOKH@?9i?5?5?5?5?5?3?5inspect?5interactively?5a@ DB '-i   '
	DB	'  : inspect interactively after running script; forces a prom'
	DB	'pt even', 0aH, '         if stdin does not appear to be a ter'
	DB	'minal; also PYTHONINSPECT=x', 0aH, '-m mod : run library modu'
	DB	'le as a script (terminates option list)', 0aH, '-O     : opti'
	DB	'mize generated bytecode slightly; also PYTHONOPTIMIZE=x', 0aH
	DB	'-OO    : remove doc-strings in addition to the -O optimizatio'
	DB	'ns', 0aH, '-q     : don''t print version and copyright messag'
	DB	'es on interactive startup', 0aH, '-s     : don''t add user si'
	DB	'te directory to sys.path; also PYTHONNOUSERSITE', 0aH, '-S   '
	DB	'  : don''t imply ''import site'' on initialization', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CAO@BDKKHAC@Options?5and?5arguments?5?$CIand?5corre@
CONST	SEGMENT
??_C@_0CAO@BDKKHAC@Options?5and?5arguments?5?$CIand?5corre@ DB 'Options a'
	DB	'nd arguments (and corresponding environment variables):', 0aH
	DB	'-b     : issue warnings about str(bytes_instance), str(bytear'
	DB	'ray_instance)', 0aH, '         and comparing bytes/bytearray '
	DB	'with str. (-bb: issue errors)', 0aH, '-B     : don''t write .'
	DB	'py[co] files on import; also PYTHONDONTWRITEBYTECODE=x', 0aH, '-'
	DB	'c cmd : program passed in as string (terminates option list)', 0aH
	DB	'-d     : debug output from parser; also PYTHONDEBUG=x', 0aH, '-'
	DB	'E     : ignore PYTHON* environment variables (such as PYTHONP'
	DB	'ATH)', 0aH, '-h     : print this help message and exit (also '
	DB	'--help)', 0aH, 00H				; `string'
CONST	ENDS
_DATA	SEGMENT
usage_line DQ	FLAT:??_C@_0EA@DDFOEECA@usage?3?5?$CFls?5?$FLoption?$FN?5?4?4?4?5?$FL?9c?5cmd?5@
usage_1	DQ	FLAT:??_C@_0CAO@BDKKHAC@Options?5and?5arguments?5?$CIand?5corre@
usage_2	DQ	FLAT:??_C@_0CCE@ELHEAOKH@?9i?5?5?5?5?5?3?5inspect?5interactively?5a@
usage_3	DQ	FLAT:??_C@_0CFC@NIJOBHPJ@?9u?5?5?5?5?5?3?5unbuffered?5binary?5stdou@
usage_4	DQ	FLAT:??_C@_0BII@FPIDEIJE@file?5?5?5?3?5program?5read?5from?5scrip@
usage_5	DQ	FLAT:??_C@_0BEA@BALBKLFN@PYTHONHOME?5?5?5?3?5alternate?5?$DMprefix@
usage_6	DQ	FLAT:??_C@_0PH@PPPCLIAI@PYTHONHASHSEED?3?5if?5this?5variable@
_DATA	ENDS
;	COMDAT ??_C@_0EA@DDFOEECA@usage?3?5?$CFls?5?$FLoption?$FN?5?4?4?4?5?$FL?9c?5cmd?5@
CONST	SEGMENT
??_C@_0EA@DDFOEECA@usage?3?5?$CFls?5?$FLoption?$FN?5?4?4?4?5?$FL?9c?5cmd?5@ DB 'u'
	DB	'sage: %ls [option] ... [-c cmd | -m mod | file | -] [arg] ...'
	DB	0aH, 00H					; `string'
CONST	ENDS
EXTRN	__imp__fstat64i32:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\sys\stat.inl
;	COMDAT fstat
_TEXT	SEGMENT
_Desc$ = 8
_Stat$ = 16
fstat	PROC						; COMDAT

; 53   :     _STATIC_ASSERT( sizeof(struct stat) == sizeof(struct _stat64i32) );
; 54   :     return _fstat64i32(_Desc,(struct _stat64i32 *)_Stat);
; 55   : }

  00000	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__fstat64i32
fstat	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@EFHGGAIP@?$DMprefix?$DO?2lib?$AA@	; `string'
PUBLIC	??_C@_0CH@EAKDMNDH@Try?5?$GApython?5?9h?8?5for?5more?5informa@ ; `string'
EXTRN	__imp_fputs:PROC
EXTRN	__imp_fprintf:PROC
EXTRN	__imp___iob_func:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\main.c
pdata	SEGMENT
$pdata$usage DD	imagerel usage
	DD	imagerel usage+236
	DD	imagerel $unwind$usage
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$usage DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0N@EFHGGAIP@?$DMprefix?$DO?2lib?$AA@
CONST	SEGMENT
??_C@_0N@EFHGGAIP@?$DMprefix?$DO?2lib?$AA@ DB '<prefix>\lib', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@EAKDMNDH@Try?5?$GApython?5?9h?8?5for?5more?5informa@
CONST	SEGMENT
??_C@_0CH@EAKDMNDH@Try?5?$GApython?5?9h?8?5for?5more?5informa@ DB 'Try `p'
	DB	'ython -h'' for more information.', 0aH, 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT usage
_TEXT	SEGMENT
exitcode$ = 48
program$ = 56
usage	PROC						; COMDAT

; 116  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f2	 mov	 rsi, rdx
  00012	8b f9		 mov	 edi, ecx

; 117  :     FILE *f = exitcode ? stderr : stdout;

  00014	85 c9		 test	 ecx, ecx
  00016	74 0c		 je	 SHORT $LN5@usage
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0001e	48 8d 58 60	 lea	 rbx, QWORD PTR [rax+96]
  00022	eb 0a		 jmp	 SHORT $LN6@usage
$LN5@usage:
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0002a	48 8d 58 30	 lea	 rbx, QWORD PTR [rax+48]
$LN6@usage:

; 118  : 
; 119  :     fprintf(f, usage_line, program);

  0002e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR usage_line
  00035	4c 8b c6	 mov	 r8, rsi
  00038	48 8b cb	 mov	 rcx, rbx
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 120  :     if (exitcode)

  00041	85 ff		 test	 edi, edi
  00043	74 22		 je	 SHORT $LN2@usage

; 121  :         fprintf(f, "Try `python -h' for more information.\n");

  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@EAKDMNDH@Try?5?$GApython?5?9h?8?5for?5more?5informa@
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 129  :     }
; 130  : #if defined(__VMS)
; 131  :     if (exitcode == 0) {
; 132  :         /* suppress 'error' message */
; 133  :         return 1;
; 134  :     }
; 135  :     else {
; 136  :         /* STS$M_INHIB_MSG + SS$_ABORT */
; 137  :         return 0x1000002c;
; 138  :     }
; 139  : #else
; 140  :     return exitcode;

  00055	8b c7		 mov	 eax, edi

; 141  : #endif
; 142  :     /*NOTREACHED*/
; 143  : }

  00057	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005c	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00061	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00065	5f		 pop	 rdi
  00066	c3		 ret	 0
$LN2@usage:

; 122  :     else {
; 123  :         fputs(usage_1, f);

  00067	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR usage_1
  0006e	48 8b d3	 mov	 rdx, rbx
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputs

; 124  :         fputs(usage_2, f);

  00077	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR usage_2
  0007e	48 8b d3	 mov	 rdx, rbx
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputs

; 125  :         fputs(usage_3, f);

  00087	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR usage_3
  0008e	48 8b d3	 mov	 rdx, rbx
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputs

; 126  :         fprintf(f, usage_4, DELIM);

  00097	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR usage_4
  0009e	41 b8 3b 00 00
	00		 mov	 r8d, 59			; 0000003bH
  000a4	48 8b cb	 mov	 rcx, rbx
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 127  :         fprintf(f, usage_5, DELIM, PYTHONHOMEHELP);

  000ad	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR usage_5
  000b4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0N@EFHGGAIP@?$DMprefix?$DO?2lib?$AA@
  000bb	41 b8 3b 00 00
	00		 mov	 r8d, 59			; 0000003bH
  000c1	48 8b cb	 mov	 rcx, rbx
  000c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 128  :         fputs(usage_6, f);

  000ca	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR usage_6
  000d1	48 8b d3	 mov	 rdx, rbx
  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputs

; 141  : #endif
; 142  :     /*NOTREACHED*/
; 143  : }

  000da	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000df	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000e4	8b c7		 mov	 eax, edi
  000e6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ea	5f		 pop	 rdi
  000eb	c3		 ret	 0
usage	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@DBLAKLMG@Could?5not?5open?5PYTHONSTARTUP?6?$AA@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_0O@LDAADIEE@PYTHONSTARTUP?$AA@		; `string'
EXTRN	PyErr_Print:PROC
EXTRN	PyErr_SetFromErrnoWithFilename:PROC
EXTRN	PyExc_IOError:QWORD
EXTRN	PySys_WriteStderr:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp_fclose:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	PyRun_SimpleFileExFlags:PROC
EXTRN	__imp_fopen:PROC
EXTRN	__imp_getenv:PROC
EXTRN	Py_IgnoreEnvironmentFlag:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$RunStartupFile DD imagerel RunStartupFile
	DD	imagerel RunStartupFile+29
	DD	imagerel $unwind$RunStartupFile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$RunStartupFile DD imagerel RunStartupFile+29
	DD	imagerel RunStartupFile+137
	DD	imagerel $chain$1$RunStartupFile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$RunStartupFile DD imagerel RunStartupFile+137
	DD	imagerel RunStartupFile+195
	DD	imagerel $chain$3$RunStartupFile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$RunStartupFile DD imagerel RunStartupFile+195
	DD	imagerel RunStartupFile+200
	DD	imagerel $chain$4$RunStartupFile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$RunStartupFile DD imagerel RunStartupFile+200
	DD	imagerel RunStartupFile+206
	DD	imagerel $chain$5$RunStartupFile
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$RunStartupFile DD 021H
	DD	imagerel RunStartupFile
	DD	imagerel RunStartupFile+29
	DD	imagerel $unwind$RunStartupFile
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$RunStartupFile DD 020021H
	DD	077400H
	DD	imagerel RunStartupFile
	DD	imagerel RunStartupFile+29
	DD	imagerel $unwind$RunStartupFile
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$RunStartupFile DD 040021H
	DD	077400H
	DD	063400H
	DD	imagerel RunStartupFile
	DD	imagerel RunStartupFile+29
	DD	imagerel $unwind$RunStartupFile
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$RunStartupFile DD 042f21H
	DD	06342fH
	DD	077405H
	DD	imagerel RunStartupFile
	DD	imagerel RunStartupFile+29
	DD	imagerel $unwind$RunStartupFile
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RunStartupFile DD 020601H
	DD	060023206H
xdata	ENDS
;	COMDAT ??_C@_0BO@DBLAKLMG@Could?5not?5open?5PYTHONSTARTUP?6?$AA@
CONST	SEGMENT
??_C@_0BO@DBLAKLMG@Could?5not?5open?5PYTHONSTARTUP?6?$AA@ DB 'Could not o'
	DB	'pen PYTHONSTARTUP', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LDAADIEE@PYTHONSTARTUP?$AA@
CONST	SEGMENT
??_C@_0O@LDAADIEE@PYTHONSTARTUP?$AA@ DB 'PYTHONSTARTUP', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT RunStartupFile
_TEXT	SEGMENT
cf$ = 48
RunStartupFile PROC					; COMDAT

; 146  : {

  00000	40 56		 push	 rsi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 147  :     char *startup = Py_GETENV("PYTHONSTARTUP");

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_IgnoreEnvironmentFlag, 0
  0000d	48 8b f1	 mov	 rsi, rcx
  00010	0f 85 b2 00 00
	00		 jne	 $LN1@RunStartup
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@LDAADIEE@PYTHONSTARTUP?$AA@
  0001d	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getenv
  00028	48 8b f8	 mov	 rdi, rax

; 148  :     if (startup != NULL && startup[0] != '\0') {

  0002b	48 85 c0	 test	 rax, rax
  0002e	0f 84 8f 00 00
	00		 je	 $LN8@RunStartup
  00034	80 38 00	 cmp	 BYTE PTR [rax], 0
  00037	0f 84 86 00 00
	00		 je	 $LN8@RunStartup

; 149  :         FILE *fp = fopen(startup, "r");

  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01KDCPPGHE@r?$AA@
  00044	48 8b c8	 mov	 rcx, rax
  00047	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  00052	48 8b d8	 mov	 rbx, rax

; 150  :         if (fp != NULL) {

  00055	48 85 c0	 test	 rax, rax
  00058	74 2f		 je	 SHORT $LN2@RunStartup

; 151  :             (void) PyRun_SimpleFileExFlags(fp, startup, 0, cf);

  0005a	4c 8b ce	 mov	 r9, rsi
  0005d	45 33 c0	 xor	 r8d, r8d
  00060	48 8b d7	 mov	 rdx, rdi
  00063	48 8b c8	 mov	 rcx, rax
  00066	e8 00 00 00 00	 call	 PyRun_SimpleFileExFlags

; 152  :             PyErr_Clear();

  0006b	e8 00 00 00 00	 call	 PyErr_Clear

; 153  :             fclose(fp);

  00070	48 8b cb	 mov	 rcx, rbx
  00073	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00078	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 164  :         }
; 165  :     }
; 166  : }

  0007d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00081	5e		 pop	 rsi
  00082	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_fclose
$LN2@RunStartup:

; 154  :         } else {
; 155  :             int save_errno;
; 156  : 
; 157  :             save_errno = errno;

  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 158  :             PySys_WriteStderr("Could not open PYTHONSTARTUP\n");

  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@DBLAKLMG@Could?5not?5open?5PYTHONSTARTUP?6?$AA@
  00096	8b 18		 mov	 ebx, DWORD PTR [rax]
  00098	e8 00 00 00 00	 call	 PySys_WriteStderr

; 159  :             errno = save_errno;

  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000a3	89 18		 mov	 DWORD PTR [rax], ebx

; 160  :             PyErr_SetFromErrnoWithFilename(PyExc_IOError,
; 161  :                             startup);

  000a5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  000ac	48 8b d7	 mov	 rdx, rdi
  000af	e8 00 00 00 00	 call	 PyErr_SetFromErrnoWithFilename

; 162  :             PyErr_Print();

  000b4	e8 00 00 00 00	 call	 PyErr_Print

; 163  :             PyErr_Clear();

  000b9	e8 00 00 00 00	 call	 PyErr_Clear
  000be	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
$LN8@RunStartup:
  000c3	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
$LN1@RunStartup:

; 164  :         }
; 165  :     }
; 166  : }

  000c8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cc	5e		 pop	 rsi
  000cd	c3		 ret	 0
RunStartupFile ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DK@PJLBBAF@Could?5not?5create?5arguments?5for?5r@ ; `string'
PUBLIC	??_C@_04IFLELAI@?$CIOi?$CJ?$AA@			; `string'
PUBLIC	??_C@_0CK@DPKAPBBI@Could?5not?5convert?5module?5name?5to@ ; `string'
PUBLIC	??_C@_0CM@NOBPIIPO@Could?5not?5access?5runpy?4_run_modu@ ; `string'
PUBLIC	??_C@_0BE@LIHJAHBD@_run_module_as_main?$AA@	; `string'
PUBLIC	??_C@_0BP@OFAJBJJI@Could?5not?5import?5runpy?5module?6?$AA@ ; `string'
PUBLIC	??_C@_05EIBALHPG@runpy?$AA@			; `string'
EXTRN	PyObject_Call:PROC
EXTRN	Py_BuildValue:PROC
EXTRN	PyUnicode_FromWideChar:PROC
EXTRN	PyObject_GetAttrString:PROC
EXTRN	PyImport_ImportModule:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$RunModule DD imagerel RunModule
	DD	imagerel RunModule+80
	DD	imagerel $unwind$RunModule
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$RunModule DD imagerel RunModule+80
	DD	imagerel RunModule+146
	DD	imagerel $chain$0$RunModule
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$RunModule DD imagerel RunModule+146
	DD	imagerel RunModule+414
	DD	imagerel $chain$4$RunModule
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$RunModule DD 061321H
	DD	0ac413H
	DD	097409H
	DD	086400H
	DD	imagerel RunModule
	DD	imagerel RunModule+80
	DD	imagerel $unwind$RunModule
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$RunModule DD 020521H
	DD	086405H
	DD	imagerel RunModule
	DD	imagerel RunModule+80
	DD	imagerel $unwind$RunModule
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RunModule DD 040901H
	DD	0d0053209H
	DD	030025003H
xdata	ENDS
;	COMDAT ??_C@_0DK@PJLBBAF@Could?5not?5create?5arguments?5for?5r@
CONST	SEGMENT
??_C@_0DK@PJLBBAF@Could?5not?5create?5arguments?5for?5r@ DB 'Could not cr'
	DB	'eate arguments for runpy._run_module_as_main', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04IFLELAI@?$CIOi?$CJ?$AA@
CONST	SEGMENT
??_C@_04IFLELAI@?$CIOi?$CJ?$AA@ DB '(Oi)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@DPKAPBBI@Could?5not?5convert?5module?5name?5to@
CONST	SEGMENT
??_C@_0CK@DPKAPBBI@Could?5not?5convert?5module?5name?5to@ DB 'Could not c'
	DB	'onvert module name to unicode', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@NOBPIIPO@Could?5not?5access?5runpy?4_run_modu@
CONST	SEGMENT
??_C@_0CM@NOBPIIPO@Could?5not?5access?5runpy?4_run_modu@ DB 'Could not ac'
	DB	'cess runpy._run_module_as_main', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LIHJAHBD@_run_module_as_main?$AA@
CONST	SEGMENT
??_C@_0BE@LIHJAHBD@_run_module_as_main?$AA@ DB '_run_module_as_main', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OFAJBJJI@Could?5not?5import?5runpy?5module?6?$AA@
CONST	SEGMENT
??_C@_0BP@OFAJBJJI@Could?5not?5import?5runpy?5module?6?$AA@ DB 'Could not'
	DB	' import runpy module', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EIBALHPG@runpy?$AA@
CONST	SEGMENT
??_C@_05EIBALHPG@runpy?$AA@ DB 'runpy', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT RunModule
_TEXT	SEGMENT
modname$ = 64
set_argv0$ = 72
RunModule PROC						; COMDAT

; 170  : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	41 55		 push	 r13
  00005	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00009	48 8b e9	 mov	 rbp, rcx

; 171  :     PyObject *module, *runpy, *runmodule, *runargs, *result;
; 172  :     runpy = PyImport_ImportModule("runpy");

  0000c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05EIBALHPG@runpy?$AA@
  00013	44 8b ea	 mov	 r13d, edx
  00016	e8 00 00 00 00	 call	 PyImport_ImportModule
  0001b	48 8b d8	 mov	 rbx, rax

; 173  :     if (runpy == NULL) {

  0001e	48 85 c0	 test	 rax, rax
  00021	75 23		 jne	 SHORT $LN6@RunModule

; 174  :         fprintf(stderr, "Could not import runpy module\n");

  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@OFAJBJJI@Could?5not?5import?5runpy?5module?6?$AA@
  00030	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 175  :         return -1;

  0003a	83 c8 ff	 or	 eax, -1

; 212  : }

  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	41 5d		 pop	 r13
  00043	5d		 pop	 rbp
  00044	5b		 pop	 rbx
  00045	c3		 ret	 0
$LN6@RunModule:

; 176  :     }
; 177  :     runmodule = PyObject_GetAttrString(runpy, "_run_module_as_main");

  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@LIHJAHBD@_run_module_as_main?$AA@
  0004d	48 8b c8	 mov	 rcx, rax
  00050	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00055	e8 00 00 00 00	 call	 PyObject_GetAttrString
  0005a	48 8b f0	 mov	 rsi, rax

; 178  :     if (runmodule == NULL) {

  0005d	48 85 c0	 test	 rax, rax
  00060	75 30		 jne	 SHORT $LN5@RunModule

; 179  :         fprintf(stderr, "Could not access runpy._run_module_as_main\n");

  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@NOBPIIPO@Could?5not?5access?5runpy?4_run_modu@
  0006f	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 180  :         Py_DECREF(runpy);

  00079	48 8b cb	 mov	 rcx, rbx
  0007c	e8 00 00 00 00	 call	 _Py_DecRef
  00081	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 181  :         return -1;

  00086	83 c8 ff	 or	 eax, -1

; 212  : }

  00089	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008d	41 5d		 pop	 r13
  0008f	5d		 pop	 rbp
  00090	5b		 pop	 rbx
  00091	c3		 ret	 0
$LN5@RunModule:

; 182  :     }
; 183  :     module = PyUnicode_FromWideChar(modname, wcslen(modname));

  00092	48 83 c9 ff	 or	 rcx, -1
  00096	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  0009b	33 c0		 xor	 eax, eax
  0009d	48 8b fd	 mov	 rdi, rbp
  000a0	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  000a5	66 f2 af	 repne scasw
  000a8	48 f7 d1	 not	 rcx
  000ab	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
  000af	48 8b cd	 mov	 rcx, rbp
  000b2	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
  000b7	4c 8b e0	 mov	 r12, rax

; 184  :     if (module == NULL) {

  000ba	48 85 c0	 test	 rax, rax
  000bd	75 2f		 jne	 SHORT $LN4@RunModule

; 185  :         fprintf(stderr, "Could not convert module name to unicode\n");

  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  000c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@DPKAPBBI@Could?5not?5convert?5module?5name?5to@
  000cc	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 186  :         Py_DECREF(runpy);

  000d6	48 8b cb	 mov	 rcx, rbx
  000d9	e8 00 00 00 00	 call	 _Py_DecRef

; 187  :         Py_DECREF(runmodule);

  000de	48 8b ce	 mov	 rcx, rsi
  000e1	e8 00 00 00 00	 call	 _Py_DecRef

; 188  :         return -1;

  000e6	83 c8 ff	 or	 eax, -1
  000e9	e9 98 00 00 00	 jmp	 $LN11@RunModule
$LN4@RunModule:

; 189  :     }
; 190  :     runargs = Py_BuildValue("(Oi)", module, set_argv0);

  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04IFLELAI@?$CIOi?$CJ?$AA@
  000f5	45 8b c5	 mov	 r8d, r13d
  000f8	48 8b d0	 mov	 rdx, rax
  000fb	e8 00 00 00 00	 call	 Py_BuildValue
  00100	48 8b e8	 mov	 rbp, rax

; 191  :     if (runargs == NULL) {

  00103	48 85 c0	 test	 rax, rax
  00106	75 34		 jne	 SHORT $LN3@RunModule

; 192  :         fprintf(stderr,
; 193  :             "Could not create arguments for runpy._run_module_as_main\n");

  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0010e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DK@PJLBBAF@Could?5not?5create?5arguments?5for?5r@
  00115	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  00119	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 194  :         Py_DECREF(runpy);

  0011f	48 8b cb	 mov	 rcx, rbx
  00122	e8 00 00 00 00	 call	 _Py_DecRef

; 195  :         Py_DECREF(runmodule);

  00127	48 8b ce	 mov	 rcx, rsi
  0012a	e8 00 00 00 00	 call	 _Py_DecRef

; 196  :         Py_DECREF(module);

  0012f	49 8b cc	 mov	 rcx, r12
  00132	e8 00 00 00 00	 call	 _Py_DecRef
$LN12@RunModule:

; 197  :         return -1;

  00137	83 c8 ff	 or	 eax, -1
  0013a	eb 4a		 jmp	 SHORT $LN11@RunModule
$LN3@RunModule:

; 198  :     }
; 199  :     result = PyObject_Call(runmodule, runargs, NULL);

  0013c	45 33 c0	 xor	 r8d, r8d
  0013f	48 8b d0	 mov	 rdx, rax
  00142	48 8b ce	 mov	 rcx, rsi
  00145	e8 00 00 00 00	 call	 PyObject_Call
  0014a	48 8b f8	 mov	 rdi, rax

; 200  :     if (result == NULL) {

  0014d	48 85 c0	 test	 rax, rax
  00150	75 05		 jne	 SHORT $LN2@RunModule

; 201  :         PyErr_Print();

  00152	e8 00 00 00 00	 call	 PyErr_Print
$LN2@RunModule:

; 202  :     }
; 203  :     Py_DECREF(runpy);

  00157	48 8b cb	 mov	 rcx, rbx
  0015a	e8 00 00 00 00	 call	 _Py_DecRef

; 204  :     Py_DECREF(runmodule);

  0015f	48 8b ce	 mov	 rcx, rsi
  00162	e8 00 00 00 00	 call	 _Py_DecRef

; 205  :     Py_DECREF(module);

  00167	49 8b cc	 mov	 rcx, r12
  0016a	e8 00 00 00 00	 call	 _Py_DecRef

; 206  :     Py_DECREF(runargs);

  0016f	48 8b cd	 mov	 rcx, rbp
  00172	e8 00 00 00 00	 call	 _Py_DecRef

; 207  :     if (result == NULL) {

  00177	48 85 ff	 test	 rdi, rdi

; 208  :         return -1;

  0017a	74 bb		 je	 SHORT $LN12@RunModule

; 209  :     }
; 210  :     Py_DECREF(result);

  0017c	48 8b cf	 mov	 rcx, rdi
  0017f	e8 00 00 00 00	 call	 _Py_DecRef

; 211  :     return 0;

  00184	33 c0		 xor	 eax, eax
$LN11@RunModule:
  00186	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0018b	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
  00190	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 212  : }

  00195	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00199	41 5d		 pop	 r13
  0019b	5d		 pop	 rbp
  0019c	5b		 pop	 rbx
  0019d	c3		 ret	 0
RunModule ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BC@LCPDPAAM@?$AA_?$AA_?$AAm?$AAa?$AAi?$AAn?$AA_?$AA_?$AA?$AA@ ; `string'
PUBLIC	??_C@_04LNEJFJGI@path?$AA@			; `string'
EXTRN	PyList_SetItem:PROC
EXTRN	PySys_GetObject:PROC
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyImport_GetImporter:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$RunMainFromImporter DD imagerel RunMainFromImporter
	DD	imagerel RunMainFromImporter+324
	DD	imagerel $unwind$RunMainFromImporter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RunMainFromImporter DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_1BC@LCPDPAAM@?$AA_?$AA_?$AAm?$AAa?$AAi?$AAn?$AA_?$AA_?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@LCPDPAAM@?$AA_?$AA_?$AAm?$AAa?$AAi?$AAn?$AA_?$AA_?$AA?$AA@ DB '_'
	DB	00H, '_', 00H, 'm', 00H, 'a', 00H, 'i', 00H, 'n', 00H, '_', 00H
	DB	'_', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04LNEJFJGI@path?$AA@
CONST	SEGMENT
??_C@_04LNEJFJGI@path?$AA@ DB 'path', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\main.c
CONST	ENDS
;	COMDAT RunMainFromImporter
_TEXT	SEGMENT
filename$ = 64
RunMainFromImporter PROC				; COMDAT

; 216  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	4c 8b c1	 mov	 r8, rcx

; 217  :     PyObject *argv0 = NULL, *importer, *sys_path;
; 218  :     int sts;
; 219  : 
; 220  :     argv0 = PyUnicode_FromWideChar(filename, wcslen(filename));

  0000d	48 83 c9 ff	 or	 rcx, -1
  00011	33 c0		 xor	 eax, eax
  00013	49 8b f8	 mov	 rdi, r8
  00016	66 f2 af	 repne scasw
  00019	48 f7 d1	 not	 rcx
  0001c	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
  00020	49 8b c8	 mov	 rcx, r8
  00023	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
  00028	48 8b f8	 mov	 rdi, rax

; 221  :     if (argv0 == NULL)

  0002b	48 85 c0	 test	 rax, rax
  0002e	0f 84 fb 00 00
	00		 je	 $LN3@RunMainFro

; 222  :         goto error;
; 223  : 
; 224  :     importer = PyImport_GetImporter(argv0);

  00034	48 8b c8	 mov	 rcx, rax
  00037	e8 00 00 00 00	 call	 PyImport_GetImporter
  0003c	48 8b d8	 mov	 rbx, rax

; 225  :     if (importer == NULL)

  0003f	48 85 c0	 test	 rax, rax
  00042	0f 84 82 00 00
	00		 je	 $error$120672

; 226  :         goto error;
; 227  : 
; 228  :     if (importer == Py_None) {

  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0004f	48 3b c1	 cmp	 rax, rcx
  00052	75 1e		 jne	 SHORT $LN7@RunMainFro

; 229  :         Py_DECREF(argv0);

  00054	48 8b cf	 mov	 rcx, rdi
  00057	e8 00 00 00 00	 call	 _Py_DecRef

; 230  :         Py_DECREF(importer);

  0005c	48 8b cb	 mov	 rcx, rbx
  0005f	e8 00 00 00 00	 call	 _Py_DecRef

; 231  :         return -1;

  00064	83 c8 ff	 or	 eax, -1

; 252  :     return 1;
; 253  : }

  00067	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0006c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00070	5f		 pop	 rdi
  00071	c3		 ret	 0
$LN7@RunMainFro:

; 232  :     }
; 233  :     Py_DECREF(importer);

  00072	48 8b c8	 mov	 rcx, rax
  00075	e8 00 00 00 00	 call	 _Py_DecRef

; 234  : 
; 235  :     /* argv0 is usable as an import source, so put it in sys.path[0]
; 236  :        and import __main__ */
; 237  :     sys_path = PySys_GetObject("path");

  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04LNEJFJGI@path?$AA@
  00081	e8 00 00 00 00	 call	 PySys_GetObject

; 238  :     if (sys_path == NULL)

  00086	48 85 c0	 test	 rax, rax
  00089	74 3f		 je	 SHORT $error$120672

; 239  :         goto error;
; 240  :     if (PyList_SetItem(sys_path, 0, argv0)) {

  0008b	4c 8b c7	 mov	 r8, rdi
  0008e	33 d2		 xor	 edx, edx
  00090	48 8b c8	 mov	 rcx, rax
  00093	e8 00 00 00 00	 call	 PyList_SetItem
  00098	85 c0		 test	 eax, eax
  0009a	0f 85 8f 00 00
	00		 jne	 $LN3@RunMainFro

; 241  :         argv0 = NULL;
; 242  :         goto error;
; 243  :     }
; 244  :     Py_INCREF(argv0);

  000a0	48 8b cf	 mov	 rcx, rdi
  000a3	e8 00 00 00 00	 call	 _Py_IncRef

; 245  : 
; 246  :     sts = RunModule(L"__main__", 0);

  000a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@LCPDPAAM@?$AA_?$AA_?$AAm?$AAa?$AAi?$AAn?$AA_?$AA_?$AA?$AA@
  000af	33 d2		 xor	 edx, edx
  000b1	e8 00 00 00 00	 call	 RunModule

; 247  :     return sts != 0;

  000b6	33 c9		 xor	 ecx, ecx
  000b8	85 c0		 test	 eax, eax
  000ba	0f 95 c1	 setne	 cl
  000bd	8b c1		 mov	 eax, ecx

; 252  :     return 1;
; 253  : }

  000bf	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c8	5f		 pop	 rdi
  000c9	c3		 ret	 0
$error$120672:

; 248  : 
; 249  : error:
; 250  :     Py_XDECREF(argv0);

  000ca	e8 00 00 00 00	 call	 _Py_PXCTX
  000cf	85 c0		 test	 eax, eax
  000d1	75 5c		 jne	 SHORT $LN3@RunMainFro
  000d3	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  000d7	a8 20		 test	 al, 32			; 00000020H
  000d9	75 4c		 jne	 SHORT $LN16@RunMainFro
  000db	84 c0		 test	 al, al
  000dd	78 48		 js	 SHORT $LN16@RunMainFro
  000df	a8 02		 test	 al, 2
  000e1	75 4c		 jne	 SHORT $LN3@RunMainFro
  000e3	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  000e7	75 46		 jne	 SHORT $LN3@RunMainFro
  000e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000f7	4c 8b cf	 mov	 r9, rdi
  000fa	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00100	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00108	e8 00 00 00 00	 call	 _PyParallel_Guard
  0010d	48 8b cf	 mov	 rcx, rdi
  00110	85 c0		 test	 eax, eax
  00112	74 07		 je	 SHORT $LN21@RunMainFro
  00114	e8 00 00 00 00	 call	 _Px_Dealloc
  00119	eb 14		 jmp	 SHORT $LN3@RunMainFro
$LN21@RunMainFro:
  0011b	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0011f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00125	eb 08		 jmp	 SHORT $LN3@RunMainFro
$LN16@RunMainFro:
  00127	48 8b cf	 mov	 rcx, rdi
  0012a	e8 00 00 00 00	 call	 Px_DecRef
$LN3@RunMainFro:

; 251  :     PyErr_Print();

  0012f	e8 00 00 00 00	 call	 PyErr_Print

; 252  :     return 1;
; 253  : }

  00134	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00139	b8 01 00 00 00	 mov	 eax, 1
  0013e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00142	5f		 pop	 rdi
  00143	c3		 ret	 0
RunMainFromImporter ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@NFIDFCFM@Unable?5to?5decode?5the?5command?5fro@ ; `string'
EXTRN	PyRun_SimpleStringFlags:PROC
EXTRN	PyBytes_AsString:PROC
EXTRN	PyUnicode_AsUTF8String:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$run_command DD imagerel run_command
	DD	imagerel run_command+149
	DD	imagerel $unwind$run_command
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$run_command DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0DF@NFIDFCFM@Unable?5to?5decode?5the?5command?5fro@
CONST	SEGMENT
??_C@_0DF@NFIDFCFM@Unable?5to?5decode?5the?5command?5fro@ DB 'Unable to d'
	DB	'ecode the command from the command line:', 0aH, 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT run_command
_TEXT	SEGMENT
command$ = 48
cf$ = 56
run_command PROC					; COMDAT

; 257  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f2	 mov	 rsi, rdx

; 258  :     PyObject *unicode, *bytes;
; 259  :     int ret;
; 260  : 
; 261  :     unicode = PyUnicode_FromWideChar(command, -1);

  00012	48 83 ca ff	 or	 rdx, -1
  00016	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
  0001b	48 8b d8	 mov	 rbx, rax

; 262  :     if (unicode == NULL)

  0001e	48 85 c0	 test	 rax, rax
  00021	74 4c		 je	 SHORT $error$120702

; 263  :         goto error;
; 264  :     bytes = PyUnicode_AsUTF8String(unicode);

  00023	48 8b c8	 mov	 rcx, rax
  00026	e8 00 00 00 00	 call	 PyUnicode_AsUTF8String

; 265  :     Py_DECREF(unicode);

  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	48 8b f8	 mov	 rdi, rax
  00031	e8 00 00 00 00	 call	 _Py_DecRef

; 266  :     if (bytes == NULL)

  00036	48 85 ff	 test	 rdi, rdi
  00039	74 34		 je	 SHORT $error$120702

; 267  :         goto error;
; 268  :     ret = PyRun_SimpleStringFlags(PyBytes_AsString(bytes), cf);

  0003b	48 8b cf	 mov	 rcx, rdi
  0003e	e8 00 00 00 00	 call	 PyBytes_AsString
  00043	48 8b d6	 mov	 rdx, rsi
  00046	48 8b c8	 mov	 rcx, rax
  00049	e8 00 00 00 00	 call	 PyRun_SimpleStringFlags

; 269  :     Py_DECREF(bytes);

  0004e	48 8b cf	 mov	 rcx, rdi
  00051	8b d8		 mov	 ebx, eax
  00053	e8 00 00 00 00	 call	 _Py_DecRef

; 270  :     return ret != 0;

  00058	33 c0		 xor	 eax, eax
  0005a	85 db		 test	 ebx, ebx
  0005c	0f 95 c0	 setne	 al

; 275  :     return 1;
; 276  : }

  0005f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00064	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00069	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006d	5f		 pop	 rdi
  0006e	c3		 ret	 0
$error$120702:

; 271  : 
; 272  : error:
; 273  :     PySys_WriteStderr("Unable to decode the command from the command line:\n");

  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DF@NFIDFCFM@Unable?5to?5decode?5the?5command?5fro@
  00076	e8 00 00 00 00	 call	 PySys_WriteStderr

; 274  :     PyErr_Print();

  0007b	e8 00 00 00 00	 call	 PyErr_Print

; 275  :     return 1;
; 276  : }

  00080	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00085	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0008a	b8 01 00 00 00	 mov	 eax, 1
  0008f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00093	5f		 pop	 rdi
  00094	c3		 ret	 0
run_command ENDP
_TEXT	ENDS
PUBLIC	??_C@_07CMJMHHJG@?$DMstdin?$DO?$AA@		; `string'
PUBLIC	??_C@_0BB@MIIEBMAJ@?$DMencoding?5error?$DO?$AA@	; `string'
EXTRN	PyRun_AnyFileExFlags:PROC
EXTRN	PyUnicode_EncodeFSDefault:PROC
EXTRN	Py_MakePendingCalls:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$run_file DD imagerel run_file
	DD	imagerel run_file+55
	DD	imagerel $unwind$run_file
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$run_file DD imagerel run_file+55
	DD	imagerel run_file+302
	DD	imagerel $chain$0$run_file
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$run_file DD imagerel run_file+302
	DD	imagerel run_file+322
	DD	imagerel $chain$1$run_file
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$run_file DD 021H
	DD	imagerel run_file
	DD	imagerel run_file+55
	DD	imagerel $unwind$run_file
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$run_file DD 020521H
	DD	0a7405H
	DD	imagerel run_file
	DD	imagerel run_file+55
	DD	imagerel $unwind$run_file
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$run_file DD 081301H
	DD	0c5413H
	DD	0b3413H
	DD	0d00f5213H
	DD	0600bc00dH
xdata	ENDS
;	COMDAT ??_C@_07CMJMHHJG@?$DMstdin?$DO?$AA@
CONST	SEGMENT
??_C@_07CMJMHHJG@?$DMstdin?$DO?$AA@ DB '<stdin>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MIIEBMAJ@?$DMencoding?5error?$DO?$AA@
CONST	SEGMENT
??_C@_0BB@MIIEBMAJ@?$DMencoding?5error?$DO?$AA@ DB '<encoding error>', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\main.c
CONST	ENDS
;	COMDAT run_file
_TEXT	SEGMENT
fp$ = 80
filename$ = 88
p_cf$ = 96
run_file PROC						; COMDAT

; 280  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 281  :     PyObject *unicode, *bytes = NULL;

  00013	33 f6		 xor	 esi, esi
  00015	4d 8b e0	 mov	 r12, r8
  00018	48 8b ea	 mov	 rbp, rdx
  0001b	8b de		 mov	 ebx, esi
  0001d	4c 8b e9	 mov	 r13, rcx

; 282  :     char *filename_str;
; 283  :     int run;
; 284  : 
; 285  :     /* call pending calls like signal handlers (SIGINT) */
; 286  :     if (Py_MakePendingCalls() == -1) {

  00020	e8 00 00 00 00	 call	 Py_MakePendingCalls
  00025	83 f8 ff	 cmp	 eax, -1
  00028	75 0d		 jne	 SHORT $LN10@run_file

; 287  :         PyErr_Print();

  0002a	e8 00 00 00 00	 call	 PyErr_Print

; 288  :         return 1;

  0002f	8d 46 01	 lea	 eax, QWORD PTR [rsi+1]
  00032	e9 f7 00 00 00	 jmp	 $LN11@run_file
$LN10@run_file:
  00037	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi

; 289  :     }
; 290  : 
; 291  :     if (filename) {

  0003c	48 85 ed	 test	 rbp, rbp
  0003f	74 53		 je	 SHORT $LN9@run_file

; 292  :         unicode = PyUnicode_FromWideChar(filename, wcslen(filename));

  00041	48 83 c9 ff	 or	 rcx, -1
  00045	33 c0		 xor	 eax, eax
  00047	48 8b fd	 mov	 rdi, rbp
  0004a	66 f2 af	 repne scasw
  0004d	48 f7 d1	 not	 rcx
  00050	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
  00054	48 8b cd	 mov	 rcx, rbp
  00057	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
  0005c	48 8b f8	 mov	 rdi, rax

; 293  :         if (unicode != NULL) {

  0005f	48 85 c0	 test	 rax, rax
  00062	74 22		 je	 SHORT $LN7@run_file

; 294  :             bytes = PyUnicode_EncodeFSDefault(unicode);

  00064	48 8b c8	 mov	 rcx, rax
  00067	e8 00 00 00 00	 call	 PyUnicode_EncodeFSDefault

; 295  :             Py_DECREF(unicode);

  0006c	48 8b cf	 mov	 rcx, rdi
  0006f	48 8b d8	 mov	 rbx, rax
  00072	e8 00 00 00 00	 call	 _Py_DecRef

; 296  :         }
; 297  :         if (bytes != NULL)

  00077	48 85 db	 test	 rbx, rbx
  0007a	74 0a		 je	 SHORT $LN7@run_file

; 298  :             filename_str = PyBytes_AsString(bytes);

  0007c	48 8b cb	 mov	 rcx, rbx
  0007f	e8 00 00 00 00	 call	 PyBytes_AsString

; 299  :         else {

  00084	eb 15		 jmp	 SHORT $LN5@run_file
$LN7@run_file:

; 300  :             PyErr_Clear();

  00086	e8 00 00 00 00	 call	 PyErr_Clear

; 301  :             filename_str = "<encoding error>";

  0008b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BB@MIIEBMAJ@?$DMencoding?5error?$DO?$AA@

; 302  :         }
; 303  :     }
; 304  :     else

  00092	eb 07		 jmp	 SHORT $LN5@run_file
$LN9@run_file:

; 305  :         filename_str = "<stdin>";

  00094	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07CMJMHHJG@?$DMstdin?$DO?$AA@
$LN5@run_file:

; 306  : 
; 307  :     run = PyRun_AnyFileExFlags(fp, filename_str, filename != NULL, p_cf);

  0009b	44 8b c6	 mov	 r8d, esi
  0009e	48 85 ed	 test	 rbp, rbp
  000a1	4d 8b cc	 mov	 r9, r12
  000a4	48 8b d0	 mov	 rdx, rax
  000a7	49 8b cd	 mov	 rcx, r13
  000aa	41 0f 95 c0	 setne	 r8b
  000ae	e8 00 00 00 00	 call	 PyRun_AnyFileExFlags
  000b3	8b f8		 mov	 edi, eax

; 308  :     Py_XDECREF(bytes);

  000b5	48 85 db	 test	 rbx, rbx
  000b8	74 67		 je	 SHORT $LN3@run_file
  000ba	e8 00 00 00 00	 call	 _Py_PXCTX
  000bf	85 c0		 test	 eax, eax
  000c1	75 5e		 jne	 SHORT $LN3@run_file
  000c3	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  000c7	f6 c1 20	 test	 cl, 32			; 00000020H
  000ca	75 4d		 jne	 SHORT $LN17@run_file
  000cc	84 c9		 test	 cl, cl
  000ce	78 49		 js	 SHORT $LN17@run_file
  000d0	f6 c1 02	 test	 cl, 2
  000d3	75 4c		 jne	 SHORT $LN3@run_file
  000d5	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000d9	75 46		 jne	 SHORT $LN3@run_file
  000db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000e9	4c 8b cb	 mov	 r9, rbx
  000ec	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000f2	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000fa	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ff	48 8b cb	 mov	 rcx, rbx
  00102	85 c0		 test	 eax, eax
  00104	74 07		 je	 SHORT $LN22@run_file
  00106	e8 00 00 00 00	 call	 _Px_Dealloc
  0010b	eb 14		 jmp	 SHORT $LN3@run_file
$LN22@run_file:
  0010d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00111	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00117	eb 08		 jmp	 SHORT $LN3@run_file
$LN17@run_file:
  00119	48 8b cb	 mov	 rcx, rbx
  0011c	e8 00 00 00 00	 call	 Px_DecRef
$LN3@run_file:

; 309  :     return run != 0;

  00121	85 ff		 test	 edi, edi
  00123	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  00128	40 0f 95 c6	 setne	 sil
  0012c	8b c6		 mov	 eax, esi
$LN11@run_file:

; 310  : }

  0012e	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00133	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  00138	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0013c	41 5d		 pop	 r13
  0013e	41 5c		 pop	 r12
  00140	5e		 pop	 rsi
  00141	c3		 ret	 0
run_file ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@LPBAPCAP@?$CFls?3?5?8?$CFls?8?5is?5a?5directory?0?5canno@ ; `string'
PUBLIC	??_C@_0CK@KLLBLHEB@?$CFls?3?5can?8t?5open?5file?5?8?$CFs?8?3?5?$FLErrn@ ; `string'
PUBLIC	??_C@_0BI@PLNCLPPD@?$DMunprintable?5file?5name?$DO?$AA@ ; `string'
PUBLIC	??_C@_13BPINEIPE@?$AAr?$AA?$AA@			; `string'
PUBLIC	??_C@_08KBCDPPMN@readline?$AA@			; `string'
PUBLIC	??_C@_15DMEDGHGK@?$AA?9?$AAm?$AA?$AA@		; `string'
PUBLIC	??_C@_15NMJMBAFJ@?$AA?9?$AAc?$AA?$AA@		; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6?$AA@			; `string'
PUBLIC	??_C@_0EH@JFFAKOEJ@Type?5?$CChelp?$CC?0?5?$CCcopyright?$CC?0?5?$CCcredi@ ; `string'
PUBLIC	??_C@_0BF@HCFAEEPL@PyParallel?5?$CFs?5on?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_13IMODFHAA@?$AA?9?$AA?$AA@		; `string'
PUBLIC	??_C@_13DEFPDAGF@?$AA?0?$AA?$AA@		; `string'
PUBLIC	??_C@_0CJ@NCLJNGKO@not?5enough?5memory?5to?5copy?5PYTHON@ ; `string'
PUBLIC	??_C@_1BO@BIIJHIJI@?$AAP?$AAY?$AAT?$AAH?$AAO?$AAN?$AAW?$AAA?$AAR?$AAN?$AAI?$AAN?$AAG?$AAS?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BB@HMANIOON@PYTHONNOUSERSITE?$AA@	; `string'
PUBLIC	??_C@_0BB@NFDOJAMJ@PYTHONUNBUFFERED?$AA@	; `string'
PUBLIC	??_C@_0O@DNGJAMOL@PYTHONINSPECT?$AA@		; `string'
PUBLIC	??_C@_0P@KBEEOCOJ@PyParallel?5?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_05MAFOEECJ@3?43?45?$AA@			; `string'
PUBLIC	??_C@_0CG@IAAIMCOI@not?5enough?5memory?5to?5copy?5?9c?5arg@ ; `string'
PUBLIC	??_C@_1DG@HILFBDGJ@?$AAb?$AAB?$AAc?$AA?3?$AAd?$AAE?$AAh?$AAi?$AAJ?$AAm?$AA?3?$AAO?$AAq?$AAR?$AAs?$AAS?$AAt?$AAu?$AAv?$AAV?$AAW?$AA?3?$AAx?$AAX?$AA?3?$AA?$DP?$AA?$AA@ ; `string'
PUBLIC	Py_Main
EXTRN	Py_Finalize:PROC
EXTRN	__imp_ungetc:PROC
EXTRN	__imp_getc:PROC
EXTRN	PyMem_Free:PROC
EXTRN	__imp_strerror:PROC
EXTRN	_Py_wchar2char:PROC
EXTRN	_Py_wfopen:PROC
EXTRN	__imp_isatty:PROC
EXTRN	PySys_SetArgv:PROC
EXTRN	Py_GetVersion:PROC
EXTRN	Py_GetPlatform:PROC
EXTRN	Py_Initialize:PROC
EXTRN	Py_SetProgramName:PROC
EXTRN	__imp_setvbuf:PROC
EXTRN	__imp__setmode:PROC
EXTRN	__imp_fileno:PROC
EXTRN	Py_FdIsInteractive:PROC
EXTRN	_PyOS_optind:DWORD
EXTRN	__imp_free:PROC
EXTRN	__imp_wcstok:PROC
EXTRN	__imp__wgetenv:PROC
EXTRN	Py_FatalError:PROC
EXTRN	__imp_malloc:PROC
EXTRN	Py_QuietFlag:DWORD
EXTRN	PySys_AddXOption:PROC
EXTRN	PySys_AddWarnOption:PROC
EXTRN	_PyOS_optarg:QWORD
EXTRN	Py_VerboseFlag:DWORD
EXTRN	Py_UnbufferedStdioFlag:DWORD
EXTRN	Py_NoSiteFlag:DWORD
EXTRN	Py_NoUserSiteDirectory:DWORD
EXTRN	Py_DontWriteBytecodeFlag:DWORD
EXTRN	Py_OptimizeFlag:DWORD
EXTRN	Py_InteractiveFlag:DWORD
EXTRN	Py_InspectFlag:DWORD
EXTRN	Py_DebugFlag:DWORD
EXTRN	Py_BytesWarningFlag:DWORD
EXTRN	__ImageBase:BYTE
EXTRN	_PyOS_ResetGetOpt:PROC
EXTRN	PySys_ResetWarnOptions:PROC
EXTRN	_PyRandom_Init:PROC
EXTRN	Py_HashRandomizationFlag:DWORD
EXTRN	_PyOS_GetOpt:PROC
EXTRN	_PyOS_opterr:DWORD
EXTRN	_PyParallel_Init:PROC
_BSS	SEGMENT
orig_argv DQ	01H DUP (?)
orig_argc DD	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\sys\stat.inl
pdata	SEGMENT
$pdata$Py_Main DD imagerel $LN127
	DD	imagerel $LN127+2418
	DD	imagerel $unwind$Py_Main
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Py_Main DD 091101H
	DD	0f00de211H
	DD	0d009e00bH
	DD	07005c007H
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT ??_C@_0CM@LPBAPCAP@?$CFls?3?5?8?$CFls?8?5is?5a?5directory?0?5canno@
CONST	SEGMENT
??_C@_0CM@LPBAPCAP@?$CFls?3?5?8?$CFls?8?5is?5a?5directory?0?5canno@ DB '%'
	DB	'ls: ''%ls'' is a directory, cannot continue', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KLLBLHEB@?$CFls?3?5can?8t?5open?5file?5?8?$CFs?8?3?5?$FLErrn@
CONST	SEGMENT
??_C@_0CK@KLLBLHEB@?$CFls?3?5can?8t?5open?5file?5?8?$CFs?8?3?5?$FLErrn@ DB '%'
	DB	'ls: can''t open file ''%s'': [Errno %d] %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PLNCLPPD@?$DMunprintable?5file?5name?$DO?$AA@
CONST	SEGMENT
??_C@_0BI@PLNCLPPD@?$DMunprintable?5file?5name?$DO?$AA@ DB '<unprintable '
	DB	'file name>', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_13BPINEIPE@?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_13BPINEIPE@?$AAr?$AA?$AA@ DB 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KBCDPPMN@readline?$AA@
CONST	SEGMENT
??_C@_08KBCDPPMN@readline?$AA@ DB 'readline', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_15DMEDGHGK@?$AA?9?$AAm?$AA?$AA@
CONST	SEGMENT
??_C@_15DMEDGHGK@?$AA?9?$AAm?$AA?$AA@ DB '-', 00H, 'm', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15NMJMBAFJ@?$AA?9?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_15NMJMBAFJ@?$AA?9?$AAc?$AA?$AA@ DB '-', 00H, 'c', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6?$AA@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6?$AA@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@JFFAKOEJ@Type?5?$CChelp?$CC?0?5?$CCcopyright?$CC?0?5?$CCcredi@
CONST	SEGMENT
??_C@_0EH@JFFAKOEJ@Type?5?$CChelp?$CC?0?5?$CCcopyright?$CC?0?5?$CCcredi@ DB 'T'
	DB	'ype "help", "copyright", "credits" or "license" for more info'
	DB	'rmation.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HCFAEEPL@PyParallel?5?$CFs?5on?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BF@HCFAEEPL@PyParallel?5?$CFs?5on?5?$CFs?6?$AA@ DB 'PyParallel %s '
	DB	'on %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_13IMODFHAA@?$AA?9?$AA?$AA@
CONST	SEGMENT
??_C@_13IMODFHAA@?$AA?9?$AA?$AA@ DB '-', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_13DEFPDAGF@?$AA?0?$AA?$AA@
CONST	SEGMENT
??_C@_13DEFPDAGF@?$AA?0?$AA?$AA@ DB ',', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@NCLJNGKO@not?5enough?5memory?5to?5copy?5PYTHON@
CONST	SEGMENT
??_C@_0CJ@NCLJNGKO@not?5enough?5memory?5to?5copy?5PYTHON@ DB 'not enough '
	DB	'memory to copy PYTHONWARNINGS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@BIIJHIJI@?$AAP?$AAY?$AAT?$AAH?$AAO?$AAN?$AAW?$AAA?$AAR?$AAN?$AAI?$AAN?$AAG?$AAS?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@BIIJHIJI@?$AAP?$AAY?$AAT?$AAH?$AAO?$AAN?$AAW?$AAA?$AAR?$AAN?$AAI?$AAN?$AAG?$AAS?$AA?$AA@ DB 'P'
	DB	00H, 'Y', 00H, 'T', 00H, 'H', 00H, 'O', 00H, 'N', 00H, 'W', 00H
	DB	'A', 00H, 'R', 00H, 'N', 00H, 'I', 00H, 'N', 00H, 'G', 00H, 'S'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HMANIOON@PYTHONNOUSERSITE?$AA@
CONST	SEGMENT
??_C@_0BB@HMANIOON@PYTHONNOUSERSITE?$AA@ DB 'PYTHONNOUSERSITE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NFDOJAMJ@PYTHONUNBUFFERED?$AA@
CONST	SEGMENT
??_C@_0BB@NFDOJAMJ@PYTHONUNBUFFERED?$AA@ DB 'PYTHONUNBUFFERED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DNGJAMOL@PYTHONINSPECT?$AA@
CONST	SEGMENT
??_C@_0O@DNGJAMOL@PYTHONINSPECT?$AA@ DB 'PYTHONINSPECT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KBEEOCOJ@PyParallel?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0P@KBEEOCOJ@PyParallel?5?$CFs?6?$AA@ DB 'PyParallel %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MAFOEECJ@3?43?45?$AA@
CONST	SEGMENT
??_C@_05MAFOEECJ@3?43?45?$AA@ DB '3.3.5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@IAAIMCOI@not?5enough?5memory?5to?5copy?5?9c?5arg@
CONST	SEGMENT
??_C@_0CG@IAAIMCOI@not?5enough?5memory?5to?5copy?5?9c?5arg@ DB 'not enoug'
	DB	'h memory to copy -c argument', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@HILFBDGJ@?$AAb?$AAB?$AAc?$AA?3?$AAd?$AAE?$AAh?$AAi?$AAJ?$AAm?$AA?3?$AAO?$AAq?$AAR?$AAs?$AAS?$AAt?$AAu?$AAv?$AAV?$AAW?$AA?3?$AAx?$AAX?$AA?3?$AA?$DP?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@HILFBDGJ@?$AAb?$AAB?$AAc?$AA?3?$AAd?$AAE?$AAh?$AAi?$AAJ?$AAm?$AA?3?$AAO?$AAq?$AAR?$AAs?$AAS?$AAt?$AAu?$AAv?$AAV?$AAW?$AA?3?$AAx?$AAX?$AA?3?$AA?$DP?$AA?$AA@ DB 'b'
	DB	00H, 'B', 00H, 'c', 00H, ':', 00H, 'd', 00H, 'E', 00H, 'h', 00H
	DB	'i', 00H, 'J', 00H, 'm', 00H, ':', 00H, 'O', 00H, 'q', 00H, 'R'
	DB	00H, 's', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'v', 00H, 'V', 00H
	DB	'W', 00H, ':', 00H, 'x', 00H, 'X', 00H, ':', 00H, '?', 00H, 00H
	DB	00H						; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\main.c
CONST	ENDS
;	COMDAT Py_Main
_TEXT	SEGMENT
skipfirstline$1$ = 48
module$1$ = 56
sb$120902 = 64
cf$ = 192
argc$ = 192
help$1$ = 200
argv$ = 200
version$1$ = 208
saw_unbuffered_flag$1$ = 216
Py_Main	PROC						; COMDAT

; 317  : {

$LN127:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 318  :     int c;
; 319  :     int sts;
; 320  :     wchar_t *command = NULL;

  00011	33 db		 xor	 ebx, ebx
  00013	4c 8b e2	 mov	 r12, rdx
  00016	44 8b e9	 mov	 r13d, ecx
  00019	8b eb		 mov	 ebp, ebx

; 321  :     wchar_t *filename = NULL;

  0001b	44 8b f3	 mov	 r14d, ebx

; 322  :     wchar_t *module = NULL;

  0001e	48 89 5c 24 38	 mov	 QWORD PTR module$1$[rsp], rbx

; 323  :     FILE *fp = stdin;

  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func

; 324  :     char *p;
; 325  : #ifdef MS_WINDOWS
; 326  :     wchar_t *wp;
; 327  : #endif
; 328  :     int skipfirstline = 0;

  00029	89 5c 24 30	 mov	 DWORD PTR skipfirstline$1$[rsp], ebx

; 329  :     int stdin_is_interactive = 0;
; 330  :     int help = 0;

  0002d	8b fb		 mov	 edi, ebx
  0002f	89 9c 24 c8 00
	00 00		 mov	 DWORD PTR help$1$[rsp], ebx

; 331  :     int version = 0;

  00036	8b f3		 mov	 esi, ebx
  00038	89 9c 24 d0 00
	00 00		 mov	 DWORD PTR version$1$[rsp], ebx
  0003f	4c 8b f8	 mov	 r15, rax

; 332  :     int saw_unbuffered_flag = 0;

  00042	89 9c 24 d8 00
	00 00		 mov	 DWORD PTR saw_unbuffered_flag$1$[rsp], ebx

; 333  :     PyCompilerFlags cf;
; 334  : 
; 335  :     cf.cf_flags = 0;

  00049	89 9c 24 c0 00
	00 00		 mov	 DWORD PTR cf$[rsp], ebx

; 336  : 
; 337  :     orig_argc = argc;           /* For Py_GetArgcArgv() */

  00050	44 89 2d 00 00
	00 00		 mov	 DWORD PTR orig_argc, r13d

; 338  :     orig_argv = argv;

  00057	4c 89 25 00 00
	00 00		 mov	 QWORD PTR orig_argv, r12

; 339  : 
; 340  : #ifdef WITH_PARALLEL
; 341  :     _PyParallel_Init();

  0005e	e8 00 00 00 00	 call	 _PyParallel_Init

; 342  : #endif
; 343  : 
; 344  :     /* Hash randomization needed early for all string operations
; 345  :        (including -W and -X options). */
; 346  :     _PyOS_opterr = 0;  /* prevent printing the error in 1st pass */
; 347  :     while ((c = _PyOS_GetOpt(argc, argv, PROGRAM_OPTS)) != EOF) {

  00063	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1DG@HILFBDGJ@?$AAb?$AAB?$AAc?$AA?3?$AAd?$AAE?$AAh?$AAi?$AAJ?$AAm?$AA?3?$AAO?$AAq?$AAR?$AAs?$AAS?$AAt?$AAu?$AAv?$AAV?$AAW?$AA?3?$AAx?$AAX?$AA?3?$AA?$DP?$AA?$AA@
  0006a	49 8b d4	 mov	 rdx, r12
  0006d	41 8b cd	 mov	 ecx, r13d
  00070	89 1d 00 00 00
	00		 mov	 DWORD PTR _PyOS_opterr, ebx
  00076	e8 00 00 00 00	 call	 _PyOS_GetOpt
  0007b	83 f8 ff	 cmp	 eax, -1
  0007e	74 2e		 je	 SHORT $LN72@Py_Main
$LL75@Py_Main:

; 348  :         if (c == 'm' || c == 'c') {

  00080	83 f8 6d	 cmp	 eax, 109		; 0000006dH
  00083	74 29		 je	 SHORT $LN72@Py_Main
  00085	83 f8 63	 cmp	 eax, 99			; 00000063H
  00088	74 24		 je	 SHORT $LN72@Py_Main

; 349  :             /* -c / -m is the last option: following arguments are
; 350  :                not interpreter options. */
; 351  :             break;
; 352  :         }
; 353  :         if (c == 'E') {

  0008a	83 f8 45	 cmp	 eax, 69			; 00000045H
  0008d	74 19		 je	 SHORT $LN97@Py_Main

; 342  : #endif
; 343  : 
; 344  :     /* Hash randomization needed early for all string operations
; 345  :        (including -W and -X options). */
; 346  :     _PyOS_opterr = 0;  /* prevent printing the error in 1st pass */
; 347  :     while ((c = _PyOS_GetOpt(argc, argv, PROGRAM_OPTS)) != EOF) {

  0008f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1DG@HILFBDGJ@?$AAb?$AAB?$AAc?$AA?3?$AAd?$AAE?$AAh?$AAi?$AAJ?$AAm?$AA?3?$AAO?$AAq?$AAR?$AAs?$AAS?$AAt?$AAu?$AAv?$AAV?$AAW?$AA?3?$AAx?$AAX?$AA?3?$AA?$DP?$AA?$AA@
  00096	49 8b d4	 mov	 rdx, r12
  00099	41 8b cd	 mov	 ecx, r13d
  0009c	e8 00 00 00 00	 call	 _PyOS_GetOpt
  000a1	83 f8 ff	 cmp	 eax, -1
  000a4	75 da		 jne	 SHORT $LL75@Py_Main

; 729  :                     if (ch == '\n') {

  000a6	eb 06		 jmp	 SHORT $LN72@Py_Main
$LN97@Py_Main:

; 354  :             Py_IgnoreEnvironmentFlag++;

  000a8	ff 05 00 00 00
	00		 inc	 DWORD PTR Py_IgnoreEnvironmentFlag
$LN72@Py_Main:

; 355  :             break;
; 356  :         }
; 357  :     }
; 358  : 
; 359  :     Py_HashRandomizationFlag = 1;

  000ae	b8 01 00 00 00	 mov	 eax, 1
  000b3	89 05 00 00 00
	00		 mov	 DWORD PTR Py_HashRandomizationFlag, eax

; 360  :     _PyRandom_Init();

  000b9	e8 00 00 00 00	 call	 _PyRandom_Init

; 361  : 
; 362  :     PySys_ResetWarnOptions();

  000be	e8 00 00 00 00	 call	 PySys_ResetWarnOptions

; 363  :     _PyOS_ResetGetOpt();

  000c3	e8 00 00 00 00	 call	 _PyOS_ResetGetOpt

; 364  : 
; 365  :     while ((c = _PyOS_GetOpt(argc, argv, PROGRAM_OPTS)) != EOF) {

  000c8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1DG@HILFBDGJ@?$AAb?$AAB?$AAc?$AA?3?$AAd?$AAE?$AAh?$AAi?$AAJ?$AAm?$AA?3?$AAO?$AAq?$AAR?$AAs?$AAS?$AAt?$AAu?$AAv?$AAV?$AAW?$AA?3?$AAx?$AAX?$AA?3?$AA?$DP?$AA?$AA@
  000cf	49 8b d4	 mov	 rdx, r12
  000d2	41 8b cd	 mov	 ecx, r13d
  000d5	e8 00 00 00 00	 call	 _PyOS_GetOpt
  000da	83 f8 ff	 cmp	 eax, -1
  000dd	0f 84 e4 01 00
	00		 je	 $LN43@Py_Main
  000e3	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:__ImageBase
  000ea	66 0f 1f 44 00
	00		 npad	 6
$LL70@Py_Main:

; 366  :         if (c == 'c') {

  000f0	83 f8 63	 cmp	 eax, 99			; 00000063H
  000f3	0f 84 0e 01 00
	00		 je	 $LN98@Py_Main

; 380  :             break;
; 381  :         }
; 382  : 
; 383  :         if (c == 'm') {

  000f9	83 f8 6d	 cmp	 eax, 109		; 0000006dH
  000fc	0f 84 f7 00 00
	00		 je	 $LN99@Py_Main

; 389  :         }
; 390  : 
; 391  :         switch (c) {

  00102	83 c0 c1	 add	 eax, -63		; ffffffffffffffc1H
  00105	83 f8 39	 cmp	 eax, 57			; 00000039H
  00108	0f 87 d8 00 00
	00		 ja	 $LN45@Py_Main
  0010e	48 98		 cdqe
  00110	0f b6 84 03 00
	00 00 00	 movzx	 eax, BYTE PTR $LN110@Py_Main[rbx+rax]
  00118	8b 8c 83 00 00
	00 00		 mov	 ecx, DWORD PTR $LN111@Py_Main[rbx+rax*4]
  0011f	48 03 cb	 add	 rcx, rbx
  00122	ff e1		 jmp	 rcx
$LN63@Py_Main:

; 392  :         case 'b':
; 393  :             Py_BytesWarningFlag++;

  00124	ff 05 00 00 00
	00		 inc	 DWORD PTR Py_BytesWarningFlag

; 394  :             break;

  0012a	e9 97 00 00 00	 jmp	 $LN46@Py_Main
$LN62@Py_Main:

; 395  : 
; 396  :         case 'd':
; 397  :             Py_DebugFlag++;

  0012f	ff 05 00 00 00
	00		 inc	 DWORD PTR Py_DebugFlag

; 398  :             break;

  00135	e9 8c 00 00 00	 jmp	 $LN46@Py_Main
$LN61@Py_Main:

; 399  : 
; 400  :         case 'i':
; 401  :             Py_InspectFlag++;

  0013a	ff 05 00 00 00
	00		 inc	 DWORD PTR Py_InspectFlag

; 402  :             Py_InteractiveFlag++;

  00140	ff 05 00 00 00
	00		 inc	 DWORD PTR Py_InteractiveFlag

; 403  :             break;

  00146	eb 7e		 jmp	 SHORT $LN46@Py_Main
$LN60@Py_Main:

; 404  : 
; 405  :         /* case 'J': reserved for Jython */
; 406  : 
; 407  :         case 'O':
; 408  :             Py_OptimizeFlag++;

  00148	ff 05 00 00 00
	00		 inc	 DWORD PTR Py_OptimizeFlag

; 409  :             break;

  0014e	eb 76		 jmp	 SHORT $LN46@Py_Main
$LN59@Py_Main:

; 410  : 
; 411  :         case 'B':
; 412  :             Py_DontWriteBytecodeFlag++;

  00150	ff 05 00 00 00
	00		 inc	 DWORD PTR Py_DontWriteBytecodeFlag

; 413  :             break;

  00156	eb 6e		 jmp	 SHORT $LN46@Py_Main
$LN58@Py_Main:

; 414  : 
; 415  :         case 's':
; 416  :             Py_NoUserSiteDirectory++;

  00158	ff 05 00 00 00
	00		 inc	 DWORD PTR Py_NoUserSiteDirectory

; 417  :             break;

  0015e	eb 66		 jmp	 SHORT $LN46@Py_Main
$LN57@Py_Main:

; 418  : 
; 419  :         case 'S':
; 420  :             Py_NoSiteFlag++;

  00160	ff 05 00 00 00
	00		 inc	 DWORD PTR Py_NoSiteFlag

; 421  :             break;

  00166	eb 5e		 jmp	 SHORT $LN46@Py_Main
$LN54@Py_Main:

; 422  : 
; 423  :         case 'E':
; 424  :             /* Already handled above */
; 425  :             break;
; 426  : 
; 427  :         case 't':
; 428  :             /* ignored for backwards compatibility */
; 429  :             break;
; 430  : 
; 431  :         case 'u':
; 432  :             Py_UnbufferedStdioFlag = 1;

  00168	b8 01 00 00 00	 mov	 eax, 1
  0016d	89 05 00 00 00
	00		 mov	 DWORD PTR Py_UnbufferedStdioFlag, eax

; 433  :             saw_unbuffered_flag = 1;

  00173	89 84 24 d8 00
	00 00		 mov	 DWORD PTR saw_unbuffered_flag$1$[rsp], eax

; 434  :             break;

  0017a	eb 4a		 jmp	 SHORT $LN46@Py_Main
$LN53@Py_Main:

; 435  : 
; 436  :         case 'v':
; 437  :             Py_VerboseFlag++;

  0017c	ff 05 00 00 00
	00		 inc	 DWORD PTR Py_VerboseFlag

; 438  :             break;

  00182	eb 42		 jmp	 SHORT $LN46@Py_Main
$LN52@Py_Main:

; 439  : 
; 440  :         case 'x':
; 441  :             skipfirstline = 1;

  00184	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR skipfirstline$1$[rsp], 1

; 442  :             break;

  0018c	eb 38		 jmp	 SHORT $LN46@Py_Main
$LN51@Py_Main:

; 443  : 
; 444  :         case 'h':
; 445  :         case '?':
; 446  :             help++;

  0018e	ff c7		 inc	 edi
  00190	89 bc 24 c8 00
	00 00		 mov	 DWORD PTR help$1$[rsp], edi

; 447  :             break;

  00197	eb 2d		 jmp	 SHORT $LN46@Py_Main
$LN50@Py_Main:

; 448  : 
; 449  :         case 'V':
; 450  :             version++;

  00199	ff c6		 inc	 esi
  0019b	89 b4 24 d0 00
	00 00		 mov	 DWORD PTR version$1$[rsp], esi

; 451  :             break;

  001a2	eb 22		 jmp	 SHORT $LN46@Py_Main
$LN49@Py_Main:

; 452  : 
; 453  :         case 'W':
; 454  :             PySys_AddWarnOption(_PyOS_optarg);

  001a4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyOS_optarg
  001ab	e8 00 00 00 00	 call	 PySys_AddWarnOption

; 455  :             break;

  001b0	eb 14		 jmp	 SHORT $LN46@Py_Main
$LN48@Py_Main:

; 456  : 
; 457  :         case 'X':
; 458  :             PySys_AddXOption(_PyOS_optarg);

  001b2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyOS_optarg
  001b9	e8 00 00 00 00	 call	 PySys_AddXOption

; 459  :             break;

  001be	eb 06		 jmp	 SHORT $LN46@Py_Main
$LN47@Py_Main:

; 460  : 
; 461  :         case 'q':
; 462  :             Py_QuietFlag++;

  001c0	ff 05 00 00 00
	00		 inc	 DWORD PTR Py_QuietFlag
$LN46@Py_Main:

; 364  : 
; 365  :     while ((c = _PyOS_GetOpt(argc, argv, PROGRAM_OPTS)) != EOF) {

  001c6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1DG@HILFBDGJ@?$AAb?$AAB?$AAc?$AA?3?$AAd?$AAE?$AAh?$AAi?$AAJ?$AAm?$AA?3?$AAO?$AAq?$AAR?$AAs?$AAS?$AAt?$AAu?$AAv?$AAV?$AAW?$AA?3?$AAx?$AAX?$AA?3?$AA?$DP?$AA?$AA@
  001cd	49 8b d4	 mov	 rdx, r12
  001d0	41 8b cd	 mov	 ecx, r13d
  001d3	e8 00 00 00 00	 call	 _PyOS_GetOpt
  001d8	83 f8 ff	 cmp	 eax, -1
  001db	0f 85 0f ff ff
	ff		 jne	 $LL70@Py_Main

; 729  :                     if (ch == '\n') {

  001e1	e9 9d 00 00 00	 jmp	 $LN69@Py_Main
$LN45@Py_Main:

; 463  :             break;
; 464  : 
; 465  :         case 'R':
; 466  :             /* Ignored */
; 467  :             break;
; 468  : 
; 469  :         /* This space reserved for other options */
; 470  : 
; 471  :         default:
; 472  :             return usage(2, argv[0]);

  001e6	49 8b 14 24	 mov	 rdx, QWORD PTR [r12]
  001ea	b9 02 00 00 00	 mov	 ecx, 2
  001ef	e8 00 00 00 00	 call	 usage
  001f4	e9 e9 06 00 00	 jmp	 $LN76@Py_Main
$LN99@Py_Main:

; 384  :             /* -m is the last option; following arguments
; 385  :                that look like options are left for the
; 386  :                module to interpret. */
; 387  :             module = _PyOS_optarg;

  001f9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyOS_optarg
  00200	48 89 44 24 38	 mov	 QWORD PTR module$1$[rsp], rax

; 388  :             break;

  00205	eb 7c		 jmp	 SHORT $LN69@Py_Main
$LN98@Py_Main:

; 367  :             size_t len;
; 368  :             /* -c is the last option; following arguments
; 369  :                that look like options are left for the
; 370  :                command to interpret. */
; 371  : 
; 372  :             len = wcslen(_PyOS_optarg) + 1 + 1;

  00207	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR _PyOS_optarg
  0020e	48 83 c9 ff	 or	 rcx, -1
  00212	33 c0		 xor	 eax, eax
  00214	48 8b fe	 mov	 rdi, rsi
  00217	66 f2 af	 repne scasw
  0021a	48 f7 d1	 not	 rcx

; 373  :             command = (wchar_t *)malloc(sizeof(wchar_t) * len);

  0021d	48 8d 5c 09 02	 lea	 rbx, QWORD PTR [rcx+rcx+2]
  00222	48 8d 79 ff	 lea	 rdi, QWORD PTR [rcx-1]
  00226	48 8b cb	 mov	 rcx, rbx
  00229	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0022f	48 8b e8	 mov	 rbp, rax

; 374  :             if (command == NULL)

  00232	48 85 c0	 test	 rax, rax
  00235	75 13		 jne	 SHORT $LN67@Py_Main

; 375  :                 Py_FatalError(
; 376  :                    "not enough memory to copy -c argument");

  00237	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CG@IAAIMCOI@not?5enough?5memory?5to?5copy?5?9c?5arg@
  0023e	e8 00 00 00 00	 call	 Py_FatalError
  00243	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR _PyOS_optarg
$LN67@Py_Main:

; 377  :             wcscpy(command, _PyOS_optarg);

  0024a	48 8b d5	 mov	 rdx, rbp
  0024d	0f 1f 00	 npad	 3
$LL78@Py_Main:
  00250	0f b7 0e	 movzx	 ecx, WORD PTR [rsi]
  00253	48 83 c2 02	 add	 rdx, 2
  00257	48 83 c6 02	 add	 rsi, 2
  0025b	66 89 4a fe	 mov	 WORD PTR [rdx-2], cx
  0025f	66 85 c9	 test	 cx, cx
  00262	75 ec		 jne	 SHORT $LL78@Py_Main

; 378  :             command[len - 2] = '\n';

  00264	8b b4 24 d0 00
	00 00		 mov	 esi, DWORD PTR version$1$[rsp]
  0026b	b8 0a 00 00 00	 mov	 eax, 10
  00270	66 89 44 7d 00	 mov	 WORD PTR [rbp+rdi*2], ax
  00275	8b bc 24 c8 00
	00 00		 mov	 edi, DWORD PTR help$1$[rsp]

; 379  :             command[len - 1] = 0;

  0027c	33 c0		 xor	 eax, eax
  0027e	66 89 44 2b fe	 mov	 WORD PTR [rbx+rbp-2], ax
$LN69@Py_Main:

; 473  :             /*NOTREACHED*/
; 474  : 
; 475  :         }
; 476  :     }
; 477  : 
; 478  :     if (help)

  00283	85 ff		 test	 edi, edi
  00285	74 10		 je	 SHORT $LN44@Py_Main

; 479  :         return usage(0, argv[0]);

  00287	49 8b 14 24	 mov	 rdx, QWORD PTR [r12]
  0028b	33 c9		 xor	 ecx, ecx
  0028d	e8 00 00 00 00	 call	 usage
  00292	e9 4b 06 00 00	 jmp	 $LN76@Py_Main
$LN44@Py_Main:

; 480  : 
; 481  :     if (version) {

  00297	85 f6		 test	 esi, esi
  00299	74 25		 je	 SHORT $LN117@Py_Main

; 482  :         fprintf(stderr, "PyParallel %s\n", PY_VERSION);

  0029b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  002a1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05MAFOEECJ@3?43?45?$AA@
  002a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@KBEEOCOJ@PyParallel?5?$CFs?6?$AA@
  002af	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  002b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 483  :         return 0;

  002b9	33 c0		 xor	 eax, eax
  002bb	e9 22 06 00 00	 jmp	 $LN76@Py_Main
$LN117@Py_Main:

; 332  :     int saw_unbuffered_flag = 0;

  002c0	8b 9c 24 d8 00
	00 00		 mov	 ebx, DWORD PTR saw_unbuffered_flag$1$[rsp]
$LN43@Py_Main:

; 484  :     }
; 485  : 
; 486  :     if (!Py_InspectFlag &&
; 487  :         (p = Py_GETENV("PYTHONINSPECT")) && *p != '\0')

  002c7	44 39 35 00 00
	00 00		 cmp	 DWORD PTR Py_InspectFlag, r14d
  002ce	75 34		 jne	 SHORT $LN123@Py_Main
  002d0	44 39 35 00 00
	00 00		 cmp	 DWORD PTR Py_IgnoreEnvironmentFlag, r14d
  002d7	75 2b		 jne	 SHORT $LN123@Py_Main
  002d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@DNGJAMOL@PYTHONINSPECT?$AA@
  002e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getenv
  002e6	bf 01 00 00 00	 mov	 edi, 1
  002eb	48 85 c0	 test	 rax, rax
  002ee	74 19		 je	 SHORT $LN112@Py_Main
  002f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR Py_InspectFlag
  002f6	44 38 30	 cmp	 BYTE PTR [rax], r14b
  002f9	0f 45 cf	 cmovne	 ecx, edi
  002fc	89 0d 00 00 00
	00		 mov	 DWORD PTR Py_InspectFlag, ecx
  00302	eb 05		 jmp	 SHORT $LN112@Py_Main
$LN123@Py_Main:
  00304	bf 01 00 00 00	 mov	 edi, 1
$LN112@Py_Main:

; 488  :         Py_InspectFlag = 1;
; 489  :     if (!saw_unbuffered_flag &&
; 490  :         (p = Py_GETENV("PYTHONUNBUFFERED")) && *p != '\0')

  00309	85 db		 test	 ebx, ebx
  0030b	75 2d		 jne	 SHORT $LN113@Py_Main
  0030d	44 39 35 00 00
	00 00		 cmp	 DWORD PTR Py_IgnoreEnvironmentFlag, r14d
  00314	75 24		 jne	 SHORT $LN113@Py_Main
  00316	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@NFDOJAMJ@PYTHONUNBUFFERED?$AA@
  0031d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getenv
  00323	48 85 c0	 test	 rax, rax
  00326	74 12		 je	 SHORT $LN113@Py_Main
  00328	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR Py_UnbufferedStdioFlag
  0032e	44 38 30	 cmp	 BYTE PTR [rax], r14b
  00331	0f 45 cf	 cmovne	 ecx, edi
  00334	89 0d 00 00 00
	00		 mov	 DWORD PTR Py_UnbufferedStdioFlag, ecx
$LN113@Py_Main:

; 491  :         Py_UnbufferedStdioFlag = 1;
; 492  : 
; 493  :     if (!Py_NoUserSiteDirectory &&
; 494  :         (p = Py_GETENV("PYTHONNOUSERSITE")) && *p != '\0')

  0033a	44 39 35 00 00
	00 00		 cmp	 DWORD PTR Py_NoUserSiteDirectory, r14d
  00341	75 31		 jne	 SHORT $LN114@Py_Main
  00343	44 39 35 00 00
	00 00		 cmp	 DWORD PTR Py_IgnoreEnvironmentFlag, r14d
  0034a	0f 85 db 00 00
	00		 jne	 $LN39@Py_Main
  00350	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@HMANIOON@PYTHONNOUSERSITE?$AA@
  00357	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getenv
  0035d	48 85 c0	 test	 rax, rax
  00360	74 12		 je	 SHORT $LN114@Py_Main
  00362	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR Py_NoUserSiteDirectory
  00368	44 38 30	 cmp	 BYTE PTR [rax], r14b
  0036b	0f 45 cf	 cmovne	 ecx, edi
  0036e	89 0d 00 00 00
	00		 mov	 DWORD PTR Py_NoUserSiteDirectory, ecx
$LN114@Py_Main:

; 495  :         Py_NoUserSiteDirectory = 1;
; 496  : 
; 497  : #ifdef MS_WINDOWS
; 498  :     if (!Py_IgnoreEnvironmentFlag && (wp = _wgetenv(L"PYTHONWARNINGS")) &&
; 499  :         *wp != L'\0') {

  00374	44 39 35 00 00
	00 00		 cmp	 DWORD PTR Py_IgnoreEnvironmentFlag, r14d
  0037b	0f 85 aa 00 00
	00		 jne	 $LN39@Py_Main
  00381	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@BIIJHIJI@?$AAP?$AAY?$AAT?$AAH?$AAO?$AAN?$AAW?$AAA?$AAR?$AAN?$AAI?$AAN?$AAG?$AAS?$AA?$AA@
  00388	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wgetenv
  0038e	48 8b f0	 mov	 rsi, rax
  00391	48 85 c0	 test	 rax, rax
  00394	0f 84 91 00 00
	00		 je	 $LN39@Py_Main
  0039a	66 44 39 30	 cmp	 WORD PTR [rax], r14w
  0039e	0f 84 87 00 00
	00		 je	 $LN39@Py_Main

; 500  :         wchar_t *buf, *warning;
; 501  : 
; 502  :         buf = (wchar_t *)malloc((wcslen(wp) + 1) * sizeof(wchar_t));

  003a4	48 83 c9 ff	 or	 rcx, -1
  003a8	33 c0		 xor	 eax, eax
  003aa	48 8b fe	 mov	 rdi, rsi
  003ad	66 f2 af	 repne scasw
  003b0	48 f7 d1	 not	 rcx
  003b3	48 03 c9	 add	 rcx, rcx
  003b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  003bc	48 8b f8	 mov	 rdi, rax

; 503  :         if (buf == NULL)

  003bf	48 85 c0	 test	 rax, rax
  003c2	75 0c		 jne	 SHORT $LN38@Py_Main

; 504  :             Py_FatalError(
; 505  :                "not enough memory to copy PYTHONWARNINGS");

  003c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CJ@NCLJNGKO@not?5enough?5memory?5to?5copy?5PYTHON@
  003cb	e8 00 00 00 00	 call	 Py_FatalError
$LN38@Py_Main:

; 506  :         wcscpy(buf, wp);

  003d0	48 8b cf	 mov	 rcx, rdi
  003d3	48 2b ce	 sub	 rcx, rsi
  003d6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL85@Py_Main:
  003e0	0f b7 06	 movzx	 eax, WORD PTR [rsi]
  003e3	48 83 c6 02	 add	 rsi, 2
  003e7	66 89 44 31 fe	 mov	 WORD PTR [rcx+rsi-2], ax
  003ec	66 85 c0	 test	 ax, ax
  003ef	75 ef		 jne	 SHORT $LL85@Py_Main

; 507  :         for (warning = wcstok(buf, L",");
; 508  :              warning != NULL;
; 509  :              warning = wcstok(NULL, L",")) {

  003f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_13DEFPDAGF@?$AA?0?$AA?$AA@
  003f8	48 8b cf	 mov	 rcx, rdi
  003fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcstok
  00401	48 85 c0	 test	 rax, rax
  00404	74 1c		 je	 SHORT $LN35@Py_Main
$LL37@Py_Main:

; 510  :             PySys_AddWarnOption(warning);

  00406	48 8b c8	 mov	 rcx, rax
  00409	e8 00 00 00 00	 call	 PySys_AddWarnOption
  0040e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_13DEFPDAGF@?$AA?0?$AA?$AA@
  00415	33 c9		 xor	 ecx, ecx
  00417	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcstok
  0041d	48 85 c0	 test	 rax, rax
  00420	75 e4		 jne	 SHORT $LL37@Py_Main
$LN35@Py_Main:

; 511  :         }
; 512  :         free(buf);

  00422	48 8b cf	 mov	 rcx, rdi
  00425	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN39@Py_Main:

; 513  :     }
; 514  : #else
; 515  :     if ((p = Py_GETENV("PYTHONWARNINGS")) && *p != '\0') {
; 516  :         char *buf, *oldloc;
; 517  :         PyObject *unicode;
; 518  : 
; 519  :         /* settle for strtok here as there's no one standard
; 520  :            C89 wcstok */
; 521  :         buf = (char *)malloc(strlen(p) + 1);
; 522  :         if (buf == NULL)
; 523  :             Py_FatalError(
; 524  :                "not enough memory to copy PYTHONWARNINGS");
; 525  :         strcpy(buf, p);
; 526  :         oldloc = strdup(setlocale(LC_ALL, NULL));
; 527  :         setlocale(LC_ALL, "");
; 528  :         for (p = strtok(buf, ","); p != NULL; p = strtok(NULL, ",")) {
; 529  : #ifdef __APPLE__
; 530  :             /* Use utf-8 on Mac OS X */
; 531  :             unicode = PyUnicode_FromString(p);
; 532  : #else
; 533  :             unicode = PyUnicode_DecodeLocale(p, "surrogateescape");
; 534  : #endif
; 535  :             if (unicode == NULL) {
; 536  :                 /* ignore errors */
; 537  :                 PyErr_Clear();
; 538  :                 continue;
; 539  :             }
; 540  :             PySys_AddWarnOptionUnicode(unicode);
; 541  :             Py_DECREF(unicode);
; 542  :         }
; 543  :         setlocale(LC_ALL, oldloc);
; 544  :         free(oldloc);
; 545  :         free(buf);
; 546  :     }
; 547  : #endif
; 548  : 
; 549  :     if (command == NULL && module == NULL && _PyOS_optind < argc &&
; 550  :         wcscmp(argv[_PyOS_optind], L"-") != 0)

  0042b	48 8b 74 24 38	 mov	 rsi, QWORD PTR module$1$[rsp]
  00430	48 85 ed	 test	 rbp, rbp
  00433	75 30		 jne	 SHORT $LN34@Py_Main
  00435	48 85 f6	 test	 rsi, rsi
  00438	75 2b		 jne	 SHORT $LN34@Py_Main
  0043a	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR _PyOS_optind
  00441	41 3b c5	 cmp	 eax, r13d
  00444	7d 1f		 jge	 SHORT $LN34@Py_Main
  00446	49 8b 14 c4	 mov	 rdx, QWORD PTR [r12+rax*8]
  0044a	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_13IMODFHAA@?$AA?9?$AA?$AA@
  00451	b9 02 00 00 00	 mov	 ecx, 2
  00456	48 8b f2	 mov	 rsi, rdx
  00459	66 f3 a7	 repe cmpsw
  0045c	48 8b 74 24 38	 mov	 rsi, QWORD PTR module$1$[rsp]
  00461	4c 0f 45 f2	 cmovne	 r14, rdx
$LN34@Py_Main:

; 551  :     {
; 552  : #ifdef __VMS
; 553  :         filename = decc$translate_vms(argv[_PyOS_optind]);
; 554  :         if (filename == (char *)0 || filename == (char *)-1)
; 555  :             filename = argv[_PyOS_optind];
; 556  : 
; 557  : #else
; 558  :         filename = argv[_PyOS_optind];
; 559  : #endif
; 560  :     }
; 561  : 
; 562  :     stdin_is_interactive = Py_FdIsInteractive(stdin, (char *)0);

  00465	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0046b	33 d2		 xor	 edx, edx
  0046d	48 8b c8	 mov	 rcx, rax
  00470	e8 00 00 00 00	 call	 Py_FdIsInteractive
  00475	8b d8		 mov	 ebx, eax

; 563  : 
; 564  : #if defined(MS_WINDOWS) || defined(__CYGWIN__)
; 565  :     /* don't translate newlines (\r\n <=> \n) */
; 566  :     _setmode(fileno(stdin), O_BINARY);

  00477	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0047d	48 8b c8	 mov	 rcx, rax
  00480	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  00486	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  0048b	8b c8		 mov	 ecx, eax
  0048d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__setmode

; 567  :     _setmode(fileno(stdout), O_BINARY);

  00493	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00499	48 8d 48 30	 lea	 rcx, QWORD PTR [rax+48]
  0049d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  004a3	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  004a8	8b c8		 mov	 ecx, eax
  004aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__setmode

; 568  :     _setmode(fileno(stderr), O_BINARY);

  004b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  004b6	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  004ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  004c0	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  004c5	8b c8		 mov	 ecx, eax
  004c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__setmode

; 569  : #endif
; 570  : 
; 571  :     if (Py_UnbufferedStdioFlag) {

  004cd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_UnbufferedStdioFlag, 0
  004d4	74 43		 je	 SHORT $LN33@Py_Main

; 572  : #ifdef HAVE_SETVBUF
; 573  :         setvbuf(stdin,  (char *)NULL, _IONBF, BUFSIZ);

  004d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  004dc	33 d2		 xor	 edx, edx
  004de	41 b9 00 02 00
	00		 mov	 r9d, 512		; 00000200H
  004e4	44 8d 42 04	 lea	 r8d, QWORD PTR [rdx+4]
  004e8	48 8b c8	 mov	 rcx, rax
  004eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setvbuf

; 574  :         setvbuf(stdout, (char *)NULL, _IONBF, BUFSIZ);

  004f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  004f7	33 d2		 xor	 edx, edx
  004f9	44 8d 42 04	 lea	 r8d, QWORD PTR [rdx+4]
  004fd	48 8d 48 30	 lea	 rcx, QWORD PTR [rax+48]
  00501	41 b9 00 02 00
	00		 mov	 r9d, 512		; 00000200H
  00507	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setvbuf

; 575  :         setvbuf(stderr, (char *)NULL, _IONBF, BUFSIZ);

  0050d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00513	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  00517	eb 13		 jmp	 SHORT $LN125@Py_Main
$LN33@Py_Main:

; 576  : #else /* !HAVE_SETVBUF */
; 577  :         setbuf(stdin,  (char *)NULL);
; 578  :         setbuf(stdout, (char *)NULL);
; 579  :         setbuf(stderr, (char *)NULL);
; 580  : #endif /* !HAVE_SETVBUF */
; 581  :     }
; 582  :     else if (Py_InteractiveFlag) {

  00519	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_InteractiveFlag, 0
  00520	74 1e		 je	 SHORT $LN31@Py_Main

; 583  : #ifdef MS_WINDOWS
; 584  :         /* Doesn't have to have line-buffered -- use unbuffered */
; 585  :         /* Any set[v]buf(stdin, ...) screws up Tkinter :-( */
; 586  :         setvbuf(stdout, (char *)NULL, _IONBF, BUFSIZ);

  00522	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00528	48 8d 48 30	 lea	 rcx, QWORD PTR [rax+48]
$LN125@Py_Main:
  0052c	41 b9 00 02 00
	00		 mov	 r9d, 512		; 00000200H
  00532	41 b8 04 00 00
	00		 mov	 r8d, 4
  00538	33 d2		 xor	 edx, edx
  0053a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setvbuf
$LN31@Py_Main:

; 587  : #else /* !MS_WINDOWS */
; 588  : #ifdef HAVE_SETVBUF
; 589  :         setvbuf(stdin,  (char *)NULL, _IOLBF, BUFSIZ);
; 590  :         setvbuf(stdout, (char *)NULL, _IOLBF, BUFSIZ);
; 591  : #endif /* HAVE_SETVBUF */
; 592  : #endif /* !MS_WINDOWS */
; 593  :         /* Leave stderr alone - it should be unbuffered anyway. */
; 594  :     }
; 595  : #ifdef __VMS
; 596  :     else {
; 597  :         setvbuf (stdout, (char *)NULL, _IOLBF, BUFSIZ);
; 598  :     }
; 599  : #endif /* __VMS */
; 600  : 
; 601  : #ifdef __APPLE__
; 602  :     /* On MacOS X, when the Python interpreter is embedded in an
; 603  :        application bundle, it gets executed by a bootstrapping script
; 604  :        that does os.execve() with an argv[0] that's different from the
; 605  :        actual Python executable. This is needed to keep the Finder happy,
; 606  :        or rather, to work around Apple's overly strict requirements of
; 607  :        the process name. However, we still need a usable sys.executable,
; 608  :        so the actual executable path is passed in an environment variable.
; 609  :        See Lib/plat-mac/bundlebuiler.py for details about the bootstrap
; 610  :        script. */
; 611  :     if ((p = Py_GETENV("PYTHONEXECUTABLE")) && *p != '\0') {
; 612  :         wchar_t* buffer;
; 613  :         size_t len = strlen(p) + 1;
; 614  : 
; 615  :         buffer = malloc(len * sizeof(wchar_t));
; 616  :         if (buffer == NULL) {
; 617  :             Py_FatalError(
; 618  :                "not enough memory to copy PYTHONEXECUTABLE");
; 619  :         }
; 620  : 
; 621  :         mbstowcs(buffer, p, len);
; 622  :         Py_SetProgramName(buffer);
; 623  :         /* buffer is now handed off - do not free */
; 624  :     } else {
; 625  : #ifdef WITH_NEXT_FRAMEWORK
; 626  :         char* pyvenv_launcher = getenv("__PYVENV_LAUNCHER__");
; 627  : 
; 628  :         if (pyvenv_launcher && *pyvenv_launcher) {
; 629  :             /* Used by Mac/Tools/pythonw.c to forward
; 630  :              * the argv0 of the stub executable
; 631  :              */
; 632  :             wchar_t* wbuf = _Py_char2wchar(pyvenv_launcher, NULL);
; 633  : 
; 634  :             if (wbuf == NULL) {
; 635  :                 Py_FatalError("Cannot decode __PYVENV_LAUNCHER__");
; 636  :             }
; 637  :             Py_SetProgramName(wbuf);
; 638  : 
; 639  :             /* Don't free wbuf, the argument to Py_SetProgramName
; 640  :              * must remain valid until the Py_Finalize is called.
; 641  :              */
; 642  :         } else {
; 643  :             Py_SetProgramName(argv[0]);
; 644  :         }
; 645  : #else
; 646  :         Py_SetProgramName(argv[0]);
; 647  : #endif
; 648  :     }
; 649  : #else
; 650  :     Py_SetProgramName(argv[0]);

  00540	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
  00544	e8 00 00 00 00	 call	 Py_SetProgramName

; 651  : #endif
; 652  :     Py_Initialize();

  00549	e8 00 00 00 00	 call	 Py_Initialize

; 653  : 
; 654  :     if (!Py_QuietFlag && (Py_VerboseFlag ||
; 655  :                         (command == NULL && filename == NULL &&
; 656  :                          module == NULL && stdin_is_interactive))) {

  0054e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_QuietFlag, 0
  00555	75 7c		 jne	 SHORT $LN28@Py_Main
  00557	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_VerboseFlag, 0
  0055e	75 1f		 jne	 SHORT $LN29@Py_Main
  00560	48 85 ed	 test	 rbp, rbp
  00563	75 73		 jne	 SHORT $LN104@Py_Main
  00565	4d 85 f6	 test	 r14, r14
  00568	0f 85 8a 00 00
	00		 jne	 $LN27@Py_Main
  0056e	48 85 f6	 test	 rsi, rsi
  00571	0f 85 86 00 00
	00		 jne	 $LN105@Py_Main
  00577	85 db		 test	 ebx, ebx
  00579	0f 84 99 00 00
	00		 je	 $LN26@Py_Main
$LN29@Py_Main:

; 657  :         fprintf(stderr, "PyParallel %s on %s\n",
; 658  :             Py_GetVersion(), Py_GetPlatform());

  0057f	e8 00 00 00 00	 call	 Py_GetPlatform
  00584	48 8b f0	 mov	 rsi, rax
  00587	e8 00 00 00 00	 call	 Py_GetVersion
  0058c	48 8b f8	 mov	 rdi, rax
  0058f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00595	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HCFAEEPL@PyParallel?5?$CFs?5on?5?$CFs?6?$AA@
  0059c	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  005a0	4c 8b ce	 mov	 r9, rsi
  005a3	4c 8b c7	 mov	 r8, rdi
  005a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 659  :         if (!Py_NoSiteFlag)

  005ac	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_NoSiteFlag, 0
  005b3	75 1e		 jne	 SHORT $LN28@Py_Main

; 660  :             fprintf(stderr, "%s\n", COPYRIGHT);

  005b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  005bb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0EH@JFFAKOEJ@Type?5?$CChelp?$CC?0?5?$CCcopyright?$CC?0?5?$CCcredi@
  005c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03OFAPEBGM@?$CFs?6?$AA@
  005c9	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  005cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf
$LN28@Py_Main:

; 661  :     }
; 662  : 
; 663  :     if (command != NULL) {

  005d3	48 85 ed	 test	 rbp, rbp
  005d6	74 1b		 je	 SHORT $LN115@Py_Main
$LN104@Py_Main:

; 664  :         /* Backup _PyOS_optind and force sys.argv[0] = '-c' */
; 665  :         _PyOS_optind--;

  005d8	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _PyOS_optind

; 666  :         argv[_PyOS_optind] = L"-c";

  005de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_15NMJMBAFJ@?$AA?9?$AAc?$AA?$AA@
  005e5	ff c8		 dec	 eax
  005e7	89 05 00 00 00
	00		 mov	 DWORD PTR _PyOS_optind, eax
  005ed	48 98		 cdqe
  005ef	49 89 0c c4	 mov	 QWORD PTR [r12+rax*8], rcx
$LN115@Py_Main:

; 384  :             /* -m is the last option; following arguments
; 385  :                that look like options are left for the
; 386  :                module to interpret. */
; 387  :             module = _PyOS_optarg;

  005f3	48 8b 74 24 38	 mov	 rsi, QWORD PTR module$1$[rsp]
$LN27@Py_Main:

; 667  :     }
; 668  : 
; 669  :     if (module != NULL) {

  005f8	48 85 f6	 test	 rsi, rsi
  005fb	74 1b		 je	 SHORT $LN26@Py_Main
$LN105@Py_Main:

; 670  :         /* Backup _PyOS_optind and force sys.argv[0] = '-m'*/
; 671  :         _PyOS_optind--;

  005fd	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _PyOS_optind

; 672  :         argv[_PyOS_optind] = L"-m";

  00603	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_15DMEDGHGK@?$AA?9?$AAm?$AA?$AA@
  0060a	ff c8		 dec	 eax
  0060c	89 05 00 00 00
	00		 mov	 DWORD PTR _PyOS_optind, eax
  00612	48 98		 cdqe
  00614	49 89 0c c4	 mov	 QWORD PTR [r12+rax*8], rcx
$LN26@Py_Main:

; 673  :     }
; 674  : 
; 675  :     PySys_SetArgv(argc-_PyOS_optind, argv+_PyOS_optind);

  00618	48 63 0d 00 00
	00 00		 movsxd	 rcx, DWORD PTR _PyOS_optind
  0061f	44 2b e9	 sub	 r13d, ecx
  00622	49 8d 14 cc	 lea	 rdx, QWORD PTR [r12+rcx*8]
  00626	41 8b cd	 mov	 ecx, r13d
  00629	e8 00 00 00 00	 call	 PySys_SetArgv

; 676  : 
; 677  :     if ((Py_InspectFlag || (command == NULL && filename == NULL && module == NULL)) &&
; 678  :         isatty(fileno(stdin))) {

  0062e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_InspectFlag, 0
  00635	75 17		 jne	 SHORT $LN24@Py_Main
  00637	48 85 ed	 test	 rbp, rbp
  0063a	75 52		 jne	 SHORT $LN103@Py_Main
  0063c	4d 85 f6	 test	 r14, r14
  0063f	0f 85 b2 00 00
	00		 jne	 $LN21@Py_Main
  00645	48 85 f6	 test	 rsi, rsi
  00648	0f 85 ae 00 00
	00		 jne	 $LN106@Py_Main
$LN24@Py_Main:
  0064e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00654	48 8b c8	 mov	 rcx, rax
  00657	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  0065d	8b c8		 mov	 ecx, eax
  0065f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isatty
  00665	85 c0		 test	 eax, eax
  00667	74 20		 je	 SHORT $LN22@Py_Main

; 679  :         PyObject *v;
; 680  :         v = PyImport_ImportModule("readline");

  00669	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08KBCDPPMN@readline?$AA@
  00670	e8 00 00 00 00	 call	 PyImport_ImportModule

; 681  :         if (v == NULL)

  00675	48 85 c0	 test	 rax, rax
  00678	75 07		 jne	 SHORT $LN23@Py_Main

; 682  :             PyErr_Clear();

  0067a	e8 00 00 00 00	 call	 PyErr_Clear

; 683  :         else

  0067f	eb 08		 jmp	 SHORT $LN22@Py_Main
$LN23@Py_Main:

; 684  :             Py_DECREF(v);

  00681	48 8b c8	 mov	 rcx, rax
  00684	e8 00 00 00 00	 call	 _Py_DecRef
$LN22@Py_Main:

; 685  :     }
; 686  : 
; 687  :     if (command) {

  00689	48 85 ed	 test	 rbp, rbp
  0068c	74 69		 je	 SHORT $LN21@Py_Main
$LN103@Py_Main:

; 688  :         sts = run_command(command, &cf);

  0068e	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR cf$[rsp]
  00696	48 8b cd	 mov	 rcx, rbp
  00699	e8 00 00 00 00	 call	 run_command

; 689  :         free(command);

  0069e	48 8b cd	 mov	 rcx, rbp
  006a1	8b f8		 mov	 edi, eax
  006a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN118@Py_Main:

; 332  :     int saw_unbuffered_flag = 0;

  006a9	45 33 e4	 xor	 r12d, r12d
$LN126@Py_Main:
  006ac	41 bd 01 00 00
	00		 mov	 r13d, 1
$LN4@Py_Main:

; 749  :     }
; 750  : 
; 751  :     /* Check this environment variable at the end, to give programs the
; 752  :      * opportunity to set it from Python.
; 753  :      */
; 754  :     if (!Py_InspectFlag &&
; 755  :         (p = Py_GETENV("PYTHONINSPECT")) && *p != '\0')

  006b2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_InspectFlag, 0
  006b9	0f 85 d9 01 00
	00		 jne	 $LN102@Py_Main
  006bf	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_IgnoreEnvironmentFlag, 0
  006c6	0f 85 0f 02 00
	00		 jne	 $LN2@Py_Main
  006cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@DNGJAMOL@PYTHONINSPECT?$AA@
  006d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getenv
  006d9	48 85 c0	 test	 rax, rax
  006dc	0f 84 ad 01 00
	00		 je	 $LN3@Py_Main
  006e2	80 38 00	 cmp	 BYTE PTR [rax], 0
  006e5	0f 84 a4 01 00
	00		 je	 $LN3@Py_Main

; 756  :     {
; 757  :         Py_InspectFlag = 1;

  006eb	44 89 2d 00 00
	00 00		 mov	 DWORD PTR Py_InspectFlag, r13d

; 758  :     }
; 759  : 
; 760  :     if (Py_InspectFlag && stdin_is_interactive &&
; 761  :         (filename != NULL || command != NULL || module != NULL)) {

  006f2	e9 a1 01 00 00	 jmp	 $LN102@Py_Main
$LN21@Py_Main:

; 690  :     } else if (module) {

  006f7	48 85 f6	 test	 rsi, rsi
  006fa	74 1f		 je	 SHORT $LN19@Py_Main
$LN106@Py_Main:

; 691  :         sts = (RunModule(module, 1) != 0);

  006fc	41 bd 01 00 00
	00		 mov	 r13d, 1
  00702	48 8b ce	 mov	 rcx, rsi
  00705	41 8b d5	 mov	 edx, r13d
  00708	e8 00 00 00 00	 call	 RunModule
  0070d	45 33 e4	 xor	 r12d, r12d
  00710	85 c0		 test	 eax, eax
  00712	41 8b fc	 mov	 edi, r12d
  00715	40 0f 95 c7	 setne	 dil

; 692  :     }
; 693  :     else {

  00719	eb 97		 jmp	 SHORT $LN4@Py_Main
$LN19@Py_Main:

; 694  : 
; 695  :         if (filename == NULL && stdin_is_interactive) {

  0071b	4d 85 f6	 test	 r14, r14
  0071e	75 24		 jne	 SHORT $LN109@Py_Main

; 696  :             Py_InspectFlag = 0; /* do exit on SystemExit */

  00720	45 33 e4	 xor	 r12d, r12d
  00723	85 db		 test	 ebx, ebx
  00725	0f 84 4a 01 00
	00		 je	 $LN108@Py_Main

; 697  :             RunStartupFile(&cf);

  0072b	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR cf$[rsp]
  00733	44 89 25 00 00
	00 00		 mov	 DWORD PTR Py_InspectFlag, r12d
  0073a	e8 00 00 00 00	 call	 RunStartupFile

; 698  :         }
; 699  :         /* XXX */
; 700  : 
; 701  :         sts = -1;               /* keep track of whether we've already run __main__ */
; 702  : 
; 703  :         if (filename != NULL) {

  0073f	e9 31 01 00 00	 jmp	 $LN108@Py_Main
$LN109@Py_Main:

; 704  :             sts = RunMainFromImporter(filename);

  00744	49 8b ce	 mov	 rcx, r14
  00747	e8 00 00 00 00	 call	 RunMainFromImporter
  0074c	8b f8		 mov	 edi, eax

; 705  :         }
; 706  : 
; 707  :         if (sts==-1 && filename!=NULL) {

  0074e	83 f8 ff	 cmp	 eax, -1
  00751	0f 85 52 ff ff
	ff		 jne	 $LN118@Py_Main

; 708  :             fp = _Py_wfopen(filename, L"r");

  00757	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_13BPINEIPE@?$AAr?$AA?$AA@
  0075e	49 8b ce	 mov	 rcx, r14
  00761	e8 00 00 00 00	 call	 _Py_wfopen
  00766	4c 8b f8	 mov	 r15, rax

; 709  :             if (fp == NULL) {

  00769	48 85 c0	 test	 rax, rax
  0076c	75 6c		 jne	 SHORT $LN14@Py_Main

; 710  :                 char *cfilename_buffer;
; 711  :                 const char *cfilename;
; 712  :                 int err = errno;

  0076e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 713  :                 cfilename_buffer = _Py_wchar2char(filename, NULL);

  00774	33 d2		 xor	 edx, edx
  00776	49 8b ce	 mov	 rcx, r14
  00779	8b 18		 mov	 ebx, DWORD PTR [rax]
  0077b	e8 00 00 00 00	 call	 _Py_wchar2char

; 714  :                 if (cfilename_buffer != NULL)

  00780	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:??_C@_0BI@PLNCLPPD@?$DMunprintable?5file?5name?$DO?$AA@
  00787	48 85 c0	 test	 rax, rax

; 715  :                     cfilename = cfilename_buffer;
; 716  :                 else
; 717  :                     cfilename = "<unprintable file name>";
; 718  :                 fprintf(stderr, "%ls: can't open file '%s': [Errno %d] %s\n",
; 719  :                     argv[0], cfilename, err, strerror(err));

  0078a	8b cb		 mov	 ecx, ebx
  0078c	48 8b e8	 mov	 rbp, rax
  0078f	48 0f 45 f0	 cmovne	 rsi, rax
  00793	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  00799	48 8b f8	 mov	 rdi, rax
  0079c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  007a2	4d 8b 04 24	 mov	 r8, QWORD PTR [r12]
  007a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@KLLBLHEB@?$CFls?3?5can?8t?5open?5file?5?8?$CFs?8?3?5?$FLErrn@
  007ad	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  007b1	4c 8b ce	 mov	 r9, rsi
  007b4	48 89 7c 24 28	 mov	 QWORD PTR [rsp+40], rdi
  007b9	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  007bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 720  :                 if (cfilename_buffer)

  007c3	48 85 ed	 test	 rbp, rbp
  007c6	74 08		 je	 SHORT $LN11@Py_Main

; 721  :                     PyMem_Free(cfilename_buffer);

  007c8	48 8b cd	 mov	 rcx, rbp
  007cb	e8 00 00 00 00	 call	 PyMem_Free
$LN11@Py_Main:

; 722  :                 return 2;

  007d0	b8 02 00 00 00	 mov	 eax, 2
  007d5	e9 08 01 00 00	 jmp	 $LN76@Py_Main
$LN14@Py_Main:

; 723  :             }
; 724  :             else if (skipfirstline) {

  007da	83 7c 24 30 00	 cmp	 DWORD PTR skipfirstline$1$[rsp], 0
  007df	74 32		 je	 SHORT $LN7@Py_Main

; 725  :                 int ch;
; 726  :                 /* Push back first newline so line numbers
; 727  :                    remain the same */
; 728  :                 while ((ch = getc(fp)) != EOF) {

  007e1	48 8b c8	 mov	 rcx, rax
  007e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getc
  007ea	83 f8 ff	 cmp	 eax, -1
  007ed	74 24		 je	 SHORT $LN7@Py_Main
  007ef	90		 npad	 1
$LL8@Py_Main:

; 729  :                     if (ch == '\n') {

  007f0	83 f8 0a	 cmp	 eax, 10
  007f3	74 10		 je	 SHORT $LN100@Py_Main

; 725  :                 int ch;
; 726  :                 /* Push back first newline so line numbers
; 727  :                    remain the same */
; 728  :                 while ((ch = getc(fp)) != EOF) {

  007f5	49 8b cf	 mov	 rcx, r15
  007f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getc
  007fe	83 f8 ff	 cmp	 eax, -1
  00801	75 ed		 jne	 SHORT $LL8@Py_Main

; 729  :                     if (ch == '\n') {

  00803	eb 0e		 jmp	 SHORT $LN7@Py_Main
$LN100@Py_Main:

; 730  :                         (void)ungetc(ch, fp);

  00805	49 8b d7	 mov	 rdx, r15
  00808	b9 0a 00 00 00	 mov	 ecx, 10
  0080d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ungetc
$LN7@Py_Main:

; 731  :                         break;
; 732  :                     }
; 733  :                 }
; 734  :             }
; 735  :             {
; 736  :                 /* XXX: does this work on Win/Win64? (see posix_fstat) */
; 737  :                 struct stat sb;
; 738  :                 if (fstat(fileno(fp), &sb) == 0 &&
; 739  :                     S_ISDIR(sb.st_mode)) {

  00813	49 8b cf	 mov	 rcx, r15
  00816	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  0081c	48 8d 54 24 40	 lea	 rdx, QWORD PTR sb$120902[rsp]
  00821	8b c8		 mov	 ecx, eax
  00823	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fstat64i32
  00829	85 c0		 test	 eax, eax
  0082b	75 45		 jne	 SHORT $LN121@Py_Main
  0082d	0f b7 4c 24 46	 movzx	 ecx, WORD PTR sb$120902[rsp+6]
  00832	b8 00 f0 00 00	 mov	 eax, 61440		; 0000f000H
  00837	ba 00 40 00 00	 mov	 edx, 16384		; 00004000H
  0083c	66 23 c8	 and	 cx, ax
  0083f	66 3b ca	 cmp	 cx, dx
  00842	75 2e		 jne	 SHORT $LN121@Py_Main

; 740  :                     fprintf(stderr, "%ls: '%ls' is a directory, cannot continue\n", argv[0], filename);

  00844	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0084a	4d 8b 04 24	 mov	 r8, QWORD PTR [r12]
  0084e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@LPBAPCAP@?$CFls?3?5?8?$CFls?8?5is?5a?5directory?0?5canno@
  00855	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  00859	4d 8b ce	 mov	 r9, r14
  0085c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 741  :                     fclose(fp);

  00862	49 8b cf	 mov	 rcx, r15
  00865	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 742  :                     return 1;

  0086b	b8 01 00 00 00	 mov	 eax, 1
  00870	eb 70		 jmp	 SHORT $LN76@Py_Main
$LN121@Py_Main:

; 743  :                 }
; 744  :             }
; 745  :         }
; 746  : 
; 747  :         if (sts == -1)
; 748  :             sts = run_file(fp, filename, &cf);

  00872	45 33 e4	 xor	 r12d, r12d
$LN108@Py_Main:
  00875	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR cf$[rsp]
  0087d	49 8b d6	 mov	 rdx, r14
  00880	49 8b cf	 mov	 rcx, r15
  00883	e8 00 00 00 00	 call	 run_file
  00888	8b f8		 mov	 edi, eax
  0088a	e9 1d fe ff ff	 jmp	 $LN126@Py_Main
$LN3@Py_Main:

; 758  :     }
; 759  : 
; 760  :     if (Py_InspectFlag && stdin_is_interactive &&
; 761  :         (filename != NULL || command != NULL || module != NULL)) {

  0088f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_InspectFlag, 0
  00896	74 43		 je	 SHORT $LN2@Py_Main
$LN102@Py_Main:
  00898	85 db		 test	 ebx, ebx
  0089a	74 3f		 je	 SHORT $LN2@Py_Main
  0089c	4d 85 f6	 test	 r14, r14
  0089f	75 0a		 jne	 SHORT $LN1@Py_Main
  008a1	48 85 ed	 test	 rbp, rbp
  008a4	75 05		 jne	 SHORT $LN1@Py_Main
  008a6	48 85 f6	 test	 rsi, rsi
  008a9	74 30		 je	 SHORT $LN2@Py_Main
$LN1@Py_Main:

; 762  :         Py_InspectFlag = 0;

  008ab	44 89 25 00 00
	00 00		 mov	 DWORD PTR Py_InspectFlag, r12d

; 763  :         /* XXX */
; 764  :         sts = PyRun_AnyFileFlags(stdin, "<stdin>", &cf) != 0;

  008b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  008b8	4c 8d 8c 24 c0
	00 00 00	 lea	 r9, QWORD PTR cf$[rsp]
  008c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07CMJMHHJG@?$DMstdin?$DO?$AA@
  008c7	45 33 c0	 xor	 r8d, r8d
  008ca	48 8b c8	 mov	 rcx, rax
  008cd	e8 00 00 00 00	 call	 PyRun_AnyFileExFlags
  008d2	41 8b fc	 mov	 edi, r12d
  008d5	85 c0		 test	 eax, eax
  008d7	40 0f 95 c7	 setne	 dil
$LN2@Py_Main:

; 765  :     }
; 766  : 
; 767  :     Py_Finalize();

  008db	e8 00 00 00 00	 call	 Py_Finalize

; 768  : 
; 769  : #ifdef __INSURE__
; 770  :     /* Insure++ is a memory analysis tool that aids in discovering
; 771  :      * memory leaks and other memory problems.  On Python exit, the
; 772  :      * interned string dictionaries are flagged as being in use at exit
; 773  :      * (which it is).  Under normal circumstances, this is fine because
; 774  :      * the memory will be automatically reclaimed by the system.  Under
; 775  :      * memory debugging, it's a huge source of useless noise, so we
; 776  :      * trade off slower shutdown for less distraction in the memory
; 777  :      * reports.  -baw
; 778  :      */
; 779  :     _Py_ReleaseInternedUnicodeStrings();
; 780  : #endif /* __INSURE__ */
; 781  : 
; 782  :     return sts;

  008e0	8b c7		 mov	 eax, edi
$LN76@Py_Main:

; 783  : }

  008e2	48 83 c4 78	 add	 rsp, 120		; 00000078H
  008e6	41 5f		 pop	 r15
  008e8	41 5e		 pop	 r14
  008ea	41 5d		 pop	 r13
  008ec	41 5c		 pop	 r12
  008ee	5f		 pop	 rdi
  008ef	5e		 pop	 rsi
  008f0	5d		 pop	 rbp
  008f1	5b		 pop	 rbx
  008f2	c3		 ret	 0
  008f3	90		 npad	 1
$LN111@Py_Main:
  008f4	00 00 00 00	 DD	 $LN51@Py_Main
  008f8	00 00 00 00	 DD	 $LN59@Py_Main
  008fc	00 00 00 00	 DD	 $LN46@Py_Main
  00900	00 00 00 00	 DD	 $LN60@Py_Main
  00904	00 00 00 00	 DD	 $LN57@Py_Main
  00908	00 00 00 00	 DD	 $LN50@Py_Main
  0090c	00 00 00 00	 DD	 $LN49@Py_Main
  00910	00 00 00 00	 DD	 $LN48@Py_Main
  00914	00 00 00 00	 DD	 $LN63@Py_Main
  00918	00 00 00 00	 DD	 $LN62@Py_Main
  0091c	00 00 00 00	 DD	 $LN61@Py_Main
  00920	00 00 00 00	 DD	 $LN47@Py_Main
  00924	00 00 00 00	 DD	 $LN58@Py_Main
  00928	00 00 00 00	 DD	 $LN54@Py_Main
  0092c	00 00 00 00	 DD	 $LN53@Py_Main
  00930	00 00 00 00	 DD	 $LN52@Py_Main
  00934	00 00 00 00	 DD	 $LN45@Py_Main
$LN110@Py_Main:
  00938	00		 DB	 0
  00939	10		 DB	 16
  0093a	10		 DB	 16
  0093b	01		 DB	 1
  0093c	10		 DB	 16
  0093d	10		 DB	 16
  0093e	02		 DB	 2
  0093f	10		 DB	 16
  00940	10		 DB	 16
  00941	10		 DB	 16
  00942	10		 DB	 16
  00943	10		 DB	 16
  00944	10		 DB	 16
  00945	10		 DB	 16
  00946	10		 DB	 16
  00947	10		 DB	 16
  00948	03		 DB	 3
  00949	10		 DB	 16
  0094a	10		 DB	 16
  0094b	02		 DB	 2
  0094c	04		 DB	 4
  0094d	10		 DB	 16
  0094e	10		 DB	 16
  0094f	05		 DB	 5
  00950	06		 DB	 6
  00951	07		 DB	 7
  00952	10		 DB	 16
  00953	10		 DB	 16
  00954	10		 DB	 16
  00955	10		 DB	 16
  00956	10		 DB	 16
  00957	10		 DB	 16
  00958	10		 DB	 16
  00959	10		 DB	 16
  0095a	10		 DB	 16
  0095b	08		 DB	 8
  0095c	10		 DB	 16
  0095d	09		 DB	 9
  0095e	10		 DB	 16
  0095f	10		 DB	 16
  00960	10		 DB	 16
  00961	00		 DB	 0
  00962	0a		 DB	 10
  00963	10		 DB	 16
  00964	10		 DB	 16
  00965	10		 DB	 16
  00966	10		 DB	 16
  00967	10		 DB	 16
  00968	10		 DB	 16
  00969	10		 DB	 16
  0096a	0b		 DB	 11
  0096b	10		 DB	 16
  0096c	0c		 DB	 12
  0096d	02		 DB	 2
  0096e	0d		 DB	 13
  0096f	0e		 DB	 14
  00970	10		 DB	 16
  00971	0f		 DB	 15
Py_Main	ENDP
_TEXT	ENDS
PUBLIC	Py_GetArgcArgv
; Function compile flags: /Ogtpy
;	COMDAT Py_GetArgcArgv
_TEXT	SEGMENT
argc$ = 8
argv$ = 16
Py_GetArgcArgv PROC					; COMDAT

; 795  :     *argc = orig_argc;

  00000	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR orig_argc
  00006	89 01		 mov	 DWORD PTR [rcx], eax

; 796  :     *argv = orig_argv;

  00008	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR orig_argv
  0000f	48 89 02	 mov	 QWORD PTR [rdx], rax

; 797  : }

  00012	c3		 ret	 0
Py_GetArgcArgv ENDP
_TEXT	ENDS
END
