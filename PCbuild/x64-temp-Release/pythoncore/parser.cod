; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

; Function compile flags: /Ogtpy
; File c:\src\pyparallel\parser\parser.c
;	COMDAT s_reset
_TEXT	SEGMENT
s$ = 8
s_reset	PROC						; COMDAT

; 32   :     s->s_top = &s->s_base[MAXSTACK];

  00000	48 8d 81 a8 8c
	00 00		 lea	 rax, QWORD PTR [rcx+36008]
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 33   : }

  0000a	c3		 ret	 0
s_reset	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@OFBDNFIB@s_push?3?5parser?5stack?5overflow?6?$AA@ ; `string'
EXTRN	__imp_fprintf:PROC
EXTRN	__imp___iob_func:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$s_push DD imagerel s_push
	DD	imagerel s_push+77
	DD	imagerel $unwind$s_push
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s_push DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BP@OFBDNFIB@s_push?3?5parser?5stack?5overflow?6?$AA@
CONST	SEGMENT
??_C@_0BP@OFBDNFIB@s_push?3?5parser?5stack?5overflow?6?$AA@ DB 's_push: p'
	DB	'arser stack overflow', 0aH, 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT s_push
_TEXT	SEGMENT
s$ = 48
d$ = 56
parent$ = 64
s_push	PROC						; COMDAT

; 39   : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 40   :     register stackentry *top;
; 41   :     if (s->s_top == s->s_base) {

  00004	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  00007	48 8d 41 08	 lea	 rax, QWORD PTR [rcx+8]
  0000b	4c 3b c8	 cmp	 r9, rax
  0000e	75 21		 jne	 SHORT $LN1@s_push

; 42   :         fprintf(stderr, "s_push: parser stack overflow\n");

  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@OFBDNFIB@s_push?3?5parser?5stack?5overflow?6?$AA@
  0001d	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 43   :         return E_NOMEM;

  00027	b8 0f 00 00 00	 mov	 eax, 15

; 50   : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
$LN1@s_push:

; 44   :     }
; 45   :     top = --s->s_top;

  00031	49 8d 41 e8	 lea	 rax, QWORD PTR [r9-24]
  00035	48 89 01	 mov	 QWORD PTR [rcx], rax

; 46   :     top->s_dfa = d;

  00038	48 89 50 08	 mov	 QWORD PTR [rax+8], rdx

; 47   :     top->s_parent = parent;

  0003c	4c 89 40 10	 mov	 QWORD PTR [rax+16], r8

; 48   :     top->s_state = 0;

  00040	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 49   :     return 0;

  00046	33 c0		 xor	 eax, eax

; 50   : }

  00048	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004c	c3		 ret	 0
s_push	ENDP
_TEXT	ENDS
PUBLIC	PyParser_New
EXTRN	PyGrammar_FindDFA:PROC
EXTRN	__imp_free:PROC
EXTRN	_PxMem_Free:PROC
EXTRN	PyNode_New:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_PxMem_Malloc:PROC
EXTRN	_Py_PXCTX:PROC
EXTRN	PyGrammar_AddAccelerators:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyParser_New DD imagerel $LN11
	DD	imagerel $LN11+216
	DD	imagerel $unwind$PyParser_New
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyParser_New DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyParser_New
_TEXT	SEGMENT
g$ = 48
start$ = 56
PyParser_New PROC					; COMDAT

; 73   : {

$LN11:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 74   :     parser_state *ps;
; 75   : 
; 76   :     if (!g->g_accel)

  0000f	83 79 24 00	 cmp	 DWORD PTR [rcx+36], 0
  00013	8b f2		 mov	 esi, edx
  00015	48 8b f9	 mov	 rdi, rcx
  00018	75 05		 jne	 SHORT $LN3@PyParser_N

; 77   :         PyGrammar_AddAccelerators(g);

  0001a	e8 00 00 00 00	 call	 PyGrammar_AddAccelerators
$LN3@PyParser_N:

; 78   :     ps = (parser_state *)PyMem_MALLOC(sizeof(parser_state));

  0001f	e8 00 00 00 00	 call	 _Py_PXCTX
  00024	b9 c0 8c 00 00	 mov	 ecx, 36032		; 00008cc0H
  00029	85 c0		 test	 eax, eax
  0002b	74 07		 je	 SHORT $LN6@PyParser_N
  0002d	e8 00 00 00 00	 call	 _PxMem_Malloc
  00032	eb 06		 jmp	 SHORT $LN10@PyParser_N
$LN6@PyParser_N:
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN10@PyParser_N:
  0003a	48 8b d8	 mov	 rbx, rax

; 79   :     if (ps == NULL)

  0003d	48 85 c0	 test	 rax, rax

; 80   :         return NULL;

  00040	74 4d		 je	 SHORT $LN9@PyParser_N

; 81   :     ps->p_grammar = g;
; 82   : #ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD
; 83   :     ps->p_flags = 0;
; 84   : #endif
; 85   :     ps->p_tree = PyNode_New(start);

  00042	8b ce		 mov	 ecx, esi
  00044	48 89 b8 a8 8c
	00 00		 mov	 QWORD PTR [rax+36008], rdi
  0004b	c7 80 b8 8c 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+36024], 0
  00055	e8 00 00 00 00	 call	 PyNode_New
  0005a	48 89 83 b0 8c
	00 00		 mov	 QWORD PTR [rbx+36016], rax

; 86   :     if (ps->p_tree == NULL) {

  00061	48 85 c0	 test	 rax, rax
  00064	75 3b		 jne	 SHORT $LN1@PyParser_N

; 87   :         PyMem_FREE(ps);

  00066	e8 00 00 00 00	 call	 _Py_PXCTX
  0006b	48 8b cb	 mov	 rcx, rbx
  0006e	85 c0		 test	 eax, eax
  00070	74 17		 je	 SHORT $LN8@PyParser_N
  00072	e8 00 00 00 00	 call	 _PxMem_Free

; 88   :         return NULL;

  00077	33 c0		 xor	 eax, eax

; 92   :     return ps;
; 93   : }

  00079	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00083	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00087	5f		 pop	 rdi
  00088	c3		 ret	 0
$LN8@PyParser_N:

; 87   :         PyMem_FREE(ps);

  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN9@PyParser_N:

; 88   :         return NULL;

  0008f	33 c0		 xor	 eax, eax

; 92   :     return ps;
; 93   : }

  00091	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00096	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0009b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009f	5f		 pop	 rdi
  000a0	c3		 ret	 0
$LN1@PyParser_N:

; 89   :     }
; 90   :     s_reset(&ps->p_stack);

  000a1	48 8b cb	 mov	 rcx, rbx
  000a4	e8 00 00 00 00	 call	 s_reset

; 91   :     (void) s_push(&ps->p_stack, PyGrammar_FindDFA(g, start), ps->p_tree);

  000a9	8b d6		 mov	 edx, esi
  000ab	48 8b cf	 mov	 rcx, rdi
  000ae	e8 00 00 00 00	 call	 PyGrammar_FindDFA
  000b3	4c 8b 83 b0 8c
	00 00		 mov	 r8, QWORD PTR [rbx+36016]
  000ba	48 8b cb	 mov	 rcx, rbx
  000bd	48 8b d0	 mov	 rdx, rax
  000c0	e8 00 00 00 00	 call	 s_push

; 92   :     return ps;
; 93   : }

  000c5	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000ca	48 8b c3	 mov	 rax, rbx
  000cd	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000d2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d6	5f		 pop	 rdi
  000d7	c3		 ret	 0
PyParser_New ENDP
_TEXT	ENDS
PUBLIC	PyParser_Delete
EXTRN	PyNode_Free:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyParser_Delete DD imagerel $LN5
	DD	imagerel $LN5+55
	DD	imagerel $unwind$PyParser_Delete
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyParser_Delete DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyParser_Delete
_TEXT	SEGMENT
ps$ = 48
PyParser_Delete PROC					; COMDAT

; 97   : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 98   :     /* NB If you want to save the parse tree,
; 99   :        you must set p_tree to NULL before calling delparser! */
; 100  :     PyNode_Free(ps->p_tree);

  00009	48 8b 89 b0 8c
	00 00		 mov	 rcx, QWORD PTR [rcx+36016]
  00010	e8 00 00 00 00	 call	 PyNode_Free

; 101  :     PyMem_FREE(ps);

  00015	e8 00 00 00 00	 call	 _Py_PXCTX
  0001a	48 8b cb	 mov	 rcx, rbx
  0001d	85 c0		 test	 eax, eax
  0001f	74 0a		 je	 SHORT $LN3@PyParser_D

; 102  : }

  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5b		 pop	 rbx
  00026	e9 00 00 00 00	 jmp	 _PxMem_Free
$LN3@PyParser_D:
  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5b		 pop	 rbx
  00030	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_free
PyParser_Delete ENDP
_TEXT	ENDS
EXTRN	PyNode_AddChild:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$shift DD	imagerel shift
	DD	imagerel shift+63
	DD	imagerel $unwind$shift
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$shift DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT shift
_TEXT	SEGMENT
s$ = 64
type$ = 72
str$ = 80
newstate$ = 88
lineno$ = 96
col_offset$ = 104
shift	PROC						; COMDAT

; 109  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 110  :     int err;
; 111  :     assert(!s_empty(s));
; 112  :     err = PyNode_AddChild(s->s_top->s_parent, type, str, lineno, col_offset);

  0000a	8b 44 24 68	 mov	 eax, DWORD PTR col_offset$[rsp]
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00014	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00018	41 8b f9	 mov	 edi, r9d
  0001b	44 8b 4c 24 60	 mov	 r9d, DWORD PTR lineno$[rsp]
  00020	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00024	e8 00 00 00 00	 call	 PyNode_AddChild

; 113  :     if (err)

  00029	85 c0		 test	 eax, eax

; 114  :         return err;

  0002b	75 07		 jne	 SHORT $LN2@shift

; 115  :     s->s_top->s_state = newstate;

  0002d	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00030	89 38		 mov	 DWORD PTR [rax], edi

; 116  :     return 0;

  00032	33 c0		 xor	 eax, eax
$LN2@shift:

; 117  : }

  00034	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00039	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003d	5f		 pop	 rdi
  0003e	c3		 ret	 0
shift	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$push DD	imagerel push
	DD	imagerel push+120
	DD	imagerel $unwind$push
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$push DD	081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT push
_TEXT	SEGMENT
s$ = 64
type$ = 72
d$ = 80
newstate$ = 88
lineno$ = 96
col_offset$ = 104
push	PROC						; COMDAT

; 121  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 122  :     int err;
; 123  :     register node *n;
; 124  :     n = s->s_top->s_parent;

  00014	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00017	41 8b f1	 mov	 esi, r9d

; 125  :     assert(!s_empty(s));
; 126  :     err = PyNode_AddChild(n, type, (char *)NULL, lineno, col_offset);

  0001a	44 8b 4c 24 60	 mov	 r9d, DWORD PTR lineno$[rsp]
  0001f	48 8b 78 10	 mov	 rdi, QWORD PTR [rax+16]
  00023	8b 44 24 68	 mov	 eax, DWORD PTR col_offset$[rsp]
  00027	49 8b e8	 mov	 rbp, r8
  0002a	48 8b d9	 mov	 rbx, rcx
  0002d	45 33 c0	 xor	 r8d, r8d
  00030	48 8b cf	 mov	 rcx, rdi
  00033	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00037	e8 00 00 00 00	 call	 PyNode_AddChild

; 127  :     if (err)

  0003c	85 c0		 test	 eax, eax

; 128  :         return err;

  0003e	75 23		 jne	 SHORT $LN2@push

; 129  :     s->s_top->s_state = newstate;

  00040	48 8b 03	 mov	 rax, QWORD PTR [rbx]

; 130  :     return s_push(s, d, CHILD(n, NCH(n)-1));

  00043	48 8b d5	 mov	 rdx, rbp
  00046	89 30		 mov	 DWORD PTR [rax], esi
  00048	8b 47 18	 mov	 eax, DWORD PTR [rdi+24]
  0004b	ff c8		 dec	 eax
  0004d	48 98		 cdqe
  0004f	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  00053	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00057	4c 8d 04 c8	 lea	 r8, QWORD PTR [rax+rcx*8]
  0005b	48 8b cb	 mov	 rcx, rbx
  0005e	e8 00 00 00 00	 call	 s_push
$LN2@push:

; 131  : }

  00063	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00068	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0006d	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00072	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
push	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$classify DD imagerel classify
	DD	imagerel classify+212
	DD	imagerel $unwind$classify
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$classify DD 060f01H
	DD	03740fH
	DD	02640aH
	DD	013405H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT classify
_TEXT	SEGMENT
ps$ = 8
type$ = 16
str$ = 24
classify PROC						; COMDAT

; 138  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi

; 139  :     grammar *g = ps->p_grammar;

  0000f	48 8b b1 a8 8c
	00 00		 mov	 rsi, QWORD PTR [rcx+36008]
  00016	49 8b d8	 mov	 rbx, r8
  00019	8b fa		 mov	 edi, edx

; 140  :     register int n = g->g_ll.ll_nlabels;

  0001b	44 8b 5e 10	 mov	 r11d, DWORD PTR [rsi+16]

; 141  : 
; 142  :     if (type == NAME) {

  0001f	83 fa 01	 cmp	 edx, 1
  00022	75 4f		 jne	 SHORT $LN20@classify

; 143  :         register char *s = str;
; 144  :         register label *l = g->g_ll.ll_label;

  00024	4c 8b 4e 18	 mov	 r9, QWORD PTR [rsi+24]

; 145  :         register int i;
; 146  :         for (i = n; i > 0; i--, l++) {

  00028	45 8b d3	 mov	 r10d, r11d
  0002b	45 85 db	 test	 r11d, r11d
  0002e	7e 43		 jle	 SHORT $LN20@classify
$LL9@classify:

; 147  :             if (l->lb_type != NAME || l->lb_str == NULL ||
; 148  :                 l->lb_str[0] != s[0] ||
; 149  :                 strcmp(l->lb_str, s) != 0)

  00030	41 83 39 01	 cmp	 DWORD PTR [r9], 1
  00034	75 31		 jne	 SHORT $LN8@classify
  00036	49 8b 49 08	 mov	 rcx, QWORD PTR [r9+8]
  0003a	48 85 c9	 test	 rcx, rcx
  0003d	74 28		 je	 SHORT $LN8@classify
  0003f	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00042	38 01		 cmp	 BYTE PTR [rcx], al
  00044	75 21		 jne	 SHORT $LN8@classify
  00046	4c 8b c3	 mov	 r8, rbx
  00049	4c 2b c1	 sub	 r8, rcx
  0004c	0f 1f 40 00	 npad	 4
$LL18@classify:
  00050	0f b6 11	 movzx	 edx, BYTE PTR [rcx]
  00053	42 0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+r8]
  00058	2b d0		 sub	 edx, eax
  0005a	75 07		 jne	 SHORT $LN19@classify
  0005c	48 ff c1	 inc	 rcx
  0005f	85 c0		 test	 eax, eax
  00061	75 ed		 jne	 SHORT $LL18@classify
$LN19@classify:
  00063	85 d2		 test	 edx, edx
  00065	74 41		 je	 SHORT $LN6@classify
$LN8@classify:

; 145  :         register int i;
; 146  :         for (i = n; i > 0; i--, l++) {

  00067	41 ff ca	 dec	 r10d
  0006a	49 83 c1 10	 add	 r9, 16
  0006e	45 85 d2	 test	 r10d, r10d
  00071	7f bd		 jg	 SHORT $LL9@classify
$LN20@classify:

; 164  :         }
; 165  :     }
; 166  : 
; 167  :     {
; 168  :         register label *l = g->g_ll.ll_label;

  00073	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]

; 169  :         register int i;
; 170  :         for (i = n; i > 0; i--, l++) {

  00077	41 8b cb	 mov	 ecx, r11d
  0007a	45 85 db	 test	 r11d, r11d
  0007d	7e 16		 jle	 SHORT $LN21@classify
  0007f	90		 npad	 1
$LL4@classify:

; 171  :             if (l->lb_type == type && l->lb_str == NULL) {

  00080	39 38		 cmp	 DWORD PTR [rax], edi
  00082	75 07		 jne	 SHORT $LN3@classify
  00084	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00089	74 33		 je	 SHORT $LN15@classify
$LN3@classify:

; 169  :         register int i;
; 170  :         for (i = n; i > 0; i--, l++) {

  0008b	ff c9		 dec	 ecx
  0008d	48 83 c0 10	 add	 rax, 16
  00091	85 c9		 test	 ecx, ecx
  00093	7f eb		 jg	 SHORT $LL4@classify
$LN21@classify:

; 172  :                 D(printf("It's a token we know\n"));
; 173  :                 return n - i;
; 174  :             }
; 175  :         }
; 176  :     }
; 177  : 
; 178  :     D(printf("Illegal token\n"));
; 179  :     return -1;

  00095	83 c8 ff	 or	 eax, -1

; 180  : }

  00098	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0009d	48 8b 74 24 10	 mov	 rsi, QWORD PTR [rsp+16]
  000a2	48 8b 7c 24 18	 mov	 rdi, QWORD PTR [rsp+24]
  000a7	c3		 ret	 0
$LN6@classify:

; 150  :                 continue;
; 151  : #ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD
; 152  : #if 0
; 153  :             /* Leaving this in as an example */
; 154  :             if (!(ps->p_flags & CO_FUTURE_WITH_STATEMENT)) {
; 155  :                 if (s[0] == 'w' && strcmp(s, "with") == 0)
; 156  :                     break; /* not a keyword yet */
; 157  :                 else if (s[0] == 'a' && strcmp(s, "as") == 0)
; 158  :                     break; /* not a keyword yet */
; 159  :             }
; 160  : #endif
; 161  : #endif
; 162  :             D(printf("It's a keyword\n"));
; 163  :             return n - i;

  000a8	45 2b da	 sub	 r11d, r10d
  000ab	41 8b c3	 mov	 eax, r11d

; 180  : }

  000ae	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  000b3	48 8b 74 24 10	 mov	 rsi, QWORD PTR [rsp+16]
  000b8	48 8b 7c 24 18	 mov	 rdi, QWORD PTR [rsp+24]
  000bd	c3		 ret	 0
$LN15@classify:
  000be	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  000c3	48 8b 74 24 10	 mov	 rsi, QWORD PTR [rsp+16]
  000c8	48 8b 7c 24 18	 mov	 rdi, QWORD PTR [rsp+24]
  000cd	44 2b d9	 sub	 r11d, ecx
  000d0	41 8b c3	 mov	 eax, r11d
  000d3	c3		 ret	 0
classify ENDP
_TEXT	ENDS
PUBLIC	PyParser_AddToken
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyParser_AddToken DD imagerel $LN36
	DD	imagerel $LN36+451
	DD	imagerel $unwind$PyParser_AddToken
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyParser_AddToken DD 0d4f01H
	DD	0e644fH
	DD	06d442H
	DD	0fc43dH
	DD	0c3438H
	DD	0f00a620eH
	DD	07006e008H
	DD	05005H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyParser_AddToken
_TEXT	SEGMENT
ps$ = 96
type$ = 104
str$ = 112
lineno$ = 120
col_offset$ = 128
expected_ret$ = 136
PyParser_AddToken PROC					; COMDAT

; 230  : {

$LN36:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	41 56		 push	 r14
  00008	41 57		 push	 r15
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000e	45 8b f1	 mov	 r14d, r9d
  00011	4d 8b f8	 mov	 r15, r8
  00014	48 8b f9	 mov	 rdi, rcx

; 231  :     register int ilabel;
; 232  :     int err;
; 233  : 
; 234  :     D(printf("Token %s/'%s' ... ", _PyParser_TokenNames[type], str));
; 235  : 
; 236  :     /* Find out which label this token is */
; 237  :     ilabel = classify(ps, type, str);

  00017	e8 00 00 00 00	 call	 classify
  0001c	48 63 e8	 movsxd	 rbp, eax

; 238  :     if (ilabel < 0)

  0001f	85 c0		 test	 eax, eax
  00021	79 10		 jns	 SHORT $LN22@PyParser_A

; 239  :         return E_SYNTAX;

  00023	b8 0e 00 00 00	 mov	 eax, 14

; 333  :     }
; 334  : }

  00028	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002c	41 5f		 pop	 r15
  0002e	41 5e		 pop	 r14
  00030	5f		 pop	 rdi
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
$LN22@PyParser_A:
  00033	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  00038	4c 89 64 24 78	 mov	 QWORD PTR [rsp+120], r12
  0003d	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13

; 231  :     register int ilabel;
; 232  :     int err;
; 233  : 
; 234  :     D(printf("Token %s/'%s' ... ", _PyParser_TokenNames[type], str));
; 235  : 
; 236  :     /* Find out which label this token is */
; 237  :     ilabel = classify(ps, type, str);

  00042	44 8b ac 24 80
	00 00 00	 mov	 r13d, DWORD PTR col_offset$[rsp]
  0004a	48 89 74 24 70	 mov	 QWORD PTR [rsp+112], rsi
  0004f	90		 npad	 1
$LL15@PyParser_A:

; 240  : 
; 241  :     /* Loop until the token is shifted or an error occurred */
; 242  :     for (;;) {
; 243  :         /* Fetch the current dfa and state */
; 244  :         register dfa *d = ps->p_stack.s_top->s_dfa;

  00050	4c 8b 0f	 mov	 r9, QWORD PTR [rdi]

; 245  :         register state *s = &d->d_state[ps->p_stack.s_top->s_state];

  00053	49 63 01	 movsxd	 rax, DWORD PTR [r9]
  00056	49 8b 59 08	 mov	 rbx, QWORD PTR [r9+8]
  0005a	4c 8b 43 18	 mov	 r8, QWORD PTR [rbx+24]
  0005e	48 8d 14 80	 lea	 rdx, QWORD PTR [rax+rax*4]

; 246  : 
; 247  :         D(printf(" DFA '%s', state %d:",
; 248  :             d->d_name, ps->p_stack.s_top->s_state));
; 249  : 
; 250  :         /* Check accelerator */
; 251  :         if (s->s_lower <= ilabel && ilabel < s->s_upper) {

  00062	49 63 44 d0 10	 movsxd	 rax, DWORD PTR [r8+rdx*8+16]
  00067	3b c5		 cmp	 eax, ebp
  00069	7f 60		 jg	 SHORT $LN12@PyParser_A
  0006b	41 3b 6c d0 14	 cmp	 ebp, DWORD PTR [r8+rdx*8+20]
  00070	7d 59		 jge	 SHORT $LN12@PyParser_A

; 252  :             register int x = s->s_accel[ilabel - s->s_lower];

  00072	48 8b cd	 mov	 rcx, rbp
  00075	48 2b c8	 sub	 rcx, rax
  00078	49 8b 44 d0 18	 mov	 rax, QWORD PTR [r8+rdx*8+24]
  0007d	8b 34 88	 mov	 esi, DWORD PTR [rax+rcx*4]

; 253  :             if (x != -1) {

  00080	83 fe ff	 cmp	 esi, -1
  00083	74 46		 je	 SHORT $LN12@PyParser_A

; 254  :                 if (x & (1<<7)) {

  00085	40 84 f6	 test	 sil, sil
  00088	79 69		 jns	 SHORT $LN11@PyParser_A

; 255  :                     /* Push non-terminal */
; 256  :                     int nt = (x >> 8) + NT_OFFSET;
; 257  :                     int arrow = x & ((1<<7)-1);
; 258  :                     dfa *d1 = PyGrammar_FindDFA(
; 259  :                         ps->p_grammar, nt);

  0008a	48 8b 8f a8 8c
	00 00		 mov	 rcx, QWORD PTR [rdi+36008]
  00091	8b de		 mov	 ebx, esi
  00093	c1 fb 08	 sar	 ebx, 8
  00096	8d 93 00 01 00
	00		 lea	 edx, DWORD PTR [rbx+256]
  0009c	e8 00 00 00 00	 call	 PyGrammar_FindDFA
  000a1	83 e6 7f	 and	 esi, 127		; 0000007fH

; 260  :                     if ((err = push(&ps->p_stack, nt, d1,
; 261  :                         arrow, lineno, col_offset)) > 0) {

  000a4	8d 93 00 01 00
	00		 lea	 edx, DWORD PTR [rbx+256]
  000aa	44 8b ce	 mov	 r9d, esi
  000ad	48 8b cf	 mov	 rcx, rdi
  000b0	4c 8b c0	 mov	 r8, rax
  000b3	44 89 6c 24 28	 mov	 DWORD PTR [rsp+40], r13d
  000b8	44 89 74 24 20	 mov	 DWORD PTR [rsp+32], r14d
  000bd	e8 00 00 00 00	 call	 push
  000c2	85 c0		 test	 eax, eax
  000c4	7e 8a		 jle	 SHORT $LL15@PyParser_A

; 262  :                         D(printf(" MemError: push\n"));
; 263  :                         return err;
; 264  :                     }
; 265  :                     D(printf(" Push ...\n"));
; 266  :                     continue;

  000c6	e9 d9 00 00 00	 jmp	 $LN35@PyParser_A
$LN12@PyParser_A:

; 300  :             }
; 301  :         }
; 302  : 
; 303  :         if (s->s_accept) {

  000cb	41 83 7c d0 20
	00		 cmp	 DWORD PTR [r8+rdx*8+32], 0
  000d1	0f 84 8b 00 00
	00		 je	 $LN5@PyParser_A

; 304  : #ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD
; 305  : #if 0
; 306  :             if (d->d_name[0] == 'i' &&
; 307  :                 strcmp(d->d_name, "import_stmt") == 0)
; 308  :                 future_hack(ps);
; 309  : #endif
; 310  : #endif
; 311  :             /* Pop this dfa and try again */
; 312  :             s_pop(&ps->p_stack);

  000d7	49 8d 49 18	 lea	 rcx, QWORD PTR [r9+24]

; 313  :             D(printf(" Pop ...\n"));
; 314  :             if (s_empty(&ps->p_stack)) {

  000db	48 8d 87 a8 8c
	00 00		 lea	 rax, QWORD PTR [rdi+36008]
  000e2	48 89 0f	 mov	 QWORD PTR [rdi], rcx
  000e5	48 3b c8	 cmp	 rcx, rax
  000e8	0f 85 62 ff ff
	ff		 jne	 $LL15@PyParser_A

; 315  :                 D(printf(" Error: bottom of stack.\n"));
; 316  :                 return E_SYNTAX;
; 317  :             }
; 318  :             continue;

  000ee	e9 ac 00 00 00	 jmp	 $LN1@PyParser_A
$LN11@PyParser_A:

; 267  :                 }
; 268  : 
; 269  :                 /* Shift the token */
; 270  :                 if ((err = shift(&ps->p_stack, type, str,
; 271  :                                 x, lineno, col_offset)) > 0) {

  000f3	8b 54 24 68	 mov	 edx, DWORD PTR type$[rsp]
  000f7	44 8b ce	 mov	 r9d, esi
  000fa	4d 8b c7	 mov	 r8, r15
  000fd	48 8b cf	 mov	 rcx, rdi
  00100	44 89 6c 24 28	 mov	 DWORD PTR [rsp+40], r13d
  00105	44 89 74 24 20	 mov	 DWORD PTR [rsp+32], r14d
  0010a	e8 00 00 00 00	 call	 shift
  0010f	85 c0		 test	 eax, eax

; 272  :                     D(printf(" MemError: shift.\n"));
; 273  :                     return err;

  00111	0f 8f 8d 00 00
	00		 jg	 $LN35@PyParser_A
  00117	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL8@PyParser_A:

; 274  :                 }
; 275  :                 D(printf(" Shift.\n"));
; 276  :                 /* Pop while we are in an accept-only state */
; 277  :                 while (s = &d->d_state
; 278  :                                 [ps->p_stack.s_top->s_state],
; 279  :                     s->s_accept && s->s_narcs == 1) {

  00120	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00123	48 63 02	 movsxd	 rax, DWORD PTR [rdx]
  00126	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  0012a	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  0012e	83 7c c8 20 00	 cmp	 DWORD PTR [rax+rcx*8+32], 0
  00133	74 26		 je	 SHORT $LN7@PyParser_A
  00135	83 3c c8 01	 cmp	 DWORD PTR [rax+rcx*8], 1
  00139	75 20		 jne	 SHORT $LN7@PyParser_A

; 280  :                     D(printf("  DFA '%s', state %d: "
; 281  :                              "Direct pop.\n",
; 282  :                              d->d_name,
; 283  :                              ps->p_stack.s_top->s_state));
; 284  : #ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD
; 285  : #if 0
; 286  :                     if (d->d_name[0] == 'i' &&
; 287  :                         strcmp(d->d_name,
; 288  :                            "import_stmt") == 0)
; 289  :                         future_hack(ps);
; 290  : #endif
; 291  : #endif
; 292  :                     s_pop(&ps->p_stack);

  0013b	48 8d 4a 18	 lea	 rcx, QWORD PTR [rdx+24]

; 293  :                     if (s_empty(&ps->p_stack)) {

  0013f	48 8d 87 a8 8c
	00 00		 lea	 rax, QWORD PTR [rdi+36008]
  00146	48 89 0f	 mov	 QWORD PTR [rdi], rcx
  00149	48 3b c8	 cmp	 rcx, rax
  0014c	74 06		 je	 SHORT $LN26@PyParser_A

; 296  :                     }
; 297  :                     d = ps->p_stack.s_top->s_dfa;

  0014e	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]

; 298  :                 }

  00152	eb cc		 jmp	 SHORT $LL8@PyParser_A
$LN26@PyParser_A:

; 294  :                         D(printf("  ACCEPT.\n"));
; 295  :                         return E_DONE;

  00154	b8 10 00 00 00	 mov	 eax, 16
  00159	eb 49		 jmp	 SHORT $LN35@PyParser_A
$LN7@PyParser_A:

; 299  :                 return E_OK;

  0015b	b8 0a 00 00 00	 mov	 eax, 10
  00160	eb 42		 jmp	 SHORT $LN35@PyParser_A
$LN5@PyParser_A:

; 319  :         }
; 320  : 
; 321  :         /* Stuck, report syntax error */
; 322  :         D(printf(" Error.\n"));
; 323  :         if (expected_ret) {

  00162	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR expected_ret$[rsp]
  0016a	4d 85 c9	 test	 r9, r9
  0016d	74 30		 je	 SHORT $LN1@PyParser_A

; 324  :             if (s->s_lower == s->s_upper - 1) {

  0016f	41 8b 44 d0 14	 mov	 eax, DWORD PTR [r8+rdx*8+20]
  00174	49 63 4c d0 10	 movsxd	 rcx, DWORD PTR [r8+rdx*8+16]
  00179	ff c8		 dec	 eax
  0017b	3b c8		 cmp	 ecx, eax
  0017d	75 19		 jne	 SHORT $LN2@PyParser_A

; 325  :                 /* Only one possible expected token */
; 326  :                 *expected_ret = ps->p_grammar->
; 327  :                     g_ll.ll_label[s->s_lower].lb_type;

  0017f	48 8b 87 a8 8c
	00 00		 mov	 rax, QWORD PTR [rdi+36008]
  00186	48 8b d1	 mov	 rdx, rcx
  00189	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0018d	48 03 d2	 add	 rdx, rdx
  00190	8b 04 d1	 mov	 eax, DWORD PTR [rcx+rdx*8]
  00193	41 89 01	 mov	 DWORD PTR [r9], eax

; 328  :             }
; 329  :             else

  00196	eb 07		 jmp	 SHORT $LN1@PyParser_A
$LN2@PyParser_A:

; 330  :                 *expected_ret = -1;

  00198	41 c7 01 ff ff
	ff ff		 mov	 DWORD PTR [r9], -1
$LN1@PyParser_A:

; 331  :         }
; 332  :         return E_SYNTAX;

  0019f	b8 0e 00 00 00	 mov	 eax, 14
$LN35@PyParser_A:
  001a4	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  001a9	4c 8b 64 24 78	 mov	 r12, QWORD PTR [rsp+120]
  001ae	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  001b3	4c 8b 6c 24 30	 mov	 r13, QWORD PTR [rsp+48]

; 333  :     }
; 334  : }

  001b8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001bc	41 5f		 pop	 r15
  001be	41 5e		 pop	 r14
  001c0	5f		 pop	 rdi
  001c1	5d		 pop	 rbp
  001c2	c3		 ret	 0
PyParser_AddToken ENDP
_TEXT	ENDS
END
